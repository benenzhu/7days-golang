<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <style>
        body{
            color: #aaa;
            background-color: #222;
        }
    </style>
</head>2.1 TCP/IP 网络模型<font color=#FEAE00>有哪几层</font>？<hr>问大家，为什么要有 TCP/IP 网络模型？<br>&emsp;&emsp;对于<font color=#FEAE00>同一台设备</font>上的进程间通信，有很多种方式，比如有管道、消息队列、共享内存、信号等方式，而对于不同设备上的进程间通信，就需要网络通信，而设备是多样性的，所以要兼容多种多样的设备，就协商出了一套<font color=#FEAE00>通用的网络协议</font><font color=#FEAE00>。</font><br>&emsp;&emsp;这个网络协议是分层的，每一层都有各自的作用和职责，接下来就根据「 <font color=#FEAE00>TCP/IP </font><font color=#FEAE00>网络模型</font>」分别对每一层进行介绍。<br>&emsp;&emsp;<hr><hr>2.1 传输层<br>&emsp;&emsp;- 协议都有什么? 都有什么特性<br>&emsp;&emsp;- 端口?<hr>应用层的数据包会传给传输层，<font color=#FEAE00>传输层</font>（<font color=#7414AF>Transport Layer</font>）是为应用层提供网络支持的。<br>&emsp;&emsp;￼<br>&emsp;&emsp;在传输层会有两个传输协议，分别是 TCP 和 UDP。<br>&emsp;&emsp;<font color=#FEAE00>TCP</font> 的全称叫传输控制协议（<font color=#7414AF>Transmission Control Protocol</font>），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如<font color=#FEAE00>流量控制、超时重传、拥塞控制</font>等，这些都是为了保证数据包能可靠地传输给对方。<br>&emsp;&emsp;UDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，不过要实现一个商用的可靠 UDP 传输协议，也不是一件简单的事情。<br>&emsp;&emsp;应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 <font color=#FEAE00>MSS</font><font color=#FEAE00>（</font><font color=#FEAE00>TCP </font><font color=#FEAE00>最大报文段长度）</font> ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个<font color=#FEAE00> </font><font color=#FEAE00>TCP </font><font color=#FEAE00>段</font>（<font color=#7414AF>TCP Segment</font>）。<br>&emsp;&emsp;￼<br>&emsp;&emsp;当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是<font color=#FEAE00>端口</font><font color=#FEAE00>。</font><br>&emsp;&emsp;比如 <font color=#FEAE00>80 </font><font color=#FEAE00>端口通常是</font><font color=#FEAE00> Web </font><font color=#FEAE00>服务器</font>用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。<br>&emsp;&emsp;由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>2.1 应用层<br>&emsp;&emsp;- 应用层的功能<br>&emsp;&emsp;- 应用层的协议<br>&emsp;&emsp;- 工作在什么状态<hr>最上层的，也是我们能直接接触到的就是<font color=#FEAE00>应用层</font>（<font color=#7414AF>Application Layer</font>），我们电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。<br>&emsp;&emsp;所以，应用层只需要专注于为用户提供应用功能，比如 <font color=#FEAE00>HTTP</font><font color=#FEAE00>、</font><font color=#FEAE00>FTP</font><font color=#FEAE00>、</font><font color=#FEAE00>Telnet</font><font color=#FEAE00>、</font><font color=#FEAE00>DNS</font><font color=#FEAE00>、</font><font color=#FEAE00>SMTP</font>等。<br>&emsp;&emsp;应用层是<font color=#FEAE00>不用去关心数据</font>是如何传输的，就类似于，我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关心快递是如何被运输的。<br>&emsp;&emsp;而且应用层是<font color=#FEAE00>工作在操作系统中的用户态</font>，<font color=#FEAE00>传输层及以下</font>则工作在<font color=#FEAE00>内核态</font>。<hr><hr>2.1 总结<br>&emsp;&emsp;- 封装格式?<hr>综上所述，TCP/IP 网络通常是由上到下分成 4 层，分别是<font color=#FEAE00>应用层，传输层，网络层和网络接口层</font>。<br>&emsp;&emsp;￼<br>&emsp;&emsp;再给大家贴一下<font color=#FEAE00>每一层的封装格式：</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;网络接口层的传输单位是<font color=#FEAE00>帧（</font><font color=#FEAE00>frame</font>），IP 层的传输单位是<font color=#FEAE00>包（</font><font color=#FEAE00>packet</font>），TCP 层的传输单位是<font color=#FEAE00>段（</font><font color=#FEAE00>segment</font>），HTTP 的传输单位则是消息或<font color=#FEAE00>报文（</font><font color=#FEAE00>message</font><font color=#FEAE00>）</font>。但这些名词并没有什么本质的区分，可以统称为数据包。<br>&emsp;&emsp;<hr><hr>2.1 网络层<br>&emsp;&emsp;- 网络层的协议<br>&emsp;&emsp;- 作用是什么? <br>&emsp;&emsp;- IP 地址的意义<br>&emsp;&emsp;- 路由?<hr>传输层可能大家刚接触的时候，会认为它负责将数据从一个设备传输到另一个设备，事实上它并不负责。<br>&emsp;&emsp;实际场景中的网络环节是错综复杂的，中间有<font color=#FEAE00>各种各样的线路和分叉路口</font>，如果一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，而传输层的设计理念是简单、高效、专注，如果传输层还负责这一块功能就有点违背设计原则了。<br>&emsp;&emsp;也就是说，我们不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是<font color=#FEAE00>网络层</font>（<font color=#7414AF>Internet Layer</font>）。<br>&emsp;&emsp;￼<br>&emsp;&emsp;网络层最常使用的是 <font color=#FEAE00>IP </font><font color=#FEAE00>协议</font>（<font color=#7414AF>Internet Protocol</font>），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会<font color=#FEAE00>再次进行分片</font>，得到一个即将发送到网络的 IP 报文。<br>&emsp;&emsp;￼<br>&emsp;&emsp;网络层负责将数据从一个设备传输到另一个设备，世界上那么多设备，又该如何找到对方呢？因此，网络层需要有区分设备的编号。<br>&emsp;&emsp;我们一般用 IP 地址给设备进行编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。只有一个单纯的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道一个一个去匹配？这显然不科学。<br>&emsp;&emsp;因此，需要将 IP 地址分成两种意义：<br>&emsp;&emsp;	•	一个是<font color=#FEAE00>网络号</font>，负责标识该 IP 地址是属于哪个「子网」的；<br>&emsp;&emsp;	•	一个是<font color=#FEAE00>主机号</font>，负责标识同一「子网」下的不同主机；<br>&emsp;&emsp;怎么分的呢？这需要配合<font color=#FEAE00>子网掩码</font>才能算出 IP 地址 的网络号和主机号。<br>&emsp;&emsp;举个例子，比如 10.100.122.0/24，后面的<font color=#FEAE00>/24</font><font color=#FEAE00>表示就是</font><font color=#FEAE00> 255.255.255.0 </font><font color=#FEAE00>子网掩码</font>，255.255.255.0 二进制是「11111111-11111111-11111111-00000000」，大家数数一共多少个1？不用数了，是 24 个1，为了简化子网掩码的表示，用/24代替255.255.255.0。<br>&emsp;&emsp;知道了子网掩码，该怎么计算出网络地址和主机地址呢？<br>&emsp;&emsp;将 10.100.122.2 和 255.255.255.0 进行<font color=#FEAE00>按位与运算</font>，就可以得到网络号，如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;将 255.255.255.0 取反后与IP地址进行进行<font color=#FEAE00>按位与运算</font>，就可以得到主机号。<br>&emsp;&emsp;大家可以去搜索下子网掩码计算器，自己改变下「掩码位」的数值，就能体会到子网掩码的作用了。<br>&emsp;&emsp;￼<br>&emsp;&emsp;那么在寻址的过程中，先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机。<br>&emsp;&emsp;除了寻址能力， IP 协议还有另一个重要的能力就是<font color=#FEAE00>路由</font>。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要<font color=#FEAE00>通过路由算法决定下一步走哪条路径</font>。<br>&emsp;&emsp;路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。<br>&emsp;&emsp;￼<br>&emsp;&emsp;所以，<font color=#FEAE00>IP </font><font color=#FEAE00>协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘</font><font color=#FEAE00>。</font><hr><hr>2.1 网络接口层<br>&emsp;&emsp;- 封装成数据帧<br>&emsp;&emsp;- 传输服务<hr>生成了 IP 头部之后，接下来要交给<font color=#FEAE00>网络接口层</font>（<font color=#7414AF>Link Layer</font>）在 IP 头部的前面加上 <font color=#FEAE00>MAC </font><font color=#FEAE00>头部，并封装成数据帧（</font><font color=#FEAE00>Data frame</font><font color=#FEAE00>）</font>发送到网络上。<br>&emsp;&emsp;￼<br>&emsp;&emsp;IP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。<br>&emsp;&emsp;什么是以太网呢？电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。<font color=#FEAE00>以太网就是一种在「局域网」内</font>，把附近的设备连接起来，使它们之间可以进行通讯的技术。<br>&emsp;&emsp;以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 <font color=#FEAE00>MAC </font><font color=#FEAE00>头部就是干这个用</font>的，所以，在以太网进行通讯要用到 MAC 地址。<br>&emsp;&emsp;MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过<font color=#FEAE00> ARP </font><font color=#FEAE00>协议获取对方的</font><font color=#FEAE00> MAC </font><font color=#FEAE00>地址</font>。<br>&emsp;&emsp;所以说，网络接口层主要为网络层<font color=#FEAE00>提供「链路级别」传输的服务</font>，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。<hr><hr>2.2 键入网址到网页显示，期间发生了什么？<hr>想必不少小伙伴面试过程中，会遇到「<font color=#FEAE00>当键入网址后，到网页显示，其间发生了什么</font>」的面试题。<br>&emsp;&emsp;还别说，这问题真挺常问的，前几天坐在我旁边的主管电话面试应聘者的时候，也问了这个问题。<br>&emsp;&emsp;接下来以下图较简单的网络拓扑模型作为例子，探究探究其间发生了什么？<br>&emsp;&emsp;￼<hr><hr>2.3 Linux 系统是如何收发网络包的？ <br>&emsp;&emsp;网络模型<hr>为了使得多种设备能通过网络相互通信，和为了解决各种不同设备在网络互联中的兼容性问题，国际标准化组织制定了<font color=#FEAE00>开放式系统互联通信参考模型</font>（<font color=#7414AF>Open System Interconnection Reference Model</font>），也就是 OSI 网络模型，该模型主要有 7 层，分别是<font color=#FEAE00>应用层、表示层、会话层、传输层、网络层、数据链路层以及物理层。</font><br>&emsp;&emsp;每一层负责的职能都不同，如下：<br>&emsp;&emsp;	•	应用层，负责给应用程序提供统一的接口；<br>&emsp;&emsp;	•	表示层，负责把数据转换成兼容另一个系统能识别的格式；<br>&emsp;&emsp;	•	会话层，负责建立、管理和终止表示层实体之间的通信会话；<br>&emsp;&emsp;	•	传输层，负责端到端的数据传输；<br>&emsp;&emsp;	•	网络层，负责数据的路由、转发、分片；<br>&emsp;&emsp;	•	数据链路层，负责数据的封帧和差错检测，以及 MAC 寻址；<br>&emsp;&emsp;	•	物理层，负责在物理网络中传输数据帧；<br>&emsp;&emsp;由于 OSI 模型实在太复杂，提出的也只是概念理论上的分层，并没有提供具体的实现方案。<br>&emsp;&emsp;事实上，我们比较常见，也比较实用的是<font color=#FEAE00>四层模型，即</font><font color=#FEAE00> TCP/IP </font><font color=#FEAE00>网络模型</font>，Linux 系统正是按照这套网络模型来实现网络协议栈的。<br>&emsp;&emsp;TCP/IP 网络模型共有 4 层，分别是应用层、传输层、网络层和网络接口层，每一层负责的职能如下：<br>&emsp;&emsp;	•	应用层，负责向用户提供一组应用程序，比如 <font color=#FEAE00>HTTP</font><font color=#FEAE00>、</font><font color=#FEAE00>DNS</font><font color=#FEAE00>、</font><font color=#FEAE00>FTP</font> 等;<br>&emsp;&emsp;	•	传输层，负责端到端的通信，比如 <font color=#FEAE00>TCP</font><font color=#FEAE00>、</font><font color=#FEAE00>UDP </font><font color=#FEAE00>等</font>；<br>&emsp;&emsp;	•	网络层，负责网络包的封装、分片、路由、转发，比如<font color=#FEAE00> IP</font><font color=#FEAE00>、</font><font color=#FEAE00>ICMP</font> 等；<br>&emsp;&emsp;	•	网络接口层，负责网络包在物理网络中的传输，比如<font color=#FEAE00>网络包的封帧、</font><font color=#FEAE00> MAC </font><font color=#FEAE00>寻址、差错检测，以及通过网卡传输网络帧</font>等；<br>&emsp;&emsp;TCP/IP 网络模型相比 OSI 网络模型简化了不少，也更加易记，它们之间的关系如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;不过，我们常说的七层和四层负载均衡，是用 OSI 网络模型来描述的，七层对应的是应用层，四层对应的是传输层。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>2.3 linux 系统调用总结<hr>电脑与电脑之间通常都是通过话网卡、交换机、路由器等网络设备连接到一起，那由于网络设备的异构性，国际标准化组织定义了一个<font color=#FEAE00>七层的</font><font color=#FEAE00> OSI </font><font color=#FEAE00>网络模型</font>，但是这个模型由于比较复杂，实际应用中并没有采用，而是采用了更为简化的 TCP/IP 模型，Linux 网络协议栈就是按照了该模型来实现的。<br>&emsp;&emsp;TCP/IP 模型主要分为<font color=#FEAE00>应用层、传输层、网络层、网络接口层四层</font>，每一层负责的职责都不同，这也是 Linux 网络协议栈主要构成部分。<br>&emsp;&emsp;当应用程序通过 Socket 接口发送数据包，数据包会被网络协议栈从上到下进行逐层处理后，才会被送到网卡队列中，随后由网卡将网络包发送出去。<br>&emsp;&emsp;而在接收网络包时，同样也要先经过网络协议栈从下到上的逐层处理，最后才会被送到应用程序。<br>&emsp;&emsp;<hr><hr>3.1 HTTP 常见面试题<hr>在面试过程中，HTTP 被提问的概率还是比较高的。<br>&emsp;&emsp;小林我搜集了 6 大类 HTTP 面试常问的题目，同时这 6 大类题跟 <font color=#FEAE00>HTTP </font><font color=#FEAE00>的发展和演变</font>关联性是比较大的，通过<font color=#FEAE00>问答</font><font color=#FEAE00> + </font><font color=#FEAE00>图解</font>的形式<font color=#FEAE00>由浅入深</font>的方式帮助大家进一步的学习和理解 HTTP 。<br>&emsp;&emsp;<font color=#FEAE00>	1	HTTP </font><font color=#FEAE00>基本概念</font><font color=#FEAE00><br>&emsp;&emsp;	2	Get </font><font color=#FEAE00>与</font><font color=#FEAE00> Post<br>&emsp;&emsp;	3	HTTP </font><font color=#FEAE00>特性</font><font color=#FEAE00><br>&emsp;&emsp;	4	HTTP </font><font color=#FEAE00>缓存技术</font><font color=#FEAE00><br>&emsp;&emsp;	5	HTTPS </font><font color=#FEAE00>与</font><font color=#FEAE00> HTTP<br>&emsp;&emsp;	6	HTTP/1.1</font><font color=#FEAE00>、</font><font color=#FEAE00>HTTP/2</font><font color=#FEAE00>、</font><font color=#FEAE00>HTTP/3 </font><font color=#FEAE00>演变</font><br>&emsp;&emsp;￼<hr><hr>ARP:: 31、什么是RARP？工作原理<hr>概括： 反向地址转换协议，网络层协议，RARP与ARP工作方式相反。 RARP使只知道自己硬件地址的主机能够知道其IP地址。RARP发出要反向解释的物理地址并希望返回其IP地址，应答包括能够提供所需信息的RARP服务器发出的IP地址。 原理： (1)网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包，请求RARP服务器回复该主机的IP地址。<br>&emsp;&emsp;<br>&emsp;&emsp;(2)RARP服务器收到了RARP请求数据包，为其分配IP地址，并将RARP回应发送给主机。<br>&emsp;&emsp;<br>&emsp;&emsp;(3)PC1收到RARP回应后，就使用得到的IP地址进行通讯。<hr><hr>DNS: 6、为什么区域传送用TCP协议？<hr>因为TCP协议可靠性好啊！<br>&emsp;&emsp;<br>&emsp;&emsp;你要从主DNS上复制内容啊，你用不可靠的UDP？ <font color=#FEAE00>因为</font><font color=#FEAE00>TCP</font><font color=#FEAE00>协议传输的内容大啊，你用最大只能传</font><font color=#FEAE00>512</font><font color=#FEAE00>字节的</font><font color=#FEAE00>UDP</font><font color=#FEAE00>协议？</font>万一同步的数据大于512字节，你怎么办？所以用TCP协议比较好！<hr><hr>DNS:: 17、谈谈DNS解析过程，具体一点<br>&emsp;&emsp;<br>&emsp;&emsp;todo 图<hr>![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220036692.png)<br>&emsp;&emsp;<br>&emsp;&emsp;- 请求一旦发起，若是chrome浏览器，先在浏览器找之前有没有缓存过的域名所对应的ip地址，有的话，直接跳过dns解析了，若是没有，就会找硬盘的hosts文件，看看有没有，有的话，直接找到hosts文件里面的ip<br>&emsp;&emsp;- 如果本地的hosts文件没有能得到对应的ip地址，浏览器会发出一个dns请求到本地dns服务器，本地dns服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动等。<br>&emsp;&emsp;- 查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。<br>&emsp;&emsp;- 本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。<br>&emsp;&emsp;- 最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。<hr><hr>DNS:: 18、DNS负载均衡是什么策略？<br>&emsp;&emsp;<br>&emsp;&emsp;todo ？？？<hr>当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会崩掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。<hr><hr>DNS:: 34、DNS查询方式有哪些？<hr>### 递归解析<br>&emsp;&emsp;<br>&emsp;&emsp;当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。<br>&emsp;&emsp;<br>&emsp;&emsp;### 迭代解析<br>&emsp;&emsp;<br>&emsp;&emsp;当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。<hr><hr>DNS:: 3、你知道<font color=#FEAE00>DNS</font><font color=#FEAE00>是什么</font>？<hr>官方解释：<font color=#FEAE00>DNS</font><font color=#FEAE00>（</font><font color=#FEAE00>Domain Name System</font><font color=#FEAE00>，域名系统</font>），因特网上作为<font color=#FEAE00>域名和</font><font color=#FEAE00>IP</font><font color=#FEAE00>地址相互映射</font><font color=#FEAE00>的一个</font><font color=#FEAE00>分布式数据库</font>，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。<br>&emsp;&emsp;<br>&emsp;&emsp;通过<font color=#FEAE00>主机名，最终得到该主机名对应的</font><font color=#FEAE00>IP</font><font color=#FEAE00>地址</font>的过程叫做<font color=#FEAE00>域名解析</font>（或主机名解析）。<br>&emsp;&emsp;<br>&emsp;&emsp;通俗的讲，我们更习惯于记住一个网站的名字，比如www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。<hr><hr>DNS:: 4、DNS的工作原理？<br>&emsp;&emsp;<br>&emsp;&emsp;todo 图<hr>将主机域名转换为ip地址，属于应用层协议，使用UDP传输。（DNS应用层协议，以前有个考官问过）<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220036790.png) 过程： 总结： <font color=#FEAE00>浏览器缓存，系统缓存，路由器缓存，</font><font color=#FEAE00>IPS</font><font color=#FEAE00>服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存</font>。 一、主机向本地域名服务器的查询一般都是采用递归查询。 二、本地域名服务器向根域名服务器的查询的迭代查询。<br>&emsp;&emsp;<br>&emsp;&emsp;1. 当用户输入域名时，浏览器先检查自己的缓存中是否包含这个域名映射的ip地址，有解析结束。 2）若没命中，则检查操作系统缓存（如Windows的hosts）中有没有解析过的结果，有解析结束。 3）若无命中，则请求本地域名服务器解析（LDNS）。 4）若LDNS没有命中就直接跳到根域名服务器请求解析。根域名服务器返回给LDNS一个 主域名服务器地址。 5）此时LDNS再发送请求给上一步返回的gTLD（ 通用顶级域）， 接受请求的gTLD查找并返回这个域名对应的Name Server的地址 6）Name Server根据映射关系表找到目标ip，返回给LDNS<br>&emsp;&emsp;2. LDNS缓存这个域名和对应的ip， 把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束<hr><hr>DNS:: 5、为什么<font color=#FEAE00>域名解析</font>用UDP协议？<hr>因为UDP快啊！UDP的DNS协议<font color=#FEAE00>只要一个请求、一个应答</font>就好了。<br>&emsp;&emsp;<br>&emsp;&emsp;而使用基于TCP的DNS协议要三次握手、发送数据以及应答、四次挥手，但是<font color=#FF644E>UDP</font><font color=#FF644E>协议传输内容不能超过</font><font color=#FF644E>512</font><font color=#FF644E>字节</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;不过客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。<hr><hr>GET 与 POST<br>&emsp;&emsp;<hr># GET 和 POST 有什么区别？<br>&emsp;&emsp;根据 RFC 规范，<font color=#FEAE00>GET </font><font color=#FEAE00>的语义是从服务器获取指定的资源</font>，这个资源可以是静态的文本、页面、图片视频等。GET 请求的参数位置一般是写在 URL 中，URL 规定<font color=#FEAE00>只能支持</font><font color=#FEAE00> ASCII</font>，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。<br>&emsp;&emsp;比如，你打开我的文章，浏览器就会发送 GET 请求给服务器，服务器就会返回文章的所有文字及资源。<br>&emsp;&emsp;￼<br>&emsp;&emsp;根据 RFC 规范，<font color=#FEAE00>POST </font><font color=#FEAE00>的语义是根据请求负荷（报文</font><font color=#FEAE00>body</font><font color=#FEAE00>）对指定的资源做出处理</font>，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是<font color=#FEAE00>写在报文</font><font color=#FEAE00> body </font><font color=#FEAE00>中</font>， body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。<br>&emsp;&emsp;比如，你在我文章底部，敲入了留言后点击「提交，浏览器就会执行一次 POST 请求，把你的留言文字放进了报文 body 里，然后拼接好 POST 请求头，通过 TCP 协议发送给服务器。<br>&emsp;&emsp;￼<br>&emsp;&emsp;# GET 和 POST 方法都是<font color=#FEAE00>安全和幂等</font>的吗？<br>&emsp;&emsp;先说明下安全和幂等的概念：<br>&emsp;&emsp;	•	在 HTTP 协议里，所谓的「安全」是指请求方法不会「<font color=#FEAE00>破坏</font>」服务器上的资源。<br>&emsp;&emsp;	•	所谓的「<font color=#FEAE00>幂等</font>」，意思是多次执行相同的操作，结果都是「相同」的。<br>&emsp;&emsp;如果从 RFC 规范定义的语义来看：<br>&emsp;&emsp;<font color=#FEAE00>	•	GET </font><font color=#FEAE00>方法就是安全且幂等的</font>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<font color=#FEAE00>可以对</font><font color=#FEAE00> GET </font><font color=#FEAE00>请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如</font><font color=#FEAE00>nginx</font><font color=#FEAE00>），而且在浏览器中</font><font color=#FEAE00> GET </font><font color=#FEAE00>请求可以保存为书签</font><font color=#FEAE00>。</font><br>&emsp;&emsp;<font color=#FEAE00>	•	POST</font><font color=#FEAE00> </font>因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<font color=#FEAE00>不安全</font>的，且多次提交数据就会创建多个资源，所以<font color=#FEAE00>不是幂等</font>的。所以，<font color=#FEAE00>浏览器一般不会缓存</font><font color=#FEAE00> POST </font><font color=#FEAE00>请求，也不能把</font><font color=#FEAE00> POST </font><font color=#FEAE00>请求保存为书签</font><font color=#FEAE00>。</font><br>&emsp;&emsp;做个简要的小结。<br>&emsp;&emsp;GET 的语义是请求获取指定的资源。GET 方法是<font color=#FEAE00>安全、幂等、可被缓存的。</font><br>&emsp;&emsp;POST 的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。<font color=#FEAE00>POST </font><font color=#FEAE00>不安全，不幂等，（大部分实现）不可缓存。</font><br>&emsp;&emsp;注意， 上面是从 RFC 规范定义的语义来分析的。<br>&emsp;&emsp;但是实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法。比如：<br>&emsp;&emsp;	•	可以用 <font color=#FEAE00>GET </font><font color=#FEAE00>方法实现新增或删除数据的请求</font>，这样实现的 GET 方法自然就不是安全和幂等。<br>&emsp;&emsp;	•	可以用 P<font color=#FEAE00>OST </font><font color=#FEAE00>方法实现查询数据的请求</font>，这样实现的 POST 方法自然就是安全和幂等。<br>&emsp;&emsp;曾经有个笑话，有人写了个博客，删除博客用的是GET请求，他觉得没人访问就连鉴权都没做。然后Google服务器爬虫爬了一遍，他所有博文就没了。。。<br>&emsp;&emsp;如果「安全」放入概念是指信息是否会被泄漏的话，虽然 POST 用 body 传输数据，而 GET 用 URL 传输，这样数据会在浏览器地址拦容易看到，但是并不能说 GET 不如 POST 安全的。<br>&emsp;&emsp;因为 HTTP 传输的内容都是明文的，虽然在浏览器地址拦看不到 POST 提交的 body 数据，但是只要抓个包就都能看到了。<br>&emsp;&emsp;所以，要避免传输过程中数据被窃取，就要使用 HTTPS 协议，这样所有 HTTP 的数据都会被加密传输。<br>&emsp;&emsp;# GET 请求可以<font color=#FEAE00>带</font><font color=#FEAE00> body</font> 吗？<br>&emsp;&emsp;RFC 规范并没有规定 GET 请求不能带 body 的。理论上，<font color=#FEAE00>任何请求都可以带</font><font color=#FEAE00> body</font> 的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。<br>&emsp;&emsp;另外，URL 中的查询参数也不是 GET 所独有的，<font color=#FEAE00>POST </font><font color=#FEAE00>请求的</font><font color=#FEAE00> URL </font><font color=#FEAE00>中也可以有参数的。</font><hr><hr>HTTP 2、说一下一次完整的HTTP请求过程包括哪些内容？简略回答<hr>### 第一种回答<br>&emsp;&emsp;<br>&emsp;&emsp;- 建立起客户机和服务器连接。<br>&emsp;&emsp;- 建立连接后，客户机发送一个请求给服务器。<br>&emsp;&emsp;- 服务器收到请求给予响应信息。<br>&emsp;&emsp;- 客户端浏览器将返回的内容解析并呈现，断开连接。<br>&emsp;&emsp;<br>&emsp;&emsp;### 第二种回答<br>&emsp;&emsp;<br>&emsp;&emsp;域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户。<hr><hr>HTTP <font color=#FEAE00>基本概念</font><hr>HTTP 是什么？<br>&emsp;&emsp;HTTP 是超文本传输协议，也就是<font color=#FEAE00>H</font><font color=#FEAE00>yperText </font><font color=#FEAE00>T</font><font color=#FEAE00>ransfer </font><font color=#FEAE00>P</font><font color=#FEAE00>rotocol</font><font color=#FEAE00>。</font><br>&emsp;&emsp;能否详细解释「超文本传输协议」？<br>&emsp;&emsp;HTTP的名字「超文本协议传输」，它可以拆成三个部分：<br>&emsp;&emsp;	•	<font color=#FEAE00>超文本</font><font color=#FEAE00><br>&emsp;&emsp;	•	</font><font color=#FEAE00>传输</font><font color=#FEAE00><br>&emsp;&emsp;	•	</font><font color=#FEAE00>协议</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;1. <font color=#7414AF>「协议」</font><br>&emsp;&emsp;在生活中，我们也能随处可见「协议」，例如：<br>&emsp;&emsp;	•	刚毕业时会签一个「三方协议」；<br>&emsp;&emsp;	•	找房子时会签一个「租房协议」；<br>&emsp;&emsp;￼<br>&emsp;&emsp;生活中的协议，本质上与计算机中的协议是相同的，协议的特点:<br>&emsp;&emsp;	•	「<font color=#FEAE00>协</font>」字，代表的意思是必须有<font color=#FEAE00>两个以上的参与者</font><font color=#FEAE00>。</font>例如三方协议里的参与者有三个：你、公司、学校三个；租房协议里的参与者有两个：你和房东。<br>&emsp;&emsp;	•	「<font color=#FEAE00>议</font>」字，代表的意思是对参与者的一种<font color=#FEAE00>行为约定和规范</font>。例如三方协议里规定试用期期限、毁约金等；租房协议里规定租期期限、每月租金金额、违约如何处理等。<br>&emsp;&emsp;针对 HTTP <font color=#FEAE00>协议</font>，我们可以这么理解。<br>&emsp;&emsp;HTTP 是一个用在计算机世界里的<font color=#FEAE00>协议</font>。它使用计算机能够理解的语言确立了一种计算机之间<font color=#FEAE00>交流通信</font>的规范（<font color=#FEAE00>两个以上的参与者</font>），以及相关的<font color=#FEAE00>各种控制和错误处理</font>方式（<font color=#FEAE00>行为约定和规范</font>）。<br>&emsp;&emsp;2. <font color=#7414AF>「传输」</font><br>&emsp;&emsp;所谓的「传输」，很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点 搬到 A 点。<br>&emsp;&emsp;别轻视了这个简单的动作，它至少包含两项重要的信息。<br>&emsp;&emsp;HTTP 协议是一个<font color=#FEAE00>双向协议</font>。<br>&emsp;&emsp;我们在上网冲浪时，浏览器是请求方 A ，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。<br>&emsp;&emsp;￼<br>&emsp;&emsp;数据虽然是在 A 和 B 之间传输，但允许中间有<font color=#FEAE00>中转或接力</font><font color=#FEAE00>。</font><br>&emsp;&emsp;就好像第一排的同学想传递纸条给最后一排的同学，那么传递的过程中就需要经过好多个同学（中间人），这样的传输方式就从「A < --- > B」，变成了「A <-> N <-> M <-> B」。<br>&emsp;&emsp;而在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。<br>&emsp;&emsp;针对<font color=#FEAE00>传输</font>，我们可以进一步理解了 HTTP。<br>&emsp;&emsp;HTTP 是一个在计算机世界里专门用来在<font color=#FEAE00>两点之间传输数据</font>的约定和规范。<br>&emsp;&emsp;3. <font color=#7414AF>「超文本」</font><br>&emsp;&emsp;HTTP 传输的内容是「超文本」。<br>&emsp;&emsp;我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算作「文本」。<br>&emsp;&emsp;再来理解「超文本」，它就是<font color=#FEAE00>超越了普通文本的文本</font>，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。<br>&emsp;&emsp;HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。<br>&emsp;&emsp;OK，经过了对 HTTP 里这三个名词的详细解释，就可以给出比「超文本传输协议」这七个字更准确更有技术含量的答案：<br>&emsp;&emsp;<font color=#FEAE00>HTTP </font><font color=#FEAE00>是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</font><br>&emsp;&emsp;那「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议 ，这种说法正确吗？<br>&emsp;&emsp;这种说法是<font color=#FEAE00>不正确</font>的。因为也可以是「服务器< -- >服务器」，所以采用<font color=#FEAE00>两点之间</font>的描述会更准确。<br>&emsp;&emsp;# HTTP 常见的状态码有哪些？<br>&emsp;&emsp;￼<br>&emsp;&emsp;<font color=#4D647F>1xx</font> 类状态码属于<font color=#FEAE00>提示信息</font>，是协议处理中的一种中间状态，实际用到的比较少。<br>&emsp;&emsp;<font color=#4D647F>2xx</font> 类状态码表示服务器<font color=#FEAE00>成功</font>处理了客户端的请求，也是我们最愿意看到的状态。<br>&emsp;&emsp;	•	「<font color=#FEAE00>200 OK</font>」是最常见的成功状态码，表示一切正常。如果是非 <font color=#4D647F>HEAD</font> 请求，服务器返回的响应头都会有 body 数据。<br>&emsp;&emsp;	•	「<font color=#FEAE00>204 No Content</font>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。<br>&emsp;&emsp;	•	「<font color=#FEAE00>206 Partial Content</font>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。<br>&emsp;&emsp;<font color=#FEAE00>3xx</font> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<font color=#FEAE00>重定向</font>。<br>&emsp;&emsp;	•	「<font color=#FEAE00>301 Moved Permanently</font>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。<br>&emsp;&emsp;	•	「<font color=#FEAE00>302 Found</font>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。<br>&emsp;&emsp;301 和 302 都会在响应头里使用字段 <font color=#4D647F>Location</font>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。<br>&emsp;&emsp;	•	「<font color=#FEAE00>304 Not Modified</font>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。<br>&emsp;&emsp;<font color=#4D647F>4xx</font> 类状态码表示客户端发送的<font color=#FEAE00>报文有误</font>，服务器无法处理，也就是错误码的含义。<br>&emsp;&emsp;	•	「<font color=#FEAE00>400 Bad Request</font>」表示客户端请求的报文有错误，但只是个笼统的错误。<br>&emsp;&emsp;	•	「<font color=#FEAE00>403 Forbidden</font>」表示服务器禁止访问资源，并不是客户端的请求出错。<br>&emsp;&emsp;	•	「<font color=#FEAE00>404 Not Found</font>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。<br>&emsp;&emsp;<font color=#4D647F>5xx</font> 类状态码表示客户端请求报文正确，但是<font color=#FEAE00>服务器处理时内部发生了错误</font>，属于服务器端的错误码。<br>&emsp;&emsp;	•	「<font color=#FEAE00>500 Internal Server Error</font>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。<br>&emsp;&emsp;	•	「<font color=#FEAE00>501 Not Implemented</font>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。<br>&emsp;&emsp;	•	「<font color=#FEAE00>502 Bad Gateway</font>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。<br>&emsp;&emsp;	•	「<font color=#FEAE00>503 Service Unavailable</font>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。<br>&emsp;&emsp;# HTTP 常见字段有哪些？<br>&emsp;&emsp;<font color=#7414AF>Host</font> 字段<br>&emsp;&emsp;客户端发送请求时，用来指定服务器的域名。<br>&emsp;&emsp;￼<br>&emsp;&emsp;Host: www.A.com<br>&emsp;&emsp;有了 <font color=#FEAE00>Host</font> 字段，就可以将请求发往「同一台」服务器上的不同网站。<br>&emsp;&emsp;<font color=#7414AF>Content-Length </font><font color=#7414AF>字段</font><br>&emsp;&emsp;服务器在返回数据时，会有 <font color=#FEAE00>Content-Length</font> 字段，表明本次回应的数据长度。<br>&emsp;&emsp;￼<br>&emsp;&emsp;Content-Length: 1000<br>&emsp;&emsp;如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。<br>&emsp;&emsp;<font color=#7414AF>Connection </font><font color=#7414AF>字段</font><br>&emsp;&emsp;<font color=#4D647F>Connection</font> 字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。<br>&emsp;&emsp;￼<br>&emsp;&emsp;HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 <font color=#4D647F>Connection</font> 首部字段的值为 <font color=#4D647F>Keep-Alive</font>。<br>&emsp;&emsp;Connection: keep-alive<br>&emsp;&emsp;一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。<br>&emsp;&emsp;<font color=#7414AF>Content-Type </font><font color=#7414AF>字段</font><br>&emsp;&emsp;<font color=#4D647F>Content-Type</font> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。<br>&emsp;&emsp;￼<br>&emsp;&emsp;Content-Type: text/html; charset=utf-8<br>&emsp;&emsp;上面的类型表明，发送的是网页，而且编码是UTF-8。<br>&emsp;&emsp;客户端请求的时候，可以使用 <font color=#4D647F>Accept</font> 字段声明自己可以接受哪些数据格式。<br>&emsp;&emsp;Accept: */*<br>&emsp;&emsp;上面代码中，客户端声明自己可以接受任何格式的数据。<br>&emsp;&emsp;<font color=#7414AF>Content-Encoding </font><font color=#7414AF>字段</font><br>&emsp;&emsp;<font color=#4D647F>Content-Encoding</font> 字段说明<font color=#FEAE00>数据的压缩方法</font>。表示服务器返回的数据使用了什么<font color=#FEAE00>压缩格式</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;Content-Encoding: gzip<br>&emsp;&emsp;上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。<br>&emsp;&emsp;客户端在请求时，用 <font color=#4D647F>Accept-Encoding</font> 字段说明自己可以接受哪些压缩方法。<br>&emsp;&emsp;Accept-Encoding: gzip, deflate<hr><hr>HTTP <font color=#FEAE00>缓存技术</font><hr># HTTP 缓存<font color=#FEAE00>有哪些实现方式</font>？<br>&emsp;&emsp;对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都<font color=#FEAE00>缓存在本地</font>，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定肉眼可见的提升。<br>&emsp;&emsp;所以，避免发送 HTTP 请求的方法就是通过<font color=#FEAE00>缓存技术</font>，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。<br>&emsp;&emsp;HTTP 缓存有两种实现方式，分别是<font color=#FEAE00>强制缓存和协商缓存</font><font color=#FEAE00>。</font><br>&emsp;&emsp;# 什么是<font color=#FEAE00>强制缓存</font>？<br>&emsp;&emsp;强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。<br>&emsp;&emsp;如下图中，返回的是 200 状态码，但在 size 项中标识的是 from disk cache，就是使用了强制缓存。<br>&emsp;&emsp;￼<br>&emsp;&emsp;强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：<br>&emsp;&emsp;<font color=#4D647F>	•	</font><font color=#4D647F>Cache-Control</font>， 是一个相对时间；<br>&emsp;&emsp;<font color=#4D647F>	•	</font><font color=#4D647F>Expires</font>，是一个绝对时间；<br>&emsp;&emsp;如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，<font color=#FEAE00>Cache-Control</font><font color=#FEAE00>的优先级高于</font><font color=#FEAE00> Expires</font><font color=#FEAE00> </font><font color=#FEAE00>。</font><br>&emsp;&emsp;Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：<br>&emsp;&emsp;	•	当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；<br>&emsp;&emsp;	•	浏览器再次请求访问服务器中的该资源时，会先<font color=#FEAE00>通过请求资源的时间与</font><font color=#FEAE00> Cache-Control </font><font color=#FEAE00>中设置的过期时间大小，来计算出该资源是否过期</font><font color=#FEAE00>，</font>如果没有，则使用该缓存，否则重新请求服务器；<br>&emsp;&emsp;	•	服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。<br>&emsp;&emsp;# 什么是<font color=#FEAE00>协商缓存</font>？<br>&emsp;&emsp;当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 <font color=#FEAE00>304</font>，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。<br>&emsp;&emsp;￼<br>&emsp;&emsp;上图就是一个协商缓存的过程，所以<font color=#FEAE00>协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存</font><font color=#FEAE00>。</font><br>&emsp;&emsp;协商缓存可以基于<font color=#FEAE00>两种头部来实现</font>。<br>&emsp;&emsp;第一种：请求头部中的 <font color=#FEAE00>If-Modified-Since</font> 字段与响应头部中的 <font color=#FEAE00>Last-Modified</font> 字段实现，这两个字段的意思是：<br>&emsp;&emsp;	•	响应头部中的 <font color=#FEAE00>Last-Modified</font>：标示这个响应资源的最后修改时间；<br>&emsp;&emsp;	•	请求头部中的 <font color=#FEAE00>If-Modified-Since</font>：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。<br>&emsp;&emsp;第二种：请求头部中的 <font color=#FEAE00>If-None-Match</font> 字段与响应头部中的 <font color=#FEAE00>ETag</font> 字段，这两个字段的意思是：<br>&emsp;&emsp;	•	响应头部中 <font color=#4D647F>Etag</font>：<font color=#FEAE00>唯一标识响应资源；</font><br>&emsp;&emsp;	•	请求头部中的 <font color=#4D647F>If-None-Match</font>：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。<br>&emsp;&emsp;第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。<br>&emsp;&emsp;如果在第一次请求资源的时候，服务端返回的 HTTP 响应头部同时有 Etag 和 Last-Modified 字段，那么客户端再下一次请求的时候，如果带上了 ETag 和 Last-Modified 字段信息给服务端，<font color=#FEAE00>这时</font><font color=#FEAE00> Etag </font><font color=#FEAE00>的优先级更高</font>，也就是服务端先会判断 Etag 是否变化了，如果 Etag 有变化就不用在判断 Last-Modified 了，如果 Etag 没有变化，然后再看 Last-Modified。<br>&emsp;&emsp;# 为什么 ETag 的<font color=#FEAE00>优先级更高</font>？<br>&emsp;&emsp;这是因为 ETag 主要能解决 Last-Modified 几个比较难以解决的问题：<br>&emsp;&emsp;	1	在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求；<br>&emsp;&emsp;	2	可能有些文件是在秒级以内修改的，<font color=#4D647F>If-Modified-Since</font> 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；<br>&emsp;&emsp;	3	有些服务器不能精确获取文件的最后修改时间。<br>&emsp;&emsp;注意，<font color=#FEAE00>协商缓存这两个字段都需要配合强制缓存中</font><font color=#FEAE00> Cache-control </font><font color=#FEAE00>字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求</font><font color=#FEAE00>。</font><br>&emsp;&emsp;下图是强制缓存和协商缓存的工作流程：<br>&emsp;&emsp;￼<br>&emsp;&emsp;当使用 ETag 字段实现的协商缓存的过程：<br>&emsp;&emsp;	•	当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部<font color=#FEAE00>加上</font><font color=#FEAE00> ETag </font><font color=#FEAE00>唯一标识</font>，这个唯一标识的值是根据当前请求的资源生成的；<br>&emsp;&emsp;	•	当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：<br>&emsp;&emsp;	◦	如果没有过期，则直接使用本地缓存；<br>&emsp;&emsp;	◦	如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识；<br>&emsp;&emsp;	•	服务器再次收到请求后，<font color=#FEAE00>会根据请求中的</font><font color=#FEAE00> If-None-Match </font><font color=#FEAE00>值与当前请求的资源生成的唯一标识进行比较</font><font color=#FEAE00>：</font><font color=#FEAE00><br>&emsp;&emsp;</font><font color=#FEAE00>	◦	</font><font color=#FEAE00>如果值相等，则返回</font><font color=#FEAE00> 304 Not Modified</font><font color=#FEAE00>，不会返回资源</font><font color=#FEAE00>；</font><br>&emsp;&emsp;	◦	如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；<br>&emsp;&emsp;	•	如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。<hr><hr>HTTP.GET:: 37、GET 方法的长度限制是怎么回事？<br>&emsp;&emsp;<br>&emsp;&emsp;todo 可能重了<hr>网络上都会提到浏览器地址栏输入的参数是有限的。<br>&emsp;&emsp;<br>&emsp;&emsp;首先说明一点，HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。<br>&emsp;&emsp;<br>&emsp;&emsp;浏览器原因就不说了，服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。<hr><hr>HTTP:: 10、HTTP请求方法你知道多少？<hr>客户端发送的 请求报文 第一行为请求行，包含了方法字段。<br>&emsp;&emsp;<br>&emsp;&emsp;根据 HTTP 标准，HTTP 请求可以使用多种请求方法。<br>&emsp;&emsp;<br>&emsp;&emsp;HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。<br>&emsp;&emsp;<br>&emsp;&emsp;HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。<br>&emsp;&emsp;<br>&emsp;&emsp;| 序 号 | 方法    | 描述                                                         |<br>&emsp;&emsp;| :---- | :------ | :----------------------------------------------------------- |<br>&emsp;&emsp;| 1     | GET     | 请求指定的页面信息，并返回实体主体。                         |<br>&emsp;&emsp;| 2     | HEAD    | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 |<br>&emsp;&emsp;| 3     | POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 |<br>&emsp;&emsp;| 4     | PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。             |<br>&emsp;&emsp;| 5     | DELETE  | 请求服务器删除指定的页面。                                   |<br>&emsp;&emsp;| 6     | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。    |<br>&emsp;&emsp;| 7     | OPTIONS | 允许客户端查看服务器的性能。                                 |<br>&emsp;&emsp;| 8     | TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                   |<br>&emsp;&emsp;| 9     | PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。           |<hr><hr>HTTP:: 12、一个TCP连接可以对应几个HTTP请求？<hr>如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的。<hr><hr>HTTP:: 13、一个 TCP 连接中 <font color=#FEAE00>HTTP </font><font color=#FEAE00>请求发送可以一起发送么</font>（比如一起发三个请求，再三个响应一起接收）？<hr><font color=#FEAE00>HTTP/1.1 </font><font color=#FEAE00>存在一个问题，单个</font><font color=#FEAE00> TCP </font><font color=#FEAE00>连接在同一时刻只能处理一个请求，</font>意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。<br>&emsp;&emsp;<br>&emsp;&emsp;在 HTTP/1.1 存在 <font color=#FEAE00>Pipelining </font><font color=#FEAE00>技术可以完成这个多个请求同时发送</font>，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中<font color=#FEAE00>由于</font><font color=#FEAE00> Multiplexing </font><font color=#FEAE00>特点的存在</font>，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。<br>&emsp;&emsp;<br>&emsp;&emsp;那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：<br>&emsp;&emsp;<br>&emsp;&emsp;- 维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。<br>&emsp;&emsp;- 和服务器建立多个 TCP 连接。<hr><hr>HTTP:: 15、在浏览器中<font color=#FEAE00>输入</font><font color=#FEAE00>url</font><font color=#FEAE00>地址</font>后显示主页的过程?<br>&emsp;&emsp;应该是重复了<hr>> - 根据域名，进行DNS域名解析；<br>&emsp;&emsp;> - 拿到解析的IP地址，建立TCP连接；<br>&emsp;&emsp;> - 向IP地址，发送HTTP请求；<br>&emsp;&emsp;> - 服务器处理请求；<br>&emsp;&emsp;> - 返回响应结果；<br>&emsp;&emsp;> - 关闭TCP连接；<br>&emsp;&emsp;> - 浏览器解析HTML；<br>&emsp;&emsp;> - 浏览器布局渲染；<hr><hr>HTTP:: 16、在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？<br>&emsp;&emsp;<br>&emsp;&emsp;todo 多总结一下<hr>### 第一种回答<br>&emsp;&emsp;<br>&emsp;&emsp;1、<font color=#FEAE00>查浏览器缓存，看看有没有已经缓存好的</font>，如果没有<br>&emsp;&emsp;<br>&emsp;&emsp;2 、检查<font color=#FEAE00>本机</font><font color=#FEAE00>host</font><font color=#FEAE00>文件</font>，<br>&emsp;&emsp;<br>&emsp;&emsp;3、调用API，Linux下Socket函数 <font color=#FEAE00>gethostbyname</font><br>&emsp;&emsp;<br>&emsp;&emsp;4、向DNS服务器<font color=#FEAE00>发送</font><font color=#FEAE00>DNS</font><font color=#FEAE00>请求</font>，查询本地DNS服务器，这其中用的是UDP的协议<br>&emsp;&emsp;<br>&emsp;&emsp;5、如果在一个子网内采用ARP地址解析协议进行ARP查询如果不在一个子网那就需要对默认网关进行DNS查询，如果还找不到会一直向上找根DNS服务器，直到最终拿到IP地址（全球400多个根DNS服务器，由13个不同的组织管理）<br>&emsp;&emsp;<br>&emsp;&emsp;6、这个时候我们就有了服务器的IP地址 以及默认的端口号了，http默认是80 https是 443 端口号，会，首先尝试http然后调用Socket建立TCP连接，<br>&emsp;&emsp;<br>&emsp;&emsp;7、经过三次握手成功建立连接后，开始传送数据，如果正是http协议的话，就返回就完事了，<br>&emsp;&emsp;<br>&emsp;&emsp;8、如果不是http协议，服务器会返回一个5开头的的重定向消息，告诉我们用的是https，那就是说IP没变，但是端口号从80变成443了，好了，再四次挥手，完事，<br>&emsp;&emsp;<br>&emsp;&emsp;9、再来一遍，这次除了上述的端口号从80变成443之外，还会采用SSL的加密技术来保证传输数据的安全性，保证数据传输过程中不被修改或者替换之类的，<br>&emsp;&emsp;<br>&emsp;&emsp;10、这次依然是三次握手，沟通好双方使用的认证算法，加密和检验算法，在此过程中也会检验对方的CA安全证书。<br>&emsp;&emsp;<br>&emsp;&emsp;11、确认无误后，开始通信，然后服务器就会返回你所要访问的网址的一些数据，在此过程中会将界面进行渲染，牵涉到ajax技术之类的，直到最后我们看到色彩斑斓的网页<br>&emsp;&emsp;<br>&emsp;&emsp;> update1:为微信好友”卷轴“提出勘误”缺少5“-》现已加上<br>&emsp;&emsp;<br>&emsp;&emsp;### 第二种回答<br>&emsp;&emsp;<br>&emsp;&emsp;浏览器检查域名是否在缓存当中（要查看 Chrome 当中的缓存， 打开 chrome://net-internals/#dns）。<br>&emsp;&emsp;<br>&emsp;&emsp;如果缓存中没有，就去调用 `gethostbyname` 库函数（操作系统不同函数也不同）进行查询。<br>&emsp;&emsp;<br>&emsp;&emsp;`如果`gethostbyname`没有这个域名的缓存记录，也没有在`hosts` 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。<br>&emsp;&emsp;<br>&emsp;&emsp;查询本地 DNS 服务器<br>&emsp;&emsp;<br>&emsp;&emsp;如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询<br>&emsp;&emsp;<br>&emsp;&emsp;如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询<hr><hr>HTTP:: 19、<font color=#FEAE00>HTTPS</font><font color=#FEAE00>和</font><font color=#FEAE00>HTTP</font>的区别<hr>1、HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全， <font color=#FEAE00>HTTPS</font><font color=#FEAE00>协议是由</font><font color=#FEAE00>SSL+HTTP</font>协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。<br>&emsp;&emsp;<br>&emsp;&emsp;2、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。 3、http和https使用的是完全不同的连接方式，用的端口也不一样，<font color=#FEAE00>前者是</font><font color=#FEAE00>80</font><font color=#FEAE00>，后者是</font><font color=#FEAE00>443</font>。<hr><hr>HTTP:: 23、HTTP请求和响应报文有哪些主要字段？<br>&emsp;&emsp;<br>&emsp;&emsp;todo 好像不全<hr>### 请求报文<br>&emsp;&emsp;<br>&emsp;&emsp;简单来说：<br>&emsp;&emsp;<br>&emsp;&emsp;- 请求行：Request Line<br>&emsp;&emsp;- 请求头：Request Headers<br>&emsp;&emsp;- 请求体：Request Body<br>&emsp;&emsp;<br>&emsp;&emsp;### 响应报文<br>&emsp;&emsp;<br>&emsp;&emsp;简单来说：<br>&emsp;&emsp;<br>&emsp;&emsp;- 状态行：Status Line<br>&emsp;&emsp;- 响应头：Response Headers<br>&emsp;&emsp;- 响应体：Response Body<hr><hr>HTTP:: 24、Cookie是什么？<hr>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务，HTTP/1.1 引入 Cookie 来保存状态信息。<br>&emsp;&emsp;<br>&emsp;&emsp;Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。<br>&emsp;&emsp;<br>&emsp;&emsp;Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。<br>&emsp;&emsp;<br>&emsp;&emsp;新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。<br>&emsp;&emsp;<br>&emsp;&emsp;cookie 的出现是因为 HTTP 是无状态的一种协议，换句话说，服务器记不住你，可能你每刷新一次网页，就要重新输入一次账号密码进行登录。这显然是让人无法接受的，cookie 的作用就好比服务器给你贴个标签，然后你每次向服务器再发请求时，服务器就能够 cookie 认出你。<br>&emsp;&emsp;<br>&emsp;&emsp;抽象地概括一下：一个 cookie 可以认为是一个「变量」，形如 name=value，存储在浏览器；一个 session 可以理解为一种数据结构，多数情况是「映射」（键值对），存储在服务器上。<hr><hr>HTTP:: 25、Cookie有什么用途？用途<hr>- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）<br>&emsp;&emsp;- 个性化设置（如用户自定义设置、主题等）<br>&emsp;&emsp;- 浏览器行为跟踪（如跟踪分析用户行为等）<hr><hr>HTTP:: 26、Session知识大总结<hr>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。<br>&emsp;&emsp;<br>&emsp;&emsp;Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。<br>&emsp;&emsp;<br>&emsp;&emsp;使用 Session 维护用户登录状态的过程如下：<br>&emsp;&emsp;<br>&emsp;&emsp;1. 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；<br>&emsp;&emsp;2. 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；<br>&emsp;&emsp;3. 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；<br>&emsp;&emsp;4. 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。<br>&emsp;&emsp;<br>&emsp;&emsp;> 注意：Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。<hr><hr>HTTP:: 28、Cookie与Session的对比<hr>HTTP作为无状态协议，必然需要在某种方式保持连接状态。这里简要介绍一下Cookie和Session。<br>&emsp;&emsp;<br>&emsp;&emsp;- ##### Cookie<br>&emsp;&emsp;<br>&emsp;&emsp;  Cookie是客户端保持状态的方法。<br>&emsp;&emsp;<br>&emsp;&emsp;  Cookie简单的理解就是存储由服务器发至客户端并由客户端保存的一段字符串。为了保持会话，服务器可以在响应客户端请求时将Cookie字符串放在Set-Cookie下，客户机收到Cookie之后保存这段字符串，之后再请求时候带上Cookie就可以被识别。<br>&emsp;&emsp;<br>&emsp;&emsp;  除了上面提到的这些，Cookie在客户端的保存形式可以有两种，一种是会话Cookie一种是持久Cookie，会话Cookie就是将服务器返回的Cookie字符串保持在内存中，关闭浏览器之后自动销毁，持久Cookie则是存储在客户端磁盘上，其有效时间在服务器响应头中被指定，在有效期内，客户端再次请求服务器时都可以直接从本地取出。需要说明的是，存储在磁盘中的Cookie是可以被多个浏览器代理所共享的。<br>&emsp;&emsp;<br>&emsp;&emsp;- Session<br>&emsp;&emsp;<br>&emsp;&emsp;  Session是服务器保持状态的方法。<br>&emsp;&emsp;<br>&emsp;&emsp;  首先需要明确的是，Session保存在服务器上，可以保存在数据库、文件或内存中，每个用户有独立的Session用户在客户端上记录用户的操作。我们可以理解为每个用户有一个独一无二的Session ID作为Session文件的Hash键，通过这个值可以锁定具体的Session结构的数据，这个Session结构中存储了用户操作行为。<br>&emsp;&emsp;<br>&emsp;&emsp;当服务器需要识别客户端时就需要结合Cookie了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。如果客户端的浏览器禁用了Cookie，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如sid=xxxxx这样的参数，服务端据此来识别用户，这样就可以帮用户完成诸如用户名等信息自动填入的操作了。<hr><hr>HTTP:: 29、SQL注入攻击了解吗？<br>&emsp;&emsp;<br>&emsp;&emsp;todo 那个sql什么意思？<br>&emsp;&emsp;sql中的单双引号<hr>攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。 用户登录，输入用户名 lianggzone，密码 ‘ or ‘1’=’1 ，如果此时使用参数构造的方式，就会出现 select * from user where name = ‘lianggzone’ and password = ‘’ or ‘1’=‘1’ 不管用户名和密码是什么内容，使查询出来的用户列表不为空。如何防范SQL注入攻击使用预编译的PrepareStatement是必须的，但是一般我们会从两个方面同时入手。 Web端 1）有效性检验。 2）限制字符串输入的长度。 服务端 1）不用拼接SQL字符串。 2）使用预编译的PrepareStatement。 3）有效性检验。(为什么服务端还要做有效性检验？第一准则，外部都是不可信的，防止攻击者绕过Web端请求) 4）过滤SQL需要的参数中的特殊字符。比如单引号、双引号。<hr><hr>HTTP:: 35、HTTP中缓存的私有和共有字段？知道吗？<hr>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。<br>&emsp;&emsp;<br>&emsp;&emsp;```html<br>&emsp;&emsp;Cache-Control: private<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。<br>&emsp;&emsp;<br>&emsp;&emsp;```html<br>&emsp;&emsp;Cache-Control: public<br>&emsp;&emsp;```<hr><hr>HTTP:: 41、使用 Session 的过程是怎样的？<hr>过程如下：<br>&emsp;&emsp;<br>&emsp;&emsp;- 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；<br>&emsp;&emsp;- 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；<br>&emsp;&emsp;- 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；<br>&emsp;&emsp;- 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。<br>&emsp;&emsp;<br>&emsp;&emsp;注意：Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。<hr><hr>HTTP:: 42、Session和cookie应该如何去选择（适用场景）？<hr>- Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；<br>&emsp;&emsp;- Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；<br>&emsp;&emsp;- 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。<hr><hr>HTTP:: 43、Cookies和Session区别是什么？<hr>Cookie和Session都是客户端与服务器之间保持状态的解决方案<br>&emsp;&emsp;1，存储的位置不同，cookie：存放在客户端，session：存放在服务端。Session存储的数据比较安全<br>&emsp;&emsp;2，存储的数据类型不同<br>&emsp;&emsp;两者都是key-value的结构，但针对value的类型是有差异的<br>&emsp;&emsp;cookie：value只能是字符串类型，session：value是Object类型<br>&emsp;&emsp;3，存储的数据大小限制不同<br>&emsp;&emsp;cookie：大小受浏览器的限制，很多是是4K的大小， session：理论上受当前内存的限制，<br>&emsp;&emsp;4，生命周期的控制<br>&emsp;&emsp;cookie的生命周期当浏览器关闭的时候，就消亡了<br>&emsp;&emsp;(1)cookie的生命周期是累计的，从创建时，就开始计时，20分钟后，cookie生命周期结束，<br>&emsp;&emsp;(2)session的生命周期是间隔的，从创建时，开始计时如在20分钟，没有访问session，那么session生命周期被销毁<hr><hr>HTTP:: 46、HTTP中有个缓存机制，但如何保证缓存是最新的呢？（缓存过期机制）<br>&emsp;&emsp;todo 答案对么<hr>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。<br>&emsp;&emsp;<br>&emsp;&emsp;max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。<br>&emsp;&emsp;<br>&emsp;&emsp;```html<br>&emsp;&emsp;Cache-Control: max-age=31536000<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。<br>&emsp;&emsp;<br>&emsp;&emsp;```html<br>&emsp;&emsp;Expires: Wed, 04 Jul 2012 08:26:05 GMT<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;- 在 HTTP/1.1 中，会优先处理 max-age 指令；<br>&emsp;&emsp;- 在 HTTP/1.0 中，max-age 指令会被忽略掉。<hr><hr>HTTP:: 74、为什么有的时候刷新页面不需要重新建立 SSL 连接？<br>&emsp;&emsp;<br>&emsp;&emsp;todo 题不清<hr>TCP 连接有的时候会被浏览器和服务端维持一段时间，TCP 不需要重新建立，SSL 自然也会用之前的。<br>&emsp;&emsp;<br>&emsp;&emsp;长连接？<br>&emsp;&emsp;不对呀 都刷新了<hr><hr>HTTP:: 7、HTTP<font color=#FEAE00>长连接和短连接</font>的区别<hr>在HTTP/1.0中<font color=#FEAE00>默认使用短连接</font>。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。<br>&emsp;&emsp;<br>&emsp;&emsp;而从<font color=#FEAE00>HTTP/1.1</font><font color=#FEAE00>起，默认使用长连接</font>，用以保持连接特性。<hr><hr>HTTP:: 我们本身有一个机器准备联网访问 baidu.com 每一步都做了什么？<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;todo<hr><hr>HTTP::27、Session 的工作原理是什么？<hr>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。<hr><hr>HTTP::54、浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？<hr>在 <font color=#FEAE00>HTTP/1.0 </font><font color=#FEAE00>中</font>，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以<font color=#FEAE00>虽然标准中没有设定</font>，某些服务器对 <font color=#FEAE00>Connection: keep-alive</font> 的 Header 进行了支持。意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及<font color=#FEAE00>如果维持连接，那么</font><font color=#FEAE00> SSL </font><font color=#FEAE00>的开销</font>也可以避免。<br>&emsp;&emsp;<br>&emsp;&emsp;持久连接：既然维持 TCP 连接好处这么多，<font color=#FEAE00>HTTP/1.1 </font><font color=#FEAE00>就把</font><font color=#FEAE00> Connection </font><font color=#FEAE00>头写进标准</font>，并且默认开启持久连接，除非请求中写明<font color=#FEAE00> Connection: close</font>，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。<br>&emsp;&emsp;<br>&emsp;&emsp;默认情况下建立 TCP 连接不会断开，<font color=#FEAE00>只有在请求报头中声明</font><font color=#FEAE00> Connection: close </font>才会在请求完成后关闭连接。<hr><hr>HTTP::72、<font color=#FEAE00>HTTP</font><font color=#FEAE00>的缺点</font>有哪些？<hr>- 使用明文进行通信，内容可能会被<font color=#FEAE00>窃听</font>；<br>&emsp;&emsp;- 不验证通信方的身份，通信方的身份有可能遭遇<font color=#FEAE00>伪装</font>；<br>&emsp;&emsp;- 无法证明报文的<font color=#FEAE00>完整性</font>，报文有可能遭<font color=#FEAE00>篡改</font>。<hr><hr>HTTP:get:: 36、GET 方法参数写法是固定的吗？<hr>在约定中，我们的参数是写在 ? 后面，用 & 分割。<br>&emsp;&emsp;<br>&emsp;&emsp;我们知道，解析报文的过程是通过获取 TCP 数据，用正则等工具从数据中获取 Header 和 Body，从而提取参数。<br>&emsp;&emsp;<br>&emsp;&emsp;比如header请求头中添加token，来验证用户是否登录等权限问题。<br>&emsp;&emsp;<br>&emsp;&emsp;也就是说，我们可以自己约定参数的写法，只要服务端能够解释出来就行，万变不离其宗。<hr><hr>HTTP:get:: 9、为什么服务器会<font color=#FEAE00>缓存</font>这一项功能?如何实现的？<hr>处<font color=#FEAE00>理压力</font><font color=#FEAE00>-</font><font color=#FEAE00>热点数据</font>。<font color=#FEAE00>qps</font><font color=#FEAE00>和</font><font color=#FEAE00>latency</font><br>&emsp;&emsp;<br>&emsp;&emsp;原因<br>&emsp;&emsp;<br>&emsp;&emsp;- 缓解服务器压力；<br>&emsp;&emsp;- 降低客户端获取资源的<font color=#FEAE00>延迟：缓存通常位于内存中，读取缓存的速度更快</font>。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。<br>&emsp;&emsp;<br>&emsp;&emsp;实现方法<br>&emsp;&emsp;<br>&emsp;&emsp;- 让代理服务器进行缓存；<br>&emsp;&emsp;- 让客户端浏览器进行缓存。<hr><hr>HTTPS:: 20、什么是SSL/TLS ？<hr>SSL代表安全套接字层。它是一种用于加密和验证应用程序（如浏览器）和Web服务器之间发送的数据的协议。 身份验证 ， 加密Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。<br>&emsp;&emsp;<br>&emsp;&emsp;SSL/TLS协议作用：认证用户和服务，加密数据，维护数据的完整性的应用层协议加密和解密需要两个不同的密钥，故被称为非对称加密；加密和解密都使用同一个密钥的<br>&emsp;&emsp;<br>&emsp;&emsp;对称加密：优点在于加密、解密效率通常比较高 ，HTTPS 是基于非对称加密的， 公钥是公开的，<hr><hr>HTTPS:: 21、HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）<hr>（1）客户端向服务器端发起SSL连接请求； （2） 服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥 （3）客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端 （4）服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密， （5）进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，即是第三方获得数据包，也无法对其进行加密，解密和篡改。<br>&emsp;&emsp;<br>&emsp;&emsp;因为数字签名、摘要是证书防伪非常关键的武器。 “摘要”就是对传输的内容，通过hash算法计算出一段固定长度的串。然后，通过发送方的私钥对这段摘要进行加密，加密后得到的结果就是“数字签名”<br>&emsp;&emsp;<br>&emsp;&emsp;SSL/TLS协议的基本思路是<font color=#FEAE00>采用公钥加密法</font>，也就是说，客户端<font color=#FEAE00>先向服务器端索要公钥，然后用公钥加密信息</font>，服务器收到密文后，用自己的私钥解密。<br>&emsp;&emsp;<br>&emsp;&emsp;补充：SSL/TLS的四次握手，目前网上的主流答案都在重复阮一峰老师的博客，属于TLS 1.0版本的答案，<font color=#FEAE00>使用</font><font color=#FEAE00>RSA</font><font color=#FEAE00>密钥交换算法。但是现在</font><font color=#FEAE00>TLS 1.2</font><font color=#FEAE00>已经成为主流，使用</font><font color=#FEAE00>ECDHE</font><font color=#FEAE00>算法</font>，如果面试可以说出这个版本的答案，应该会更好。<br>&emsp;&emsp;<br>&emsp;&emsp;> 感谢网友提出补充，已补充，2021.10.12[https://github.com/forthespada/InterviewGuide/issues/15(opens new window)](https://github.com/forthespada/InterviewGuide/issues/15)<hr><hr>HTTPS:: 22、如何保证公钥不被篡改？<hr>将<font color=#FEAE00>公钥放在数字证书中。只要证书是可信的，公钥就是可信的</font>。 公钥加密计算量太大，如何减少耗用的时间？ 每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。 （1） 客户端向服务器端索要并验证公钥。 （2） 双方协商生成"对话密钥"。 （3） 双方采用"对<font color=#FEAE00>话密钥</font><font color=#FEAE00>"</font><font color=#FEAE00>进行加密通信。上面过程的前两步，又称为</font><font color=#FEAE00>"</font><font color=#FEAE00>握手阶段</font><font color=#FEAE00>"</font><font color=#FEAE00>（</font><font color=#FEAE00>handshake</font><font color=#FEAE00>）。</font><hr><hr>HTTPS:: 71 <font color=#FEAE00>https</font>是什么？ <font color=#FEAE00>优点</font>? <hr>HTTPS 并不是新协议，而是让 <font color=#FEAE00>HTTP </font><font color=#FEAE00>先和</font><font color=#FEAE00> SSL</font><font color=#FEAE00>（</font><font color=#FEAE00>Secure Sockets Layer</font><font color=#FEAE00>）</font>通信，再由 <font color=#FEAE00>SSL </font><font color=#FEAE00>和</font><font color=#FEAE00> TCP </font><font color=#FEAE00>通信</font>，也就是说 HTTPS <font color=#FEAE00>使用了隧道进行通信</font>。通过使用 SSL，HTTPS 具有了<font color=#FEAE00>加密（防窃听）</font>、<font color=#FEAE00>认证（防伪装）</font>和<font color=#FEAE00>完整性保护（防篡改）</font>。<hr><hr>HTTPS::69、<font color=#FEAE00>对称密钥加密</font>的优点缺点？<hr><font color=#FEAE00>对称密钥加密（</font><font color=#FEAE00>Symmetric-Key Encryption</font>），加密和解密使用<font color=#FEAE00>同一密钥</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;- 优点：<font color=#FEAE00>运算速度快</font><br>&emsp;&emsp;- 缺点：<font color=#FEAE00>无法安全地</font>将密钥传输给通信方<hr><hr>HTTPS::70、<font color=#FEAE00>非对称密钥加密</font>你了解吗？优缺点？<hr>非对称密钥加密，又称<font color=#FEAE00>公开密钥加密（</font><font color=#FEAE00>Public-Key Encryption</font><font color=#FEAE00>）</font>，加密和解密使用不同的密钥。<br>&emsp;&emsp;<br>&emsp;&emsp;公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以<font color=#FEAE00>使用公开密钥进行加密</font>，接收方收到通信内容后<font color=#FEAE00>使用私有密钥解密</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;非对称密钥除了用来加密，<font color=#FEAE00>还可以用来进行签名</font>。因为私有密钥无法被其他人获取，因此通信发送方<font color=#FEAE00>使用其私有密钥进行签名</font>，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。<br>&emsp;&emsp;<br>&emsp;&emsp;- 优点：可以<font color=#FEAE00>更安全地将公开密钥传输给通信发送方</font>；<br>&emsp;&emsp;- 缺点：<font color=#FEAE00>运算速度慢</font>。<hr><hr>HTTPS::73、HTTPS采用的<font color=#FEAE00>加密方式</font>有哪些？是对称还是非对称？<br>&emsp;&emsp;<br>&emsp;&emsp;图 todo<br>&emsp;&emsp;todo https的握手过程<hr>HTTPS 采用<font color=#FEAE00>混合的加密机制</font>，使用<font color=#FEAE00>非对称密钥加密</font>用于<font color=#FEAE00>传输对称密钥</font>来保证传输过程的安全性，之后使用<font color=#FEAE00>对称密钥加密</font>进行通信来<font color=#FEAE00>保证通信过程的效率</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;![](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220036403.png)<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;确保传输安全过程（其实就是<font color=#FEAE00>rsa</font><font color=#FEAE00>原理</font>）：<br>&emsp;&emsp;<br>&emsp;&emsp;1. Client给出<font color=#FEAE00>协议版本号</font>、一个<font color=#1DB100>客户端生成的随机数（</font><font color=#1DB100>Client random</font><font color=#FEAE00>）</font>，以及客户端支持的加密方法。<br>&emsp;&emsp;2. Server确认双方使用的加密方法，并给出<font color=#FEAE00>数字证书</font>、以及一个<font color=#1DB100>服务器生成的随机数（</font><font color=#1DB100>Server random</font><font color=#1DB100>）</font>。<br>&emsp;&emsp;3. Client确认<font color=#FEAE00>数字证书有效</font>，然后生成呀一个<font color=#1DB100>新的随机数（</font><font color=#1DB100>Premaster secret</font><font color=#FEAE00>）</font>，并使用数字证书中的<font color=#FEAE00>公钥，加密这个随机数</font>，发给Server。<br>&emsp;&emsp;4. Server使用自己的私钥，<font color=#FEAE00>获取</font><font color=#FEAE00>Client</font><font color=#FEAE00>发来的随机数</font>（Premaster secret）。<br>&emsp;&emsp;5. Client和Server根据约定的加密方法，<font color=#FEAE00>使用前面的三个随机数，生成”对话密钥”（</font><font color=#FEAE00>session key</font><font color=#FEAE00>）</font>，用来加密接下来的整个对话过程。<hr><hr>IP:: 45、MTU和MSS分别是什么？为什么TCP层需要MSS?<hr>MTU (IP)：maximum transmission unit，最大传输单元，由硬件规定，如以太网的MTU为1500字节。<br>&emsp;&emsp;<br>&emsp;&emsp;MSS (TCP)：maximum segment size，最大分节大小. TCP建立连接的时候协商双方的 MSS 和 Win <br>&emsp;&emsp;MSS = MTU - IPv4 Header(20B) - TCP header(20B)<br>&emsp;&emsp;<br>&emsp;&emsp;如果让IP层进行分片, IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。整个IP报文的所有分片都要重传, 非常没有效率. <br>&emsp;&emsp;<hr><hr>IP::32、端口有效范围是多少到多少？<hr>0-1023为知名端口号，比如其中HTTP是80，FTP是20（数据端口）、21（控制端口）<br>&emsp;&emsp;<br>&emsp;&emsp;UDP和TCP报头使用两个字节存放端口号，所以端口号的有效范围是从0到65535。动态端口的范围是从1024到65535<hr><hr>Linux <font color=#FEAE00>发送网络包</font>的流程<br>&emsp;&emsp;- 发送网络数据的时候，涉及几次<font color=#FEAE00>内存拷贝操作</font>？ <hr>如上图的右半部分，发送网络包的流程正好和接收流程相反。<br>&emsp;&emsp;首先，应用程序会调用 Socket 发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的 Socket 层，内核会申请一个内核态的 sk_buff 内存，<font color=#FEAE00>将用户待发送的数据拷贝到</font><font color=#FEAE00> sk_buff </font><font color=#FEAE00>内存，并将其加入到发送缓冲区</font><font color=#FEAE00>。</font><br>&emsp;&emsp;接下来，网络协议栈从 Socket 发送缓冲区中取出 sk_buff，并按照 TCP/IP 协议栈从上到下逐层处理。<br>&emsp;&emsp;如果使用的是 TCP 传输协议发送数据，那么<font color=#FEAE00>先拷贝一个新的</font><font color=#FEAE00> sk_buff </font><font color=#FEAE00>副本</font><font color=#FEAE00> </font>，这是因为 sk_buff 后续在调用网络层，最后到达网卡发送完成的时候，这个 sk_buff 会被释放掉。而 TCP 协议是支持丢失重传的，在收到对方的 ACK 之前，这个 sk_buff 不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 <font color=#FEAE00>sk_buff </font><font color=#FEAE00>的一个拷贝</font>，等收到 ACK 再真正删除。<br>&emsp;&emsp;接着，对 sk_buff <font color=#FEAE00>填充</font><font color=#FEAE00> TCP </font><font color=#FEAE00>头</font>。这里提一下，sk_buff 可以表示各个层的数据包，在<font color=#FEAE00>应用层数据包叫</font><font color=#FEAE00> data</font><font color=#FEAE00>，在</font><font color=#FEAE00> TCP </font><font color=#FEAE00>层我们称为</font><font color=#FEAE00> segment</font><font color=#FEAE00>，在</font><font color=#FEAE00> IP </font><font color=#FEAE00>层我们叫</font><font color=#FEAE00> packet</font><font color=#FEAE00>，在数据链路层称为</font><font color=#FEAE00> frame</font>。<br>&emsp;&emsp;你可能会好奇，为什么全部数据包只用一个结构体来描述呢？协议栈采用的是分层结构，上层向下层传递数据时需要增加包头，下层向上层数据时又需要去掉包头，如果每一层都用一个结构体，那在层之间传递数据的时候，就要<font color=#FEAE00>发生多次拷贝</font>，这将大大降低 CPU 效率。<br>&emsp;&emsp;于是，为了在层级之间传递数据时，不发生拷贝，只用 sk_buff 一个结构体来描述所有的网络包，那它是如何做到的呢？是通过调整 sk_buff 中 <font color=#FEAE00>data</font> 的指针，比如：<br>&emsp;&emsp;	•	当接收报文时，从<font color=#FEAE00>网卡驱动开始</font>，通过协议栈层层往上传送数据报，通过增加 <font color=#FEAE00>skb->data</font> 的值，来逐步<font color=#FEAE00>剥离协议首部</font>。<br>&emsp;&emsp;	•	当要发送报文时，创建 sk_buff 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过<font color=#FEAE00>减少</font><font color=#FEAE00> skb->data </font><font color=#FEAE00>的</font>值来增加协议首部。<br>&emsp;&emsp;你可以从下面这张图看到，当发送报文时，data 指针的移动过程。<br>&emsp;&emsp;￼<br>&emsp;&emsp;至此，传输层的工作也就都完成了。<br>&emsp;&emsp;然后交给网络层，在<font color=#FEAE00>网络层</font>里会做这些工作：<font color=#FEAE00>选取路由（确认下一跳的</font><font color=#FEAE00> IP</font><font color=#FEAE00>）、填充</font><font color=#FEAE00> IP </font><font color=#FEAE00>头、</font><font color=#FEAE00>netfilter </font><font color=#FEAE00>过滤、对超过</font><font color=#FEAE00> MTU </font><font color=#FEAE00>大小的数据包进行分片</font>。处理完这些工作后会交给网络接口层处理。<br>&emsp;&emsp;<font color=#FEAE00>网络接口层</font>会通过 ARP 协议获得下一跳的 MAC 地址，然后对 sk_buff 填充帧头和帧尾，接着将 sk_buff 放到网卡的发送队列中。<br>&emsp;&emsp;这一些工作准备好后，会触发「<font color=#FEAE00>软中断</font>」告诉网卡驱动程序，这里有新的网络包需要发送，驱动程序会从发送队列中读取 sk_buff，将这个 sk_buff 挂到 RingBuffer 中，接着将 sk_buff 数据映射到网卡可访问的内存 DMA 区域，最后触发真实的发送。<br>&emsp;&emsp;当数据发送完成以后，其实工作并没有结束，因为内存还没有清理。当发送完成的时候，网卡设备会触发一个硬中断来释放内存，主要是<font color=#FEAE00>释放</font><font color=#FEAE00> sk_buff </font><font color=#FEAE00>内存和清理</font><font color=#FEAE00> RingBuffer </font><font color=#FEAE00>内存</font>。<br>&emsp;&emsp;最后，当收到这个 TCP 报文的 ACK 应答时，传输层就会释放原始的 sk_buff 。<br>&emsp;&emsp;# 发送网络数据的时候，涉及几次<font color=#FEAE00>内存拷贝操作</font>？<br>&emsp;&emsp;第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。<br>&emsp;&emsp;第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff 。<br>&emsp;&emsp;第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff。<hr><hr>Linux <font color=#FEAE00>接收网络包</font>的流程<hr>网卡是计算机里的一个硬件，专门负责接收和发送网络包，当网卡接收到一个网络包后，会通过<font color=#FEAE00> DMA </font><font color=#FEAE00>技术</font>，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区，接着就会告诉操作系统这个网络包已经到达。<br>&emsp;&emsp;# 那应该怎么告诉操作系统这个网络包已经到达了呢？<br>&emsp;&emsp;最简单的一种方式就是<font color=#FEAE00>触发中断</font>，也就是每当网卡收到一个网络包，就触发一个中断告诉操作系统。<br>&emsp;&emsp;但是，这存在一个问题，在高性能网络场景下，网络包的数量会非常多，那么就会触发非常多的中断，要知道当 CPU 收到了中断，就会停下手里的事情，而去处理这些网络包，处理完毕后，才会回去继续其他事情，那么<font color=#FEAE00>频繁地触发中断</font>，则会导致 CPU 一直没完没了的处理中断，而导致其他任务可能无法继续前进，从而<font color=#FEAE00>影响系统的整体效率</font>。<br>&emsp;&emsp;所以为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了 <font color=#FEAE00>NAPI </font><font color=#FEAE00>机制</font>，它是混合「中断和轮询」的方式来接收网络包，它的核心概念就是<font color=#FEAE00>不采用中断的方式读取数据</font>，而是首先采用<font color=#FEAE00>中断唤醒数据接收的服务程序</font>，然后 <font color=#FEAE00>poll</font> 的方法来轮询数据。<br>&emsp;&emsp;因此，当有网络包到达时，会通过 DMA 技术，将网络包写入到指定的内存地址，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据<font color=#FEAE00>中断表</font>，调用已经注册的中断处理函数。<br>&emsp;&emsp;# 硬件中断处理函数会做如下的事情：<br>&emsp;&emsp;	•	需要先「<font color=#FEAE00>暂时屏蔽中断</font>」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。<br>&emsp;&emsp;	•	接着，发起「<font color=#FEAE00>软中断</font>」，然后<font color=#FEAE00>恢复刚才屏蔽的中断</font>。<br>&emsp;&emsp;至此，硬件中断处理函数的工作就已经完成。<br>&emsp;&emsp;硬件中断处理函数做的事情很少，主要耗时的工作都交给软中断处理函数了。<br>&emsp;&emsp;# 软中断的处理<br>&emsp;&emsp;内核中的 <font color=#FEAE00>ksoftirqd</font> 线程专门负责<font color=#FEAE00>软中断的处理</font>，当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。<br>&emsp;&emsp;ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 <font color=#FEAE00>sk_buff</font> 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。<br>&emsp;&emsp;# 网络协议栈<br>&emsp;&emsp;首先，会先进入到<font color=#FEAE00>网络接口层</font>，在这一层会检查报文的合法性，如果不合法则丢弃，合法则会找出该网络包的上层协议的类型，比如是 IPv4，还是 IPv6，接着再去掉帧头和帧尾，然后交给网络层。<br>&emsp;&emsp;到了网络层，则取出 IP 包，判断<font color=#FEAE00>网络包下一步的走向</font>，比如是交给上层处理还是转发出去。当确认这个网络包要发送给本机后，就会从 IP 头里看看上一层协议的类型是 <font color=#FEAE00>TCP </font><font color=#FEAE00>还是</font><font color=#FEAE00> UDP</font>，接着去掉 IP 头，然后交给传输层。<br>&emsp;&emsp;传输层取出 TCP 头或 UDP 头，根据四元组「<font color=#FEAE00>源</font><font color=#FEAE00> IP</font><font color=#FEAE00>、源端口、目的</font><font color=#FEAE00> IP</font><font color=#FEAE00>、目的端口</font>」 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区。<br>&emsp;&emsp;最后，应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。<br>&emsp;&emsp;至此，一个网络包的接收过程就已经结束了，你也可以从下图左边部分看到网络包接收的流程，右边部分刚好反过来，它是网络包发送的流程。<br>&emsp;&emsp;￼<hr><hr>Linux 网络协议栈<hr>我们可以把自己的身体比作应用层中的数据，打底衣服比作传输层中的 TCP 头，外套比作网络层中 IP 头，帽子和鞋子分别比作网络接口层的帧头和帧尾。<br>&emsp;&emsp;在冬天这个季节，当我们要从家里出去玩的时候，自然要先穿个打底衣服，再套上保暖外套，最后穿上帽子和鞋子才出门，这个过程就好像我们把 TCP 协议通信的网络包发出去的时候，会把应用层的数据按照<font color=#FEAE00>网络协议栈层层封装和处理</font>。<br>&emsp;&emsp;你从下面这张图可以看到，应用层数据在每一层的<font color=#FEAE00>封装格式。</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;其中：<br>&emsp;&emsp;	•	<font color=#FEAE00>传输层</font>，给应用数据前面增加了<font color=#FEAE00> TCP </font><font color=#FEAE00>头</font>；<br>&emsp;&emsp;	•	<font color=#FEAE00>网络层</font>，给 TCP 数据包前面增加了 <font color=#FEAE00>IP </font><font color=#FEAE00>头；</font><br>&emsp;&emsp;	•	<font color=#FEAE00>网络接口层</font>，给 IP 数据包前后分别增加了<font color=#FEAE00>帧头和帧尾</font>；<br>&emsp;&emsp;这些新增的头部和尾部，都有各自的作用，也都是按照特定的协议格式填充，这每一层都增加了各自的协议头，那自然网络包的大小就增大了，但物理链路并不能传输任意大小的数据包，所以在以太网中，规定了最大传输单元（MTU）是 <font color=#4D647F>1500</font> 字节，也就是规定了单次传输的最大 IP 包大小。<br>&emsp;&emsp;当网络包超过 MTU 的大小，<font color=#FEAE00>就会在网络层分片</font>，以确保分片后的 IP 包不会超过 MTU 大小，如果 MTU 越小，需要的分包就越多，那么网络吞吐能力就越差，相反的，如果 MTU 越大，需要的分包就越少，那么网络吞吐能力就越好。<br>&emsp;&emsp;知道了 TCP/IP 网络模型，以及网络包的封装原理后，那么 Linux 网络协议栈的样子，你想必猜到了大概，它其实就类似于 TCP/IP 的四层结构：<br>&emsp;&emsp;￼<br>&emsp;&emsp;从上图的的网络协议栈，你可以看到：<br>&emsp;&emsp;	•	应用程序需要通过系统调用，来跟 Socket 层进行数据交互；<br>&emsp;&emsp;	•	Socket 层的下面就是传输层、网络层和网络接口层；<br>&emsp;&emsp;	•	最下面的一层，则是网卡驱动程序和硬件网卡设备；<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>Socket:: TCP 编程的流程?<hr>* socket -> 文件描述符<br>&emsp;&emsp;* bind  -> 绑定IP 和 端口<br>&emsp;&emsp;* listen  -> 进行监听<br>&emsp;&emsp;* connect -> 客户端发起请求<br>&emsp;&emsp;* accept  -> 等待客户端调用<br>&emsp;&emsp;* read/write <br>&emsp;&emsp;* close -> 这样服务端 read读取会读取到EOF , 等待处理完成后, 服务端调用 close<br>&emsp;&emsp;<br>&emsp;&emsp;::  这里需要注意的是，服务端调用 `accept` 时，连接成功了<font color=#FEAE00>会返回一个已完成连接的</font><font color=#FEAE00> socket</font>，后续用来传输数据。<br>&emsp;&emsp;<br>&emsp;&emsp;所以，监听的 socket 和真正用来传送数据的 socket，是「<font color=#FEAE00>两个」</font><font color=#FEAE00> socket</font>，一个叫作<font color=#FEAE00>监听</font><font color=#FEAE00> socket</font>，一个叫作<font color=#FEAE00>已完成连接</font><font color=#FEAE00> socket</font>。<hr><hr>TCP:: 14、浏览器对同一 <font color=#FEAE00>Host </font><font color=#FEAE00>建立</font><font color=#FEAE00> TCP</font> 连接到的数量有没有限制？<hr>HTTP/1.1 时代, 类似线程池的处理方式<br>&emsp;&emsp;HTTP2 multiplexing来处理<br>&emsp;&emsp;##<br>&emsp;&emsp;假设我们还处在 HTTP/1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？肯定不能只开一个 TCP 连接顺序下载，那样用户肯定等的很难受，但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了，要是有 1000 张图片的话总不能开 1000 个TCP 连接吧，你的电脑同意 NAT 也不一定会同意。<br>&emsp;&emsp;<br>&emsp;&emsp;有。<font color=#FEAE00>Chrome </font><font color=#FEAE00>最多允许对同一个</font><font color=#FEAE00> Host </font><font color=#FEAE00>建立六个</font><font color=#FEAE00> TCP </font><font color=#FEAE00>连接</font>。不同的浏览器有一些区别。<br>&emsp;&emsp;<br>&emsp;&emsp;如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 <font color=#FEAE00>SSL </font><font color=#FEAE00>握手之后会和服务器商量能不能用</font><font color=#FEAE00> HTTP2</font>，如果能的话就使用 <font color=#FEAE00>Multiplexing </font>功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。<br>&emsp;&emsp;<br>&emsp;&emsp;如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，<font color=#FEAE00>连接数量的最大限制取决于浏览器设置</font>，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。<hr><hr>TCP:: 50、TCP是什么？ 有什么特点?<hr>TCP（Transmission Control Protocol 传输控制协议）是一种<font color=#FEAE00>面向连接</font>的、<font color=#FEAE00>可靠</font>的、<font color=#FEAE00>基于字节流</font>的<font color=#FEAE00>传输层</font>通信协议。<br>&emsp;&emsp;- 面向连接：一定是「<font color=#FEAE00>一对一</font>」才能连接, 即<font color=#FEAE00>没有广播</font><br>&emsp;&emsp;- <font color=#FEAE00>可靠的</font>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证<font color=#FEAE00>一个报文一定能够到达接收端</font>；<br>&emsp;&emsp;- <font color=#FEAE00>字节流</font>：(可能是<font color=#FEAE00>拆包和黏包</font>)用户消息通过 TCP 协议传输时，消息可能会被操作系统「<font color=#FEAE00>分组</font>」成多个的 TCP 报文，如果接收方的程序如果不知道「<font color=#FEAE00>消息的边界</font>」，是<font color=#FEAE00>无法读出一个有效的用户消息的</font>。并且 TCP 报文是「<font color=#FEAE00>有序的</font>」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「<font color=#FEAE00>重复</font>」的 TCP 报文会自动丢弃。<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;	<hr><hr>TCP:: 8、什么是<font color=#FEAE00>TCP</font><font color=#FEAE00>粘包</font><font color=#FEAE00>/</font><font color=#FEAE00>拆包</font>？发生的原因？<hr>一个完整的业务可能会被<font color=#FEAE00>TCP</font><font color=#FEAE00>拆分成多个包进行发送</font>，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题。<br>&emsp;&emsp;<br>&emsp;&emsp;##### 原因<br>&emsp;&emsp;<br>&emsp;&emsp;1、应用程序写入数据的字节大小大于套接字发送缓冲区的大小.<br>&emsp;&emsp;<br>&emsp;&emsp;2、<font color=#FEAE00>进行</font><font color=#FEAE00>MSS</font><font color=#FEAE00>大小的</font><font color=#FEAE00>TCP</font><font color=#FEAE00>分段。</font>( MSS=TCP报文段长度-TCP首部长度)<br>&emsp;&emsp;<br>&emsp;&emsp;3、以太网的<font color=#FEAE00>payload</font><font color=#FEAE00>大于</font><font color=#FEAE00>MTU</font><font color=#FEAE00>进行</font><font color=#FEAE00>IP</font><font color=#FEAE00>分片</font>。（ MTU指：一种通信协议的某一层上面所能通过的最大数据包大小。）<br>&emsp;&emsp;<br>&emsp;&emsp;##### 解决方案<br>&emsp;&emsp;<br>&emsp;&emsp;1、<font color=#FEAE00>消息定长</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;2、在包尾部增加<font color=#FEAE00>回车或者空格符等特殊字符进行分割</font>3. 将消息分为<font color=#FEAE00>消息头和消息尾</font>。4. 使用其它复杂的协议，如RTMP协议等。<hr><hr>TCP:: TCP 和 UDP 的应用场景? <br>&emsp;&emsp;<br>&emsp;&emsp;特点合并下<hr>TCP 面向连接, 可靠交付: <br>&emsp;&emsp;	FTP  文件传输<br>&emsp;&emsp;	HTTPS / HTTP<br>&emsp;&emsp;UDP 无连接, 随时发送, 简单高效<br>&emsp;&emsp;	包总量少的通信, : DNS, SNMP<br>&emsp;&emsp;	视频音频等多媒体通信<br>&emsp;&emsp;	广播通信<hr><hr>TCP:: 什么是 TCP 连接, 如何唯一确定? <hr>RFC 973 <br>&emsp;&emsp;用于保证可靠性和流量控制的某些状态信息, 这些信息的组合, 包括Socket, 序列号和窗口大小称为连接. <br>&emsp;&emsp;因此: 连接包括: <br>&emsp;&emsp;* socket: 四元组<br>&emsp;&emsp;* 序列号, 乱序问题<br>&emsp;&emsp;* 窗口大小, 流量控制<br>&emsp;&emsp;<br>&emsp;&emsp;用四元组可以唯一确定.<br>&emsp;&emsp;源地址, 源端口, 目的地址, 目标端口<hr><hr>TCP:: 几大功能 <br>&emsp;&emsp;todo<hr><hr>TCP:: 如何在Linux系统重查看TCP状态<hr>netstat -napt 命令查看<br>&emsp;&emsp;TCP协议, 四元组, 连接状态, PID + 服务名称等信息<hr><hr>TCP:: 监听了一个端口的<font color=#FEAE00>TCP</font><font color=#FEAE00>最大连接数</font>是多少? <hr>服务器通常固定在某个本地端口上监听，等待客户端的连接请求。<br>&emsp;&emsp;<br>&emsp;&emsp;因此，<font color=#FEAE00>客户端</font><font color=#FEAE00> IP </font><font color=#FEAE00>和</font><font color=#FEAE00> </font><font color=#FEAE00>端口是可变的</font><font color=#FEAE00>.</font> 理论最大值是 客户端的IP数 x 客户端的端口数 2^32 x 2^16 = 2 ^48<br>&emsp;&emsp;现实中的限制主要是 <font color=#FEAE00>文件描述符</font>和<font color=#FEAE00>内存</font>：<br>&emsp;&emsp;- 文件描述符限制<br>&emsp;&emsp;  ，每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 <font color=#FEAE00>too many open files</font>。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：<br>&emsp;&emsp;  - <font color=#FEAE00>系统级</font>：当前系统可打开的最大数量，通过 cat <font color=#FEAE00>/proc/sys/fs/file-max</font> 查看；<br>&emsp;&emsp;  - 用户级：指定用户可打开的最大数量，通过 <font color=#FEAE00>cat /etc/security/limits.conf</font> 查看；<br>&emsp;&emsp;  - 进程级：单个进程可打开的最大数量，通过 <font color=#FEAE00>cat /proc/sys/fs/nr_open</font> 查看；<br>&emsp;&emsp;- 内存限制，每个 TCP 连接都要占用一定内存，操作系统的内存是有限的，如果<font color=#FEAE00>内存资源被占满后，会发生</font><font color=#FEAE00> OOM</font><font color=#FEAE00>。</font><hr><hr>TCP::48、常见TCP的<font color=#FEAE00>连接状态</font>有哪些？<hr>- <font color=#FEAE00>CLOSED</font>：初始状态。<br>&emsp;&emsp;- <font color=#FEAE00>LISTEN </font><font color=#FEAE00>[</font><font color=#FEAE00>S</font><font color=#FEAE00>]</font>：监听状态。<br>&emsp;&emsp;- <font color=#FEAE00>SYN_SEND </font><font color=#FEAE00>[</font><font color=#FEAE00>C</font><font color=#FEAE00>]</font><font color=#FEAE00>: </font>执行CONNECT连接，发送SYN包后<br>&emsp;&emsp;- <font color=#FEAE00>SYN_RECV </font><font color=#FEAE00>[</font><font color=#FEAE00>S</font><font color=#FEAE00>]</font>：收到SYN包<br>&emsp;&emsp;- <font color=#FEAE00>ESTABLISH </font><font color=#FEAE00>[</font><font color=#FEAE00>C/S</font><font color=#FEAE00>]</font>：连接建立<br>&emsp;&emsp;- <font color=#FEAE00>FIN_WAIT_1</font>：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN (一次握手后)<br>&emsp;&emsp;- <font color=#FEAE00>CLOSE_WAIT</font>：二次握手后, 收到FIN包, 发送FIN包之前的状态的<br>&emsp;&emsp;- <font color=#FEAE00>FIN_WAIT_2</font>：此时是<font color=#FEAE00>半连接状态</font><font color=#FEAE00> / </font><font color=#FEAE00>半关闭状态</font><font color=#FEAE00> </font>即有一方要求关闭连接，等待另一方关闭。<font color=#FEAE00>客户端接收到服务器的</font><font color=#FEAE00>ACK</font><font color=#FEAE00>包，但并没有立即接收到服务端的</font><font color=#FEAE00>FIN</font><font color=#FEAE00>包</font>，进入FIN_WAIT_2状态。<br>&emsp;&emsp;- <font color=#FEAE00>LAST_ACK</font>：(三次握手后) 服务端发<font color=#FEAE00>动最后的</font><font color=#FEAE00>FIN</font><font color=#FEAE00>包</font>，等待最后的客户端ACK响应，进入此状态。<br>&emsp;&emsp;- <font color=#FEAE00>TIME_WAIT</font>：(<font color=#FEAE00>四次握手后</font>) 的状态客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。<hr><hr>TCP::66、TCP粘包问题是什么？你会如何去解决它？<br>&emsp;&emsp;<br>&emsp;&emsp;todo 里面说的算法<hr>TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。<br>&emsp;&emsp;<br>&emsp;&emsp;- 由TCP连接复用造成的粘包问题。<br>&emsp;&emsp;- 因为TCP默认会使用Nagle算法，此算法会导致粘包问题。<br>&emsp;&emsp;  - 只有上一个分组得到确认，才会发送下一个分组；<br>&emsp;&emsp;  - 收集多个小分组，在一个确认到来时一起发送。<br>&emsp;&emsp;- 数据包过大造成的粘包问题。<br>&emsp;&emsp;- 流量控制，拥塞控制也可能导致粘包。<br>&emsp;&emsp;- 接收方不及时接收缓冲区的包，造成多个包接收<br>&emsp;&emsp;<br>&emsp;&emsp;解决：<br>&emsp;&emsp;<br>&emsp;&emsp;1. Nagle算法问题导致的，需要结合应用场景适当关闭该算法<br>&emsp;&emsp;2. <font color=#FEAE00>尾部标记序列。通过特殊标识符表示数据包的边界，例如</font><font color=#FEAE00>\n\r</font><font color=#FEAE00>，</font><font color=#FEAE00>\t</font><font color=#FEAE00>，或者一些隐藏字符。</font><br>&emsp;&emsp;3. 头部标记分步接收。在TCP报文的头部加上表示数据长度。<br>&emsp;&emsp;4. 应用层发送数据时定长发送。<hr><hr>TCP::79、TCP四大拥塞控制算法总结？（极其重要）<br>&emsp;&emsp;<br>&emsp;&emsp;todo 图整理下<hr>### 四大算法<br>&emsp;&emsp;<br>&emsp;&emsp;拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。<br>&emsp;&emsp;<br>&emsp;&emsp;![](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220036635.png)<br>&emsp;&emsp;<br>&emsp;&emsp;### 慢热启动算法 – Slow Start<br>&emsp;&emsp;<br>&emsp;&emsp; 所谓慢启动，也就是TCP连接刚建立，一点一点地提速，试探一下网络的承受能力，以免直接扰乱了网络通道的秩序。<br>&emsp;&emsp;<br>&emsp;&emsp; 慢启动算法：<br>&emsp;&emsp;<br>&emsp;&emsp;1) 连接建好的开始先初始化拥塞窗口cwnd大小为1，表明可以传一个MSS大小的数据。<br>&emsp;&emsp;2) 每当收到一个ACK，cwnd大小加一，呈线性上升。<br>&emsp;&emsp;3) 每当过了一个往返延迟时间RTT(Round-Trip Time)，cwnd大小直接翻倍，乘以2，呈指数让升。<br>&emsp;&emsp;4) 还有一个ssthresh（slow start threshold），是一个上限，当cwnd >= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）<br>&emsp;&emsp;<br>&emsp;&emsp;### 拥塞避免算法 – Congestion Avoidance<br>&emsp;&emsp;<br>&emsp;&emsp; 如同前边说的，当拥塞窗口大小cwnd大于等于慢启动阈值ssthresh后，就进入拥塞避免算法。算法如下：<br>&emsp;&emsp;<br>&emsp;&emsp;1) 收到一个ACK，则cwnd = cwnd + 1 / cwnd<br>&emsp;&emsp;2) 每当过了一个往返延迟时间RTT，cwnd大小加一。<br>&emsp;&emsp;<br>&emsp;&emsp; 过了慢启动阈值后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢的增加调整到网络的最佳值。<br>&emsp;&emsp;<br>&emsp;&emsp;### 拥塞发生状态时的算法<br>&emsp;&emsp;<br>&emsp;&emsp; 一般来说，TCP拥塞控制默认认为网络丢包是由于网络拥塞导致的，所以一般的TCP拥塞控制算法以丢包为网络进入拥塞状态的信号。对于丢包有两种判定方式，一种是超时重传RTO[Retransmission Timeout]超时，另一个是收到三个重复确认ACK。<br>&emsp;&emsp;<br>&emsp;&emsp; 超时重传是TCP协议保证数据可靠性的一个重要机制，其原理是在发送一个数据以后就开启一个计时器，在一定时间内如果没有得到发送数据报的ACK报文，那么就重新发送数据，直到发送成功为止。<br>&emsp;&emsp;<br>&emsp;&emsp; 但是如果发送端接收到3个以上的重复ACK，TCP就意识到数据发生丢失，需要重传。这个机制不需要等到重传定时器超时，所以叫<br>&emsp;&emsp;做快速重传，而快速重传后没有使用慢启动算法，而是拥塞避免算法，所以这又叫做快速恢复算法。<br>&emsp;&emsp;<br>&emsp;&emsp; 超时重传RTO[Retransmission Timeout]超时，TCP会重传数据包。TCP认为这种情况比较糟糕，反应也比较强烈：<br>&emsp;&emsp;<br>&emsp;&emsp;- 由于发生丢包，将慢启动阈值ssthresh设置为当前cwnd的一半，即ssthresh = cwnd / 2.<br>&emsp;&emsp;- cwnd重置为1<br>&emsp;&emsp;- 进入慢启动过程<br>&emsp;&emsp;<br>&emsp;&emsp; 最为早期的TCP Tahoe算法就只使用上述处理办法，但是由于一丢包就一切重来，导致cwnd又重置为1，十分不利于网络数据的稳定传递。<br>&emsp;&emsp;<br>&emsp;&emsp; 所以，TCP Reno算法进行了优化。当收到三个重复确认ACK时，TCP开启快速重传Fast Retransmit算法，而不用等到RTO超时再进行重传：<br>&emsp;&emsp;<br>&emsp;&emsp;- cwnd大小缩小为当前的一半<br>&emsp;&emsp;- ssthresh设置为缩小后的cwnd大小<br>&emsp;&emsp;- 然后进入快速恢复算法Fast Recovery。<br>&emsp;&emsp;<br>&emsp;&emsp;![](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220036573.png)<br>&emsp;&emsp;<br>&emsp;&emsp;### 快速恢复算法 – Fast Recovery<br>&emsp;&emsp;<br>&emsp;&emsp; TCP Tahoe是早期的算法，所以没有快速恢复算法，而Reno算法有。在进入快速恢复之前，cwnd和ssthresh已经被更改为原有cwnd的一半。快速恢复算法的逻辑如下：<br>&emsp;&emsp;<br>&emsp;&emsp;- cwnd = cwnd + 3 *MSS，加3* MSS的原因是因为收到3个重复的ACK。<br>&emsp;&emsp;<br>&emsp;&emsp;- 重传DACKs指定的数据包。<br>&emsp;&emsp;<br>&emsp;&emsp;- 如果再收到DACKs，那么cwnd大小增加一。<br>&emsp;&emsp;<br>&emsp;&emsp;- 如果收到新的ACK，表明重传的包成功了，那么退出快速恢复算法。将cwnd设置为ssthresh，然后进入拥塞避免算法。<br>&emsp;&emsp;<br>&emsp;&emsp;  ![](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220036984.png)<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp; 如图所示，第五个包发生了丢失，所以导致接收方接收到三次重复ACK，也就是ACK5。所以将ssthresh设置当当时cwnd的一半，也就是6/2 = 3，cwnd设置为3 + 3 = 6。然后重传第五个包。当收到新的ACK时，也就是ACK11，则退出快速恢复阶段，将cwnd重新设置为当前的ssthresh，也就是3，然后进入拥塞避免算法阶段。<hr><hr>TCP:流传输如何理解? 如何确定边界? <hr><hr>TCP头:: 47、<font color=#FEAE00>TCP</font><font color=#FEAE00>头部中</font>有哪些信息？<hr>* <font color=#FEAE00>源端口号</font>和<font color=#FEAE00>目的端口号</font><br>&emsp;&emsp;- <font color=#FEAE00>序列号（</font><font color=#FEAE00>32bit</font><font color=#FEAE00>）</font>：字节流的字节编号。<font color=#FEAE00>初始</font>时<font color=#FEAE00>随机值（</font><font color=#FEAE00>ISN</font>), 之后每次<font color=#FEAE00>累加</font>该次 "<font color=#FEAE00>数据字节数</font>"的大小。用于解决<font color=#FEAE00>网络包乱序</font>问题。<br>&emsp;&emsp;- <font color=#FEAE00>确认应答号（</font><font color=#FEAE00>32bit</font><font color=#FEAE00>）</font>：<font color=#FEAE00>期望收到的数据的序列号</font>，其值是收到的序号值 + 1, 表示<font color=#FEAE00>前面的都已经正常接受</font><font color=#FEAE00>,</font> 用来解决<font color=#FEAE00>丢包</font>问题。<br>&emsp;&emsp;- <font color=#FEAE00>首部长（</font><font color=#FEAE00>4bit</font><font color=#FEAE00>）</font>：标识首部有多少个<font color=#FEAE00>4</font><font color=#FEAE00>字节</font><font color=#FEAE00> * </font><font color=#FEAE00>首部长</font>，最大为15，即60字节。<br>&emsp;&emsp;<br>&emsp;&emsp;- 标志位/控制位（6bit）：<br>&emsp;&emsp;  - URG：标志<font color=#FEAE00>紧急指针</font>是否有效。<br>&emsp;&emsp;  - <font color=#FEAE00>ACK</font>：标志<font color=#FEAE00>确认号是否有效</font><font color=#FEAE00>, </font>解决<font color=#FEAE00>丢包问题</font>。<br>&emsp;&emsp;  - PSH：提示接收端<font color=#FEAE00>立即从缓冲读</font>走数据。<br>&emsp;&emsp;  - <font color=#FEAE00>RST</font>：表示要求对方<font color=#FEAE00>重新建立连接</font>（复位报文段）。<br>&emsp;&emsp;  - <font color=#FEAE00>SYN</font>：表示<font color=#FEAE00>请求建立一个连接</font>（连接报文段）。<br>&emsp;&emsp;  - <font color=#FEAE00>FIN</font>：表示<font color=#FEAE00>关闭连接</font><font color=#FEAE00>,</font><font color=#FEAE00>没有新数据发送</font>（断开报文段）。<br>&emsp;&emsp;- 窗口（16bit）：<font color=#FEAE00>接收窗口</font>。用于告知对方（发送方）本方的<font color=#FEAE00>缓冲还能接收多少字节</font>数据。用于解决<font color=#FEAE00>流控</font>。<br>&emsp;&emsp;- <font color=#FEAE00>校验和</font>（16bit）：接收端用<font color=#FEAE00>CRC</font><font color=#FEAE00>检验</font>整个报文段有无损坏。<hr><hr>TCP头:: 为什么 TCP 只有首部长度, 而UDP只有包长度呢? <hr>首部长度: <br>&emsp;&emsp;	原因是 TCP<font color=#FEAE00> </font><font color=#FEAE00>有可变长</font>的「选项」字段，而 <font color=#FEAE00>UDP </font><font color=#FEAE00>头部长度则是不会变化的</font>，无需多一个字段去记录 UDP 的首部长度。<br>&emsp;&emsp;包长度: <br>&emsp;&emsp;	TCP数据长度 = IP总长度 - IP首部长度 - TCP首部长度：<br>&emsp;&emsp;因此不需要 包长度, 也能知道包长度是多少. <br>&emsp;&emsp;UDP 「包长度」可能也是冗余的。<br>&emsp;&emsp;因为为了网络设备硬件设计和处理方便，首部长度需要是 4字节的整数倍。<br>&emsp;&emsp;也可能是基于分片上的考虑吧<br>&emsp;&emsp;如果去掉 UDP 「包长度」字段，那 UDP 首部长度就不是 4 字节的整数倍了，所以小林觉得这可能是为了补全 UDP 首部长度是 4 字节的整数倍，才补充了「包长度」字段。<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;<hr><hr>TCP挥手-1::61、 四次挥手相关内容<hr>四次挥手, 由于 TCP的 半关闭 (half-close)导致<br>&emsp;&emsp;一开始 [ESTABLISHED | ESTABLISHED] 状态<br>&emsp;&emsp;1 [C]: FIN=1<br>&emsp;&emsp;	[<font color=#FEAE00>FIN_WAIT_1 </font>| ESTABLISHED]<br>&emsp;&emsp;2 [S]: ACK=1 <br>&emsp;&emsp;	[FIN_WAIT_1 | <font color=#FEAE00>CLOSED_WAIT</font>]<br>&emsp;&emsp;	收到 : [<font color=#FEAE00>FIN_WAIT_2</font> | CLOSED_WAIT]<br>&emsp;&emsp;3 [S]:  FIN=1<br>&emsp;&emsp;	[FIN_WAIT_2 | <font color=#FEAE00>LAST_ACK</font>]<br>&emsp;&emsp;4 [C]: ACK = 1<br>&emsp;&emsp;	[<font color=#FEAE00>TIME_WAIT</font> | | <font color=#FEAE00>LAST_ACK</font>]<br>&emsp;&emsp;	收到: [TIME_WAIT |  <font color=#FEAE00>CLOSE</font>]<br>&emsp;&emsp;	2MSL后: [<font color=#FEAE00>CLOSE</font> | <font color=#FEAE00>CLOSE</font>]<br>&emsp;&emsp;<br>&emsp;&emsp;四次挥手(Four-way handshake)，C/S 均可主动发起<br>&emsp;&emsp;这里注意: <font color=#FEAE00>主动关闭连接</font>的, 才会有 <font color=#FEAE00>TIME_WAIT</font><font color=#FEAE00>状态</font>. <br>&emsp;&emsp;<hr><hr>TCP挥手-2::62、<font color=#FEAE00>挥手</font>为什么需要<font color=#FEAE00>四次</font>？<hr>因为当 server 收到客户端的<font color=#FEAE00>SYN</font>连接请求报文后，可以直接发送<font color=#FEAE00>SYN+ACK</font><font color=#FEAE00>报文</font>。其中<font color=#FEAE00>ACK</font>报文是用来<font color=#FEAE00>应答的</font>，SYN报文是用来同步的。<br>&emsp;&emsp;<br>&emsp;&emsp;但是关闭连接时，当服务端<font color=#FEAE00>收到</font><font color=#FEAE00>FIN</font><font color=#FEAE00>报文</font>时，<font color=#FEAE00>很可能并不会立即关闭</font><font color=#FEAE00>SOCKET</font>， 所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。<font color=#FEAE00>可能还有数据需要处理和发送</font>，<font color=#FEAE00>等服务端不再发送数据时</font>, and 等到我服务端所有的报文都发送完了，我<font color=#FEAE00>才能发送</font><font color=#FEAE00>FIN</font><font color=#FEAE00>报文</font>，因此不能一起发送。故需要四次挥手。<br>&emsp;&emsp;<br>&emsp;&emsp;<hr><hr>TCP挥手-3:: 第<font color=#FEAE00>一次挥手丢失</font>了, 会发生什么? <hr>当客户端（主动关闭方）调用 close 函数后，就会向服务端<font color=#FEAE00>发送</font><font color=#FEAE00> FIN </font><font color=#FEAE00>报文</font>，试图与服务端断开连接，此时客户端的连接进入到 `<font color=#FEAE00>FIN_WAIT_1</font>` 状态。<br>&emsp;&emsp;<br>&emsp;&emsp;正常情况下，如果能<font color=#FEAE00>及时收到</font>服务端（被动关闭方）的 <font color=#FEAE00>ACK</font>，则会很快变为 `<font color=#FEAE00>FIN_WAIT2</font>`状态。<br>&emsp;&emsp;<br>&emsp;&emsp;如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会<font color=#FEAE00>触发超时重传机制</font>，重传 FIN 报文，重发次数由 `<font color=#FEAE00>tcp_orphan_retries</font>` 参数控制。<br>&emsp;&emsp;<br>&emsp;&emsp;当客户端重传 FIN 报文的次数超过 `tcp_orphan_retries` 后，就不再发送 FIN 报文，直接进入到 `close` 状态。<hr><hr>TCP挥手-4:: 第<font color=#FEAE00>三次挥手丢失</font>了，会发生什么？<hr>当服务端（被动关闭方）收到客户端（主动关闭方）的 <font color=#FEAE00>FIN</font> 报文后，内核会自动回复 <font color=#FEAE00>ACK</font>，同时连接处于 `<font color=#FEAE00>CLOSE_WAIT</font>` 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。<br>&emsp;&emsp;<br>&emsp;&emsp;此时，内核是没有权利<font color=#FEAE00>替代进程关闭连接</font>，必须由<font color=#FEAE00>进程主动调用</font><font color=#FEAE00> close </font><font color=#FEAE00>函数</font>来触发服务端发送 FIN 报文。<br>&emsp;&emsp;<br>&emsp;&emsp;服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会<font color=#FEAE00>发出</font><font color=#FEAE00> FIN </font><font color=#FEAE00>报文</font>，同时连接<font color=#FEAE00>进入</font><font color=#FEAE00> LAST_ACK </font><font color=#FEAE00>状态</font>，等待客户端返回 ACK 来确认连接关闭。<br>&emsp;&emsp;<br>&emsp;&emsp;如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 `<font color=#FEAE00>tcp_orphan_retrie</font>`s 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。<hr><hr>TCP挥手-4:: 第<font color=#FEAE00>二次挥手丢失</font>了，会发生什么？<hr>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 `<font color=#FEAE00>CLOSE_WAIT</font>` 状态。<br>&emsp;&emsp;<br>&emsp;&emsp;在前面我们也提了，ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客<font color=#FEAE00>户端就会触发超时重传机制，重传</font><font color=#FEAE00> FIN </font><font color=#FEAE00>报文</font>，直到收到服务端的第二次挥手，或者达到最大的重传次数。<br>&emsp;&emsp;<br>&emsp;&emsp;这里提一下，当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 `FIN_WAIT2` 状态，在这个<font color=#FEAE00>状态需要等服务端发送第三次挥手</font>，也就是服务端的 FIN 报文。<br>&emsp;&emsp;<br>&emsp;&emsp;对于 close 函数关闭的连接，由于无法再发送和接收数据，所以`<font color=#FEAE00>FIN_WAIT2</font>` 状态不可以持续太久，而 `<font color=#FEAE00>tcp_fin_timeout</font>` 控制了这个状态下连接的持续时长，<font color=#FEAE00>默认值是</font><font color=#FEAE00> 60 </font><font color=#FEAE00>秒。</font><br>&emsp;&emsp;<br>&emsp;&emsp;这意味着对于调用 close 关闭的连接，如果在 <font color=#FEAE00>60 </font><font color=#FEAE00>秒后还没有收到</font><font color=#FEAE00> FIN </font><font color=#FEAE00>报文，客户端（主动关闭方）的连接就会直接关闭。</font><br>&emsp;&emsp;<br>&emsp;&emsp;但是注意，如果<font color=#FEAE00>主动关闭方使用</font><font color=#FEAE00> shutdown </font><font color=#FEAE00>函数关闭连接</font>，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。此时，如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 <font color=#FEAE00>`FIN_WAIT2` </font><font color=#FEAE00>状态（</font><font color=#FEAE00>`tcp_fin_timeout` </font><font color=#FEAE00>无法控制</font><font color=#FEAE00> shutdown </font><font color=#FEAE00>关闭的连接）</font>。<hr><hr>TCP挥手-4:: 第<font color=#FEAE00>四次挥手丢失</font>了，会发生什么？<hr>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 `<font color=#FEAE00>TIME_WAIT</font>` 状态。<br>&emsp;&emsp;<br>&emsp;&emsp;在 Linux 系统，TIME_WAIT 状态会持续 <font color=#FEAE00>2MSL</font> 后才会进入关闭状态。<br>&emsp;&emsp;<br>&emsp;&emsp;然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 LAST_ACK 状态。<br>&emsp;&emsp;<br>&emsp;&emsp;如果第四次挥手的 ACK 报文没有到达服务端，服务端<font color=#FEAE00>就会重发</font><font color=#FEAE00> FIN </font><font color=#FEAE00>报文</font>，重发次数仍然由前面介绍过的 `<font color=#FEAE00>tcp_orphan_retries</font>` 参数控制。<hr><hr>TCP挥手-5:: 什么是 <font color=#FEAE00>2MSL</font>?<br>&emsp;&emsp;为什么<font color=#FEAE00>TIME_WAIT</font>状态需要经过<font color=#FEAE00>2MSL</font>才能返回到CLOSE状态？<hr>`<font color=#FEAE00>MSL` </font><font color=#FEAE00>是</font><font color=#FEAE00> Maximum Segment Lifetime</font>，<font color=#FEAE00>报文最大生存时间</font>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。<br>&emsp;&emsp;<br>&emsp;&emsp;MSL 与 IP 的 TTL 的区别： MSL 的单位是时间，而<font color=#FEAE00> TTL </font><font color=#FEAE00>是经过路由跳数</font>。所以 <font color=#FEAE00>MSL </font><font color=#FEAE00>应该要大于等于</font><font color=#FEAE00> TTL </font><font color=#FEAE00>消耗为</font><font color=#FEAE00> 0 </font><font color=#FEAE00>的时间</font>，以确保报文已被自然消亡。<br>&emsp;&emsp;<br>&emsp;&emsp;TTL 的值一般是 <font color=#FEAE00>64</font>，Linux 将 <font color=#FEAE00>MSL </font><font color=#FEAE00>设置为</font><font color=#FEAE00> 30 </font><font color=#FEAE00>秒</font>，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了。<br>&emsp;&emsp;<br>&emsp;&emsp;TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： <font color=#FEAE00>网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以</font><font color=#FEAE00>一来一回需要等待</font><font color=#FEAE00> 2 </font><font color=#FEAE00>倍的时间</font><font color=#FEAE00>。</font><br>&emsp;&emsp;<br>&emsp;&emsp;比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 `FIN` 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。<br>&emsp;&emsp;<br>&emsp;&emsp;为什么<font color=#FEAE00>不是</font><font color=#FEAE00> 4 </font><font color=#FEAE00>或者</font><font color=#FEAE00> 8 MSL </font><font color=#FEAE00>的时长呢</font>？你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它<font color=#FEAE00>更具性价比</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;`2MSL` 的时间是从客户端接收到 <font color=#FEAE00>FIN </font><font color=#FEAE00>后发送</font><font color=#FEAE00> ACK </font><font color=#FEAE00>开始计时的</font>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端<font color=#FEAE00>重发的</font><font color=#FEAE00> FIN </font><font color=#FEAE00>报文，那么</font><font color=#FEAE00> </font><font color=#FEAE00>2MSL </font><font color=#FEAE00>时间将重新计时</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;#define TCP_TIMEWAIT_LEN (60*HZ)  定义在Linux内核中<br>&emsp;&emsp;<br>&emsp;&emsp;TIME_WAIT状态主要用来:<br>&emsp;&emsp;- 防止历史连接中的数据，被后面<font color=#FEAE00>相同四元组</font>的<font color=#FEAE00>连接错误的接收</font>；<br>&emsp;&emsp;- 保证「<font color=#FEAE00>被动关闭连接</font>」的一方，能被<font color=#FEAE00>正确的关闭</font>；<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;序列号 和 初始序列号 会发生<font color=#FEAE00>绕回初值</font>的情况<br>&emsp;&emsp;	如果 TIME_WAIT 过短, 服务端发送的 报文被网络延迟到 本该TIME_WAIT的时间, 错误以为是新的连接.<br>&emsp;&emsp;	因此 TCP 设计了 TIME_WAIT 状态，状态会持续 `2MSL` 时长，这个时间足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。<br>&emsp;&emsp;	在2MSL时间内，<font color=#FEAE00>同一个</font><font color=#FEAE00>socket</font><font color=#FEAE00>不能再被使用</font>，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）。<br>&emsp;&emsp;<br>&emsp;&emsp;2. 保证「被动关闭连接」的一方，能被正确的关闭<br>&emsp;&emsp;<font color=#FEAE00>也就是保证</font><font color=#FEAE00> client </font><font color=#FEAE00>发送的最后一个</font><font color=#FEAE00> ACK </font><font color=#FEAE00>报文能成功到达</font><font color=#FEAE00> server </font><font color=#FEAE00>端</font><br>&emsp;&emsp;TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.<br>&emsp;&emsp;	这时候如果新来报文, <font color=#FEAE00>会回复自己的</font><font color=#FEAE00>ACK</font><br>&emsp;&emsp;	防止呢, 客户端发送 RST, 服务端<font color=#FEAE00>收到这个</font><font color=#FEAE00> RST </font>并将其解释为一个错误（Connection reset by peer），这对于一个可靠的协议来说<font color=#FEAE00>不是一个优雅的终止方式</font>。<hr><hr>TCP挥手-6:: TIME_WAIT 过多有什么危害？<hr>- 第一是<font color=#FEAE00>占用系统资源</font>，比如文件描述符、内存资源、CPU 资源、线程资源等；<br>&emsp;&emsp;- 第二是<font color=#FEAE00>占用端口资源</font>，端口资源也是有限的，一般可以开启的端口为 `32768～61000`，也可以通过 `<font color=#FEAE00>net.ipv4.ip_local_port_range</font>`参数指定范围。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#FEAE00>client </font><font color=#FEAE00>和</font><font color=#FEAE00> server </font><font color=#FEAE00>的</font><font color=#FEAE00> TIME_WAIT </font><font color=#FEAE00>过多，会造成不同影响。</font><br>&emsp;&emsp;<br>&emsp;&emsp;如果<font color=#FEAE00>client</font>（发起连接方）的 TIME_WAIT 状态过多，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务器发起连接了，但是<font color=#FEAE00>被使用的端口，还是可以继续对另外一个服务器发起连接的</font>. 具体看 <font color=#FEAE00>小林</font><font color=#FEAE00>coding::</font><font color=#FEAE00>复用文章</font><br>&emsp;&emsp;<br>&emsp;&emsp;因此，客户端（发起连接方）都是和「目的 IP+ 目的 PORT 」都一样的服务器建立连接的话，当客户端的 TIME_WAIT 状态连接过多的话，就<font color=#FEAE00>会受端口资源限制，如果占满了所有端口资源，那么就无法再跟「目的</font><font color=#FEAE00> IP+ </font><font color=#FEAE00>目的</font><font color=#FEAE00> PORT</font><font color=#FEAE00>」都一样的服务器建立连接</font>了。<br>&emsp;&emsp;<br>&emsp;&emsp;不过，即使是在这种场景下，只要<font color=#FEAE00>连接的是不同的服务器，端口是可以重复使用的</font>，所以客户端还是可以向其他服务器发起连接的，这是因为内核在定位一个连接的时候，是通过四元组（源IP、源端口、目的IP、目的端口）信息来定位的，并不会因为客户端的端口一样，而导致连接冲突。<font color=#FEAE00>同一个端口</font><font color=#FEAE00>, </font><font color=#FEAE00>可以去连接不同的</font><font color=#FEAE00>IP</font>? <br>&emsp;&emsp;<br>&emsp;&emsp;如果<font color=#FEAE00>服务端（发起连接方）的</font><font color=#FEAE00> TIME_WAIT </font><font color=#FEAE00>状态过多</font>，并不会导致端口资源受限，因为<font color=#FEAE00>服务端只监听一个端口</font>，而且由于一个<font color=#FEAE00>四元组唯一确定一个</font><font color=#FEAE00> TCP </font><font color=#FEAE00>连接</font>，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如<font color=#FEAE00>文件描述符、内存资源、</font><font color=#FEAE00>CPU </font><font color=#FEAE00>资源、线程资源等。</font><hr><hr>TCP挥手-7:: 如何优化 TIME_WAIT？<hr>- 打开 <font color=#FEAE00>net.ipv4.tcp_tw_reuse</font> 和 <font color=#FEAE00>net.ipv4.tcp_timestamps </font>选项；<br>&emsp;&emsp;- <font color=#FEAE00>net.ipv4.tcp_max_tw_buckets</font><br>&emsp;&emsp;- 程序中使用 <font color=#FEAE00>SO_LINGER</font> ，应用<font color=#FEAE00>强制使用</font><font color=#FEAE00> RST </font>关闭。<br>&emsp;&emsp;<br>&emsp;&emsp;方式一：<font color=#FEAE00>net.ipv4.tcp_tw_reuse </font>和 <font color=#FEAE00>tcp_timestamps</font><br>&emsp;&emsp;<br>&emsp;&emsp;如下的 Linux 内核参数开启后，则可以复用处于 <font color=#FEAE00>TIME_WAIT</font> 的 <font color=#FEAE00>socket </font><font color=#FEAE00>为新的连接</font>所用。<br>&emsp;&emsp;<br>&emsp;&emsp;有一点需要注意的是，tcp_tw_reuse 功能<font color=#FEAE00>只能用客户端（连接发起方</font>），因为开启了该功能，在调用 connect() 函数时，内核会<font color=#1DB100>随机找一个</font><font color=#1DB100> time_wait </font><font color=#1DB100>状态超过</font><font color=#1DB100> 1 </font><font color=#1DB100>秒</font>的连接给新的连接复用。<br>&emsp;&emsp;<br>&emsp;&emsp;```shell<br>&emsp;&emsp;<font color=#FEAE00>net.ipv4.tcp_tw_reuse = 1</font><br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;使用这个选项，还有一个<font color=#FEAE00>前提</font>，需要打开对 <font color=#FEAE00>TCP </font><font color=#FEAE00>时间戳的支持</font>，即<br>&emsp;&emsp;<br>&emsp;&emsp;```text<br>&emsp;&emsp;net.ipv4.tcp_timestamps=1（默认即为 1）<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;这个时间戳的字段是在 TCP 头部的「选项」里，它由<font color=#FEAE00>一共</font><font color=#FEAE00> 8 </font><font color=#FEAE00>个字节表示时间戳</font>，其中第一个 4 字节字段用来<font color=#FEAE00>保存发送该数据包</font>的时间，第二个 4 字节字段用来保存<font color=#FEAE00>最近一次接收对方发送到达数据</font>的时间。<br>&emsp;&emsp;<br>&emsp;&emsp;由于引入了时间戳，我们在前面提到的 `2MSL` 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。<br>&emsp;&emsp;<br>&emsp;&emsp;*方式二：net.ipv4.tcp<font color=#FEAE00>_max_tw_buckets</font>*<br>&emsp;&emsp;<br>&emsp;&emsp;这个值默认为 18000，当系统中<font color=#FEAE00>处于</font><font color=#FEAE00> TIME_WAIT </font><font color=#FEAE00>的连接一旦超过这个值时</font>，系统就会将<font color=#FEAE00>后面的</font><font color=#FEAE00> TIME_WAIT </font><font color=#FEAE00>连接状态重置</font>，这个方法比较暴力。<br>&emsp;&emsp;<br>&emsp;&emsp;*方式三：程序中使用 <font color=#FEAE00>SO_LINGER</font>*<br>&emsp;&emsp;<br>&emsp;&emsp;我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。<br>&emsp;&emsp;<br>&emsp;&emsp;```c<br>&emsp;&emsp;struct linger so_linger;<br>&emsp;&emsp;so_linger.l_onoff = 1;<br>&emsp;&emsp;so_linger.l_linger = 0;<br>&emsp;&emsp;setsockopt(s, SOL_SOCKET, SO_LINGER, &so_linger,sizeof(so_linger));<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;如果`<font color=#FEAE00>l_onoff</font>`为非 0， 且`l_linger`值为 0，那么调用`close`后，<font color=#FEAE00>会立该发送一个</font><font color=#FEAE00>`RST`</font><font color=#FEAE00>标志给对端</font>，该 TCP 连接将跳过四次挥手，也就<font color=#FEAE00>跳过了</font><font color=#FEAE00>`TIME_WAIT`</font><font color=#FEAE00>状态</font>，直接关闭。<br>&emsp;&emsp;<br>&emsp;&emsp;但这为跨越`TIME_WAIT`状态提供了一个可能，不过是一个<font color=#FEAE00>非常危险的行为</font>，不值得提倡。<br>&emsp;&emsp;<br>&emsp;&emsp;前面介绍的方法都是试图越过 `TIME_WAIT`状态的，这样其实不太好。虽然 TIME_WAIT 状态持续的时间是有一点长，显得很不友好，但是它被设计来就是用来避免发生乱七八糟的事情。<br>&emsp;&emsp;<br>&emsp;&emsp;《UNIX网络编程》一书中却说道：TIME_WAIT 是我们的朋友，它是有助于我们的，不要试图避免这个状态，而是应该弄清楚它。<br>&emsp;&emsp;<br>&emsp;&emsp;如果服务端要避免过多的 TIME_WAIT 状态的连接，就永远不要主动断开连接，<font color=#FEAE00>让客户端去断开，由分布在各处的客户端去承受</font><font color=#FEAE00> TIME_WAIT</font>。<hr><hr>TCP握手-1:: 三次握手具体过程?  两端状态变迁? <br>&emsp;&emsp;<hr>一开始 [<font color=#FEAE00>closed | listen</font>] 状态<br>&emsp;&emsp;1st: <font color=#FEAE00>seq=x</font>(isn) | <font color=#FEAE00>SYN</font>=1,<br>&emsp;&emsp;	-> [<font color=#FEAE00>syn-sent</font> | listen] 状态<br>&emsp;&emsp;2st: <font color=#FEAE00>seq=y</font> | <font color=#FEAE00>ack = y+1</font> | SYN=1, ACK=1<br>&emsp;&emsp;	->[syn-sent | <font color=#FEAE00>syn-rcvd</font>] 状态<br>&emsp;&emsp;3st: <font color=#FEAE00>ack=y+1 </font>| ACK=1 <br>&emsp;&emsp;	->[<font color=#FEAE00>Established</font> | syn-rcvd] 状态<br>&emsp;&emsp;服务端收到以后: <br>&emsp;&emsp;	->[Established | <font color=#FEAE00>Established</font>] 状态<br>&emsp;&emsp;第三次握手是可以携带数据的, 不过这样子, 怎么变化? <hr><hr>TCP握手-2:: TCP为什么是三次握手, 不是两次 / 四次? <hr>“因为三次握手才能保证双方具有接收和发送的能力。”<br>&emsp;&emsp;- 第一次握手：Server知道：Client的发送能力、Server的接收能力是正常的。<br>&emsp;&emsp;- 第二次握手：Client知道：Server的接收、发送能力，Client的接收、发送 OK 。<br>&emsp;&emsp;- 第三次握手：Server知道。 Client的接收、发送，Server的发送、接收 OK。<br>&emsp;&emsp;1. 「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；<br>&emsp;&emsp;<br>&emsp;&emsp;2. 「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。<br>&emsp;&emsp;<br>&emsp;&emsp;- 三次握手才可以阻止重复历史连接的初始化（主要原因）<br>&emsp;&emsp;<br>&emsp;&emsp;  首要原因是为了防止旧的重复连接初始化造成混乱。 <br>&emsp;&emsp;<br>&emsp;&emsp;  多次发送SYN连接的报文, 在网络拥堵情况下: <br>&emsp;&emsp;<br>&emsp;&emsp;  ​	如果旧的SYN比新的早到达了, 客户端可以通过判断是历史连接, 发送 `RST` 给服务端来中止连接<br>&emsp;&emsp;<br>&emsp;&emsp;  ​    两次握手, 服务端没有中间状态, 可能直接建立起来历史连接了, 无法避免在建立连接前组织他<br>&emsp;&emsp;<br>&emsp;&emsp;- 三次握手才可以同步双方的初始序列号<br>&emsp;&emsp;<br>&emsp;&emsp;  维护序列号: (去重, 按序接受, 判断对方进度)<br>&emsp;&emsp;<br>&emsp;&emsp;  一来一回才能保证两个序列号被成功同步<br>&emsp;&emsp;<br>&emsp;&emsp;- 三次握手才可以避免服务端资源浪费<br>&emsp;&emsp;<br>&emsp;&emsp;  服务端不用频繁建立无效链接了<hr><hr>TCP握手-3:: 59、 三次握手过程中可以携带数据吗？<hr>其实第三次握手的时候，是可以携带数据的。但是，<font color=#FEAE00>第一次、第二次握手不可以携带数据</font><br>&emsp;&emsp;<br>&emsp;&emsp;为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。<br>&emsp;&emsp;<br>&emsp;&emsp;也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时<font color=#FEAE00>客户端已经处于</font><font color=#FEAE00> ESTABLISHED </font><font color=#FEAE00>状态</font>。对于客户端来说，他已经建立起连接了，并且<font color=#FEAE00>也已经知道服务器的接收、发送能力是正常</font>的了，所以能携带数据也没啥毛病。<hr><hr>TCP握手-4:: 第一次握手丢失了，会发生什么？<hr>第一次发送 SYN 报文，进入 `<font color=#FEAE00>SYN_SENT</font>` 状态<br>&emsp;&emsp;<br>&emsp;&emsp;如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会「<font color=#FEAE00>超时重传</font>」机制，重传 SYN 报文。<br>&emsp;&emsp;<br>&emsp;&emsp;超时时间不同，<font color=#FEAE00>1 </font><font color=#FEAE00>秒</font><font color=#FEAE00> / 3 </font><font color=#FEAE00>秒的</font>，超时时间是写死在内核里的，如果想要更改则需要重新编译内核. <br>&emsp;&emsp;<br>&emsp;&emsp;当客户端在 1 秒后<font color=#FEAE00>没收到服务端</font>的 <font color=#FEAE00>SYN-ACK</font> 报文后，客户端就会重发 SYN 报文.<br>&emsp;&emsp;<br>&emsp;&emsp;在 Linux 里，客户端的 SYN 报文最大重传次数由 `<font color=#FEAE00>tcp_syn_retries</font>`内核参数控制，这个参数是可以自定义的，默认值一般是 5。<br>&emsp;&emsp;<br>&emsp;&emsp;通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，<font color=#FEAE00>每次超时的时间是上一次的</font><font color=#FEAE00> 2 </font><font color=#FEAE00>倍</font><font color=#FEAE00>。</font><br>&emsp;&emsp;<br>&emsp;&emsp;当第五次超时重传后，<font color=#FEAE00>会继续等待</font><font color=#FEAE00> 32 </font><font color=#FEAE00>秒</font>，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。<br>&emsp;&emsp;<br>&emsp;&emsp;所以，总耗时是 1+2+4+8+16+32=63 秒，<font color=#FEAE00>大约</font><font color=#FEAE00> 1 </font><font color=#FEAE00>分钟左右。</font><br>&emsp;&emsp;<hr><hr>TCP握手-5:: 第二次握手丢失了，会发生什么？<hr>第二次回 SYN-ACK 报文给client, 进入 `<font color=#FEAE00>SYN_RCVD</font>` 状态。<br>&emsp;&emsp;<br>&emsp;&emsp;两个目的 ：<br>&emsp;&emsp;- 第二次握手里的 ACK， 是对<font color=#FEAE00>第一次握手的确认报文</font>；<br>&emsp;&emsp;- 第二次握手里的 SYN，是服务端<font color=#FEAE00>发起建立</font><font color=#FEAE00> TCP </font><font color=#FEAE00>连接</font>的报文；<br>&emsp;&emsp;<br>&emsp;&emsp;因此丢失以后?<br>&emsp;&emsp;	因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是<font color=#FEAE00>客户端就会触发超时重传机制</font>，重传 SYN 报文。<br>&emsp;&emsp;	然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。<br>&emsp;&emsp;	那么，如果第二次握手丢失了，<font color=#FEAE00>服务端就收不到第三次握手</font>，于是<font color=#FEAE00>服务端这边会触发超时重传机制</font>，重传 SYN-ACK 报文。<br>&emsp;&emsp;<br>&emsp;&emsp;在 Linux 下，SYN-ACK 报文的最大重传次数由 `<font color=#FEAE00>tcp_synack_retries</font>`内核参数决定，默认值是 5。<br>&emsp;&emsp;<br>&emsp;&emsp;因此，当第二次握手丢失了，<font color=#FEAE00>客户端和服务端都会重传</font>：<br>&emsp;&emsp;<br>&emsp;&emsp;- 客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 `<font color=#FEAE00>tcp_syn_retries</font>`内核参数决定；<br>&emsp;&emsp;- 服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 `<font color=#FEAE00>tcp_synack_retries</font>` 内核参数决定。<hr><hr>TCP握手-6:: 第三次握手丢失了，会发生什么？<hr>第三次握手，发送, ACK, 此时client -> `ESTABLISH` <br>&emsp;&emsp;<br>&emsp;&emsp;:: 是服务端, 对面进行重传. <br>&emsp;&emsp;	因为，ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文。<br>&emsp;&emsp;<br>&emsp;&emsp;因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超<font color=#FEAE00>时重传机制</font>，<font color=#FEAE00>重传</font><font color=#FEAE00> SYN-ACK </font><font color=#FEAE00>报文</font>，直到收到第三次握手，或者达到最大重传次数。<br>&emsp;&emsp;<hr><hr>TCP握手-7:: 为什么每次TCP链接, ISN初始化序列号都不一样? 如何随机产生?<br>&emsp;&emsp;<hr>- 为了防止<font color=#FEAE00>历史报文</font>被下一个<font color=#FEAE00>相同四元组</font>的连接接收（主要方面）；<br>&emsp;&emsp;- 为了<font color=#FEAE00>安全性</font>，防止黑客伪造的相同序列号的 TCP 报文被对方接收；<br>&emsp;&emsp;<br>&emsp;&emsp;如果每次都是从0开始, 很容易历史阻塞报文被重复接受<br>&emsp;&emsp;<br>&emsp;&emsp;无法完全避免历史报文, 所以加上<font color=#FEAE00>时间戳</font>的机制, 因为是<font color=#FEAE00>回绕</font>的, <br>&emsp;&emsp;<br>&emsp;&emsp;ISN产生是: <font color=#FEAE00>ISN = M + F(localhost, localport, remotehost, remoteport)</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;- `M` 是一个<font color=#FEAE00>计时器</font>，这个计时器每隔 <font color=#FEAE00>4 </font><font color=#FEAE00>微秒加</font><font color=#FEAE00> 1</font>。转一圈要 4.55 个小时。<br>&emsp;&emsp;- `F` 是一个 <font color=#FEAE00>Hash</font> 算法，根据源 IP、目的 IP、源端口、目的端口生成一个<font color=#FEAE00>随机数值</font>。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。<hr><hr>TCP握手-8::60、SYN攻击是什么？ 如何避免? <hr>我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 `SYN` 报文，服务端每接收到一个 `SYN` 报文，就进入`SYN_RCVD` 状态，但服务端发送出去的 `ACK + SYN` 报文，无法得到未知(因为是伪造的) IP 主机的 `ACK` 应答，久而久之就会占满服务端的半连接队列，使得服务器不能为正常用户服务。<br>&emsp;&emsp;<br>&emsp;&emsp;检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。<br>&emsp;&emsp;```<br>&emsp;&emsp;netstat -n -p TCP | grep SYN_RECV<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;有两种队列: <br>&emsp;&emsp;`SYN队列` 处于 `SYN_RCVD` 状态的那些 (受到SYN攻击会满)  (这个叫做半连接队列么?)<br>&emsp;&emsp;<br>&emsp;&emsp;`ACCPET 队列` 接收到ACK, 但是还没有 `accpet()` 应用走的那些 (如果应用程序过慢的话)<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;常见的防御 SYN 攻击的方法有如下几种：<br>&emsp;&emsp;<br>&emsp;&emsp;- 缩短超时（SYN Timeout）时间<br>&emsp;&emsp;- 增加最大半连接数<br>&emsp;&emsp;- 过滤网关防护<br>&emsp;&emsp;- SYN cookies技术<br>&emsp;&emsp;<br>&emsp;&emsp;方式一: 修改 SYN 队列,  数据包队列`net.core.netdev_max_backlog`  SYN队列, `net.ipv4.tcp_max_syn_backlog` 设置直接 abort  `net.ipv4.tcp_abort_on_overflow`<br>&emsp;&emsp;<br>&emsp;&emsp;方式二: `net.ipv4.tcp_syncookies = 1` SYN队列满了以后, 直接算出cookie值, 下次来的直接放入到 ACCEPT() 队列中去<hr><hr>TCP握手::68、三次握手四次挥手的变迁图<hr>《TCP/IP详解 卷1:协议》有一张TCP状态变迁图，很具有代表性，有助于大家理解三次握手和四次挥手的状态变化。如下图所示，粗的实线箭头表示正常的客户端状态变迁，粗的虚线箭头表示正常的服务器状态变迁。<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><hr><font color=#1DB100>accept</font> 发生在三次握手的哪一步？<hr>accept 阻塞在 第二次握手发送的时候, <br>&emsp;&emsp;accept 返回发生在第二次握手返回的时候. <br>&emsp;&emsp; ￼<br>&emsp;&emsp;<hr><hr>arp:: 什么是ARP协议? 头里面都有什么?<hr><hr>epoll: rd准备队列如何维护? <hr><hr>epoll:: UDP需要 LT 和 ET么? 为什么? <hr><hr>get:: 11、GET 和 POST 的区别，你知道哪些？<br>&emsp;&emsp;<br>&emsp;&emsp;todo总结<hr>1. get是获取数据，post是修改数据<br>&emsp;&emsp;<br>&emsp;&emsp;2. get把请求的数据放在url上， 以?分割URL和传输数据，参数之间以&相连，所以get不太安全。而post把数据放在HTTP的包体内（requrest body）<br>&emsp;&emsp;<br>&emsp;&emsp;3. get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制。<br>&emsp;&emsp;<br>&emsp;&emsp;4. GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。<br>&emsp;&emsp;<br>&emsp;&emsp;5. GET请求会被浏览器主动缓存，而POST不会，除非手动设置。<br>&emsp;&emsp;<br>&emsp;&emsp;6. 本质区别：GET是幂等的，而POST不是幂等的<br>&emsp;&emsp;<br>&emsp;&emsp;   > 这里的幂等性：幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。<br>&emsp;&emsp;<br>&emsp;&emsp;正因为它们有这样的区别，所以不应该且不能用get请求做数据的增删改这些有副作用的操作。因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。<hr><hr>http.cookie:: 40、Session是什么？<hr>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。<br>&emsp;&emsp;<br>&emsp;&emsp;Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。<hr><hr>http.get 39、POST 方法会产生两个 TCP 数据包？你了解吗？<hr>有些文章中提到，POST 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。<br>&emsp;&emsp;<br>&emsp;&emsp;HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。<br>&emsp;&emsp;<br>&emsp;&emsp;所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。<hr><hr>http.get:: 38、POST 方法比 GET 方法安全？<hr>有人说POST 比 GET 安全，因为数据在地址栏上不可见。<br>&emsp;&emsp;<br>&emsp;&emsp;然而，从传输的角度来说，他们都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上捉包，就能完整地获取数据报文。<br>&emsp;&emsp;<br>&emsp;&emsp;要想安全传输，就只有加密，也就是 HTTPS。<hr><hr>http:: 102.1 1xx 信息<hr>100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。<hr><hr>http:: 102.2 2xx 成功<hr>- 200 OK<br>&emsp;&emsp;- 204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。<br>&emsp;&emsp;- 206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。<hr><hr>http:: 102.3 3xx 重定向<hr>- 301 Moved Permanently ：永久性重定向<br>&emsp;&emsp;- 302 Found ：临时性重定向<br>&emsp;&emsp;- 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。<br>&emsp;&emsp;- 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。<br>&emsp;&emsp;- 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。<hr><hr>http:: 102.4 4xx 客户端错误<hr>- 400 Bad Request ：请求报文中存在语法错误。<br>&emsp;&emsp;- 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。<br>&emsp;&emsp;- 403 Forbidden ：请求被拒绝。<br>&emsp;&emsp;- 404 Not Found<hr><hr>http:: 102.5 5xx 服务器错误<hr>- 500 Internal Server Error ：服务器正在执行请求时发生错误。<br>&emsp;&emsp;- 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。<hr><hr>http:: 102、常见的HTTP状态码有哪些？<hr>| 状态码 | 类别                             | 含义                       |<br>&emsp;&emsp;| ------ | -------------------------------- | -------------------------- |<br>&emsp;&emsp;| 1XX    | Informational（信息性状态码）    | 接收的请求正在处理         |<br>&emsp;&emsp;| 2XX    | Success（成功状态码）            | 请求正常处理完毕           |<br>&emsp;&emsp;| 3XX    | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |<br>&emsp;&emsp;| 4XX    | Client Error（客户端错误状态码） | 服务器无法处理请求         |<br>&emsp;&emsp;| 5XX    | Server Error（服务器错误状态码） | 服务器处理请求出           |<hr><hr>http:: 88、TCP对应的<font color=#FEAE00>应用层</font>协议 todo 和UDP的写到一起去<hr><font color=#FEAE00>FTP</font>：定义了文件传输协议，使用<font color=#FEAE00>21</font><font color=#FEAE00>端口</font><font color=#FEAE00>.</font><br>&emsp;&emsp;<font color=#FEAE00>Telnet</font>：它是一种用于远程登陆的端口,<font color=#FEAE00>23</font><font color=#FEAE00>端口</font><br>&emsp;&emsp;<font color=#FEAE00>SMTP</font>：定义了简单邮件传送协议，服务器开放的是25号端口。<br>&emsp;&emsp;<font color=#FEAE00>POP3</font>：它是和SMTP对应，POP3用于接收邮件。<hr><hr>http:: 89、UDP对应的<font color=#FEAE00>应用层</font>协议<hr><font color=#FEAE00>DNS</font>：用于域名解析服务，用的是<font color=#FEAE00>53</font>号端口<br>&emsp;&emsp;<font color=#FEAE00>SNMP</font>：简单网络管理协议，使用161号端口<br>&emsp;&emsp;TFTP(Trival File Transfer Protocal)：<font color=#FEAE00>简单文件传输协议</font>，69<hr><hr>http:: 95、XSS攻击是什么？（低频）<hr>跨站点脚本攻击，指攻击者通过篡改网页，嵌入恶意脚本程序，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式。如何防范XSS攻击<br>&emsp;&emsp;1）前端，服务端，同时需要字符串输入的长度限制。<br>&emsp;&emsp;2）前端，服务端，同时需要对HTML转义处理。将其中的”<”,”>”等特殊字符进行转义编码。<br>&emsp;&emsp;防 XSS 的核心是必须对输入的数据做过滤处理。<hr><hr>http:: 96、CSRF攻击？你知道吗？<hr>跨站点请求伪造，指攻击者通过跨站请求，以合法的用户的身份进行非法操作。可以这么理解CSRF攻击：攻击者盗用你的身份，以你的名义向第三方网站发送恶意请求。CRSF能做的事情包括利用你的身份发邮件，发短信，进行交易转账，甚至盗取账号信息。<hr><hr>http:: 97、如何防范CSRF攻击<br>&emsp;&emsp;<br>&emsp;&emsp;todo 不清晰<hr>安全框架，例如Spring Security。<br>&emsp;&emsp;token机制。在HTTP请求中进行token验证，如果请求中没有token或者token内容不正确，则认为CSRF攻击而拒绝该请求。<br>&emsp;&emsp;验证码。通常情况下，验证码能够很好的遏制CSRF攻击，但是很多情况下，出于用户体验考虑，验证码只能作为一种辅助手段，而不是最主要的解决方案。<br>&emsp;&emsp;referer识别。在HTTP Header中有一个字段Referer，它记录了HTTP请求的来源地址。如果Referer是其他网站，就有可能是CSRF攻击，则拒绝该请求。但是，服务器并非都能取到Referer。很多用户出于隐私保护的考虑，限制了Referer的发送。在某些情况下，浏览器也不会发送Referer，例如HTTPS跳转到HTTP。<br>&emsp;&emsp;1）验证请求来源地址；<br>&emsp;&emsp;2）关键操作添加验证码；<br>&emsp;&emsp;3）在请求地址添加 token 并验证。<hr><hr>http:: 98、文件上传漏洞是如何发生的？你有经历过吗？<hr>文件上传漏洞，指的是用户上传一个可执行的脚本文件，并通过此脚本文件获得了执行服务端命令的能力。<br>&emsp;&emsp;许多第三方框架、服务，都曾经被爆出文件上传漏洞，比如很早之前的Struts2，以及富文本编辑器等等，可被攻击者上传恶意代码，有可能服务端就被人黑了。<hr><hr>http::76、HTTP如何禁用缓存？如何确认缓存？<br>&emsp;&emsp;<br>&emsp;&emsp;todo 这是啥？<hr>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。<br>&emsp;&emsp;<br>&emsp;&emsp; 禁止进行缓存<br>&emsp;&emsp;<br>&emsp;&emsp;no-store 指令规定不能对请求或响应的任何一部分进行缓存。<br>&emsp;&emsp;<br>&emsp;&emsp;```html<br>&emsp;&emsp;Cache-Control: no-store<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;强制确认缓存<br>&emsp;&emsp;<br>&emsp;&emsp;no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。<br>&emsp;&emsp;<br>&emsp;&emsp;```html<br>&emsp;&emsp;Cache-Control: no-cache<br>&emsp;&emsp;```<hr><hr>http::77、GET与POST传递数据的最大长度能够达到多少呢？<hr>get 是通过URL提交数据，因此GET可提交的数据量就跟URL所能达到的最大长度有直接关系。<br>&emsp;&emsp;<br>&emsp;&emsp;很多文章都说GET方式提交的数据最多只能是1024字节，而实际上，URL不存在参数上限的问题，HTTP协议规范也没有对URL长度进行限制。<br>&emsp;&emsp;<br>&emsp;&emsp;这个限制是特定的浏览器及服务器对它的限制，比如IE对URL长度的限制是2083字节(2K+35字节)。对于其他浏览器，如FireFox，Netscape等，则没有长度限制，这个时候其限制取决于服务器的操作系统；即如果url太长，服务器可能会因为安全方面的设置从而拒绝请求或者发生不完整的数据请求。<br>&emsp;&emsp;<br>&emsp;&emsp;post 理论上讲是没有大小限制的，HTTP协议规范也没有进行大小限制，但实际上post所能传递的数据量大小取决于服务器的设置和内存大小。<br>&emsp;&emsp;<br>&emsp;&emsp;因为我们一般post的数据量很少超过MB的，所以我们很少能感觉的到post的数据量限制，但实际中如果你上传文件的过程中可能会发现这样一个问题，即上传个头比较大的文件到服务器时候，可能上传不上去。<br>&emsp;&emsp;<br>&emsp;&emsp;以php语言来说，查原因的时候你也许会看到有说PHP上传文件涉及到的参数PHP默认的上传有限定，一般这个值是2MB，更改这个值需要更改php.conf的post_max_size这个值。这就很明白的说明了这个问题了。<hr><hr>http::99、如何防范文件上传漏洞<hr>文件上传的目录设置为不可执行。<br>&emsp;&emsp;<br>&emsp;&emsp;1）判断文件类型。在判断文件类型的时候，可以结合使用MIME Type，后缀检查等方式。因为对于上传文件，不能简单地通过后缀名称来判断文件的类型，因为攻击者可以将可执行文件的后缀名称改为图片或其他后缀类型，诱导用户执行。<br>&emsp;&emsp;<br>&emsp;&emsp;2）对上传的文件类型进行白名单校验，只允许上传可靠类型。<br>&emsp;&emsp;<br>&emsp;&emsp;3）上传的文件需要进行重新命名，使攻击者无法猜想上传文件的访问路径，将极大地增加攻击成本，同时向shell.php.rar.ara这种文件，因为重命名而无法成功实施攻击。<br>&emsp;&emsp;<br>&emsp;&emsp;4）限制上传文件的大小。<br>&emsp;&emsp;<br>&emsp;&emsp;5）单独设置文件服务器的域名。<hr><hr>https::75、<font color=#FEAE00>SSL</font>中的认证中的<font color=#FEAE00>证书是什么</font>？了解过吗？<hr>通过使用 <font color=#FEAE00>证书</font><font color=#FEAE00> </font>来对通信方进行认证。<br>&emsp;&emsp;<br>&emsp;&emsp;数字<font color=#FEAE00>证书认证机构（</font><font color=#FEAE00>CA</font><font color=#FEAE00>，</font><font color=#FEAE00>Certificate Authority</font><font color=#FEAE00>）</font>是客户端与服务器双方都<font color=#FEAE00>可信赖的第三方机构</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的<font color=#FEAE00>公开密钥做数字签名</font>，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密<font color=#FEAE00>钥证书后绑定在一起</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;进行 HTTPS 通信时，服务器<font color=#FEAE00>会把证书发送给客户端</font>。客户端<font color=#FEAE00>取得其中的公开密钥之后</font>，先使用数字签名<font color=#FEAE00>进行验证</font>，如果验证通过，就可以开始通信了。<hr><hr>ip:: 91、Ping命令基于哪一层协议的原理是什么？<hr>ping命令基于网络层的命令，是基于ICMP协议工作的。<hr><hr>ip::104、一台机器能够使用的端口号上限是多少，是否可以修改？如果想要用的端口超过这个限制怎么办？<hr>65536.因为TCP的报文头部中源端口号和目的端口号的长度是16位，也就是可以表示2^16=65536个不同端口号，因此TCP可供识别的端口号最多只有65536个。但是由于0到1023是知名服务端口，所以实际上还要少1024个端口号。<br>&emsp;&emsp;<br>&emsp;&emsp;而对于服务器来说，可以开的端口号与65536无关，其实是受限于Linux可以打开的文件数量，并且可以通过MaxUserPort来进行配置。<hr><hr>socket:: listen时候backlog的意义?<hr>Linux内核中会维护两个队列：<br>&emsp;&emsp;- <font color=#FEAE00>半连接队列</font>（<font color=#FEAE00>SYN</font> 队列）：接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态；<br>&emsp;&emsp;- <font color=#FEAE00>全连接队列</font>（<font color=#FEAE00>Accpet</font> 队列）：已完成 TCP 三次握手过程，处于 ESTABLISHED 状态；<br>&emsp;&emsp;- <font color=#FEAE00>应用程序</font>可以调用 <font color=#FEAE00>accept</font>() 从 全连接队列中取出<br>&emsp;&emsp;<br>&emsp;&emsp;```c<br>&emsp;&emsp;int listen (int socketfd, int backlog)<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;- 参数一 socketfd 为 socketfd 文件描述符<br>&emsp;&emsp;- 参数二 backlog，这参数在历史版本有一定的变化<br>&emsp;&emsp;<br>&emsp;&emsp;在早期 Linux 内核 backlog 是 SYN 队列大小，也就是未完成的队列大小。<br>&emsp;&emsp;<br>&emsp;&emsp;在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建立的队列长度，所以现在通常认为 <font color=#FEAE00>backlog </font><font color=#FEAE00>是</font><font color=#FEAE00> accept </font>队列。<br>&emsp;&emsp;<br>&emsp;&emsp;但是上限值是内核参数 somaxconn 的大小，也就说 accpet 队列长度 = <font color=#FEAE00>min(backlog, somaxconn)</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;想详细了解 TCP 半连接队列和全连接队列，可以看这篇：[<font color=#FEAE00>TCP </font><font color=#FEAE00>半连接队列和全连接队列满了会发生什么？又该如何应对？]</font><font color=#FEAE00>(https://mp.weixin.qq.com/s/2qN0ulyBtO2I67NB_RnJbg)</font><hr><hr>tcp:: 101、如何区分流量控制和拥塞控制？<hr>- 流量控制属于通信双方协商；拥塞控制涉及通信链路全局。<br>&emsp;&emsp;<br>&emsp;&emsp;- 流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。<br>&emsp;&emsp;<br>&emsp;&emsp;- 实际最终发送窗口 = min{流控发送窗口，拥塞窗口}。<hr><hr>tcp:: 44、DDos 攻击了解吗？<hr>客户端向服务端发送请求链接数据包，服务端向客户端发送确认数据包，客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认<br>&emsp;&emsp;没有彻底根治的办法，除非不使用TCP<br>&emsp;&emsp;DDos 预防：<br>&emsp;&emsp;1）限制同时打开SYN半链接的数目<br>&emsp;&emsp;2）缩短SYN半链接的Time out 时间<br>&emsp;&emsp;3）关闭不必要的服务<hr><hr>tcp:: 84、TCP 协议如何保证可靠传输？<br>&emsp;&emsp;<br>&emsp;&emsp;todo 长<hr>### 第一种回答<br>&emsp;&emsp;<br>&emsp;&emsp;- <font color=#FEAE00>确认和重传</font>：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。<br>&emsp;&emsp;- <font color=#FEAE00>数据校验</font>：TCP报文头有校验和，用于校验报文是否损坏。<br>&emsp;&emsp;- 数据<font color=#FEAE00>合理分片和排序</font>：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。而UDP：IP数据报大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，把数据报分成若干片，是的每一片都小于MTU。而接收方IP层则需要进行数据报的重组。由于UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报。<br>&emsp;&emsp;- <font color=#FEAE00>流量控制</font>：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。<br>&emsp;&emsp;- <font color=#FEAE00>拥塞控制</font>：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。<br>&emsp;&emsp;<br>&emsp;&emsp;### 第二种回答<br>&emsp;&emsp;<br>&emsp;&emsp;- 建立连接（标志位）：通信前确认通信实体存在。<br>&emsp;&emsp;<br>&emsp;&emsp;- 序号机制（序号、确认号）：确保了数据是按序、完整到达。<br>&emsp;&emsp;<br>&emsp;&emsp;- 数据校验（校验和）：CRC校验全部数据。<br>&emsp;&emsp;<br>&emsp;&emsp;- 超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。<br>&emsp;&emsp;<br>&emsp;&emsp;- 窗口机制（窗口）：提供流量控制，避免过量发送。<br>&emsp;&emsp;<br>&emsp;&emsp;- 拥塞控制：同上。<br>&emsp;&emsp;<br>&emsp;&emsp;### 第三种回答<br>&emsp;&emsp;<br>&emsp;&emsp;首部校验 <br>&emsp;&emsp;这个校验机制能够确保数据传输不会出错吗？ 答案是不能。<br>&emsp;&emsp;<br>&emsp;&emsp;原因<br>&emsp;&emsp;<br>&emsp;&emsp;TCP协议中规定，TCP的首部字段中有一个字段是校验和，发送方将伪首部、TCP首部、TCP数据使用累加和校验的方式计算出一个数字，然后存放在首部的校验和字段里，接收者收到TCP包后重复这个过程，然后将计算出的校验和和接收到的首部中的校验和比较，如果不一致则说明数据在传输过程中出错。<br>&emsp;&emsp;<br>&emsp;&emsp;这就是TCP的数据校验机制。 但是这个机制能够保证检查出一切错误吗？显然不能。<br>&emsp;&emsp;<br>&emsp;&emsp;因为这种校验方式是累加和，也就是将一系列的数字（TCP协议规定的是数据中的每16个比特位数据作为一个数字）求和后取末位。 但是小学生都知道A+B=B+A，假如在传输的过程中有前后两个16比特位的数据前后颠倒了（至于为什么这么巧合？我不知道，也许路由器有bug？也许是宇宙中的高能粒子击中了电缆？反正这个事情的概率不为零，就有可能会发生），那么校验和的计算结果和颠倒之前是一样的，那么接收端肯定无法检查出这是错误的数据。 <br>&emsp;&emsp;<br>&emsp;&emsp;解决方案<br>&emsp;&emsp;<br>&emsp;&emsp;传输之前先使用MD5加密数据获得摘要，跟数据一起发送到服务端，服务端接收之后对数据也进行MD5加密，如果加密结果和摘要一致，则认为没有问题<hr><hr>tcp:: 85、UDP是什么？<hr>提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。<hr><hr>tcp:: 86、<font color=#FEAE00>TCP</font><font color=#FEAE00>和</font><font color=#FEAE00>UDP</font>的区别<hr><font color=#00AB8E>面相连接</font><font color=#00AB8E> (</font><font color=#00AB8E>连接</font><font color=#00AB8E> + </font><font color=#00AB8E>服务对象</font><font color=#00AB8E>)<br>&emsp;&emsp;</font><font color=#00AB8E>可靠</font><font color=#00AB8E> (</font><font color=#00AB8E>可靠性</font><font color=#00AB8E>, </font><font color=#00AB8E>拥塞和流量控制</font><font color=#00AB8E>, </font><font color=#00AB8E>因此头部多</font><font color=#00AB8E>, </font><font color=#00AB8E>超时重传</font><font color=#00AB8E>(</font><font color=#00AB8E>分片</font><font color=#00AB8E>)) <br>&emsp;&emsp;</font><font color=#00AB8E>面相字节流</font><font color=#00AB8E>(</font><font color=#00AB8E>传输方式</font><font color=#00AB8E>, </font><font color=#00AB8E>数据报</font><font color=#00AB8E>)</font><br>&emsp;&emsp;1、<font color=#FEAE00>连接</font>: TCP面向连接, UDP是无连接<br>&emsp;&emsp;<br>&emsp;&emsp;2、<font color=#FEAE00>可靠性</font>: <br>&emsp;&emsp;* TCP提供可靠的服务, 无差错，不丢失，不重复，且按序到达;<br>&emsp;&emsp;* UDP尽最大努力交付，即不保证可靠交付<br>&emsp;&emsp;<br>&emsp;&emsp;3、<font color=#FEAE00>传输方式</font>: TCP面向字节流, 没有边界;UDP是面向报文的, 可能丢包和乱序<br>&emsp;&emsp;<br>&emsp;&emsp;UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br>&emsp;&emsp;<br>&emsp;&emsp;4、<font color=#FEAE00>服务对象</font>, TCP 一对一, UDP支持一对一, 一对多, 多对多<br>&emsp;&emsp;<br>&emsp;&emsp;5、<font color=#FEAE00>首部开销</font>,: TCP首部开销最少20字节;UDP的首部开销小，只有8个字节<br>&emsp;&emsp;<br>&emsp;&emsp;6、<font color=#FEAE00>拥塞和流量控制</font>: TCP进行控制, 保证传输的安全性, UDP不保证, <br>&emsp;&emsp;<br>&emsp;&emsp;7、<font color=#FEAE00>分片不同</font>: TCP如果大于 <font color=#FEAE00>MSS</font> 大小, 会在传输层进行分片, UDP如果大于<font color=#FEAE00>MTU</font>大小, 会在IP层进行分片<hr><hr>tcp:: 92、在进行UDP编程的时候，一次发送多少bytes好?<hr>当然,这个没有唯一答案，相对于不同的系统,不同的要求,其得到的答案是不一样的。<br>&emsp;&emsp;<br>&emsp;&emsp;我这里仅对像ICQ一类的发送聊天消息的情况作分析，对于其他情况，你或许也能得到一点帮助:首先,我们知道,TCP/IP通常被认为是一个四层协议系统,包括链路层,网络层,运输层,应用层.UDP属于运输层,<br>&emsp;&emsp;<br>&emsp;&emsp;下面我们由下至上一步一步来看:以太网(Ethernet)数据帧的长度必须在46-1500字节之间,这是由以太网的物理特性决定的.这个1500字节被称为链路层的MTU(最大传输单元).但这并不是指链路层的长度被限制在1500字节,其实这这个MTU指的是链路层的数据区.并不包括链路层的首部和尾部的18个字节.<br>&emsp;&emsp;<br>&emsp;&emsp;所以,事实上,这个1500字节就是网络层IP数据报的长度限制。因为IP数据报的首部为20字节,所以IP数据报的数据区长度最大为1480字节.而这个1480字节就是用来放TCP传来的TCP报文段或UDP传来的UDP数据报的.又因为UDP数据报的首部8字节,所以UDP数据报的数据区最大长度为1472字节.这个1472字节就是我们可以使用的字节数。<br>&emsp;&emsp;<br>&emsp;&emsp;当我们发送的UDP数据大于1472的时候会怎样呢？<br>&emsp;&emsp;这也就是说IP数据报大于1500字节,大于MTU.这个时候发送方IP层就需要分片(fragmentation).<br>&emsp;&emsp;把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.<br>&emsp;&emsp;这样就会多做许多事情,而更严重的是,由于UDP的特性,当某一片数据传送中丢失时,接收方便<br>&emsp;&emsp;无法重组数据报.将导致丢弃整个UDP数据报。<br>&emsp;&emsp;<br>&emsp;&emsp;因此,在普通的局域网环境下，我建议将UDP的数据控制在1472字节以下为好.<br>&emsp;&emsp;<br>&emsp;&emsp;进行Internet编程时则不同,因为Internet上的路由器可能会将MTU设为不同的值.<br>&emsp;&emsp;如果我们假定MTU为1500来发送数据的,而途经的某个网络的MTU值小于1500字节,那么系统将会使用一系列的机<br>&emsp;&emsp;制来调整MTU值,使数据报能够顺利到达目的地,这样就会做许多不必要的操作.<br>&emsp;&emsp;<br>&emsp;&emsp;鉴于Internet上的标准MTU值为576字节,所以我建议在进行Internet的UDP编程时.<br>&emsp;&emsp;最好将UDP的数据长度控件在548字节(576-8-20)以内<hr><hr>tcp:: 93、TCP 利用滑动窗口实现流量控制的机制？<br>&emsp;&emsp;<br>&emsp;&emsp;todo 看不懂<hr>>  流量控制是为了控制发送方发送速率，保证接收方来得及接收。TCP 利用滑动窗口实现流量控制。<br>&emsp;&emsp;<br>&emsp;&emsp;TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据。<br>&emsp;&emsp;<br>&emsp;&emsp;> 例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。<hr><hr>tcp:: 94、可以解释一下RTO，RTT和超时重传分别是什么吗？<hr>- 超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：<br>&emsp;&emsp;<br>&emsp;&emsp;  - 发送的数据没能到达接收端，所以对方没有响应。<br>&emsp;&emsp;<br>&emsp;&emsp;  - 接收端接收到数据，但是ACK报文在返回过程中丢失。<br>&emsp;&emsp;<br>&emsp;&emsp;  - 接收端拒绝或丢弃数据。<br>&emsp;&emsp;<br>&emsp;&emsp;- RTO：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是重传间隔。<br>&emsp;&emsp;  - 通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT......<br>&emsp;&emsp;<br>&emsp;&emsp;  - 重传次数到达上限之后停止重传。<br>&emsp;&emsp;<br>&emsp;&emsp;- RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。<hr><hr>tcp:: <font color=#FEAE00>保活</font>, server 什么时候<font color=#FEAE00>断开连接</font>?<hr>TCP 有一个机制是保活机制。这个机制的原理是这样的：<br>&emsp;&emsp;<br>&emsp;&emsp;	(<font color=#FEAE00>心跳包</font>) 定义一个时间段，在这个时间段内，如果<font color=#FEAE00>没有任何连接相关的活动</font>，TCP 保活机制会开始作用，每隔一个时间间隔，发<font color=#FEAE00>送一个探测报文</font>，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将<font color=#FEAE00>错误信息通知给上层应用程序</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;在 Linux 内核可以有对应的参数可以设置<font color=#FEAE00>保活时间</font>、<font color=#FEAE00>保活探测的次数</font>、<font color=#FEAE00>保活探测的时间间隔</font>，以下都为默认值：<br>&emsp;&emsp;<br>&emsp;&emsp;```shell<br>&emsp;&emsp;net.ipv4.<font color=#FEAE00>tcp_keepalive_time</font>=7200<br>&emsp;&emsp;net.ipv4.<font color=#FEAE00>tcp_keepalive_intvl</font>=75  <br>&emsp;&emsp;net.ipv4.<font color=#FEAE00>tcp_keepalive_probes</font>=9<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;- tcp_keepalive_time=7200：表示保活时间是 7200 秒（2小时），也就 <font color=#FEAE00>2 </font><font color=#FEAE00>小时内</font>如果没有任何连接相关的活动，则会启动保活机制<br>&emsp;&emsp;- tcp_keepalive_intvl=75：表示每次检测间隔 75 秒；<br>&emsp;&emsp;- tcp_keepalive_probes=9：表示检测 <font color=#FEAE00>9 </font><font color=#FEAE00>次无响应</font>，认为对方是不可达的，从而中断本次的连接。<br>&emsp;&emsp;<br>&emsp;&emsp;也就是说在 Linux 系统中，最少需要经过 2<font color=#FEAE00> </font><font color=#FEAE00>小时</font><font color=#FEAE00> 11 </font><font color=#FEAE00>分</font><font color=#FEAE00> 15 </font><font color=#FEAE00>秒</font><font color=#FEAE00> (7200 + 75*9) </font>才可以发现一个「死亡」连接。<br>&emsp;&emsp;<br>&emsp;&emsp;注意，应用程序若想使用 TCP 保活机制需要通过 <font color=#FEAE00>socket </font><font color=#FEAE00>接口</font>设置 `<font color=#FEAE00>SO_KEEPALIVE</font>` 选项才能够生效，如果没有设置，那么就无法使用 TCP 保活机制。<br>&emsp;&emsp;<br>&emsp;&emsp;如果开启了 TCP 保活，需要考虑以下几种情况：<br>&emsp;&emsp;<br>&emsp;&emsp;- 第一种，对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, <font color=#FEAE00>对端会正常响应</font>，这样 TCP <font color=#FEAE00>保活时间会被重置</font>，等待下一个 TCP 保活时间的到来。<br>&emsp;&emsp;- 第二种，对端程序崩溃并重启。当 TCP 保活的探测报文发送给对端后，<font color=#FEAE00>对端是可以响应的</font>，但由于没有该连接的有效信息，<font color=#FEAE00>会产生一个</font><font color=#FEAE00> RST </font><font color=#FEAE00>报文</font>，这样很快就会发现 TCP 连接已经被重置。<br>&emsp;&emsp;- 第三种，<font color=#FEAE00>是对端程序崩溃</font>，或对端由于其他原因导致报文<font color=#FEAE00>不可达</font>。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<font color=#FEAE00>TCP </font><font color=#FEAE00>会报告该</font><font color=#FEAE00> TCP </font><font color=#FEAE00>连接已经死亡</font><font color=#FEAE00>。</font><br>&emsp;&emsp;<br>&emsp;&emsp;TCP 保活的这个机制检测的时间是有点长，我们可以自己在<font color=#FEAE00>应用层实现一个心跳机制</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;比如，web 服务软件一般都会提供 `<font color=#FEAE00>keepalive_timeout</font>` 参数，用来指定 HTTP 长连接的超时时间。如果设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会启动一个定时器，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，<font color=#FEAE00>定时器的时间一到，就会触发回调函数来释放该连接</font>。<br>&emsp;&emsp;<font color=#FEAE00>server </font><font color=#FEAE00>主动发生</font><font color=#FEAE00> </font><font color=#FEAE00>四次挥手</font>.<hr><hr>tcp::100、<font color=#FEAE00>拥塞控制</font>原理听说过吗？<hr>- 拥塞控制目的是防止数据过多注入到网络中导致网络资源（路由器、交换机等）过载。因为拥塞控制涉及网络链路全局，所以属于全局控制。控制拥塞使用拥塞窗口。<br>&emsp;&emsp;- TCP拥塞控制算法：<br>&emsp;&emsp;  - 慢开始 & 拥塞避免：先试探网络拥塞程度再逐渐增大拥塞窗口。假设窗口长度为d，收到一个确认就加1，正好收到了d个确认，所以一共加d，正好是翻倍，直到达到阀值ssthresh，这部分是慢开始过程。达到阀值后每次以一个MSS为单位增长拥塞窗口大小，当发生拥塞（超时未收到确认），将阀值减为原先一半，继续执行增加，这个过程为拥塞避免。<br>&emsp;&emsp;  - 快速重传 & 快速恢复：略。<br>&emsp;&emsp;  - 最终拥塞窗口会收敛于稳定值。<hr><hr>tcp::80、为何快速重传是选择3次ACK？<hr>主要的考虑还是要区分包的丢失是由于链路故障还是乱序等其他因素引发。<br>&emsp;&emsp;<br>&emsp;&emsp;两次duplicated ACK时很可能是乱序造成的！三次duplicated ACK时很可能是丢包造成的！四次duplicated ACK更更更可能是丢包造成的，但是这样的响应策略太慢。丢包肯定会造成三次duplicated ACK!综上是选择收到三个重复确认时窗口减半效果最好，这是实践经验。<br>&emsp;&emsp;<br>&emsp;&emsp;在没有fast retransmit / recovery 算法之前，重传依靠发送方的retransmit timeout，就是在timeout内如果没有接收到对方的ACK，默认包丢了，发送方就重传，包的丢失原因。<br>&emsp;&emsp;<br>&emsp;&emsp;1）包checksum 出错 <br>&emsp;&emsp;<br>&emsp;&emsp;2）网络拥塞 <br>&emsp;&emsp;<br>&emsp;&emsp;3）网络断，包括路由重收敛，但是发送方无法判断是哪一种情况，于是采用最笨的办法，就是将自己的发送速率减半，即CWND 减为1/2，这样的方法对2是有效的，可以缓解网络拥塞，3则无所谓，反正网络断了，无论发快发慢都会被丢；但对于1来说，丢包是因为偶尔的出错引起，一丢包就对半减速不合理。<br>&emsp;&emsp;<br>&emsp;&emsp;于是有了fast retransmit 算法，基于在反向还可以接收到ACK，可以认为网络并没有断，否则也接收不到ACK，如果在timeout 时间内没有接收到> 2 的duplicated ACK，则概率大事件为乱序，乱序无需重传，接收方会进行排序工作；<br>&emsp;&emsp;<br>&emsp;&emsp;而如果接收到三个或三个以上的duplicated ACK，则大概率是丢包，可以逻辑推理，发送方可以接收ACK，则网络是通的，可能是1、2造成的，先不降速，重传一次，如果接收到正确的ACK，则一切OK，流速依然（包出错被丢）。<br>&emsp;&emsp;<br>&emsp;&emsp;而如果依然接收到duplicated ACK，则认为是网络拥塞造成的，此时降速则比较合理。<hr><hr>tcp::80、为何<font color=#FEAE00>快速重传</font>是选择<font color=#FEAE00>3</font><font color=#FEAE00>次</font><font color=#FEAE00>ACK</font>？<hr>主要的考虑还是要区<font color=#FEAE00>分包的丢失</font>是由于<font color=#FEAE00>链路故障</font>还是<font color=#FEAE00>乱序</font>等其他因素引发。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#FEAE00>两次</font><font color=#FEAE00>duplicated ACK</font>时很可能是<font color=#FEAE00>乱序造成的</font>！三次duplicated ACK时<font color=#FEAE00>很可能是丢包造成的</font>！四次duplicated ACK更更更可能是丢包造成的，但是这样的响应策略太慢。丢包肯定会造成三次duplicated ACK!综上是选择收到三个重复确认时窗口减半效果最好，这是实践经验。<br>&emsp;&emsp;<br>&emsp;&emsp;在没有fast retransmit / recovery 算法之前，重传依靠发送方的retransmit timeout，就是在timeout内如果没有接收到对方的ACK，默认包丢了，发送方就重传，包的丢失原因<br>&emsp;&emsp;<br>&emsp;&emsp;1）<font color=#FEAE00>包</font><font color=#FEAE00>checksum </font><font color=#FEAE00>出错</font> <br>&emsp;&emsp;<br>&emsp;&emsp;2）<font color=#FEAE00>网络拥塞</font><font color=#FEAE00> </font><br>&emsp;&emsp;<br>&emsp;&emsp;3）网络断，<font color=#FEAE00>包括路由重收敛</font>，但是发送方无法判断是哪一种情况，于是采用最笨的办法，就是将自己的发送速率减半，即CWND 减为1/2，这样的方法对2是有效的，可以缓解网络拥塞，3则无所谓，反正网络断了，无论发快发慢都会被丢；但对于1来说，丢包是因为偶尔的出错引起，一丢包就对半减速不合理。<br>&emsp;&emsp;<br>&emsp;&emsp;于是有了fast retransmit 算法，基于在反向还可以接收到ACK，可以认为网络并没有断，否则也接收不到ACK，如果在timeout 时间内没有接收到> 2 的duplicated ACK，则概率大事件为乱序，乱序无需重传，接收方会进行排序工作；<br>&emsp;&emsp;<br>&emsp;&emsp;而如果接收到三个或三个以上的duplicated ACK，则大概率是丢包，可以逻辑推理，发送方可以接收ACK，则网络是通的，可能是1、2造成的，先不降速，重传一次，如果接收到正确的ACK，则一切OK，流速依然（包出错被丢）。<br>&emsp;&emsp;<br>&emsp;&emsp;而如果依然接收到duplicated ACK，则认为是网络拥塞造成的，此时降速则比较合理。<hr><hr>tcp::82、你了解<font color=#FEAE00>流量控制</font>原理吗？<hr>- 目的是接收方通过<font color=#FEAE00>TCP</font><font color=#FEAE00>头窗口</font>字段告知发送方本方可接收的最大数据量，用以<font color=#FEAE00>解决发送速率过快</font>导致接收方不能接收的问题。所以流量控制是<font color=#FEAE00>点对点控制</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;- TCP是<font color=#FEAE00>双工协议</font>，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。<br>&emsp;&emsp;<br>&emsp;&emsp;  - 发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段<font color=#FEAE00>告知发送方自己的缓冲</font>（受系统、硬件等限制）大小。<br>&emsp;&emsp;<br>&emsp;&emsp;  - 接收窗：用来标记可以接收的数据大小。<br>&emsp;&emsp;<br>&emsp;&emsp;- TCP是流数据，发送出去的数据流可以被分为以下四部分：<font color=#FEAE00>已发送且被确认部分</font><font color=#FEAE00> | </font><font color=#FEAE00>已发送未被确认部分</font><font color=#FEAE00> | </font><font color=#FEAE00>未发送但可发送部分</font><font color=#FEAE00> | </font><font color=#FEAE00>不可发送部分</font>，其中发送窗 = 已发送未确认部分 + <font color=#FEAE00>未发但可发送部分</font>。接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 = 未接收但准备接收部分。<br>&emsp;&emsp;<br>&emsp;&emsp;- 发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，<font color=#FEAE00>左边缘紧贴刚被确认的数据</font>。接收窗也只有接收到数据且最左侧连续时才移动接收窗口。<hr><hr>tcp::83、建立TCP服务器的各个系统调用过程是怎样的？<br>&emsp;&emsp;<br>&emsp;&emsp;todo 好长<hr>![](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220023934.png)<br>&emsp;&emsp;<br>&emsp;&emsp;![](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220023348.png)<br>&emsp;&emsp;<br>&emsp;&emsp;- 服务器：<br>&emsp;&emsp;<br>&emsp;&emsp;  - 创建socket -> int socket(int domain, int type, int protocol);<br>&emsp;&emsp;<br>&emsp;&emsp;    - domain：协议域，决定了socket的地址类型，IPv4为AF_INET。<br>&emsp;&emsp;<br>&emsp;&emsp;    - type：指定socket类型，SOCK_STREAM为TCP连接。<br>&emsp;&emsp;<br>&emsp;&emsp;    - protocol：指定协议。IPPROTO_TCP表示TCP协议，为0时自动选择type默认协议。<br>&emsp;&emsp;<br>&emsp;&emsp;  - 绑定socket和端口号 -> int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);<br>&emsp;&emsp;<br>&emsp;&emsp;    - sockfd：socket返回的套接字描述符，类似于文件描述符fd。<br>&emsp;&emsp;<br>&emsp;&emsp;    - addr：有个sockaddr类型数据的指针，指向的是被绑定结构变量。<br>&emsp;&emsp;<br>&emsp;&emsp;    ```C++<br>&emsp;&emsp;        // IPv4的sockaddr地址结构<br>&emsp;&emsp;        struct sockaddr_in {<br>&emsp;&emsp;            sa_family_t sin_family;    // 协议类型，AF_INET<br>&emsp;&emsp;            in_port_t sin_port;    // 端口号<br>&emsp;&emsp;            struct in_addr sin_addr;    // IP地址<br>&emsp;&emsp;        };<br>&emsp;&emsp;        struct in_addr {<br>&emsp;&emsp;            uint32_t s_addr;<br>&emsp;&emsp;        }<br>&emsp;&emsp;    ```<br>&emsp;&emsp;<br>&emsp;&emsp;    - addrlen：地址长度。<br>&emsp;&emsp;<br>&emsp;&emsp;  - 监听端口号 -> int listen(int sockfd, int backlog);<br>&emsp;&emsp;<br>&emsp;&emsp;    - sockfd：要监听的sock描述字。<br>&emsp;&emsp;<br>&emsp;&emsp;    - backlog：socket可以排队的最大连接数。<br>&emsp;&emsp;<br>&emsp;&emsp;  - 接收用户请求 -> int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);<br>&emsp;&emsp;<br>&emsp;&emsp;    - sockfd：服务器socket描述字。<br>&emsp;&emsp;<br>&emsp;&emsp;    - addr：指向地址结构指针。<br>&emsp;&emsp;<br>&emsp;&emsp;    - addrlen：协议地址长度。<br>&emsp;&emsp;<br>&emsp;&emsp;    - 注：一旦accept某个客户机请求成功将返回一个全新的描述符用于标识具体客户的TCP连接。<br>&emsp;&emsp;<br>&emsp;&emsp;  - 从socket中读取字符 -> ssize_t read(int fd, void *buf, size_t count);<br>&emsp;&emsp;<br>&emsp;&emsp;    - fd：连接描述字。<br>&emsp;&emsp;<br>&emsp;&emsp;    - buf：缓冲区buf。<br>&emsp;&emsp;<br>&emsp;&emsp;    - count：缓冲区长度。<br>&emsp;&emsp;<br>&emsp;&emsp;    - 注：大于0表示读取的字节数，返回0表示文件读取结束，小于0表示发生错误。<br>&emsp;&emsp;<br>&emsp;&emsp;  - 关闭socket -> int close(int fd);<br>&emsp;&emsp;<br>&emsp;&emsp;    - fd：accept返回的连接描述字，每个连接有一个，生命周期为连接周期。<br>&emsp;&emsp;<br>&emsp;&emsp;    - 注：sockfd是监听描述字，一个服务器只有一个，用于监听是否有连接；fd是连接描述字，用于每个连接的操作。<br>&emsp;&emsp;<br>&emsp;&emsp;- 客户机：<br>&emsp;&emsp;<br>&emsp;&emsp;  - 创建socket -> int socket(int domain, int type, int protocol);<br>&emsp;&emsp;<br>&emsp;&emsp;  - 连接指定计算机 -> int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen);<br>&emsp;&emsp;    - sockfd客户端的sock描述字。<br>&emsp;&emsp;<br>&emsp;&emsp;    - addr：服务器的地址。<br>&emsp;&emsp;<br>&emsp;&emsp;    - addrlen：socket地址长度。<br>&emsp;&emsp;<br>&emsp;&emsp;  - 向socket写入信息 -> ssize_t write(int fd, const void *buf, size_t count);<br>&emsp;&emsp;    - fd、buf、count：同read中意义。<br>&emsp;&emsp;<br>&emsp;&emsp;    - 大于0表示写了部分或全部数据，小于0表示出错。<br>&emsp;&emsp;<br>&emsp;&emsp;  - 关闭oscket -> int close(int fd);<br>&emsp;&emsp;    - fd：同服务器端fd。<hr><hr>tcp::如果已经建立了连接，但是服务端的进程崩溃会发生什么？<hr>kill-9 server的话, server 会启动四次挥手机制<hr><hr>tcp::补充题：<font color=#FEAE00>封包和拆包</font>你听说过吗？TCP / UDP?<hr>封包和拆包都是基于TCP的概念。因为TCP是<font color=#FEAE00>无边界的流传输</font>，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。<br>&emsp;&emsp;<br>&emsp;&emsp;* <font color=#FEAE00>封包</font>：封包就是在发送数据报的时候为每个<font color=#FEAE00>TCP</font><font color=#FEAE00>数据包加上一个包头</font>，将数据报分为<font color=#FEAE00>包头和包体两个部分</font>。包头是一个固定长度的结构体，里面包含该数据包的总长度。<br>&emsp;&emsp;* 拆包：接收方在接收到报文后<font color=#FEAE00>提取包头中的长度信息进行截取</font>。<hr><hr>tcp挥手:: 103、服务器出现大量close_wait的连接的原因是什么？有什么解决方法？<hr>close_wait状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量close_wait状态的原因有两种：<br>&emsp;&emsp;<br>&emsp;&emsp;* 服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法<br>&emsp;&emsp;* 服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收<br>&emsp;&emsp;<br>&emsp;&emsp;处理方法：<br>&emsp;&emsp;<br>&emsp;&emsp;* 停止应用程序<br>&emsp;&emsp;* 修改程序里的bug<hr><hr>tcp挥手::客户端调用 <font color=#FEAE00>close</font> 了，连接是断开的流程是什么？<hr>- 客户端调用 <font color=#FEAE00>close</font>，表明客户端没有数据需要发送了，则此时会向服务端发送 <font color=#FEAE00>FIN</font> 报文，进入 FIN_WAIT_1 状态；<br>&emsp;&emsp;- 服务端接收到了 FIN 报文，TCP 协议栈会为 <font color=#FEAE00>FIN </font><font color=#FEAE00>包插入一个文件结束符</font><font color=#FEAE00> EOF </font><font color=#FEAE00>到接收缓冲区中</font>，应用程序可以通过 read 调用<font color=#FEAE00>来感知这个</font><font color=#FEAE00> FIN </font><font color=#FEAE00>包</font>。这个 <font color=#FEAE00>EOF </font><font color=#FEAE00>会被放在已排队等候的其他已接收的数据之后</font>，这就意味着<font color=#FEAE00>服务端需要处理这种异常情况</font>，因为 EOF 表示在该连接上再无额外数据到达。此时，服务端进入 CLOSE_WAIT 状态；<br>&emsp;&emsp;- 接着，当处理完数据后，自然就会<font color=#FEAE00>读到</font><font color=#FEAE00> EOF</font><font color=#FEAE00>，于是也调用</font><font color=#FEAE00> close </font><font color=#FEAE00>关闭它的套接字</font>，这会使得服务端发出一个 FIN 包，之后处于 LAST_ACK 状态；<br>&emsp;&emsp;- 客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；<br>&emsp;&emsp;- 服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；<br>&emsp;&emsp;- 客户端经过 2MSL 时间之后，也进入 CLOSE 状态；<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;<hr><hr>一个数据包臭不要脸的感受<hr>下面内容的 「我」，代表「臭美的数据包角色」。注：（括号的内容）代表我的吐槽，三连呸！<br>&emsp;&emsp;我一开始我虽然孤单、不知所措，但没有停滞不前。我依然满怀信心和勇气开始了征途。（<font color=#FEAE00>你当然有勇气，你是应用层数据，后面有底层兄弟当靠山，我呸！</font><font color=#FEAE00>）</font><br>&emsp;&emsp;我很庆幸遇到了各路神通广大的大佬，有可靠传输的 TCP、有远程定位功能的 IP、有指明下一站位置的 MAC 等（<font color=#FEAE00>你当然会遇到，因为都被计算机安排好的，我呸！</font><font color=#FEAE00>）。</font><br>&emsp;&emsp;这些大佬都给我前面加上了头部，使得我能在交换机和路由器的转发下，抵达到了目的地！（<font color=#FEAE00>哎，你也不容易，不吐槽了，放过你！</font>）<br>&emsp;&emsp;这一路上的经历，让我认识到了网络世界中各路大侠协作的重要性，是他们维护了网络世界的秩序，感谢他们！（<font color=#FEAE00>我呸，你应该感谢众多计算机科学家！</font><font color=#FEAE00>）</font><br>&emsp;&emsp;<font color=#5478F6><br>&emsp;&emsp;</font>读者问答<br>&emsp;&emsp;读者问：“<font color=#FEAE00>笔记本的是自带交换机的吗</font>？交换机现在我还不知道是什么”<br>&emsp;&emsp;笔记本不是交换机，<font color=#FEAE00>交换机通常是</font><font color=#FEAE00>2</font><font color=#FEAE00>个网口以上。</font><br>&emsp;&emsp;现在家里的<font color=#FEAE00>路由器其实有了交换机</font>的功能了。交换机可以简单理解成一个设备，三台电脑网线接到这个设备，这三台电脑就可以互相通信了，交换机嘛，交换数据这么理解就可以。<br>&emsp;&emsp;读者问：“如果知道你电脑的mac地址，我可以直接给你发消息吗？”<br>&emsp;&emsp;Mac地址只能是两个设备之间传递时使用的，如果你要从大老远给我发消息，是离不开 IP 的。<br>&emsp;&emsp;读者问：“请问<font color=#FEAE00>公网服务器的</font><font color=#FEAE00> Mac </font><font color=#FEAE00>地址</font>是在什么时机通过什么方式获取到的？我看 arp 获取Mac地址只能获取到内网机器的 Mac 地址吧？”<br>&emsp;&emsp;在发送数据包时，如果目标主机不是本地局域网，填入的MAC地址是路由器，也就是把数据包转发给路由器，路由器一直转发下一个路由器，直到转发到目标主机的路由器，发现 IP 地址是自己局域网内的主机，就会 arp 请求获取目标主机的 MAC 地址，从而转发到这个服务器主机。<br>&emsp;&emsp;转发的过程中，源IP地址和目标IP地址是不会变的（<font color=#FEAE00>前提：没有使用</font><font color=#FEAE00> NAT </font><font color=#FEAE00>网络的</font>），源 MAC 地址和目标 MAC 地址是会变化的。<hr><hr>七层.0:: 七层 /  五层 / 四层模型？ 作用 & 协议<hr>物理层: 底层数据传输标准, 网线, 网卡等<br>&emsp;&emsp;	PAM5, EIA422 等网线 [比特流 bits]<br>&emsp;&emsp;数据链路层: 链路管理, 和 介质访问 标识 MAC地址<br>&emsp;&emsp;	ARP RARP  [帧 frames] <br>&emsp;&emsp;网络层: IP地址, 路由功能, 不同设备的数据转发<br>&emsp;&emsp;	IP, ICMP, RIP, IGMP [包 Packages]<br>&emsp;&emsp;传输层: 端到端数据传输功能<br>&emsp;&emsp;	TCP, UDP [段 segments]<br>&emsp;&emsp;会话层: 建立 管理 维护 会话 `session认证, 断点续传等` 数据的分发<br>&emsp;&emsp;	FTP, HTTP, DNS, Telnet, SMTP, HTTPS, TLS 等<br>&emsp;&emsp;表示层: 数据格式标识, 压缩加密等功能<br>&emsp;&emsp;应用层: 各种应用软件, web应用等<br>&emsp;&emsp;<br>&emsp;&emsp;最上面三层合并 -> 五层模型<br>&emsp;&emsp;最下面两层合并 -> 三层模型<hr><hr>七层.0::分成 七层 / 五层 / 四层的好处 ?<hr>ARPANET 的研制经验表明，对于复杂的计算机网络协议，其<font color=#FEAE00>结构应该是层次式</font>的。<br>&emsp;&emsp;好处: <br>&emsp;&emsp;①各层之间是<font color=#FEAE00>独立</font>的<br>&emsp;&emsp;②<font color=#FEAE00>灵活性好</font><br>&emsp;&emsp;③结构上可以<font color=#FEAE00>分隔开</font><font color=#FEAE00>, </font><font color=#FEAE00>耦合性小</font><br>&emsp;&emsp;④<font color=#FEAE00>易于实现</font>和<font color=#FEAE00>维护</font><br>&emsp;&emsp;⑤能促进<font color=#FEAE00>标准化工作</font>。<hr><hr>七层.1:: 90、<font color=#FEAE00>数据链路层</font>常见协议？可以说一下吗？<hr>| 协议 | 名称             | 作用                                                         |<br>&emsp;&emsp;| ---- | ---------------- | ------------------------------------------------------------ |<br>&emsp;&emsp;| <font color=#FEAE00>ARP</font>  | <font color=#FEAE00>地址解析</font>协议     | 根据IP地址获取物理地址                                       |<br>&emsp;&emsp;| <font color=#FEAE00>RARP</font> | <font color=#FEAE00>反向地址转换</font>协议 | 根据物理地址获取IP地址                                       |<br>&emsp;&emsp;| <font color=#FEAE00>PPP</font>  | <font color=#FEAE00>点对点协议</font><font color=#FEAE00> </font>      | 主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案 |<hr><hr>七层.1::53、应用层常见协议知道多少？了解几个？<br>&emsp;&emsp;<hr><font color=#FEAE00>HTTPS HTTP Telnet FTP TFTP SMTP POP DNS</font><br>&emsp;&emsp;| 协议   | 名称                       | 默认端口       | 底层协议                                                     |<br>&emsp;&emsp;| HTTP   | 超文本传输协议             | 80             | TCP                                                          |<br>&emsp;&emsp;| HTTPS  | 超文本传输安全协议         | 443            | TCP                                                          |<br>&emsp;&emsp;| Telnet | 远程登录服务的标准协议     | 23             | TCP                                                          |<br>&emsp;&emsp;| FTP    | 文件传输协议               | 20传输和21连接 | TCP                                                          |<br>&emsp;&emsp;| TFTP   | 简单文件传输协议           | 69             | UDP                                                          |<br>&emsp;&emsp;| SMTP   | 简单邮件传输协议（发送用） | 25             | TCP                                                          |<br>&emsp;&emsp;| POP    | 邮局协议（接收用）         | 110            | TCP                                                          |<br>&emsp;&emsp;| DNS    | 域名解析服务               | 53             | 服务器间进行域传输的时候用TCP<br />客户端查询DNS服务器时用 UDP |<br>&emsp;&emsp;<br>&emsp;&emsp;>感谢网友勘误”TFTP简单文件传输协议 初始默认端口号69“，已修正，2021.10.12[https://github.com/forthespada/InterviewGuide/issues/13](https://github.com/forthespada/InterviewGuide/issues/13)<hr><hr>七层.1::78、网络层常见协议？可以说一下吗？<br>&emsp;&emsp;<br>&emsp;&emsp;todo 整理下<hr>| 协议 | 名称                 | 作用                                                         |<br>&emsp;&emsp;| ---- | -------------------- | ------------------------------------------------------------ |<br>&emsp;&emsp;* | IP   | <br>&emsp;&emsp;	* 网际协议        <br>&emsp;&emsp;	* IP协议不但定义了数据传输时的基本单元和格式，还定义了数据报的递交方法和路由选择<br>&emsp;&emsp;* | ICMP | <br>&emsp;&emsp;	* Internet控制报文协议 | <br>&emsp;&emsp;	* ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性，是ping和traceroute的工作协议<br>&emsp;&emsp;* | RIP  | <br>&emsp;&emsp;	* 路由信息协议 <br>&emsp;&emsp;	* 使用“跳数”(即metric)来衡量到达目标地址的路由距离<br>&emsp;&emsp;* IGMP <br>&emsp;&emsp;	* Internet组管理协议 <br>&emsp;&emsp;	* 用于实现组播、广播等通信                                     |<hr><hr>两点传输 —— MAC<br>&emsp;&emsp;- MAC 包头格式<br>&emsp;&emsp;- MAC 发送方和接收方如何确认<br>&emsp;&emsp;- 既然知道要发给谁，按如何获取对方的 MAC 地址呢？<br>&emsp;&emsp;- 好像每次都要广播获取，这不是很麻烦吗？<br>&emsp;&emsp;- 如何查看 ARP 缓存内容<hr>生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 <font color=#FEAE00>MAC </font><font color=#FEAE00>头部</font><font color=#FEAE00>。</font><br>&emsp;&emsp;# MAC 包头格式<br>&emsp;&emsp;MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。<br>&emsp;&emsp;￼<br>&emsp;&emsp;在 MAC 包头里需要<font color=#FEAE00>发送方</font><font color=#FEAE00> MAC </font><font color=#FEAE00>地址</font><font color=#FEAE00>和</font><font color=#FEAE00>接收方目标</font><font color=#FEAE00> MAC </font><font color=#FEAE00>地址</font>，用于<font color=#FEAE00>两点之间的传输</font>。<br>&emsp;&emsp;一般在 TCP/IP 通信里，MAC 包头的<font color=#FEAE00>协议类型</font>只使用：<br>&emsp;&emsp;<font color=#4D647F>	•	</font><font color=#4D647F>0800</font> ： IP 协议<br>&emsp;&emsp;<font color=#4D647F>	•	</font><font color=#4D647F>0806</font> ： ARP 协议<br>&emsp;&emsp;# MAC 发送方和接收方如何确认?<br>&emsp;&emsp;<font color=#FEAE00>发送方</font>的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。<br>&emsp;&emsp;<font color=#FEAE00>接收方</font>的 MAC 地址就有点复杂了，只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址。<br>&emsp;&emsp;所以先得搞清楚应该把包发给谁，这个只要查一下<font color=#FEAE00>路由表</font>就知道了。在路由表中找到相匹配的条目，然后把包<font color=#FEAE00>发给</font><font color=#FEAE00> Gateway </font><font color=#FEAE00>列中的</font><font color=#FEAE00> IP </font><font color=#FEAE00>地址就可以了。</font><br>&emsp;&emsp;# 既然知道要发给谁，按如何获取对方的 MAC 地址呢？<br>&emsp;&emsp;不知道对方 MAC 地址？不知道就喊呗。<br>&emsp;&emsp;此时就需要 <font color=#FEAE00>ARP</font> 协议帮我们找到路由器的 MAC 地址。<br>&emsp;&emsp;￼<br>&emsp;&emsp;ARP 协议会在以太网中以<font color=#FEAE00>广播</font>的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。<br>&emsp;&emsp;然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。<br>&emsp;&emsp;如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了。<br>&emsp;&emsp;# 好像每次都要广播获取，这不是很麻烦吗？<br>&emsp;&emsp;放心，在后续操作系统会把本次查询结果放到一块叫做 <font color=#FEAE00>ARP </font><font color=#FEAE00>缓存</font>的内存空间留着以后用，不过缓存的时间就几分钟。<br>&emsp;&emsp;也就是说，在发包时：<br>&emsp;&emsp;	•	先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。<br>&emsp;&emsp;	•	而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。<br>&emsp;&emsp;# 查看 ARP 缓存内容<br>&emsp;&emsp;在 Linux 系统中，我们可以使用 <font color=#FEAE00>arp -a </font>命令来查看 ARP 缓存的内容。<br>&emsp;&emsp;￼<br>&emsp;&emsp;MAC 报文生成<br>&emsp;&emsp;至此，网络包的报文如下图。<br>&emsp;&emsp;￼<br>&emsp;&emsp;此时，加上了 MAC 头部的数据包万分感谢，说道 ：“感谢 MAC 大佬，我知道我下一步要去哪了！我现在有很多头部兄弟，相信我可以到达最终的目的地！”。 带着众多头部兄弟的数据包，终于准备要出门了。<hr><hr><font color=#FEAE00>互相扒皮</font><font color=#FEAE00> </font>—— 服务器 与 客户端<hr>	数据包抵达了服务器，服务器肯定高兴呀，正所谓有朋自远方来，不亦乐乎？<br>&emsp;&emsp;	服务器高兴的不得了，于是<font color=#FEAE00>开始扒数据包的皮！</font>就好像你收到快递，能不兴奋吗？<br>&emsp;&emsp;￼<br>&emsp;&emsp;	数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。<br>&emsp;&emsp;	接着继续扒开数据包的 IP 头，<font color=#FEAE00>发现</font><font color=#FEAE00> IP </font><font color=#FEAE00>地址符合</font>，根据 IP 头中协议项，知道自己<font color=#FEAE00>上层是</font><font color=#FEAE00> TCP </font><font color=#FEAE00>协议。</font><br>&emsp;&emsp;	于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。<br>&emsp;&emsp;	于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。<br>&emsp;&emsp;	服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。<br>&emsp;&emsp;	HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。<br>&emsp;&emsp;	穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。<br>&emsp;&emsp;	最后跳到了<font color=#FEAE00>客户端的城门把守的路由器</font>，路由器扒开 IP 头部发现是要找城内的人，于是又把包发给了城内的交换机，再由交换机转发到客户端。<br>&emsp;&emsp;	客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！<br>&emsp;&emsp;	于是，客户端开始扒皮，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！<br>&emsp;&emsp;	最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。<hr><hr>出口 —— 网卡<br>&emsp;&emsp;- 二进制数字转换成电信号<br>&emsp;&emsp;- 复制到网卡的缓存区中<br>&emsp;&emsp;-<hr>	网络包只是存放在内存中的<font color=#FEAE00>一串二进制数字</font>信息，没有办法直接发送给对方。因此，我们需要将<font color=#FEAE00>数字信息转换为电信号</font>，才能在网线上传输，也就是说，这才是真正的数据发送过程。<br>&emsp;&emsp;	负责执行这一操作的是<font color=#FEAE00>网卡</font>，要控制网卡还需要靠<font color=#FEAE00>网卡驱动程序</font>。<br>&emsp;&emsp;	网卡驱动获取网络包之后，会将其<font color=#FEAE00>复制</font>到网卡内的缓存区中，接着会在其<font color=#FEAE00>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</font><font color=#FEAE00>。</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;	•	<font color=#FEAE00>起始帧分界符</font>是一个用来表示包起始位置的标记<br>&emsp;&emsp;	•	末尾的 <font color=#FEAE00>FCS</font><font color=#FEAE00>（帧校验序列）</font>用来检查包传输过程是否有损坏<br>&emsp;&emsp;	最后网卡会将包转为电信号，通过网线发送出去。<br>&emsp;&emsp;	唉，真是不容易，发一个包，真是历经千辛万苦。致此，一个带有许多头部的数据终于踏上寻找目的地的征途了！<hr><hr>出境大门 —— 路由器<br>&emsp;&emsp;-  路由器与交换机的区别<br>&emsp;&emsp;- 路由器的基本原理<br>&emsp;&emsp;- 路由器的包接收操作<br>&emsp;&emsp;- 查询路由表确定输出端口<br>&emsp;&emsp;- 路由器的发送操作<hr># 路由器与交换机的区别<br>&emsp;&emsp;	网络包经过交换机之后，现在到达了<font color=#FEAE00>路由器</font>，并在此被转发到下一个路由器或目标设备。<br>&emsp;&emsp;	这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。<br>&emsp;&emsp;	不过在具体的操作过程上，路由器和交换机是有区别的。<br>&emsp;&emsp;	•	因为<font color=#FEAE00>路由器</font>是基于 IP 设计的，俗称<font color=#FEAE00>三层</font>网络设备，路由器的<font color=#FEAE00>各个端口都具有</font><font color=#FEAE00> MAC </font><font color=#FEAE00>地址和</font><font color=#FEAE00> IP </font><font color=#FEAE00>地址；</font><br>&emsp;&emsp;	•	而<font color=#FEAE00>交换机</font>是基于以太网设计的，俗称<font color=#FEAE00>二层</font>网络设备，<font color=#FEAE00>交换机的端口不具有</font><font color=#FEAE00> MAC </font><font color=#FEAE00>地址。</font><br>&emsp;&emsp;# 路由器基本原理<br>&emsp;&emsp;	路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。<br>&emsp;&emsp;	当转发包时，首先路由器端口会接收发给自己的以太网包，然后<font color=#FEAE00>路由表</font>查询转发目标，再由相应的端口作为发送方将以太网包发送出去。<br>&emsp;&emsp;# 路由器的包接收操作<br>&emsp;&emsp;	首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 <font color=#4D647F>FCS</font> 进行错误校验。<br>&emsp;&emsp;	如果没问题则检查 MAC 头部中的<font color=#FEAE00>接收方</font><font color=#FEAE00> MAC </font><font color=#FEAE00>地址</font>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。<br>&emsp;&emsp;	总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。<br>&emsp;&emsp;# 查询路由表确定输出端口<br>&emsp;&emsp;	完成包接收操作之后，路由器就会<font color=#FEAE00>去掉</font>包开头的 MAC 头部。<br>&emsp;&emsp;	<font color=#FEAE00>MAC </font><font color=#FEAE00>头部的作用就是将包送达路由器</font>，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会<font color=#FEAE00>被丢弃</font>。<br>&emsp;&emsp;	接下来，路由器会根据 MAC 头部后方的 <font color=#4D647F>IP</font> 头部中的内容进行包的转发操作。<br>&emsp;&emsp;	转发操作分为几个阶段，首先是查询<font color=#FEAE00>路由表</font>判断转发目标。<br>&emsp;&emsp;￼<br>&emsp;&emsp;	具体的工作流程根据上图，举个例子。<br>&emsp;&emsp;	假设地址为 <font color=#4D647F>10.10.1.101</font> 的计算机要向地址为 <font color=#4D647F>192.168.1.100</font> 的服务器发送一个包，这个包先到达图中的路由器。<br>&emsp;&emsp;	判断转发目标的第一步，就是根据包的接收方 IP 地址查询路由表中的目标地址栏，以找到相匹配的记录。<br>&emsp;&emsp;	路由匹配和前面讲的一样，每个条目的子网掩码和 <font color=#4D647F>192.168.1.100</font> IP 做 <font color=#FEAE00>& </font><font color=#FEAE00>与运算</font>后，得到的结果与对应条目的目标地址进行匹配，如果匹配就会作为候选转发目标，如果不匹配就继续与下个条目进行路由匹配。<br>&emsp;&emsp;	如第二条目的子网掩码 <font color=#4D647F>255.255.255.0</font> 与 <font color=#4D647F>192.168.1.100</font> IP 做<font color=#FEAE00> </font><font color=#FEAE00>& </font><font color=#FEAE00>与运算</font>后，得到结果是 <font color=#4D647F>192.168.1.0</font> ，这与第二条目的目标地址 <font color=#4D647F>192.168.1.0</font> 匹配，该第二条目记录就会被作为转发目标。<br>&emsp;&emsp;	实在找不到匹配路由时，就会选择<font color=#FEAE00>默认路由</font><font color=#FEAE00>，</font>路由表中子网掩码为 <font color=#4D647F>0.0.0.0</font> 的记录表示「默认路由」。<br>&emsp;&emsp;# 路由器的发送操作<br>&emsp;&emsp;	接下来就会进入包的<font color=#FEAE00>发送操作</font><font color=#FEAE00>。</font><br>&emsp;&emsp;	首先，我们需要根据<font color=#FEAE00>路由表的网关列</font>判断对方的地址。<br>&emsp;&emsp;	•	如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，<font color=#FEAE00>还未抵达终点</font>，还需继续需要路由器转发。<br>&emsp;&emsp;	•	如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明<font color=#FEAE00>已抵达终点</font><font color=#FEAE00>。</font><br>&emsp;&emsp;	知道对方的 IP 地址之后，接下来需要通过 <font color=#4D647F>ARP</font> 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。<br>&emsp;&emsp;	路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。<br>&emsp;&emsp;	接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 <font color=#4D647F>0800</font> （十六进制）表示 IP 协议。<br>&emsp;&emsp;	网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。<br>&emsp;&emsp;	发送出去的网络包会通过<font color=#FEAE00>交换机</font><font color=#FEAE00>到</font>达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。<br>&emsp;&emsp;	接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。<br>&emsp;&emsp;	不知你发现了没有，在网络包传输的过程中，<font color=#FEAE00>源</font><font color=#FEAE00> IP </font><font color=#FEAE00>和目标</font><font color=#FEAE00> IP </font><font color=#FEAE00>始终是不会变的，一直变化的是</font><font color=#FEAE00> MAC </font><font color=#FEAE00>地址</font>，因为需要<font color=#FEAE00> MAC </font><font color=#FEAE00>地址在以太网内进行</font><font color=#FEAE00>两个设备</font><font color=#FEAE00>之间的包传输。</font><br>&emsp;&emsp;	数据包通过多个路由器道友的帮助，在网络世界途经了很多路程，最终抵达了目的地的城门！城门值守的路由器，发现了这个小兄弟数据包原来是找城内的人，于是它就将数据包送进了城内，再<font color=#FEAE00>经由城内的交换机帮助下</font>，最终转发到了目的地了。数据包感慨万千的说道：“多谢这一路上，各路大侠的相助！”<hr><hr>可靠传输 —— TCP<br>&emsp;&emsp;- TCP 报头格式<br>&emsp;&emsp;- 三次握手过程? <br>&emsp;&emsp;- 如何查看 TCP 的连接状态？<br>&emsp;&emsp;- TCP 分割数据<br>&emsp;&emsp;-  <font color=#FEAE00>TCP </font><font color=#FEAE00>报文生成</font><hr>HTTP 是基于 TCP 协议传输的，所以在这我们先<font color=#FEAE00>了解下</font><font color=#FEAE00> TCP </font><font color=#FEAE00>协议</font>。<br>&emsp;&emsp;TCP 包头格式<br>&emsp;&emsp;我们先看看 TCP 报文头部的格式：<br>&emsp;&emsp;￼<br>&emsp;&emsp;首先，<font color=#FEAE00>源端口号</font><font color=#FEAE00>和</font><font color=#FEAE00>目标端口</font>号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。<br>&emsp;&emsp;接下来有包的<font color=#FEAE00>序</font><font color=#FEAE00>号</font>，这个是为了解决包乱序的问题。<br>&emsp;&emsp;还有应该有的是<font color=#FEAE00>确认号</font>，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决不丢包的问题。<br>&emsp;&emsp;接下来还有一些<font color=#FEAE00>状态位</font>。例如 <font color=#4D647F>SYN</font> 是发起一个连接，<font color=#4D647F>ACK</font> 是回复，<font color=#4D647F>RST</font> 是重新连接，<font color=#4D647F>FIN</font> 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。<br>&emsp;&emsp;还有一个重要的就是<font color=#FEAE00>窗口大小</font>。TCP <font color=#FEAE00>要做</font><font color=#FEAE00>流量控制</font>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。<br>&emsp;&emsp;除了做流量控制以外，TCP还会做<font color=#FEAE00>拥塞控制</font><font color=#FEAE00>，</font>对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。<br>&emsp;&emsp;TCP 传输数据之前，要先三次握手建立连接<br>&emsp;&emsp;在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为<font color=#FEAE00>三次握手</font>。<br>&emsp;&emsp;这个所谓的「连接」，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。<br>&emsp;&emsp;￼<br>&emsp;&emsp;	•	一开始，客户端和服务端都处于 <font color=#4D647F>CLOSED</font> 状态。先是服务端主动监听某个端口，处于 <font color=#4D647F>LISTEN</font> 状态。<br>&emsp;&emsp;	•	然后客户端主动发起连接 <font color=#4D647F>SYN</font>，之后处于 <font color=#4D647F>SYN-SENT</font> 状态。<br>&emsp;&emsp;	•	服务端收到发起的连接，返回 <font color=#4D647F>SYN</font>，并且 <font color=#4D647F>ACK</font> 客户端的 <font color=#4D647F>SYN</font>，之后处于 <font color=#4D647F>SYN-RCVD</font> 状态。<br>&emsp;&emsp;	•	客户端收到服务端发送的 <font color=#4D647F>SYN</font> 和 <font color=#4D647F>ACK</font> 之后，发送对 <font color=#4D647F>SYN</font> 确认的 <font color=#4D647F>ACK</font>，之后处于 <font color=#4D647F>ESTABLISHED</font> 状态，因为它一发一收成功了。<br>&emsp;&emsp;	•	服务端收到 <font color=#4D647F>ACK</font> 的 <font color=#4D647F>ACK</font> 之后，处于 <font color=#4D647F>ESTABLISHED</font> 状态，因为它也一发一收了。<br>&emsp;&emsp;所以三次握手目的是<font color=#FEAE00>保证双方都有发送和接收的能力</font>。<br>&emsp;&emsp;# 如何查看 TCP 的连接状态？<br>&emsp;&emsp;TCP 的连接状态查看，在 Linux 可以通过 <font color=#FEAE00>netstat -napt</font> 命令查看。<br>&emsp;&emsp;￼<br>&emsp;&emsp;# TCP 分割数据<br>&emsp;&emsp;如果 HTTP 请求消息比较长，<font color=#FEAE00>超过了</font><font color=#FEAE00> MSS </font><font color=#FEAE00>的长度</font>，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。<br>&emsp;&emsp;￼<br>&emsp;&emsp;<font color=#4D647F>	•	</font><font color=#FEAE00>MTU</font>：一个网络包的最大长度，以太网中一般为 <font color=#4D647F>1500</font> 字节。<br>&emsp;&emsp;<font color=#4D647F>	•	</font><font color=#FEAE00>MSS</font>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。<br>&emsp;&emsp;数据会被以 <font color=#4D647F>MSS</font> 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。<br>&emsp;&emsp;￼<br>&emsp;&emsp;# <font color=#FEAE00>TCP </font><font color=#FEAE00>报文生成</font><br>&emsp;&emsp;TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 <font color=#4D647F>80</font>， HTTPS 默认端口号是 <font color=#4D647F>443</font>）。<br>&emsp;&emsp;在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，<font color=#FEAE00>就需交给下面的网络层处理。</font><font color=#FEAE00><br>&emsp;&emsp;</font><font color=#FEAE00>至此，网络包的报文如下图。</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;此时，遇上了 TCP 的 数据包激动表示：“太好了，碰到了可靠传输的 TCP 传输，它给我加上 TCP 头部，我不再孤单了，安全感十足啊！有大佬可以保护我的可靠送达！但我应该往哪走呢？”<hr><hr>指南好帮手 —— 协议栈<br>&emsp;&emsp;协议栈有哪几层?<hr>通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的<font color=#FEAE00>协议栈</font>。<br>&emsp;&emsp;协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。<br>&emsp;&emsp;￼<br>&emsp;&emsp;应用程序（浏览器）<font color=#FEAE00>通过调用</font><font color=#FEAE00> Socket </font><font color=#FEAE00>库</font>，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 <font color=#FEAE00>TCP </font><font color=#FEAE00>和</font><font color=#FEAE00> UDP </font><font color=#FEAE00>协议</font>，这两个传输协议会接受应用层的委托执行收发数据的操作。<br>&emsp;&emsp;协议栈的下面一半是<font color=#FEAE00>用</font><font color=#FEAE00> IP </font><font color=#FEAE00>协议控制网络包收发操作</font>，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。<br>&emsp;&emsp;此外 IP 中还包括 <font color=#FEAE00>ICMP </font><font color=#FEAE00>协议和</font><font color=#FEAE00> ARP </font><font color=#FEAE00>协议。</font><br>&emsp;&emsp;<font color=#4D647F>	•	</font><font color=#4D647F>ICMP</font> 用于告知网络包传送过程中产生的<font color=#FEAE00>错误以及各种控制信息</font>。<br>&emsp;&emsp;<font color=#4D647F>	•	</font><font color=#4D647F>ARP</font> 用于根据 IP 地址查询相应的以太网 MAC 地址。<br>&emsp;&emsp;IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。<br>&emsp;&emsp;数据包看了这份指南表示：“原来我需要那么多大佬的协助啊，那我先去找找 TCP 大佬！”<hr><hr>真实地址查询 —— DNS<br>&emsp;&emsp;- DNS 分层有哪些? <br>&emsp;&emsp;- 过程? <br>&emsp;&emsp;- 解析过程?<br>&emsp;&emsp;- 浏览器输入地址后查询过程?<hr>过浏览器解析 URL 并<font color=#FEAE00>生成</font><font color=#FEAE00> HTTP </font><font color=#FEAE00>消息后</font>，需要委托操作系统将消息发送给 <font color=#4D647F>Web</font> 服务器。<br>&emsp;&emsp;但在发送之前，还有一项工作需要完成，那就是<font color=#FEAE00>查询服务器域名对应的</font><font color=#FEAE00> IP </font><font color=#FEAE00>地址</font>，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。<br>&emsp;&emsp;比如我们打电话的时候，必须要知道对方的电话号码，但由于电话号码难以记忆，所以通常我们会将对方电话号 + 姓名保存在通讯录里。<br>&emsp;&emsp;所以，有一种服务器就专门保存了 <font color=#4D647F>Web</font> 服务器域名与 <font color=#4D647F>IP</font> 的对应关系，它就是 <font color=#4D647F>DNS</font> 服务器。<br>&emsp;&emsp;域名的层级关系<br>&emsp;&emsp;DNS 中的域名都是用<font color=#FEAE00>句点</font>来分隔的，比如 <font color=#4D647F>www.server.com</font>，这里的句点代表了不同层次之间的<font color=#FEAE00>界限</font>。<br>&emsp;&emsp;在域名中，<font color=#FEAE00>越靠右</font>的位置表示其层级<font color=#FEAE00>越高</font>。<br>&emsp;&emsp;毕竟域名是外国人发明，所以思维和中国人相反，比如说一个城市地点的时候，外国喜欢从小到大的方式顺序说起（如 XX 街道 XX 区 XX 市 XX 省），而中国则喜欢从大到小的顺序（如 XX 省 XX 市 XX 区 XX 街道）。<br>&emsp;&emsp;实际上域名最后还有一个点，比如 <font color=#4D647F>www.server.com.</font>，这个最后的一个点代表根域名。<br>&emsp;&emsp;也就是，<font color=#4D647F>.</font> 根域是在最顶层，它的下一层就是 <font color=#4D647F>.com</font> 顶级域，再下面是 <font color=#4D647F>server.com</font>。<br>&emsp;&emsp;所以域名的层级关系<font color=#FEAE00>类似一个树状结构</font>：<br>&emsp;&emsp;	•	<font color=#FEAE00>根</font> DNS 服务器（.）<br>&emsp;&emsp;	•	<font color=#FEAE00>顶级域</font> DNS 服务器（.com）<br>&emsp;&emsp;	•	<font color=#FEAE00>权威</font><font color=#FEAE00> </font>DNS 服务器（server.com）<br>&emsp;&emsp;￼<br>&emsp;&emsp;根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。<br>&emsp;&emsp;这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。<br>&emsp;&emsp;因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。<br>&emsp;&emsp;域名解析的工作流程<br>&emsp;&emsp;	1	<font color=#FEAE00>客户端首先会发出一个</font><font color=#FEAE00> DNS </font><font color=#FEAE00>请求，</font>问 www.server.com 的 IP 是啥，并发给<font color=#FEAE00>本地</font><font color=#FEAE00> DNS </font><font color=#FEAE00>服务器</font>（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。<br>&emsp;&emsp;	2	本地域名服务器收到客户端的请求后，<font color=#FEAE00>如果缓存里的表格</font>能找到 www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会<font color=#FEAE00>去问它的根域名服务器</font>：“老大， 能告诉我 www.server.com 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。<br>&emsp;&emsp;	3	根 DNS 收到来自本地 DNS 的请求后，<font color=#FEAE00>发现后置是</font><font color=#FEAE00> .com</font>，说：“www.server.com 这个域名归 .com 区域管理”，我给你 <font color=#FEAE00>.com </font><font color=#FEAE00>顶级域名服务器地址</font>给你，你去问问它吧。”<br>&emsp;&emsp;	4	本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com 的 IP 地址吗？”<br>&emsp;&emsp;	5	<font color=#FEAE00>顶级域名服务器</font>说：“我给你负责 www.server.com 区域的<font color=#FEAE00>权威</font><font color=#FEAE00> DNS </font><font color=#FEAE00>服务器的地址</font>，你去问它应该能问到”。<br>&emsp;&emsp;	6	本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。<br>&emsp;&emsp;	7	权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。<br>&emsp;&emsp;	8	本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。<br>&emsp;&emsp;至此，我们完成了 DNS 的解析过程。现在总结一下，整个过程我画成了一个图。<br>&emsp;&emsp;￼<br>&emsp;&emsp;DNS 域名解析的过程蛮有意思的，整个过程就和我们日常生活中找人问路的过程类似，<font color=#FEAE00>只指路不带路</font>。<br>&emsp;&emsp;那是不是每次解析域名都要经过那么多的步骤呢？<br>&emsp;&emsp;当然不是了，<font color=#FEAE00>还有缓存这个东西的</font>嘛。<br>&emsp;&emsp;<font color=#FEAE00>浏览器会先看自身有没有对这个域名的缓存</font>，如果有，就直接返回，如果没有，就去问<font color=#FEAE00>操作系统，操作系统也会去看自己的缓存</font>，如果有，就直接返回，如果没有，<font color=#FEAE00>再去</font><font color=#FEAE00> hosts </font><font color=#FEAE00>文件看</font>，也没有，才会去问「本地 DNS 服务器」。<br>&emsp;&emsp;数据包表示：“DNS 老大哥厉害呀，找到了目的地了！我还是很迷茫呀，我要发出去，接下来我需要谁的帮助呢?”<hr><hr>远程定位 —— IP<br>&emsp;&emsp;- IP 包头格式<br>&emsp;&emsp;- 多个网卡, 源地址选择哪个 IP? <br>&emsp;&emsp;- IP报文生成<hr>TCP 模块在执行<font color=#FEAE00>连接、收发、断开</font>等各阶段操作时，都需要委托 IP 模块将数据封装成<font color=#FEAE00>网络包</font><font color=#FEAE00>发</font>送给通信对象。<br>&emsp;&emsp;- IP 包头格式<br>&emsp;&emsp;我们先看看 IP 报文头部的格式：<br>&emsp;&emsp;￼<br>&emsp;&emsp;在 IP 协议里面需要有<font color=#FEAE00>源地址</font><font color=#FEAE00> IP</font><font color=#FEAE00> </font><font color=#FEAE00>和</font><font color=#FEAE00> </font><font color=#FEAE00>目标地址</font><font color=#FEAE00> IP</font><font color=#FEAE00>：</font><br>&emsp;&emsp;	•	源地址IP，即是客户端输出的 IP 地址；<br>&emsp;&emsp;	•	目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。<br>&emsp;&emsp;因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的<font color=#FEAE00>协议号</font>，要填写为 <font color=#FEAE00>06</font><font color=#FEAE00>（十六进制</font>），表示协议为 TCP。<br>&emsp;&emsp;# 假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？<br>&emsp;&emsp;当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。<br>&emsp;&emsp;这个时候就需要根据<font color=#FEAE00>路由表</font><font color=#FEAE00>规</font>则，来判断哪一个网卡作为源地址 IP。<br>&emsp;&emsp;在 Linux 操作系统，我们可以使用 <font color=#FEAE00>route -n</font> 命令查看当前系统的路由表。<br>&emsp;&emsp;￼<br>&emsp;&emsp;举个例子，根据上面的路由表，我们假设 Web 服务器的目标地址是 <font color=#4D647F>192.168.10.200</font>。<br>&emsp;&emsp;￼<br>&emsp;&emsp;	1	首先先和第一条目的<font color=#FEAE00>子网掩码（</font><font color=#FEAE00>Genmask</font>）进行<font color=#FEAE00> </font><font color=#FEAE00>与运算</font>，得到结果为 <font color=#4D647F>192.168.10.0</font>，但是第一个条目的 <font color=#4D647F>Destination</font> 是 <font color=#4D647F>192.168.3.0</font>，两者不一致所以匹配失败。<br>&emsp;&emsp;	2	再与第二条目的子网掩码进行 <font color=#FEAE00>与运算</font>，得到的结果为 <font color=#4D647F>192.168.10.0</font>，与第二条目的 <font color=#4D647F>Destination 192.168.10.0</font> 匹配成功，所以将使用 <font color=#4D647F>eth1</font> 网卡的 IP 地址作为 IP 包头的源地址。<br>&emsp;&emsp;那么假设 Web 服务器的目标地址是 <font color=#4D647F>10.100.20.100</font>，那么依然依照上面的路由表规则判断，判断后的结果是和第三条目匹配。<br>&emsp;&emsp;第三条目比较特殊，它目标地址和子网掩码都是 <font color=#4D647F>0.0.0.0</font>，这表示<font color=#FEAE00>默认网关</font>，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，<font color=#4D647F>Gateway</font> 即是路由器的 IP 地址。<br>&emsp;&emsp;# IP 报文生成<br>&emsp;&emsp;至此，网络包的报文如下图。<br>&emsp;&emsp;￼<br>&emsp;&emsp;此时，加上了 IP 头部的数据包表示 ：“有 IP 大佬给我指路了，感谢 IP 层给我加上了 IP 包头，让我有了远程定位的能力！不会害怕在浩瀚的互联网迷茫了！可是目的地好远啊，我下一站应该去哪呢？”<hr><hr>送别者 —— <font color=#FEAE00>交换机</font><font color=#FEAE00><br>&emsp;&emsp;</font>- 交换机的包接受操作<br>&emsp;&emsp;<hr>	下面来看一下包是如何通过交换机的。<font color=#FEAE00>交换机</font>的设计是将网络包<font color=#FEAE00>原样</font>转发到目的地。交换机工作在 MAC 层，也称为<font color=#FEAE00>二层网络设备</font><font color=#FEAE00>。</font><br>&emsp;&emsp;交换机的包接收操作<br>&emsp;&emsp;	首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。<br>&emsp;&emsp;	然后通过包末尾的 <font color=#FEAE00>FCS </font><font color=#FEAE00>校验错误</font>，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。<br>&emsp;&emsp;	计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<font color=#FEAE00>交换机的端口不具有</font><font color=#FEAE00> MAC </font><font color=#FEAE00>地址</font><font color=#FEAE00>。</font><br>&emsp;&emsp;	将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。<br>&emsp;&emsp;	<font color=#FEAE00>交换机的</font><font color=#FEAE00> MAC </font><font color=#FEAE00>地址表</font>主要包含两个信息：<br>&emsp;&emsp;	•	一个是<font color=#FEAE00>设备的</font><font color=#FEAE00> MAC </font><font color=#FEAE00>地址，</font><br>&emsp;&emsp;	•	另一个是<font color=#FEAE00>该设备连接在交换机的哪个端口上。</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;	举个例子，如果收到的包的接收方 MAC 地址为 <font color=#4D647F>00-02-B3-1C-9C-F9</font>，则与图中表中的第 3 行匹配，根据端口列的信息，可知这个地址位于 <font color=#4D647F>3</font> 号端口上，然后就可以通过交换电路将包发送到相应的端口了。<br>&emsp;&emsp;	所以，<font color=#FEAE00>交换机根据</font><font color=#FEAE00> MAC </font><font color=#FEAE00>地址表查找</font><font color=#FEAE00> MAC </font><font color=#FEAE00>地址，然后将信号发送到相应的端口</font><font color=#FEAE00>。</font><br>&emsp;&emsp;# 当 MAC 地址表找不到指定的 MAC 地址会怎么样？<br>&emsp;&emsp;	地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。<br>&emsp;&emsp;	这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。<br>&emsp;&emsp;	这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后<font color=#FEAE00>只有相应的接收者才接收包，而其他设备则会忽略这个包</font><font color=#FEAE00>。</font><br>&emsp;&emsp;	有人会说：“这样做会发送多余的包，会不会造成网络拥塞呢？”<br>&emsp;&emsp;	其实完全不用过于担心，因为发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入 MAC 地址表，下次也就不需要把包发到所有端口了。<br>&emsp;&emsp;	局域网中每秒可以传输上千个包，多出一两个包并无大碍。<br>&emsp;&emsp;	此外，如果接收方 MAC 地址是一个<font color=#FEAE00>广播地址</font><font color=#FEAE00>，</font>那么交换机会将包发送到除源端口之外的所有端口。<br>&emsp;&emsp;	以下两个属于广播地址：<br>&emsp;&emsp;	•	MAC 地址中的 <font color=#4D647F>FF:FF:FF:FF:FF:FF</font><br>&emsp;&emsp;	•	IP 地址中的 <font color=#4D647F>255.255.255.255</font><br>&emsp;&emsp;	数据包通过交换机转发抵达了路由器，准备要离开土生土长的子网了。此时，数据包和交换机离别时说道：“感谢交换机兄弟，帮我转发到出境的大门，我要出远门啦！”<hr><hr>键入网址后: 2.2 孤单小弟 —— HTTP<br>&emsp;&emsp;- URL 如何解析?  各个元素都是什么? <br>&emsp;&emsp;- HTTP 请求信息的生成? <br>&emsp;&emsp;-<hr>浏览器做的第一步工作是<font color=#FEAE00>解析</font><font color=#FEAE00> URL</font><br>&emsp;&emsp;首先浏览器做的第一步工作就是要对 <font color=#4D647F>URL</font> 进行解析，从而生成发送给 <font color=#4D647F>Web</font> 服务器的请求信息。<br>&emsp;&emsp;让我们看看一条<font color=#FEAE00>长长的</font><font color=#FEAE00> URL </font><font color=#FEAE00>里的各个元素的代表</font>什么，见下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;所以图中的长长的 URL 实际上是请求服务器里的文件资源。<br>&emsp;&emsp;要是上图中的蓝色部分 URL 元素都省略了，那应该是请求哪个文件呢？<br>&emsp;&emsp;当没有路径名时，就代表访问根目录下事先设置的<font color=#FEAE00>默认文件</font>，也就是 <font color=#FEAE00>/index.html </font><font color=#FEAE00>或者</font><font color=#FEAE00> /default.html</font> 这些文件，这样就不会发生混乱了。<br>&emsp;&emsp;生产 <font color=#FEAE00>HTTP </font><font color=#FEAE00>请求信息</font><br>&emsp;&emsp;对 <font color=#4D647F>URL</font> 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来<font color=#FEAE00>生成</font><font color=#FEAE00> HTTP </font><font color=#FEAE00>请求消息</font>了。<br>&emsp;&emsp;￼<br>&emsp;&emsp;一个孤单 HTTP 数据包表示：“我这么一个小小的数据包，没亲没友，直接发到浩瀚的网络，谁会知道我呢？谁能载我一程呢？谁能保护我呢？我的目的地在哪呢？”。充满各种疑问的它，没有停滞不前，依然踏上了征途！<hr><hr> raft划分出来的子问题<hr>节点选举, 日志复制, 安全性保证, 节点压缩, leader transfer, pre vote, 成员变更, 线性一致性读<br>&emsp;&emsp;---<br>&emsp;&emsp;Raft 将共识算法这个难解决的问题分解成了多个易解决，相对独立的子问题，这些问题都会在接下来的章节中进行介绍。<br>&emsp;&emsp;	•	<font color=#FEAE00>Leader election</font>：选出集群的 leader 来统筹全局。<br>&emsp;&emsp;	•	<font color=#FEAE00>Log replication</font>：leader 负责从客户端接收请求，并且在集群中扩散同步。<br>&emsp;&emsp;	•	<font color=#FEAE00>Safety</font>：各节点间状态机的一致性保证。<br>&emsp;&emsp;在博士论文和实际生产系统中，还有更多可以探讨的模块或细节功能：<br>&emsp;&emsp;	•	<font color=#FEAE00>Log compaction</font>：压缩日志以节约磁盘空间；加速重启后节点恢复速率；加速新节点 catch up 速率。<br>&emsp;&emsp;	•	<font color=#FEAE00>Leader transfer</font>：能够将 leader 禅让另一个 follower，便于平滑的负载均衡。<br>&emsp;&emsp;	•	<font color=#FEAE00>Pre vote</font>：在竞选开始时先进行一轮预备竞选，若被允许再转变为 candidate，这样有助于防止某些异常节点扰乱整个集群的正常工作。<br>&emsp;&emsp;	•	<font color=#FEAE00>Membership change</font>：集群动态增删节点。<br>&emsp;&emsp;	•	Client interaction：客户端交互。<br>&emsp;&emsp;	•	<font color=#FEAE00>Linearizable read</font>：线性一致性读。<br>&emsp;&emsp;	•	Optimization：业界常见优化。<br>&emsp;&emsp;	•	…<br>&emsp;&emsp;<hr><hr>0.22、<font color=#FEAE00>视图</font>的作用是什么？可以更改吗？<hr>视图是<font color=#FEAE00>虚拟的表</font>，与包含数据的表不一样，视图只包含<font color=#FEAE00>使用时动态检索数据的查询</font>；不包含任何列或数据。使用视图可以简<font color=#FEAE00>化复杂的</font><font color=#FEAE00> sql </font><font color=#FEAE00>操作</font>，隐藏具体的细节，保护数据；视图创建后，可以使用与表相同的方式利用它们。<br>&emsp;&emsp;<br>&emsp;&emsp;视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by 则对视图再次order by将被覆盖。<br>&emsp;&emsp;<br>&emsp;&emsp;创建视图：<font color=#FEAE00>create view xxx as xxxx</font><br>&emsp;&emsp;<br>&emsp;&emsp;对于某些视图比如未使用联结子查询分组聚集函数<font color=#FEAE00>Distinct Union</font><font color=#FEAE00>等</font>，是可以对其更新的，对视图的更新将对基表进行更新；但是视图主要用于简化检索，保护数据，并不用于更新，<font color=#FEAE00>而且大部分视图都不可以更新。</font><hr><hr>0.37、MySQL中CHAR和VARCHAR的区别有哪些？<hr>- char的长度是不可变的，用空格填充到指定长度大小，而varchar的长度是可变的。<br>&emsp;&emsp;- char的存取数度还是要比varchar要快得多<br>&emsp;&emsp;- char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。<hr><hr>0.优化19、数据库为什么要进行<font color=#FEAE00>分库和分表</font>呢？都放在一个库或者一张表中不可以吗？<hr>分库与分表的目的在于，<font color=#FEAE00>减小数据库的单库单表负担，</font>提高查询性能，缩短查询时间。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#FEAE00>通过分表</font>，可以减少数据库的单表负担，将<font color=#FEAE00>压力分散到不同的表上</font>，同时因为不同的表上的数据量少了，起到提高查询性能，缩短查询时间的作用，此外，可以很大的缓解表锁的问题。 分表策略可以归纳为垂直拆分和水平拆分： 水平分表：取模分表就属于随机分表，而时间维度分表则属于连续分表。 如何设计好垂直拆分，我的建议：将不常用的字段单独拆分到另外一张扩展表. 将大文本的字段单独拆分到另外一张扩展表, 将不经常修改的字段放在同一张表中，将经常改变的字段放在另一张表中。 对于海量用户场景，可以考虑取模分表，数据相对比较均匀，不容易出现热点和并发访问的瓶颈。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#FEAE00>库内分表</font>，仅仅是解决了单表数据过大的问题，但并没有把<font color=#FEAE00>单表的数据分散到不同的物理机上，因此并不能减轻</font><font color=#FEAE00> MySQL </font><font color=#FEAE00>服务器的压力</font>，仍然存在同一个物理机上的资源竞争和瓶颈，包括 CPU、内存、磁盘 IO、网络带宽等。<br>&emsp;&emsp;<br>&emsp;&emsp;分库与分表带来的<font color=#FEAE00>分布式困境与应对之策</font> 数据迁移与扩容问题----一般做法是通过程序先读出数据，然后按照<font color=#FEAE00>指定的分表策略再将数据写入到各个分表</font>中。 分页与排序问题----需要在不同的分表中将数据进行排序并返回，并将不同分表返回的结果集进行汇总和再次排序，最后再返回给用户。<hr><hr>0.优化24、一道场景题：假如你所在的公司选择MySQL数据库作数据存储，一天五万条以上的增量，预计运维三年，你有哪些优化手段？<hr>- 设计良好的数据库结构，允许<font color=#FEAE00>部分数据冗余</font>，尽量避免join查询，提高效率。<br>&emsp;&emsp;- 选择合适的<font color=#FEAE00>表字段数据类型</font>和存储引擎，适当的<font color=#FEAE00>添加索引</font>。<br>&emsp;&emsp;- MySQL库<font color=#FEAE00>主从读写分离</font>。<br>&emsp;&emsp;- 找规律分表，减少单表中的数据量提高查询速度。<br>&emsp;&emsp;- 添加缓存机制，比如Memcached，Apc等。<br>&emsp;&emsp;- 不经常改动的页面，生成静态页面。<br>&emsp;&emsp;- <font color=#FEAE00>书写高效率的</font><font color=#FEAE00>SQL</font>。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE。<hr><hr>0.优化46、你知道哪些数据库结构优化的手段<br>&emsp;&emsp;<br>&emsp;&emsp;todo 分阶段 <br>&emsp;&emsp;<br>&emsp;&emsp;存储 核心查询<br>&emsp;&emsp;分布式<br>&emsp;&emsp;等等<hr>- 范式优化： 比如消除冗余（节省空间。。）<br>&emsp;&emsp;- 反范式优化：比如适当加冗余等（减少join）<br>&emsp;&emsp;- 限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。<br>&emsp;&emsp;- 读/写分离： 经典的数据库拆分方案，主库负责写，从库负责读；<br>&emsp;&emsp;- 拆分表：分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的时时表可采取此方法。可按月自动建表分区。<hr><hr>0.优化47、数据库优化中有一个比较常用的手段就是把数据表进行拆分，<font color=#FEAE00>关于拆分数据表你了解哪些</font>？<br>&emsp;&emsp;<br>&emsp;&emsp;todo 啥？<hr>拆分其实又分<font color=#FEAE00>垂直拆分</font><font color=#FEAE00>和</font><font color=#FEAE00>水平拆分</font><br>&emsp;&emsp;<br>&emsp;&emsp;案例： 简单购物系统暂设涉及如下表：<br>&emsp;&emsp;<br>&emsp;&emsp;1.产品表（数据量10w，稳定）<br>&emsp;&emsp;<br>&emsp;&emsp;2.订单表（数据量200w，且有增长趋势）<br>&emsp;&emsp;<br>&emsp;&emsp;3.用户表 （数据量100w，且有增长趋势）<br>&emsp;&emsp;<br>&emsp;&emsp;以 MySQL 为例讲述下水平拆分和垂直拆分，MySQL能容忍的数量级在百万静态数据可以到千万<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#FEAE00>垂直拆分</font><br>&emsp;&emsp;<br>&emsp;&emsp;解决问题：<font color=#FEAE00>表与表之间的</font><font color=#FEAE00>io</font><font color=#FEAE00>竞争</font><br>&emsp;&emsp;<br>&emsp;&emsp;不解决问题：单表中数据量增长出现的压力<br>&emsp;&emsp;<br>&emsp;&emsp;方案： 把产品表和用户表放到一个server上 订单表单独放到一个server上<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#FEAE00>水平拆分</font><br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#FEAE00>解决问题：单表中数据量增长出现的压力</font><br>&emsp;&emsp;<br>&emsp;&emsp;不解决问题：表与表之间的io争夺<br>&emsp;&emsp;<br>&emsp;&emsp;方案：用户表 通过性别拆分为男用户表和女用户表，订单表 通过已完成和完成中拆分为已完成订单和未完成订单，产品表 未完成订单放一个server上，已完成订单表盒男用户表放一个server上，女用户表放一个server上(女的爱购物 哈哈)。<hr><hr>0.优化55、数据库高并发是我们经常会遇到的，你有什么好的解决方案吗？<hr>- 在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。<br>&emsp;&emsp;- 增加数据库索引，进而提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）<br>&emsp;&emsp;- 主从读写分离，让主服务器负责写，从服务器负责读。<br>&emsp;&emsp;- 将数据库进行拆分，使得数据库的表尽可能小，提高查询的速度。<br>&emsp;&emsp;- 使用分布式架构，分散计算压力。<hr><hr>0.优化9、MySQL<font color=#FEAE00>优化</font>了解吗？说一下从哪些方面可以做到性能优化？<hr>- 为搜索字段创建<font color=#FEAE00>索引</font><br>&emsp;&emsp;- 避免使用 <font color=#FEAE00>Select *</font>，列出需要查询的字段<br>&emsp;&emsp;- 垂直<font color=#FEAE00>分割分表</font><br>&emsp;&emsp;- 选择正确的存储引擎<hr><hr>0.关系1、<font color=#FEAE00>关系型和非关系型</font>数据库的区别你了解多少？<hr>- 关系型数据库的优点<br>&emsp;&emsp;  - <font color=#FEAE00>容易理解</font>。因为它采用了关系模型来组织数据。<br>&emsp;&emsp;  - 可以保持数据的<font color=#FEAE00>一致性</font>。<br>&emsp;&emsp;  - 数据更新的开销比较小。<br>&emsp;&emsp;  - 支持<font color=#FEAE00>复杂查询</font>（带where子句的查询）<br>&emsp;&emsp;- <font color=#FEAE00>非关系型数据库</font>的优点<br>&emsp;&emsp;  - 不需要经过SQL层的解析，<font color=#FEAE00>读写效率高</font>。<br>&emsp;&emsp;  - 基于<font color=#FEAE00>键值对</font>，数据的扩展性很好。<br>&emsp;&emsp;  - 可以支持多种类型数据的存储，如图片，文档等等。<hr><hr>0.关系2、什么是<font color=#FEAE00>非关系型数据库</font>？<hr>非关系型数据库也叫<font color=#FEAE00>NOSQL</font>，采用键值对的形式进行存储。<br>&emsp;&emsp;<br>&emsp;&emsp;它的读写性能很高，易于扩展，可分为<font color=#FEAE00>内存性数据库</font>以及<font color=#FEAE00>文档型数据库</font>，比如 <font color=#FEAE00>Redis</font><font color=#FEAE00>，</font><font color=#FEAE00>Mongodb</font><font color=#FEAE00>，</font><font color=#FEAE00>HBase</font>等等。<br>&emsp;&emsp;<br>&emsp;&emsp;适合使用非关系型数据库的场景：<br>&emsp;&emsp;<br>&emsp;&emsp;- 日志系统<br>&emsp;&emsp;- 地理位置存储<br>&emsp;&emsp;- 数据量巨大<br>&emsp;&emsp;- 高可用<hr><hr>0.引擎15、数据库引擎<font color=#FEAE00>InnoDB</font>与MyISAM的区别<hr>### InnoDB<br>&emsp;&emsp;<br>&emsp;&emsp;- 是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。<br>&emsp;&emsp;- 实现了四个标准的隔离级别，默认级别是<font color=#FEAE00>可重复读</font><font color=#FEAE00>(REPEATABLE READ)</font>。在可重复读隔离级别下，通过多<font color=#FEAE00>版本并发控制</font><font color=#FEAE00>(MVCC)+ </font><font color=#FEAE00>间隙锁</font><font color=#FEAE00>(Next-Key Locking)</font>防止幻影读。<br>&emsp;&emsp;- <font color=#FEAE00>主索引是聚簇索引</font>，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。<br>&emsp;&emsp;- 内部做了很多<font color=#FEAE00>优化</font>，包括从磁盘读取数据时<font color=#FEAE00>采用的可预测性读</font>、能够加快读操作并且自动创建的<font color=#FEAE00>自适应哈希索引</font>、能够加速插入操作的<font color=#FEAE00>插入缓冲区</font>等。<br>&emsp;&emsp;- 支持真正的<font color=#FEAE00>在线热备份</font>。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。<br>&emsp;&emsp;<br>&emsp;&emsp;### MyISAM<br>&emsp;&emsp;<br>&emsp;&emsp;- 设计简单，数据以<font color=#FEAE00>紧密格式存储</font>。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。<br>&emsp;&emsp;- 提供了大量的特性，包括压缩表、空间数据索引等。<br>&emsp;&emsp;- <font color=#FEAE00>不支持事务</font>。<br>&emsp;&emsp;- 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入(CONCURRENT INSERT)。<br>&emsp;&emsp;<br>&emsp;&emsp;### 总结 对比<br>&emsp;&emsp;<br>&emsp;&emsp;- 事务: InnoDB 是事务型的，可以使用 `Commit` 和 `Rollback` 语句。<br>&emsp;&emsp;- 并发: MyISAM <font color=#FEAE00>只支持表级锁</font>，而 InnoDB 还支持行级锁。<br>&emsp;&emsp;- 外键: InnoDB 支持<font color=#FEAE00>外键</font>。<br>&emsp;&emsp;- 备份: InnoDB 支持在线热备份。<br>&emsp;&emsp;- 崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。<br>&emsp;&emsp;- 其它特性: MyISAM 支持压缩表和空间数据索引。<hr><hr>0.引擎30、MySQL常见的存储引擎InnoDB、MyISAM的区别？适用场景分别是？<hr>1）事务：MyISAM不支持，InnoDB支持 2）锁级别： MyISAM 表级锁，InnoDB 行级锁及外键约束 3）MyISAM存储表的总行数；InnoDB不存储总行数； 4）MyISAM采用非聚集索引，B+树叶子存储指向数据文件的指针。InnoDB主键索引采用聚集索引，B+树叶子存储数据<br>&emsp;&emsp;<br>&emsp;&emsp;适用场景： MyISAM适合： 插入不频繁，查询非常频繁，如果执行大量的SELECT，MyISAM是更好的选择， 没有事务。 InnoDB适合： 可靠性要求比较高，或者要求事务； 表更新和查询都相当的频繁， 大量的INSERT或UPDATE<hr><hr>0.组成7、你了解MySQL的<font color=#FEAE00>内部构造吗</font>？一般可以分为哪两个部分？<hr>可以分为<font color=#FEAE00>服务层和存储引擎层</font>两部分，其中：<br>&emsp;&emsp;<br>&emsp;&emsp;服务层包括<font color=#FEAE00>连接器、查询缓存、分析器、优化器、执行器</font>等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。<br>&emsp;&emsp;<br>&emsp;&emsp;存储引擎层<font color=#FEAE00>负责数据的存储和提取</font>。其<font color=#FEAE00>架构模式是插件式</font>的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认的存储引擎。<hr><hr>0.范式28、数据库<font color=#FEAE00>三大范式</font>精讲<hr>### 第一范式<br>&emsp;&emsp;<br>&emsp;&emsp;在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。 所谓第一范式（1NF）是<font color=#FEAE00>指数据库表的每一列都是不可分割的基本数据项</font>，<font color=#FEAE00>同一列中不能有多个值</font><font color=#FEAE00> </font><font color=#FEAE00>列中数据尽可能分割掉</font><br>&emsp;&emsp;<br>&emsp;&emsp;如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。<br>&emsp;&emsp;<br>&emsp;&emsp;简而言之，第一范式<font color=#FEAE00>就是无重复的列</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;### 第二范式<br>&emsp;&emsp;<br>&emsp;&emsp;第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的<font color=#FEAE00>每个实例或行必须可以被惟一地区分。</font><br>&emsp;&emsp;<br>&emsp;&emsp;为实现区分通常需要为表<font color=#FEAE00>加上一个列，以存储各个实例的惟一标识</font>。这个惟一属性列被称为主关键字或<font color=#FEAE00>主键、主码</font>。 第二范式（2NF）要求实体的属性完全依赖于主关键字。<br>&emsp;&emsp;<br>&emsp;&emsp;所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。<br>&emsp;&emsp;<br>&emsp;&emsp;简而言之，第二范式就是<font color=#FEAE00>非主属性非部分依赖于主关键字</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;### 第三范式<br>&emsp;&emsp;<br>&emsp;&emsp;满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个<font color=#FEAE00>数据库表中不包含已在其它表中已包含的非主关键字信息</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，<font color=#FEAE00>则根据第三范式（</font><font color=#FEAE00>3NF</font><font color=#FEAE00>）也应该构建它，否则就会有大量的数据冗余。</font><br>&emsp;&emsp;<br>&emsp;&emsp;简而言之，<font color=#FEAE00>第三范式就是属性不依赖于其它非主属性</font>。<hr><hr>1.13、听说过<font color=#FEAE00>视图</font>吗？那<font color=#FEAE00>游标</font>呢？<hr><font color=#FEAE00>视图是一种虚拟的表</font>，通常是有一个表或者多个表的行或列的子集，具有和物理表相同的功能 <font color=#FEAE00>游标是对查询出来的结果集作为一个单元来有效的处理</font>。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。<hr><hr>1.语法10 条件函数<br>&emsp;&emsp;在查看用户学校时，我们想把非北京大学的用户统一归为其他大学<br>&emsp;&emsp;<br>&emsp;&emsp;或者在多个条件之下<hr>if 条件函数<br>&emsp;&emsp;	select id, <font color=#1DB100>if(uni = '</font><font color=#1DB100>北大</font><font color=#1DB100>':'</font><font color=#1DB100>北大</font><font color=#1DB100>':'</font><font color=#1DB100>其他大学</font><font color=#1DB100>')</font><br>&emsp;&emsp;	as uni from user<br>&emsp;&emsp;---<br>&emsp;&emsp;case when 函数<br>&emsp;&emsp;	select case<br>&emsp;&emsp;	<font color=#1DB100>when score = </font>'A' then '优' <br>&emsp;&emsp;	<font color=#1DB100>when score =</font> 'B' then '..' <br>&emsp;&emsp;	<font color=#1DB100>else  '</font><font color=#1DB100>不及格</font><font color=#1DB100>'</font><br>&emsp;&emsp;	<font color=#1DB100>end </font><hr><hr>1.语法11 文本函数<br>&emsp;&emsp;	返回函数中文本字段的长度<br>&emsp;&emsp;	连接  <hr>长度: <br>&emsp;&emsp;	select <font color=#FEAE00>length('abc') .. </font><br>&emsp;&emsp;连接, 多个连起来<br>&emsp;&emsp;	select concat('abc', 'bcd' ...)<br>&emsp;&emsp;	是这样用的么? <br>&emsp;&emsp;分割: <br>&emsp;&emsp;	<font color=#FEAE00>substring_index(string, '.' , '1') as </font>height <br>&emsp;&emsp;	选择第几个? 从1开始的<br>&emsp;&emsp;定位: <br>&emsp;&emsp;	instr(substr, str) <br>&emsp;&emsp;	返回在str里面第一次出现的位置, 从1开始<br>&emsp;&emsp;截取:<br>&emsp;&emsp;	substr(string A, int start, int len) <br>&emsp;&emsp;	substring(string A, int start) <br>&emsp;&emsp;<hr><hr>1.语法1: 简单的查询语句<br>&emsp;&emsp;select 用法<hr>select * from user<br>&emsp;&emsp;select a from user<br>&emsp;&emsp;select id, device from user<br>&emsp;&emsp;查询多个列, 之间用逗号分隔<hr><hr>1.语法2: 	简单处理: 去重, 限制返回行数, 列重命名<br>&emsp;&emsp;<br>&emsp;&emsp;<hr>去重: select <font color=#1DB100>distinct</font> age from user<br>&emsp;&emsp;限制返回行数:  select device_id from user <font color=#1DB100>limit 5<br>&emsp;&emsp;<br>&emsp;&emsp;limit 5,10 </font><font color=#1DB100>可以限制查找的范围</font><font color=#1DB100><br>&emsp;&emsp;</font>列重命名: select device <font color=#1DB100>as active_user</font> from user<hr><hr>1.语法32、SQL中的NOW()和CURRENT_DATE()两个函数有什么区别？<hr>NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。 CURRENT_DATE（）仅显示当前年份，月份和日期。<hr><hr>1.语法3: <font color=#1DB100>简单排序</font><br>&emsp;&emsp;单列, 多列, 升序降序<hr>order-by: <br>&emsp;&emsp;[	select age from user<br>&emsp;&emsp;	<font color=#1DB100>order by age </font>]<font color=#1DB100><br>&emsp;&emsp;</font>升序排列<br>&emsp;&emsp;	select age from user <font color=#1DB100>order by age, gpa<br>&emsp;&emsp;</font>降序排列<br>&emsp;&emsp;	select age from user <font color=#1DB100>order by age desc<br>&emsp;&emsp;	</font>需要注意, desc关键字, 只用于直接前面的那个<hr><hr>1.语法45、SQL语法中内连接、自连接、外连接（左、右、全）、交叉连接的区别分别是什么？<br>&emsp;&emsp;<br>&emsp;&emsp;todo 什么是外链接<hr>左/外连接(left join) 左所有<br>&emsp;&emsp;右连接(right join) 右所有<br>&emsp;&emsp;等值/内连接(inner join) 等值<br>&emsp;&emsp;全外连接(full join)两个所有笛卡尔积<br>&emsp;&emsp;---<font color=#FEAE00><br>&emsp;&emsp;</font><font color=#FEAE00>内连接</font>：只有两个元素表相匹配的才能在结果集中显示。<br>&emsp;&emsp;	select * from (...)<font color=#1DB100>a left join</font> (select ...)<font color=#1DB100>b on a.id = b.id</font><br>&emsp;&emsp;外连接： 左外连接: 左边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。<br>&emsp;&emsp;	right join<br>&emsp;&emsp;<font color=#FEAE00>右外连接</font>:右边为驱动表，驱动表的数据全部显示，匹配表的不匹配的不会显示。<br>&emsp;&emsp;<font color=#FEAE00>全外连接</font>：连接的表中不匹配的数据全部会显示出来。<br>&emsp;&emsp;<font color=#FEAE00>交叉连接</font>： 笛卡尔效应，显示的结果是链接表数的乘积。<br>&emsp;&emsp;	笛卡尔积 好像是 直接join出来的<hr><hr>1.语法4: 	where语句, 基础操作符, 	<hr>where: <br>&emsp;&emsp;	select id from user <font color=#FEAE00>where gender = 'name'</font><br>&emsp;&emsp;基础操作符: <br>&emsp;&emsp;	不等于:  <>  != <br>&emsp;&emsp;	大于小于号:  >  <<br>&emsp;&emsp;	<font color=#FEAE00>范围值</font><font color=#FEAE00>:  between n1 and n2</font><br>&emsp;&emsp;		?? 这里的是包括 左边和右边么? <br>&emsp;&emsp;	空值:  <br>&emsp;&emsp;		where gender is NULL<br>&emsp;&emsp;		where gender is NOT NULL<br>&emsp;&emsp;	<hr><hr>1.语法5: 高级操作符<br>&emsp;&emsp;	and or, in, not in, 混用时候次序, like <hr>and:<br>&emsp;&emsp;	where age < 30 and gender = 'male' <br>&emsp;&emsp;or: <br>&emsp;&emsp;	<br>&emsp;&emsp;in:<br>&emsp;&emsp;	Where university in ('北京大学','复旦大学')<br>&emsp;&emsp;not in: <br>&emsp;&emsp;	Where university not in ('北京大学','复旦大学')<br>&emsp;&emsp;混用: <br>&emsp;&emsp;	先处理and, 在处理 or<br>&emsp;&emsp;like:	模糊匹配<br>&emsp;&emsp;	where university like "北京%"<br>&emsp;&emsp;	类似 .*? <br>&emsp;&emsp;	<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;<hr><hr>1.语法6: 计算函数<br>&emsp;&emsp;	多对一的函数<br>&emsp;&emsp;	都有哪些?<br>&emsp;&emsp;	avg, count, max, min, sum, 取整<br>&emsp;&emsp;<br>&emsp;&emsp;<hr>avg: <br>&emsp;&emsp;	select <font color=#1DB100>avg(gpa)</font> from user<br>&emsp;&emsp;		// 这里不用 as 的话, 返回的是什么? <br>&emsp;&emsp;count: <br>&emsp;&emsp;	select <font color=#1DB100>count(*) as num_cnt</font> from user <br>&emsp;&emsp;MAX: <br>&emsp;&emsp;	select <font color=#1DB100>max(age) as max_age</font> from user <br>&emsp;&emsp;min: <br>&emsp;&emsp;	select <font color=#1DB100>min(age) as min</font> from user <br>&emsp;&emsp;sum:<br>&emsp;&emsp;	select <font color=#1DB100>sum(age) as sum</font> from user <br>&emsp;&emsp;// 这个能用么<br>&emsp;&emsp;取整: 	<br>&emsp;&emsp;	select <font color=#1DB100>round(avg(age))</font> as avg_age from user<br>&emsp;&emsp;<hr><hr>1.语法7 分组查询<br>&emsp;&emsp;	1. 查找每个大学的平均成绩<br>&emsp;&emsp;	2. 平均高于 10 的平均成绩<br>&emsp;&emsp;//todo 所有这些混合起来是什么样子? <hr>group by 语句<br>&emsp;&emsp;	select uni, avg(gpa) from user <font color=#FEAE00>group by uni</font><br>&emsp;&emsp;	## 按大学来计算平均成绩<br>&emsp;&emsp;	group by 可以进行嵌套<br>&emsp;&emsp;	group by 在 where 之后, order by 之前<br>&emsp;&emsp;分组过滤: <br>&emsp;&emsp;	<font color=#FEAE00>group by uni having avg(gpa) > 10</font><br>&emsp;&emsp;	可以过滤掉组内的一些信息<br>&emsp;&emsp;	和 where 由什么区别呢? <hr><hr>1.语法8 子查询<br>&emsp;&emsp;	<hr>select ... from ... <font color=#1DB100>where device_id in</font><br>&emsp;&emsp;(select .. from .. where ...)<br>&emsp;&emsp;<hr><hr>10、Redis 为什么是单线程的而不采用多线程方案？<hr>这主要是基于一种客观原因来考虑的。因为Redis是基于内存的操作，CPU不是Redis的瓶颈，<font color=#FEAE00>Redis</font><font color=#FEAE00>的瓶颈最有可能是机器内存的大小或者网络带宽</font>。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）<hr><hr>11、<font color=#FEAE00>单线程的</font><font color=#FEAE00>Redis</font><font color=#FEAE00>为</font>什么这么快？<hr>纯内存, 无上下文切换, epoll<br>&emsp;&emsp;---<br>&emsp;&emsp;主要是有三个原因：<br>&emsp;&emsp;1、<font color=#FEAE00>Redis</font><font color=#FEAE00>的全部操作都是纯内存</font>的操作；<br>&emsp;&emsp;2、Redis采用单线程，有效避免了频繁的上下文切换；<br>&emsp;&emsp;3，采用了<font color=#FEAE00>非阻塞</font><font color=#FEAE00>I/O</font><font color=#FEAE00>多路复用机制</font>。<hr><hr>13、Redis<font color=#FEAE00>设置过期时间的两种方案</font>是什么？<hr>定期删除 惰性删除<br>&emsp;&emsp;###<br>&emsp;&emsp;Redis中有个设置时间过期的功能，即对存储在 Redis 数据库中的值可以设置一个过期时间。<br>&emsp;&emsp;<br>&emsp;&emsp;作为一个缓存数据库， 这是非常实用的，比如一些 token 或者登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。<br>&emsp;&emsp;<br>&emsp;&emsp;我们 <font color=#FEAE00>set key </font><font color=#FEAE00>的时候，都可以给一个</font><font color=#FEAE00> expire time</font><font color=#FEAE00>，就是过期时间</font>，通过过期时间我们可以指定这个 key 可以存活的时间，主要可采用<font color=#FEAE00>定期删除和惰性删除</font><font color=#FEAE00>两种方案。</font><br>&emsp;&emsp;<br>&emsp;&emsp;- <font color=#FEAE00>定期删除：</font><font color=#FEAE00>Redis</font><font color=#FEAE00>默认是每隔</font><font color=#FEAE00> 100ms</font> 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删 除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 Redis 存了几十万个 key ，每隔100ms就遍历所 有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！<br>&emsp;&emsp;- <font color=#FEAE00>惰性删除</font><font color=#FEAE00> </font><font color=#FEAE00>：定期删除可能会导致很多过期</font><font color=#FEAE00> key </font><font color=#FEAE00>到了时间并没有被删除</font>掉。所以就有了惰性删除。它是指某个键值过期后,此键值不会马上被删除,<font color=#FEAE00>而是等到下次被使用的时候</font><font color=#FEAE00>,</font><font color=#FEAE00>才会被检查到过期</font><font color=#FEAE00>,</font><font color=#FEAE00>此时才能得到删除</font><font color=#FEAE00>,</font><font color=#FEAE00>惰性删除的缺点很明显是浪费内</font>存。 除非你的系统去查一下那个 key，才会被Redis给删除掉。这就是所谓的惰性删除！<hr><hr>18、Redis持久化机制可以说一说吗？<hr>Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。<br>&emsp;&emsp;<br>&emsp;&emsp;很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机 器、机器故障之后回复数据），或者是为了防止系统故障而将数据备份到一个远程位置。<br>&emsp;&emsp;<br>&emsp;&emsp;实现：单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。<br>&emsp;&emsp;<br>&emsp;&emsp;以下有两种持久化机制<br>&emsp;&emsp;<br>&emsp;&emsp;### 快照（snapshotting）持久化（RDB持久化）<br>&emsp;&emsp;<br>&emsp;&emsp;Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行 备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性 能），还可以将快照留在原地以便重启服务器的时候使用。<br>&emsp;&emsp;<br>&emsp;&emsp;快照持久化是Redis默认采用的持久化方式，在Redis.conf配置文件中默认有此下配置：<br>&emsp;&emsp;<br>&emsp;&emsp;```shell<br>&emsp;&emsp;save 900 1 #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令<br>&emsp;&emsp;创建快照。<br>&emsp;&emsp;<br>&emsp;&emsp;save 300 10 #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。<br>&emsp;&emsp;<br>&emsp;&emsp;save 60 10000 #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;### AOF（append-only file）持久化<br>&emsp;&emsp;<br>&emsp;&emsp;与快照持久化相比，AOF持久化的实时性更好，因此已成为主流的持久化方案。默认情况下Redis没有开启 AOF（append only ﬁle）方式的持久化，可以通过appendonly参数开启：`appendonly yes`<br>&emsp;&emsp;<br>&emsp;&emsp;开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的 保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。<br>&emsp;&emsp;<br>&emsp;&emsp;在Redis的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：<br>&emsp;&emsp;<br>&emsp;&emsp;```shell<br>&emsp;&emsp;appendfsync always #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度<br>&emsp;&emsp;appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘<br>&emsp;&emsp;appendfsync no  #让操作系统决定何时进行同步<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec选项 ，让Redis每秒同步一次AOF文件，Redis性能 几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。<br>&emsp;&emsp;<br>&emsp;&emsp;Redis 4.0 对于持久化机制的优化<br>&emsp;&emsp;<br>&emsp;&emsp;Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。<br>&emsp;&emsp;<br>&emsp;&emsp;如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。<hr><hr>19、AOF重写了解吗？可以简单说说吗？<hr>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。<br>&emsp;&emsp;<br>&emsp;&emsp;AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任伺读 入、分析或者写入操作。<br>&emsp;&emsp;<br>&emsp;&emsp;在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容 追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的 AOF文件，以此来完成AOF文件重写操作。<hr><hr>1、听说过Redis吗？它是什么？<hr>Redis是一个数据库，不过与传统数据库不同的是Redis的数据库是存在内存中，所以读写速度非常快，因此 <font color=#FEAE00>Redis</font><font color=#FEAE00>被广泛应用于</font><font color=#FEAE00>缓存</font><font color=#FEAE00>方向。</font><br>&emsp;&emsp;<br>&emsp;&emsp;除此之外，<font color=#FEAE00>Redis</font><font color=#FEAE00>也经常用来做分布式锁</font>，Redis提供了多种数据类型来支持不同的业务场景。除此之外，Redis 支持事务持久化、LUA脚本、LRU驱动事件、多种集群方案。<hr><hr>2.1 Redis 常见面试题<hr>大家好，我是小林。<br>&emsp;&emsp;不知不觉《图解 Redis》系列文章写了很多了，考虑到一些同学面试突击 Redis，所以我整理了 3 万字 + 40 张图的 Redis 八股文，共收集了 40 多个面试题。<br>&emsp;&emsp;￼<br>&emsp;&emsp;发车！<br>&emsp;&emsp;￼<hr><hr>2.B树11、都知道数据库索引采用B+树而不是B树，原因也有很多，主要原因是什么？<hr>主要原因：B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低。<hr><hr>2.B树18、MySQL索引主要使用的两种数据结构是什么？<hr>- 哈希索引，对于哈希索引来说，底层的数据结构肯定是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引<br>&emsp;&emsp;<br>&emsp;&emsp;- BTree索引，Mysql的BTree索引使用的是B树中的B+Tree，BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。<br>&emsp;&emsp;<br>&emsp;&emsp;  但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。<hr><hr>2.B树23、为什么说B+tree比B 树更适合实际应用中操作系统的文件索引和数据库索引？<hr>B+tree的磁盘读写代价更低，B+tree的查询效率更加稳定 数据库索引采用B+树而不是B树的主要原因：B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低。<br>&emsp;&emsp;<br>&emsp;&emsp;B+树的特点<br>&emsp;&emsp;<br>&emsp;&emsp;- 所有关键字都出现在叶子结点的链表中(稠密索引)，且链表中的关键字恰好是有序的;<br>&emsp;&emsp;- 不可能在非叶子结点命中;<br>&emsp;&emsp;- 非叶子结点相当于是叶子结点的索引(稀疏索引)，叶子结点相当于是存储(关键字)数据的数据层;<hr><hr>2.B树43、增加B+树的路数可以降低树的高度，那么无限增加树的路数是不是可以有最优的查找效率？<hr>不可以。因为这样会形成一个有序数组，文件系统和数据库的索引都是存在硬盘上的，并且如果数据量大的话，不一定能一次性加载到内存中。有序数组没法一次性加载进内存，这时候<font color=#FEAE00>B+</font><font color=#FEAE00>树的多路存储威力就出来了，可以每次加载</font><font color=#FEAE00>B+</font><font color=#FEAE00>树的一个结点，然后一步步往下找</font>，<hr><hr>2.B树48、为什么MySQL索引要使用B+树，而不是B树或者红黑树？<hr>我们在MySQL中的数据一般是放在磁盘中的，读取数据的时候肯定会有访问磁盘的操作，磁盘中有两个机械运动的部分，分别是盘片旋转和磁臂移动。盘片旋转就是我们市面上所提到的多少转每分钟，而磁盘移动则是在盘片旋转到指定位置以后，移动磁臂后开始进行数据的读写。那么这就存在一个定位到磁盘中的块的过程，而定位是磁盘的存取中花费时间比较大的一块，毕竟机械运动花费的时候要远远大于电子运动的时间。当大规模数据存储到磁盘中的时候，显然定位是一个非常花费时间的过程，但是我们可以通过B树进行优化，提高磁盘读取时定位的效率。<br>&emsp;&emsp;<br>&emsp;&emsp;为什么B类树可以进行优化呢？我们可以根据B类树的特点，构造一个多阶的B类树，然后在尽量多的在结点上存储相关的信息，保证层数（树的高度）尽量的少，以便后面我们可以更快的找到信息，磁盘的I/O操作也少一些，而且B类树是平衡树，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的。<br>&emsp;&emsp;<br>&emsp;&emsp;特别地：只有B-树和B+树，这里的B-树是叫B树，不是B减树，没有B减树的说法。<hr><hr>2.B树49、为什么MySQL索引适用用B+树而不用hash表和B树？<hr>- 利用Hash需要把数据全部加载到内存中，如果数据量大，是一件很消耗内存的事，而采用B+树，是基于按照节点分段加载，<font color=#FEAE00>由此减少内存消耗</font>。<br>&emsp;&emsp;- 和业务场景有段，对于唯一查找（查找一个值），Hash确实更快，但数据库中经常查询多条数据，这时候由于B+数据的有序性，与<font color=#FF644E>叶子节点又有链表相连，他的查询效率会比</font><font color=#FF644E>Hash</font><font color=#FF644E>快的多。</font><br>&emsp;&emsp;- b+树的非叶子节点不保存数据，只保存子树的临界值（最大或者最小），所以同样大小的节点，<font color=#FEAE00>b+</font><font color=#FEAE00>树相对于</font><font color=#FEAE00>b</font><font color=#FEAE00>树能够有更多的分支，使得这棵树更加矮胖</font>，查询时做的IO操作次数也更少。<hr><hr>2.B树50、既然Hash比B+树更快，为什么MySQL用<font color=#1DB100>B+</font><font color=#1DB100>树来存储索引呢</font>？<hr>范围查询, 矮壮, 便于 buffer poll交换<br>&emsp;&emsp;---<br>&emsp;&emsp;MySQL中存储索引用到的数据结构是B+树，<font color=#FEAE00>B+</font><font color=#FEAE00>树的查询时间跟树的高度有关，是</font><font color=#FEAE00>log(n)</font><font color=#FEAE00>，如果用</font><font color=#FEAE00>hash</font><font color=#FEAE00>存储，那么查询时间是</font><font color=#FEAE00>O(1)</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;采用Hash来存储确实要更快，但是采用B+树来存储索引的原因主要有以下两点：<br>&emsp;&emsp;<br>&emsp;&emsp;一、从内存角度上说，数据库中的索引一般是在<font color=#FEAE00>磁盘上，数据量大的情况可能无法一次性装入内存，</font><font color=#FEAE00>B+</font><font color=#FEAE00>树的设计可以允许数据分批加载</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;二、从业务场景上说，如果只选择一个数据那确实是hash更快，<font color=#FEAE00>但是数据库中经常会选中多条，这时候由于</font><font color=#FEAE00>B+</font><font color=#FEAE00>树索引有序</font>，并且又有链表相连，它的查询效率比hash就快很多了。<hr><hr>2.B树5、<font color=#FEAE00>MyISAM</font><font color=#FEAE00>和</font><font color=#FEAE00>InnoDB</font>实现<font color=#FEAE00>B</font><font color=#FEAE00>树</font>索引方式的区别是什么？<hr>- MyISAM，B+Tree叶节点的data域存放的是数据记录的地址，在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为<font color=#FEAE00>“非聚簇索引”</font><br>&emsp;&emsp;<br>&emsp;&emsp;- InnoDB，其数据文件本身就是索引文件，相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的节点data域保存了完整的数据记录，这个索引的key是数据表的主键，<font color=#FEAE00>因此</font><font color=#FEAE00>InnoDB</font><font color=#FEAE00>表数据文件本身就是主索引，这被称为“聚簇索引”或者聚集索引</font>，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。<br>&emsp;&emsp;<br>&emsp;&emsp;  在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。<hr><hr>2.主键4、Innodb为什么要用<font color=#FEAE00>自增</font><font color=#FEAE00>id</font><font color=#FEAE00>作为主键</font>？<hr>如果表使用自增主键，那么每次插入新的记录，记录就会<font color=#FEAE00>顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</font>。 如果使用<font color=#FEAE00>非自增主键</font>（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此<font color=#FEAE00>每次新纪录都要被插到现有索引页得中间某个位置</font>， 频繁的<font color=#FEAE00>移动、分页操作造成了大量的碎片，</font>得到了不够紧凑的索引结构，后续不得不通过<font color=#FEAE00>OPTIMIZE TABLE</font><font color=#FEAE00>（</font><font color=#FEAE00>optimize table</font><font color=#FEAE00>）</font>来重建表并优化填充页面。<hr><hr>2.索引25、什么时候需要建立数据库索引呢？<hr>在最频繁使用的、用以缩小查询范围的字段,需要排序的字段上建立索引。 不宜： 1）对于查询中很少涉及的列或者重复值比较多的列 2）对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等。<hr><hr>2.索引26、<font color=#FEAE00>覆盖索引</font>是什么？<hr>如果一个<font color=#FEAE00>索</font><font color=#FEAE00>=</font><font color=#FEAE00>引包含（或者说覆盖）所有需要查询的字段的值</font>，我们就称 之为“覆盖索引”。<br>&emsp;&emsp;<br>&emsp;&emsp;我们知道在InnoDB存储引 擎中，如果不是主键索引，<font color=#FEAE00>叶子节点存储的是主键</font><font color=#FEAE00>+</font><font color=#FEAE00>列值。最终还是要“回表”</font>，也就是要通过主键再查找一次,这样就 会比较慢。覆盖索引就是把要查询出的列和索引是对应的，<font color=#FEAE00>不做回表操作</font>！<hr><hr>2.索引34、什么是非<font color=#FEAE00>聚合索引</font>?<hr>如果您认识某个字，您可以快速地从自动中查到这个字。但您也可能会遇到您不认识的字，不知道它的发音，这时候，您就不能按照刚才的方法找到您要查的字，而 需要去根据"偏旁部首"查到您要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。但您结合"部首目录"和"检字表"而查到的字的排序并不是 真正的正文的排序方法，比如您查"张"字，我们可以看到在查部首之后的检字表中"张"的页码是672页，检字表中"张"的上面是"驰"字，但页码却是63 页，"张"的下面是"弩"字，页面是390页。很显然，这些字并不是真正的分别位于"张"字的上下方，现在您看到的连续的"驰、张、弩"三字实际上就是他 们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到您所需要的字，<font color=#FEAE00>但它需要两个过程，先找到目录中的结果，然后</font><font color=#FEAE00> </font><font color=#FEAE00>再翻到您所需要的页码。</font><br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#FEAE00>我们把</font><font color=#FEAE00>这种目录纯粹是目录，正文纯粹是正文的排序方式称为</font><font color=#FEAE00>"</font><font color=#FEAE00>非聚集索引</font><font color=#FEAE00>"</font><font color=#FEAE00>。</font><hr><hr>2.索引35、<font color=#FEAE00>聚集索引与非聚集索引</font>的区别是什么?<hr>聚集索引和非聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据。 聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#FEAE00>聚集索引（</font><font color=#FEAE00>Innodb</font><font color=#FEAE00>）的叶节点就是数据节点，而非聚集索引</font><font color=#FEAE00>(MyisAM)</font><font color=#FEAE00>的叶节点仍然是索引节点，只不过其包含一个指向对应数据块的指针。</font><hr><hr>2.索引36、<font color=#FEAE00>创建索引</font>时需要注意什么？<hr><font color=#FEAE00>非空字段：应该指定列为</font><font color=#FEAE00>NOT NULL</font>，除非你想存储NULL。在 MySQL 中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#FEAE00>取值离散大的字段</font>：（变量各个取值之间的差异程度）<font color=#FEAE00>的列放到联合索引的前面，</font>可以通过<font color=#FEAE00>count()</font><font color=#FEAE00>函数查看字段的差异值</font>，返回值越大说明字段的唯一值越多字段的离散程度高；<br>&emsp;&emsp;<br>&emsp;&emsp;索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。 <font color=#FEAE00>唯一、不为空、经常被查询的字段</font><font color=#FEAE00> </font>的字段适合建索引<hr><hr>2.索引38、MySQL <font color=#FEAE00>索引使用的注意事项</font><hr>MySQL 索引通常是被用于提高 WHERE 条件的数据行匹配时的搜索速度，在索引的使用过程中，存在一些使用细节和注意事项。<br>&emsp;&emsp;<br>&emsp;&emsp;函数，运算，否定操作符，连接条件，多个单列索引，最左前缀原则，范围查询，不会包含有NULL值的列，like 语句不要在列上使用函数和进行运算<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-02-MySQL.html#_1-不要在列上使用函数-这将导致索引失效而进行全表扫描。)1）不要在列上使用函数，这将导致索引失效而进行全表扫描。<br>&emsp;&emsp;<br>&emsp;&emsp;```text<br>&emsp;&emsp;select * from news where year(publish_time) < 2017<br>&emsp;&emsp; <br>&emsp;&emsp;        @阿秀: 代码已成功复制到剪贴板<br>&emsp;&emsp;    <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;1<br>&emsp;&emsp;<br>&emsp;&emsp;为了使用索引，防止执行全表扫描，可以进行改造。<br>&emsp;&emsp;<br>&emsp;&emsp;```text<br>&emsp;&emsp;select * from news where publish_time < '2017-01-01'<br>&emsp;&emsp; <br>&emsp;&emsp;        @阿秀: 代码已成功复制到剪贴板<br>&emsp;&emsp;    <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;1<br>&emsp;&emsp;<br>&emsp;&emsp;还有一个建议，不要在列上进行运算，这也将导致索引失效而进行全表扫描。<br>&emsp;&emsp;<br>&emsp;&emsp;```text<br>&emsp;&emsp;select * from news where id / 100 = 1<br>&emsp;&emsp; <br>&emsp;&emsp;        @阿秀: 代码已成功复制到剪贴板<br>&emsp;&emsp;    <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;1<br>&emsp;&emsp;<br>&emsp;&emsp;为了使用索引，防止执行全表扫描，可以进行改造。<br>&emsp;&emsp;<br>&emsp;&emsp;```text<br>&emsp;&emsp;select * from news where id = 1 * 100<br>&emsp;&emsp; <br>&emsp;&emsp;        @阿秀: 代码已成功复制到剪贴板<br>&emsp;&emsp;    <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;1<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-02-MySQL.html#_2-尽量避免使用-或-not-in或-等否定操作符)2）尽量避免使用 != 或 not in或 <> 等否定操作符<br>&emsp;&emsp;<br>&emsp;&emsp;应该尽量避免在 where 子句中使用 != 或 not in 或 <> 操作符，因为这几个操作符都会导致索引失效而进行全表扫描。尽量避免使用 or 来连接条件 应该尽量避免在 where 子句中使用 or 来连接条件，因为这会导致索引失效而进行全表扫描。<br>&emsp;&emsp;<br>&emsp;&emsp;```text<br>&emsp;&emsp;select * from news where id = 1 or id = 2<br>&emsp;&emsp; <br>&emsp;&emsp;        @阿秀: 代码已成功复制到剪贴板<br>&emsp;&emsp;    <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;1<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-02-MySQL.html#_3-多个单列索引并不是最佳选择)3）多个单列索引并不是最佳选择<br>&emsp;&emsp;<br>&emsp;&emsp;MySQL 只能使用一个索引，会从多个索引中选择一个限制最为严格的索引，因此，为多个列创建单列索引，并不能提高 MySQL 的查询性能。 假设，有两个单列索引，分别为 news_year_idx(news_year) 和 news_month_idx(news_month)。现在，有一个场景需要针对资讯的年份和月份进行查询，那么，SQL 语句可以写成：<br>&emsp;&emsp;<br>&emsp;&emsp;```text<br>&emsp;&emsp;select * from news where news_year = 2017 and news_month = 1<br>&emsp;&emsp; <br>&emsp;&emsp;        @阿秀: 代码已成功复制到剪贴板<br>&emsp;&emsp;    <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;1<br>&emsp;&emsp;<br>&emsp;&emsp;事实上，MySQL 只能使用一个单列索引。为了提高性能，可以使用复合索引 news_year_month_idx(news_year, news_month) 保证 news_year 和 news_month 两个列都被索引覆盖。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-02-MySQL.html#_4-复合索引的最左前缀原则)4）复合索引的最左前缀原则<br>&emsp;&emsp;<br>&emsp;&emsp;复合索引遵守“最左前缀”原则，即在查询条件中使用了复合索引的第一个字段，索引才会被使用。因此，在复合索引中索引列的顺序至关重要。如果不是按照索引的最左列开始查找，则无法使用索引。 假设，有一个场景只需要针对资讯的月份进行查询，那么，SQL 语句可以写成：<br>&emsp;&emsp;<br>&emsp;&emsp;```text<br>&emsp;&emsp;select * from news where news_month = 1<br>&emsp;&emsp; <br>&emsp;&emsp;        @阿秀: 代码已成功复制到剪贴板<br>&emsp;&emsp;    <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;1<br>&emsp;&emsp;<br>&emsp;&emsp;此时，无法使用 news_year_month_idx(news_year, news_month) 索引，因为遵守“最左前缀”原则，在查询条件中没有使用复合索引的第一个字段，索引是不会被使用的。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-02-MySQL.html#_5-覆盖索引的好处)5）覆盖索引的好处<br>&emsp;&emsp;<br>&emsp;&emsp;如果一个索引包含所有需要的查询的字段的值，直接根据索引的查询结果返回数据，而无需读表，能够极大的提高性能。因此，可以定义一个让索引包含的额外的列，即使这个列对于索引而言是无用的。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-02-MySQL.html#_6-范围查询对多列查询的影响)6）范围查询对多列查询的影响<br>&emsp;&emsp;<br>&emsp;&emsp;查询中的某个列有范围查询，则其右边所有列都无法使用索引优化查找。 举个例子，假设有一个场景需要查询本周发布的资讯文章，其中的条件是必须是启用状态，且发布时间在这周内。那么，SQL 语句可以写成：<br>&emsp;&emsp;<br>&emsp;&emsp;```text<br>&emsp;&emsp;select * from news where publish_time >= '2017-01-02' and publish_time <= '2017-01-08' and enable = 1<br>&emsp;&emsp; <br>&emsp;&emsp;        @阿秀: 代码已成功复制到剪贴板<br>&emsp;&emsp;    <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;1<br>&emsp;&emsp;<br>&emsp;&emsp;这种情况下，因为范围查询对多列查询的影响，将导致 news_publish_idx(publish_time, enable) 索引中 publish_time 右边所有列都无法使用索引优化查找。换句话说，news_publish_idx(publish_time, enable) 索引等价于 news_publish_idx(publish_time) 。 对于这种情况，我的建议：对于范围查询，务必要注意它带来的副作用，并且尽量少用范围查询，可以通过曲线救国的方式满足业务场景。 例如，上面案例的需求是查询本周发布的资讯文章，因此可以创建一个news_weekth 字段用来存储资讯文章的周信息，使得范围查询变成普通的查询，SQL 可以改写成：<br>&emsp;&emsp;<br>&emsp;&emsp;```text<br>&emsp;&emsp;select * from news where news_weekth = 1 and enable = 1<br>&emsp;&emsp;<br>&emsp;&emsp; <br>&emsp;&emsp;        @阿秀: 代码已成功复制到剪贴板<br>&emsp;&emsp;    <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;1<br>&emsp;&emsp;2<br>&emsp;&emsp;<br>&emsp;&emsp;然而，并不是所有的范围查询都可以进行改造，对于必须使用范围查询但无法改造的情况，我的建议：不必试图用 SQL 来解决所有问题，可以使用其他数据存储技术控制时间轴，例如 Redis 的 SortedSet 有序集合保存时间，或者通过缓存方式缓存查询结果从而提高性能。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-02-MySQL.html#_7-索引不会包含有null值的列)7）索引不会包含有NULL值的列<br>&emsp;&emsp;<br>&emsp;&emsp;只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL值，那么这一列对于此复合索引就是无效的。 因此，在数据库设计时，除非有一个很特别的原因使用 NULL 值，不然尽量不要让字段的默认值为 NULL。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-02-MySQL.html#_8-隐式转换的影响)8）隐式转换的影响<br>&emsp;&emsp;<br>&emsp;&emsp;当查询条件左右两侧类型不匹配的时候会发生隐式转换，隐式转换带来的影响就是可能导致索引失效而进行全表扫描。下面的案例中，date_str 是字符串，然而匹配的是整数类型，从而发生隐式转换。<br>&emsp;&emsp;<br>&emsp;&emsp;```text<br>&emsp;&emsp;select * from news where date_str = 201701<br>&emsp;&emsp;<br>&emsp;&emsp; <br>&emsp;&emsp;        @阿秀: 代码已成功复制到剪贴板<br>&emsp;&emsp;    <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;1<br>&emsp;&emsp;2<br>&emsp;&emsp;<br>&emsp;&emsp;因此，要谨记隐式转换的危害，时刻注意通过同类型进行比较。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-02-MySQL.html#_9-like-语句的索引失效问题)9）like 语句的索引失效问题<br>&emsp;&emsp;<br>&emsp;&emsp;like 的方式进行查询，在 like “value%” 可以使用索引，但是对于 like “%value%” 这样的方式，执行全表查询，这在数据量小的表，不存在性能问题，但是对于海量数据，全表扫描是非常可怕的事情。所以，根据业务需求，考虑使用 ElasticSearch 或 Solr 是个不错的方案。<hr><hr>2.索引39、MySQL中有哪些索引？有什么特点？<hr>- 普通索引：仅加速查询<br>&emsp;&emsp;- 唯一索引：加速查询 + 列值唯一（可以有null）<br>&emsp;&emsp;- 主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个<br>&emsp;&emsp;- 组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并<br>&emsp;&emsp;- 全文索引：对文本的内容进行分词，进行搜索<br>&emsp;&emsp;- 索引合并：使用多个单列索引组合搜索<br>&emsp;&emsp;- 覆盖索引：select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖<br>&emsp;&emsp;- 聚簇索引：表数据是和主键一起存储的，主键索引的叶结点存储行数据(包含了主键值)，<font color=#FEAE00>二级索引的叶结点存储行的主键值</font>。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)<hr><hr>2.索引3、为什么<font color=#FEAE00>使用索引</font>？<hr>类似于书本前面的目录吧<br>&emsp;&emsp;- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。<br>&emsp;&emsp;- 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。<br>&emsp;&emsp;- 帮助服务器避免排序和临时表<br>&emsp;&emsp;- 将随机IO变为顺序IO。<br>&emsp;&emsp;- 可以<font color=#FEAE00>加速表和表之间的连接，特别是在实现数据的参考完整性方</font>面特别有意义。<hr><hr>2.索引40、既然索引有那么多优点，为什么不对表总的每一列创建一个索引呢？<hr>- 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。<br>&emsp;&emsp;- 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立簇索引，那么需要的空间就会更大。<br>&emsp;&emsp;- 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加<hr><hr>2.索引42、使用<font color=#FEAE00>索引的注意事项</font><hr>- <font color=#FEAE00>在经常需要搜索的列上</font>，可以加快搜索的速度；<br>&emsp;&emsp;- 在经常使用在where子句中的列上面创建索引，加快条件的判断速度。<br>&emsp;&emsp;- 将打算加索引的列设置为NOT NULL，否则将导致引擎放弃使用索引而进行全表扫描<br>&emsp;&emsp;- 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间<br>&emsp;&emsp;<br>&emsp;&emsp;- 避免where子句中对字段施加函数，这会造成无法命中索引<br>&emsp;&emsp;- 在中到大型表索引都是非常有效的，但是特大型表的维护开销会很大，不适合建索引，建立用逻辑索引<br>&emsp;&emsp;<br>&emsp;&emsp;- 在经常用到连续的列上，这些列主要是由一些外键，可以加快连接的速度<br>&emsp;&emsp;- 与业务无关时多使用逻辑主键，也就是自增主键在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。<br>&emsp;&emsp;- 删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗<br>&emsp;&emsp;- 在使用limit offset查询缓存时，可以借助索引来提高性能。<hr><hr>22、如何保证缓存与数据库双写时的数据一致性<hr>首先说一句，你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如 何解决一致性问题？<br>&emsp;&emsp;<br>&emsp;&emsp;一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的 情况，最好不要做这个方案，最好将读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况。<br>&emsp;&emsp;<br>&emsp;&emsp;串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。<br>&emsp;&emsp;<br>&emsp;&emsp;最经典的缓存+数据库读写的模式，就是 预留缓存模式Cache Aside Pattern。<br>&emsp;&emsp;<br>&emsp;&emsp;- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。<br>&emsp;&emsp;- 更新的时候，先删除缓存，然后再更新数据库，这样读的时候就会发现缓存中没有数据而直接去数据库中拿数据了。（因为要删除，狗日的编辑器可能会背着你做一些优化，要彻底将缓存中的数据进行删除才行）<br>&emsp;&emsp;<br>&emsp;&emsp;互联网公司非常喜欢问这道面试题因为缓存在互联网公司使用非常频繁<br>&emsp;&emsp;<br>&emsp;&emsp;在高并发的业务场景下，数据库的性能瓶颈往往都是用户并发访问过大。所以，一般都使用Redis做一个缓冲操作，让请求先访问到Redis，而不是直接去访问MySQL等数据库，从而减少网络请求的延迟响应.<hr><hr>26、Redis 如何才能做到高可用？<hr>如果系统在 365 天内，有 99.99% 的时间，都是可以哗哗对外提供服务的，那么就说系统是高可用的。<br>&emsp;&emsp;<br>&emsp;&emsp;一个 slave 挂掉了，是不会影响可用性的，还有其它的 slave 在提供相同数据下的相同的对外的查询服务。<br>&emsp;&emsp;<br>&emsp;&emsp;但是，如果 master node 死掉了，会怎么样？没法写数据了，写缓存的时候，全部失效了。slave node 还有什么用呢，没有 master 给它们复制数据了，系统相当于不可用了。<br>&emsp;&emsp;<br>&emsp;&emsp;Redis 的高可用架构，叫做 `failover` 故障转移，也可以叫做主备切换。<br>&emsp;&emsp;<br>&emsp;&emsp;master node 在故障时，自动检测，并且将某个 slave node 自动切换为 master node 的过程，叫做主备切换。这个过程，实现了 Redis 的主从架构下的高可用。<hr><hr>28、如何保证缓存与数据库的双写一致性？<hr>##### 你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？<br>&emsp;&emsp;<br>&emsp;&emsp;### Cache Aside Pattern<br>&emsp;&emsp;<br>&emsp;&emsp;最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。<br>&emsp;&emsp;<br>&emsp;&emsp;- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。<br>&emsp;&emsp;- 更新的时候，先更新数据库，然后再删除缓存。<br>&emsp;&emsp;<br>&emsp;&emsp;为什么是删除缓存，而不是更新缓存？<br>&emsp;&emsp;<br>&emsp;&emsp;原因很简单，很多时候，在复杂点的缓存场景，缓存不单单是数据库中直接取出来的值。<br>&emsp;&emsp;<br>&emsp;&emsp;比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据并进行运算，才能计算出缓存最新的值的。<br>&emsp;&emsp;<br>&emsp;&emsp;另外更新缓存的代价有时候是很高的。是不是说，每次修改数据库的时候，都一定要将其对应的缓存更新一份？也许有的场景是这样，但是对于比较复杂的缓存数据计算的场景，就不是这样了。如果你频繁修改一个缓存涉及的多个表，缓存也频繁更新。但是问题在于，这个缓存到底会不会被频繁访问到？<br>&emsp;&emsp;<br>&emsp;&emsp;举个栗子，一个缓存涉及的表的字段，在 1 分钟内就修改了 20 次，或者是 100 次，那么缓存更新 20 次、100 次；但是这个缓存在 1 分钟内只被读取了 1 次，有大量的冷数据。实际上，如果你只是删除缓存的话，那么在 1 分钟内，这个缓存不过就重新计算一次而已，开销大幅度降低。用到缓存才去算缓存。<br>&emsp;&emsp;<br>&emsp;&emsp;其实删除缓存，而不是更新缓存，就是一个 lazy 计算的思想，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算。像 mybatis，hibernate，都有懒加载思想。查询一个部门，部门带了一个员工的 list，没有必要说每次查询部门，都把里面的 1000 个员工的数据也同时查出来啊。80% 的情况，查这个部门，就只是要访问这个部门的信息就可以了。先查部门，同时要访问里面的员工，那么这个时候只有在你要访问里面的员工的时候，才会去数据库里面查询 1000 个员工。<br>&emsp;&emsp;<br>&emsp;&emsp;### 最初级的缓存不一致问题及解决方案<br>&emsp;&emsp;<br>&emsp;&emsp;问题：先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。<br>&emsp;&emsp;<br>&emsp;&emsp;![redis-junior-inconsistent](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202208092301684.png)<br>&emsp;&emsp;<br>&emsp;&emsp;解决思路 1：先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。<br>&emsp;&emsp;<br>&emsp;&emsp;解决思路 2：延时双删。依旧是先更新数据库，再删除缓存，唯一不同的是，我们把这个删除的动作，在不久之后再执行一次，比如 5s 之后。<br>&emsp;&emsp;<br>&emsp;&emsp;```java<br>&emsp;&emsp;public void set(key, value) {<br>&emsp;&emsp;    putToDb(key, value);<br>&emsp;&emsp;    deleteFromRedis(key);<br>&emsp;&emsp;<br>&emsp;&emsp;    // ... a few seconds later<br>&emsp;&emsp;    deleteFromRedis(key);<br>&emsp;&emsp;}<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;删除的动作，可以有多种选择，比如：1. 使用 `DelayQueue`，会随着 JVM 进程的死亡，丢失更新的风险；2. 放在 `MQ`，但编码复杂度为增加。总之，我们需要综合各种因素去做设计，选择一个最合理的解决方案。<br>&emsp;&emsp;<br>&emsp;&emsp;### 比较复杂的数据不一致问题分析<br>&emsp;&emsp;<br>&emsp;&emsp;数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中。随后数据变更的程序完成了数据库的修改。完了，数据库和缓存中的数据不一样了...<br>&emsp;&emsp;<br>&emsp;&emsp;为什么上亿流量高并发场景下，缓存会出现这个问题？<br>&emsp;&emsp;<br>&emsp;&emsp;只有在对一个数据在并发的进行读写的时候，才可能会出现这种问题。其实如果说你的并发量很低的话，特别是读并发很低，每天访问量就 1 万次，那么很少的情况下，会出现刚才描述的那种不一致的场景。但是问题是，如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，就可能会出现上述的数据库+缓存不一致的情况。<br>&emsp;&emsp;<br>&emsp;&emsp;解决方案如下：<br>&emsp;&emsp;<br>&emsp;&emsp;更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个 jvm 内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新执行“读取数据+更新缓存”的操作，根据唯一标识路由之后，也发送到同一个 jvm 内部队列中。<br>&emsp;&emsp;<br>&emsp;&emsp;一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，没有读到缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。<br>&emsp;&emsp;<br>&emsp;&emsp;这里有一个优化点，一个队列中，其实多个更新缓存请求串在一起是没意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。<br>&emsp;&emsp;<br>&emsp;&emsp;待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。<br>&emsp;&emsp;<br>&emsp;&emsp;如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。<br>&emsp;&emsp;<br>&emsp;&emsp;高并发的场景下，该解决方案要注意的问题：<br>&emsp;&emsp;<br>&emsp;&emsp;- 读请求长时阻塞<br>&emsp;&emsp;<br>&emsp;&emsp;由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时时间范围内返回。<br>&emsp;&emsp;<br>&emsp;&emsp;该解决方案，最大的风险点在于说，可能数据更新很频繁，导致队列中积压了大量更新操作在里面，然后读请求会发生大量的超时，最后导致大量的请求直接走数据库。务必通过一些模拟真实的测试，看看更新数据的频率是怎样的。<br>&emsp;&emsp;<br>&emsp;&emsp;另外一点，因为一个队列中，可能会积压针对多个数据项的更新操作，因此需要根据自己的业务情况进行测试，可能需要部署多个服务，每个服务分摊一些数据的更新操作。如果一个内存队列里居然会挤压 100 个商品的库存修改操作，每个库存修改操作要耗费 10ms 去完成，那么最后一个商品的读请求，可能等待 10 * 100 = 1000ms = 1s 后，才能得到数据，这个时候就导致读请求的长时阻塞。<br>&emsp;&emsp;<br>&emsp;&emsp;一定要做根据实际业务系统的运行情况，去进行一些压力测试，和模拟线上环境，去看看最繁忙的时候，内存队列可能会挤压多少更新操作，可能会导致最后一个更新操作对应的读请求，会 hang 多少时间，如果读请求在 200ms 返回，如果你计算过后，哪怕是最繁忙的时候，积压 10 个更新操作，最多等待 200ms，那还可以的。<br>&emsp;&emsp;<br>&emsp;&emsp;如果一个内存队列中可能积压的更新操作特别多，那么你就要加机器，让每个机器上部署的服务实例处理更少的数据，那么每个内存队列中积压的更新操作就会越少。<br>&emsp;&emsp;<br>&emsp;&emsp;其实根据之前的项目经验，一般来说，数据的写频率是很低的，因此实际上正常来说，在队列中积压的更新操作应该是很少的。像这种针对读高并发、读缓存架构的项目，一般来说写请求是非常少的，每秒的 QPS 能到几百就不错了。<br>&emsp;&emsp;<br>&emsp;&emsp;我们来实际粗略测算一下。<br>&emsp;&emsp;<br>&emsp;&emsp;如果一秒有 500 的写操作，如果分成 5 个时间片，每 200ms 就 100 个写操作，放到 20 个内存队列中，每个内存队列，可能就积压 5 个写操作。每个写操作性能测试后，一般是在 20ms 左右就完成，那么针对每个内存队列的数据的读请求，也就最多 hang 一会儿，200ms 以内肯定能返回了。<br>&emsp;&emsp;<br>&emsp;&emsp;经过刚才简单的测算，我们知道，单机支撑的写 QPS 在几百是没问题的，如果写 QPS 扩大了 10 倍，那么就扩容机器，扩容 10 倍的机器，每个机器 20 个队列。<br>&emsp;&emsp;<br>&emsp;&emsp;- 读请求并发量过高<br>&emsp;&emsp;<br>&emsp;&emsp;这里还必须做好压力测试，确保恰巧碰上上述情况的时候，还有一个风险，就是突然间大量读请求会在几十毫秒的延时 hang 在服务上，看服务能不能扛的住，需要多少机器才能扛住最大的极限情况的峰值。<br>&emsp;&emsp;<br>&emsp;&emsp;但是因为并不是所有的数据都在同一时间更新，缓存也不会同一时间失效，所以每次可能也就是少数数据的缓存失效了，然后那些数据对应的读请求过来，并发量应该也不会特别大。<br>&emsp;&emsp;<br>&emsp;&emsp;- 多服务实例部署的请求路由<br>&emsp;&emsp;<br>&emsp;&emsp;可能这个服务部署了多个实例，那么必须保证说，执行数据更新操作，以及执行缓存更新操作的请求，都通过 Nginx 服务器路由到相同的服务实例上。<br>&emsp;&emsp;<br>&emsp;&emsp;比如说，对同一个商品的读写请求，全部路由到同一台机器上。可以自己去做服务间的按照某个请求参数的 hash 路由，也可以用 Nginx 的 hash 路由功能等等。<br>&emsp;&emsp;<br>&emsp;&emsp;- 热点商品的路由问题，导致请求的倾斜<br>&emsp;&emsp;<br>&emsp;&emsp;万一某个商品的读写请求特别高，全部打到相同的机器的相同的队列里面去了，可能会造成某台机器的压力过大。就是说，因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以其实要根据业务系统去看，如果更新频率不是太高的话，这个问题的影响并不是特别大，但是的确可能某些机器的负载会高一些。<hr><hr>2、Redis的五种数据结构整理<hr>### 简单动态字符串(Simple Dynamic String，SDS)<br>&emsp;&emsp;<br>&emsp;&emsp;Redis没有直接使用C语言传统的字符串，而是自己构建了一种名为简单动态字符串（Simple dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。<br>&emsp;&emsp;<br>&emsp;&emsp;其实SDS等同于C语言中的char * ，但它可以存储任意二进制数据，不能像C语言字符串那样以字符’\0’来标识字符串的结 束，因此它必然有个长度字段。<br>&emsp;&emsp;<br>&emsp;&emsp;定义<br>&emsp;&emsp;<br>&emsp;&emsp;```c<br>&emsp;&emsp;struct sdshdr {<br>&emsp;&emsp;    // 记录buf数组中已使用字节的数量<br>&emsp;&emsp;    // 等于sds所保存字符串的长度<br>&emsp;&emsp;    int len;<br>&emsp;&emsp;    <br>&emsp;&emsp;    // 记录buf数组中未使用字节的数量<br>&emsp;&emsp;    int free;<br>&emsp;&emsp;    <br>&emsp;&emsp;    // 字节数组，用于保存字符串<br>&emsp;&emsp;    char buf[];<br>&emsp;&emsp;}<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;优点<br>&emsp;&emsp;<br>&emsp;&emsp;- 获取字符串长度的复杂度为O(1)。<br>&emsp;&emsp;- 杜绝缓冲区溢出。<br>&emsp;&emsp;- 减少修改字符串长度时所需要的内存重分配次数。<br>&emsp;&emsp;- 二进制安全。<br>&emsp;&emsp;- 兼容部分C字符串函数。<br>&emsp;&emsp;<br>&emsp;&emsp;它具有很常规的 set/get 操作，value 可以是String也可以是数字，一般做一些复杂的计数功能的缓存。<br>&emsp;&emsp;<br>&emsp;&emsp;### 链表<br>&emsp;&emsp;<br>&emsp;&emsp;当有一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的额字符串时，Redis就会使用链表作为列表建的底层实现。<br>&emsp;&emsp;<br>&emsp;&emsp;节点底层结构<br>&emsp;&emsp;<br>&emsp;&emsp;```c<br>&emsp;&emsp;typedef struct listNode {<br>&emsp;&emsp;    // 前置节点<br>&emsp;&emsp;    struct listNode *prev;<br>&emsp;&emsp;    // 后置节点<br>&emsp;&emsp;    struct listNode *next;<br>&emsp;&emsp;    // 节点的值<br>&emsp;&emsp;    void *value;<br>&emsp;&emsp;} listNode;<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;list底层结构<br>&emsp;&emsp;<br>&emsp;&emsp;```c<br>&emsp;&emsp;typedef struct list {<br>&emsp;&emsp;    // 表头节点<br>&emsp;&emsp;    listNode *head;<br>&emsp;&emsp;    // 表尾节点<br>&emsp;&emsp;    listNode *tail;<br>&emsp;&emsp;    // 链表所包含的节点数量<br>&emsp;&emsp;    unsigned long len;<br>&emsp;&emsp;    // 节点值复制函数<br>&emsp;&emsp;    void *(*dup)(void *ptr);<br>&emsp;&emsp;    // 节点值是放过函数<br>&emsp;&emsp;    void (*free)(void *ptr);<br>&emsp;&emsp;    // 节点值对比函数<br>&emsp;&emsp;    int（*match）(void *ptr, void *key);<br>&emsp;&emsp;} list;<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;特性<br>&emsp;&emsp;<br>&emsp;&emsp;- 链表被广泛用于实现Redis的各种功能，比如列表建、发布与订阅、慢查询、监视器等。<br>&emsp;&emsp;- 每个链表节点由一个listNode结构来表示，每个节点都有一个指向前置节点和后置节点的指针，所以Redis的链表实现是双端链表。<br>&emsp;&emsp;- 每个链表使用一个list结构表示，这个结构带有表头节点指针、表尾节点指针，以及链表长度等信息。<br>&emsp;&emsp;- 因为链表表头的前置节点和表尾节点的后置节点都指向NULL，所以Redis的链表实现是无环链表。<br>&emsp;&emsp;- 通过为链表设置不同的类型特定函数，Redis的链表可以用于保存各种不同类型的值。<br>&emsp;&emsp;<br>&emsp;&emsp;### 字典<br>&emsp;&emsp;<br>&emsp;&emsp;字典的底层是哈希表，类似 C++中的 map ，也就是键值对。<br>&emsp;&emsp;<br>&emsp;&emsp;### 哈希表<br>&emsp;&emsp;<br>&emsp;&emsp;```c<br>&emsp;&emsp;typedef struct dictht {<br>&emsp;&emsp;    // 哈希表数组<br>&emsp;&emsp;    dictEntry **table;<br>&emsp;&emsp;    // 哈希表大小<br>&emsp;&emsp;    unsigned long size;<br>&emsp;&emsp;    // 哈希表大小掩码，用于计算索引值<br>&emsp;&emsp;    // 总是等于size-1<br>&emsp;&emsp;    unsigned long sizemark;<br>&emsp;&emsp;    // 该哈希表已有节点的数量<br>&emsp;&emsp;    unsigned long used;<br>&emsp;&emsp;} dichht;<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;哈希算法<br>&emsp;&emsp;<br>&emsp;&emsp;当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash算法。这种算法的优点在于即使输入的键是规律的，算法仍能给出一个个很好的随机分布性，并且算法的计算速度非常快。<br>&emsp;&emsp;<br>&emsp;&emsp;哈希冲突的解决方式<br>&emsp;&emsp;<br>&emsp;&emsp;Redis的哈希表使用链地址法来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用这个单向链表连接起来，这就解决了键冲突的问题。<br>&emsp;&emsp;<br>&emsp;&emsp;特性<br>&emsp;&emsp;<br>&emsp;&emsp;1. 字典被广泛用于实现Redis的各种功能，其中包括数据库和哈希键。<br>&emsp;&emsp;2. Redis中的字典使用哈希表作为底层结构实现，每个字典带有两个哈希表，一个平时使用，另一个仅在进行rehash时使用。<br>&emsp;&emsp;3. Redis使用MurmurHash2算法来计算键的哈希值。<br>&emsp;&emsp;4. 哈希表使用链地址法来解决键冲突。<br>&emsp;&emsp;<br>&emsp;&emsp;### 跳跃表<br>&emsp;&emsp;<br>&emsp;&emsp;先看这样一张图： ![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220024713.png)<br>&emsp;&emsp;<br>&emsp;&emsp;如上图，我们要查找一个元素，就需要从头节点开始遍历，直到找到对应的节点或者是第一个大于要查找的元素的节点（没找到）。时间复杂度为O(N)。<br>&emsp;&emsp;<br>&emsp;&emsp;这个查找效率是比较低的，但如果我们把列表的某些节点拔高一层，如下图，例如把每两个节点中有一个节点变成两层。那么第二层的节点只有第一层的一半，查找效率也就会提高。<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220024190.png)<br>&emsp;&emsp;<br>&emsp;&emsp;查找的步骤是从头节点的顶层开始，查到第一个大于指定元素的节点时，退回上一节点，在下一层继续查找。<br>&emsp;&emsp;<br>&emsp;&emsp;比如我们要查找16：<br>&emsp;&emsp;<br>&emsp;&emsp;1. 从头节点的最顶层开始，先到节点7。<br>&emsp;&emsp;2. 7的下一个节点是39，大于16，因此我们退回到7<br>&emsp;&emsp;3. 从7开始，在下一层继续查找，就可以找到16。<br>&emsp;&emsp;<br>&emsp;&emsp;这个例子中遍历的节点不比一维列表少，但是当节点更多，查找的数字更大时，这种做法的优势就体现出来了。还是上面的例子，如果我们要查找的是39，那么只需要访问两个节点（7、39）就可以找到了。这比一维列表要减少一半的数量。<br>&emsp;&emsp;<br>&emsp;&emsp;为了避免插入操作的时间复杂度是O(N)，skiplist每层的数量不会严格按照2:1的比例，而是对每个要插入的元素随机一个层数。<br>&emsp;&emsp;<br>&emsp;&emsp;随机层数的计算过程如下：<br>&emsp;&emsp;<br>&emsp;&emsp;1. 每个节点都有第一层<br>&emsp;&emsp;2. 那么它有第二层的概率是p，有第三层的概率是p*p<br>&emsp;&emsp;3. 不能超过最大层数<br>&emsp;&emsp;<br>&emsp;&emsp;zskiplistNode<br>&emsp;&emsp;<br>&emsp;&emsp;```c<br>&emsp;&emsp;typedef struct zskiplistNode {<br>&emsp;&emsp;    // 后退指针<br>&emsp;&emsp;    struct zskiplistNode *backward;<br>&emsp;&emsp;    // 分值 权重<br>&emsp;&emsp;    double score;<br>&emsp;&emsp;    // 成员对象<br>&emsp;&emsp;    robj *obj;<br>&emsp;&emsp;    // 层<br>&emsp;&emsp;    struct zskiplistLevel {<br>&emsp;&emsp;        // 前进指针<br>&emsp;&emsp;        struct zskiplistNode *forward;<br>&emsp;&emsp;        // 跨度<br>&emsp;&emsp;        unsigned int span;<br>&emsp;&emsp;    } leval[];<br>&emsp;&emsp;} zskiplistNode;<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;一般来说，层的数量越多，访问其他节点的速度越快。<br>&emsp;&emsp;<br>&emsp;&emsp;zskipList<br>&emsp;&emsp;<br>&emsp;&emsp;```c<br>&emsp;&emsp;typedef struct zskiplist {<br>&emsp;&emsp;    // 表头节点和表尾节点<br>&emsp;&emsp;    struct zskiplistNode *header, *tail;<br>&emsp;&emsp;    // 表中节点的数量<br>&emsp;&emsp;    unsigned long length;<br>&emsp;&emsp;    // 表中层数最大的节点的层数<br>&emsp;&emsp;    int leval;<br>&emsp;&emsp;} zskiplist;<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;特性<br>&emsp;&emsp;<br>&emsp;&emsp;- 跳跃表是有序集合的底层实现之一<br>&emsp;&emsp;- Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点<br>&emsp;&emsp;- 每个跳跃表节点的层高都是1至32之间的随机数<br>&emsp;&emsp;- 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。<br>&emsp;&emsp;- 跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。<br>&emsp;&emsp;- 跳表是一种实现起来很简单，单层多指针的链表，它查找效率很高，堪比优化过的二叉平衡树，且比平衡树的实现。<br>&emsp;&emsp;<br>&emsp;&emsp;### 压缩列表<br>&emsp;&emsp;<br>&emsp;&emsp;> 压缩列表(ziplist)是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。<br>&emsp;&emsp;<br>&emsp;&emsp;特性<br>&emsp;&emsp;<br>&emsp;&emsp;看他的名字就能看出来，是为了节省内存造的列表结构。<hr><hr>3.1 <font color=#FEAE00>索引</font>常见面试题 大纲<hr>大家好，我是小林。<br>&emsp;&emsp;面试中，MySQL 索引相关的问题基本都是一系列问题，都是先从<font color=#FEAE00>索引的基本原理</font>，再到<font color=#FEAE00>索引的使用场景</font>，比如：<br>&emsp;&emsp;	•	索引底层使用了什么<font color=#FEAE00>数据结构和算法</font>？<br>&emsp;&emsp;	•	为什么 MySQL InnoDB 选择 <font color=#FEAE00>B+tree</font> 作为索引的数据结构？<br>&emsp;&emsp;	•	什么时候<font color=#FEAE00>适用索引</font>？<br>&emsp;&emsp;	•	什么时候<font color=#FEAE00>不需要创建索引</font>？<br>&emsp;&emsp;	•	什么情况下<font color=#FEAE00>索引会失效</font>？<br>&emsp;&emsp;	•	有什么<font color=#FEAE00>优化索引</font>的方法？<br>&emsp;&emsp;	•	.....<br>&emsp;&emsp;今天就带大家，夯实 MySQL 索引的知识点。<br>&emsp;&emsp;￼<hr><hr>3.2 从数据页的角度看 B+ 树<hr>大家背八股文的时候，都知道 MySQL 里 InnoDB 存储引擎是采用 B+ 树来组织数据的。<br>&emsp;&emsp;这点没错，但是大家知道 <font color=#FEAE00>B+ </font><font color=#FEAE00>树里的节点里存放的是什么呢</font>？查询数据的过程又是怎样的？<br>&emsp;&emsp;这次，我们<font color=#FEAE00>从数据页的角度看</font><font color=#FEAE00> B+ </font><font color=#FEAE00>树</font>，看看每个节点长啥样。<br>&emsp;&emsp;￼<hr><hr>3.3 为什么 MySQL 采用 B+ 树作为索引？<hr>大家好，我是小林。<br>&emsp;&emsp;「<font color=#FEAE00>为什么</font><font color=#FEAE00> MySQL </font><font color=#FEAE00>采用</font><font color=#FEAE00> B+ </font><font color=#FEAE00>树作为索引？</font>」这句话，是不是在面试时经常出现。<br>&emsp;&emsp;要解释这个问题，其实不单单要从数据结构的角度出发，还要考虑<font color=#FEAE00>磁盘</font><font color=#FEAE00> I/O </font><font color=#FEAE00>操作次数</font>，因为 MySQL 的数据是存储在磁盘中的嘛。<br>&emsp;&emsp;这次，就跟大家一层一层的分析这个问题，图中包含大量的动图来帮助大家理解，相信看完你就拿捏这道题目了！<br>&emsp;&emsp;￼<hr><hr>3.3 索引总结<hr>	MySQL 是会将数据持久化在硬盘，而存储功能是由 MySQL 存储引擎实现的，所以讨论 MySQL 使用哪种数据结构作为索引，实际上是在讨论存储引<font color=#FEAE00>使用哪种数据结构作为索引，</font>InnoDB 是 MySQL 默认的存储引擎，它就是采用了 B+ 树作为索引的数据结构。<br>&emsp;&emsp;	要设计一个 MySQL 的索引数据结构，不仅仅考虑数据结构增删改的时间复杂度，更重要的是要考虑<font color=#FEAE00>磁盘</font><font color=#FEAE00> I/0 </font><font color=#FEAE00>的操作次数</font>。因为索引和记录都是存放在硬盘，硬盘是一个非常慢的存储设备，我们在查询数据的时候，最好能在尽可能少的磁盘 I/0 的操作次数内完成。<br>&emsp;&emsp;	二分查找树虽然是一个天然的二分结构，能很好的利用二分查找快速定位数据，但是它存在一种极端的情况，每当插入的元素都是树内最大的元素，就会导致二分查找树退化成一个链表，此时查询复杂度就会从 O(logn)降低为 O(n)。<br>&emsp;&emsp;	为了解决二分查找树退化成链表的问题，就出现了自平衡二叉树，保证了查询操作的时间复杂度就会一直维持在 O(logn) 。但是它本质上还是一个二叉树，每个节点只能有 2 个子节点，随着元素的增多，树的高度会越来越高。<br>&emsp;&emsp;	而树的高度决定于磁盘 I/O 操作的次数，因为树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作，也就是说树的高度就等于每次查询数据时磁盘 IO 操作的次数，所以树的高度越高，就会影响<font color=#FEAE00>查询性能</font>。<br>&emsp;&emsp;	B 树和 B+ 都是通过多叉树的方式，会将树的高度变矮，所以这两个数据结构非常适合检索存于磁盘中的数据。<br>&emsp;&emsp;	但是 MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：<br>&emsp;&emsp;	•	B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 <font color=#FEAE00>B </font><font color=#FEAE00>树更「矮胖」</font>，查询底层节点的磁盘 I/O次数会更少。<br>&emsp;&emsp;	•	B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；<br>&emsp;&emsp;	•	B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。<hr><hr>3.4 <font color=#FEAE00>总结</font><hr>今天给大家介绍了 6 种会发生<font color=#FEAE00>索引失效</font>的情况：<br>&emsp;&emsp;	•	当我们使用<font color=#FEAE00>左或者左右模糊匹配</font>的时候，也就是 <font color=#4D647F>like %xx</font> 或者 <font color=#4D647F>like %xx%</font>这两种方式都会造成索引失效；<br>&emsp;&emsp;	•	当我们在查询条件中对<font color=#FEAE00>索引列使用函数</font>，就会导致索引失效。<br>&emsp;&emsp;	•	当我们在查询条件中对索引列<font color=#FEAE00>进行表达式计算</font>，也是无法走索引的。<br>&emsp;&emsp;	•	MySQL 在遇到<font color=#FEAE00>字符串和数字比较的时候</font>，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。<br>&emsp;&emsp;	•	联合索引要能正确使用需要<font color=#FEAE00>遵循最左匹配原则</font>，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。<br>&emsp;&emsp;	•	在 <font color=#FEAE00>WHERE </font><font color=#FEAE00>子句中，如果在</font><font color=#FEAE00> OR </font><font color=#FEAE00>前的条件列是索引列</font>，而在 OR 后的条件列不是索引列，那么索引会失效。<hr><hr>3.4 索引失效有哪些？<hr>大家好，我是小林。<br>&emsp;&emsp;	在工作中，如果我们想提高一条语句查询速度，通常都会想对字段建立索引。<br>&emsp;&emsp;	但是索引并不是万能的。建立了索引，并不意味着任何查询语句都能走索引扫描。<br>&emsp;&emsp;	稍不注意，可能你写的查询语句是会导致索引失效，从而走了全表扫描，虽然查询的结果没问题，但是查询的性能大大降低。<br>&emsp;&emsp;今天就来跟大家盘一盘，常见的 <font color=#FEAE00>6 </font><font color=#FEAE00>种会发生索引失效</font>的场景。<br>&emsp;&emsp;<font color=#FEAE00>不仅会用实验案例给大家说明，也会清楚每个索引失效的原因</font><font color=#FEAE00>。</font><br>&emsp;&emsp;发车！<br>&emsp;&emsp;￼<hr><hr>3.5 MySQL 使用 like “%x“，索引一定会失效吗？<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr># 题目一<br>&emsp;&emsp;题目一很简单，相信大家都能分析出答案，我昨天分享的索引失效文章里也提及过。<br>&emsp;&emsp;**「题目 1 」**的数据库表如下，id 是主键索引，name 是二级索引，其他字段都是非索引字段。<br>&emsp;&emsp;￼<br>&emsp;&emsp;这四条模糊匹配的查询语句，第一条和第二条都会走索引扫描，而且都是选择扫描二级索引（index_name），我贴个第二条查询语句的执行计划结果图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;而第三和第四条会发生索引失效，执行计划的结果 type= ALL，代表了全表扫描。<br>&emsp;&emsp;￼<br>&emsp;&emsp;# 题目二<br>&emsp;&emsp;题目 2 的数据库表特别之处在于，<font color=#FEAE00>只有两个字段，一个是主键索引</font><font color=#FEAE00> id</font><font color=#FEAE00>，另外一个是二级索引</font><font color=#FEAE00> name</font><font color=#FEAE00>。</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;针对题目 2 的数据表，第一条和第二条模糊查询语句也是一样可以走索引扫描，第二条查询语句的执行计划如下，Extra 里的 Using index 说明用上了<font color=#FEAE00>覆盖索引</font>：<br>&emsp;&emsp;￼<br>&emsp;&emsp;我们来看一下第三条查询语句的执行计划（第四条也是一样的结果）：<br>&emsp;&emsp;￼<br>&emsp;&emsp;从执行计划的结果中，可以看到 key=index_name，也就是说用上了二级索引，而且从 Extra 里的 Using index 说明用上了覆盖索引。<br>&emsp;&emsp;这是为什么呢？<br>&emsp;&emsp;首先，这张表的字段没有「非索引」字段，所以 <font color=#4D647F>select *</font> 相当于 <font color=#4D647F>select id,name</font>，然后<font color=#FEAE00>这个查询的数据都在二级索引的</font><font color=#FEAE00> B+ </font><font color=#FEAE00>树，因为二级索引的</font><font color=#FEAE00> B+ </font><font color=#FEAE00>树的叶子节点包含「索引值</font><font color=#FEAE00>+</font><font color=#FEAE00>主键值」，所以查二级索引的</font><font color=#FEAE00> B+ </font><font color=#FEAE00>树就能查到全部结果了，这个就是覆盖索引。</font><br>&emsp;&emsp;但是执行计划里的 type 是 <font color=#4D647F>index</font>，这代表着是通过全扫描二级索引的 B+ 树的方式查询到数据的，也就是遍历了整颗索引树。<br>&emsp;&emsp;而第一和第二条查询语句的执行计划中 type 是 <font color=#4D647F>range</font>，表示对索引列进行范围查询，也就是利用了索引树的有序性的特点，通过查询比较的方式，快速定位到了数据行。<br>&emsp;&emsp;所以，t<font color=#FEAE00>ype=range </font><font color=#FEAE00>的查询效率会比</font><font color=#FEAE00> type=index </font><font color=#FEAE00>的高一些。</font><br>&emsp;&emsp;# 为什么选择全扫描二级索引树，而不扫描聚簇索引树呢？<br>&emsp;&emsp;因为二级索引树的记录东西很少，就只有「索引列+主键值」，而聚簇索引记录的东西会更多，比如聚簇索引中的叶子节点则记录了主键值、事务 id、用于事务和 MVCC 的回滚指针以及所有的剩余列。<br>&emsp;&emsp;再加上，这个 select * 不用执行回表操作。<br>&emsp;&emsp;所以， MySQL 优化器认为直接遍历二级索引树要比遍历聚簇索引树的成本要小的多，因此 MySQL 选择了「全扫描二级索引树」的方式查询数据。<br>&emsp;&emsp;为什么这个数据表加了非索引字段，执行同样的查询语句后，怎么变成走的是全表扫描呢？<br>&emsp;&emsp;加了其他字段后，<font color=#4D647F>select * from t_user where name like "%xx";</font> 要查询的数据就不能只在二级索引树里找了，得需要回表操作才能完成查询的工作，再加上是左模糊匹配，无法利用索引树的有序性来快速定位数据，所以得在二级索引树逐一遍历，获取主键值后，再到聚簇索引树检索到对应的数据行，这样实在太累了。<br>&emsp;&emsp;所以，优化器认为上面这样的查询过程的成本实在太高了，所以直接选择全表扫描的方式来查询数据。<br>&emsp;&emsp;<br>&emsp;&emsp;从这个思考题我们知道了，使用左模糊匹配（like "%xx"）并不一定会走全表扫描，关键还是看数据表中的字段。<br>&emsp;&emsp;如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，也不会走全表扫描（type=all），而是走全扫描二级索引树(type=index)。<br>&emsp;&emsp;再说一个相似，我们都知道联合索引要遵循最左匹配才能走索引，但是如果数据库表中的字段都是索引的话，即使查询过程中，没有遵循最左匹配原则，也是走全扫描二级索引树(type=index)，比如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;就说到这了，下次见啦<hr><hr>3.6 count(*) 和 count(1) 有什么区别？哪个性能最好？<hr>大家好，我是小林。<br>&emsp;&emsp;	当我们对一张数据表中的记录进行统计的时候，习惯都会使用 count 函数来统计，但是 count 函数传入的参数有很多种，比如 count(1)、count(<font color=#4D647F>*</font>)、count(字段) 等。<br>&emsp;&emsp;到底哪种效率是最好的呢？是不是 count(<font color=#4D647F>*</font>) 效率最差？<br>&emsp;&emsp;	我曾经以为<font color=#FEAE00> count(*) </font><font color=#FEAE00>是效率最差的</font>，因为认知上 <font color=#4D647F>selete * from t</font> 会读取所有表中的字段，所以凡事带有 <font color=#4D647F>*</font> 字符的就觉得会读取表中所有的字段，当时网上有很多博客也这么说。<br>&emsp;&emsp;但是，当我深入<font color=#FEAE00> count </font><font color=#FEAE00>函数的原理</font>后，被啪啪啪的打脸了！<br>&emsp;&emsp;不多说， 发车！<br>&emsp;&emsp;￼<hr><hr>3.ACID51、关系型数据库的四大特性在<font color=#1DB100>得不到保障</font>的情况下会怎样？<br>&emsp;&emsp;<br>&emsp;&emsp;答案主要再讲 ACID 是什么<hr>ACID，原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)<br>&emsp;&emsp;<br>&emsp;&emsp;我们以从A账户转账50元到B账户为例进行说明一下ACID这四大特性。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#1DB100>原子性</font><br>&emsp;&emsp;<br>&emsp;&emsp;原子性是指一个事务是一个不可分割的工作单位，<font color=#FEAE00>其中的操作要么都做，要么都不做</font><font color=#FEAE00>。</font>即要么转账成功，要么转账失败，是不存在中间的状态！<br>&emsp;&emsp;<br>&emsp;&emsp;如果无法保证原子性会怎么样？<br>&emsp;&emsp;<br>&emsp;&emsp;OK，就会出现数据不一致的情形，A账户减去50元，<font color=#FEAE00>而</font><font color=#FEAE00>B</font><font color=#FEAE00>账户增加</font><font color=#FEAE00>50</font><font color=#FEAE00>元操作失败。系统将无故丢失</font><font color=#FEAE00>50</font><font color=#FEAE00>元</font><font color=#FEAE00>~</font><br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#1DB100>一致性</font><br>&emsp;&emsp;<br>&emsp;&emsp;一致性是指事务执行前后，数据处于一种<font color=#1DB100>合法的状态</font>，这种<font color=#FEAE00>状态是语义上</font>的而不是语法上的。 那什么是合法的数据状态呢？这个状态是<font color=#FEAE00>满足预定的约束就叫做合法的状态</font>，再通俗一点，这状态是由你自己来定义的。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的！<br>&emsp;&emsp;<br>&emsp;&emsp;如果无法保证一致性会怎么样？<br>&emsp;&emsp;<br>&emsp;&emsp;- 例一:A账户有200元，转账300元出去，此时A账户余额为-100元。你自然就发现了此时数据是不一致的，为什么呢？因为你定义了一个状态，余额这列必须大于0。<br>&emsp;&emsp;- 例二:A账户200元，转账50元给B账户，A账户的钱扣了，但是B账户因为各种意外，余额并没有增加。你也知道此时数据是不一致的，为什么呢？<font color=#FEAE00>因为你定义了一个状态，要求</font><font color=#FEAE00>A+B</font><font color=#FEAE00>的余额必须不变。</font><br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#1DB100>隔离性</font><br>&emsp;&emsp;<br>&emsp;&emsp;隔离性是指多个事务并发执行的时候，事务<font color=#FEAE00>内部的操作与其他事务是隔离的</font>，并发执行的各个事务之间不能互相干扰。<br>&emsp;&emsp;<br>&emsp;&emsp;如果无法保证隔离性会怎么样？<br>&emsp;&emsp;<br>&emsp;&emsp;假设A账户有200元，B账户0元。A账户往B账户转账两次，金额为50元，分别在两个事务中执行。如果无法保证隔离性，A可能就会出现扣款两次的情形，而B只加款一次，<font color=#FEAE00>凭空消失了</font><font color=#FEAE00>50</font><font color=#FEAE00>元，</font>依然出现了数据不一致的情形！<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#1DB100>持久性</font><br>&emsp;&emsp;<br>&emsp;&emsp;根据定义，持久性是指事务一旦提交，<font color=#1DB100>它对数据库的改变就应该是永久性的</font>。接下来的其他操作或故障不应该对其有任何影响。<br>&emsp;&emsp;<br>&emsp;&emsp;如果无法保证持久性会怎么样？<br>&emsp;&emsp;<br>&emsp;&emsp;在MySQL中，为了解决CPU和磁盘速度不一致问题，MySQL是将磁盘上的数据加载到内存，对内存进行操作，然后再回写磁盘。<font color=#FEAE00>好，假设此时宕机了，在内存中修改的数据全部丢失了，持久性就无法保证。</font><br>&emsp;&emsp;<br>&emsp;&emsp;设想一下，系统提示你转账成功。但是你发现金额没有发生任何改变，此时数据出现了不合法的数据状态，<font color=#FEAE00>我们将这种状态认为是</font><font color=#FEAE00>数据不一致</font><font color=#FEAE00>的情形。</font><hr><hr>3.ACID53、数据库如何保证<font color=#1DB100>原子性</font>？<hr>主要是利用 Innodb 的<font color=#1DB100>undo log</font>。 <font color=#1DB100>undo log</font><font color=#1DB100>名为回滚日志</font>，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的 SQL语句，他需要记录你要回滚的相应日志信息。 例如<br>&emsp;&emsp;<br>&emsp;&emsp;- 当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据<br>&emsp;&emsp;- 当你update一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行update操作<br>&emsp;&emsp;- 当年insert一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行delete操作<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#1DB100>undo log</font><font color=#1DB100>记录了这些回滚需要的信息</font>，当事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。<hr><hr>3.ACID54、数据库如何保证<font color=#1DB100>持久性</font>？<hr>主要是利用Innodb的<font color=#1DB100>redo log</font><font color=#1DB100>。重写日志</font>， 正如之前说的，MySQL是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再写回到磁盘上。如果此时突然宕机，内存中的数据就会丢失。 怎么解决这个问题？ 简单啊，<font color=#1DB100>事务提交前直接把数据写入磁盘就行啊</font>。 这么做有什么问题？<br>&emsp;&emsp;<br>&emsp;&emsp;- 只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面16kb大小，你只改其中一点点东西，就要将16kb的内容刷入磁盘，听着也不合理。<br>&emsp;&emsp;- 毕竟一个事务里的SQL可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机IO。显然操作随机IO，速度会比较慢。<br>&emsp;&emsp;<br>&emsp;&emsp;于是，决定采用redo log解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作。当事务提交的时候，会将<font color=#1DB100>redo log</font><font color=#1DB100>日志进行刷盘</font>(redo log一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据undo log和binlog内容决定回滚数据还是提交数据。<br>&emsp;&emsp;<br>&emsp;&emsp;采用redo log的好处？<br>&emsp;&emsp;<br>&emsp;&emsp;其实好处就是将<font color=#1DB100>redo log</font><font color=#1DB100>进行刷盘比对数据页刷盘效率高</font>，具体表现如下：<br>&emsp;&emsp;<br>&emsp;&emsp;- redo log体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。<br>&emsp;&emsp;- redo log是一直往末尾进行追加，属于顺序IO。效率显然比随机IO来的快。<hr><hr>3.事务14、MySQL中为什么要有<font color=#1DB100>事务回滚</font>机制？<hr>而在 MySQL 中，恢复机制是通过<font color=#1DB100>回滚日志（</font><font color=#1DB100>undo log</font><font color=#1DB100>）</font>实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的<font color=#1DB100>对应行进行写入</font>。 当事务已经被提交之后，就无法再次回滚了。<br>&emsp;&emsp;<br>&emsp;&emsp;回滚日志作用： 1)能够在<font color=#1DB100>发生错误</font>或者用户<font color=#1DB100>执行</font><font color=#1DB100> ROLLBACK </font>时提供回滚相关的信息 2) 在整个<font color=#1DB100>系统发生崩溃</font>、数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立刻<font color=#1DB100>通过查询回滚日志将之前未完成的事务进行回滚</font>，这也就需要<font color=#1DB100>回滚日志必须先于数据持久化到磁盘上</font>，是我们需要先写日志后写数据库的主要原因。<hr><hr>3.锁17、数据库<font color=#1DB100>悲观锁和乐观锁</font>的原理和应用场景分别有什么？<hr>悲观锁，先获取锁，再进行业务操作，一般就是利用类似<font color=#1DB100> SELECT … FOR UPDATE</font> 这样的语句，对数据加锁，<font color=#1DB100>避免其他事务意外修改数据</font>。 当数据库执行SELECT … FOR UPDATE时会获取<font color=#1DB100>被</font><font color=#1DB100>select</font><font color=#1DB100>中的数据行的行锁</font>，select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。<br>&emsp;&emsp;<br>&emsp;&emsp;乐观锁，先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过。Java 并发包中的 AtomicFieldUpdater 类似，也是<font color=#1DB100>利用</font><font color=#1DB100> CAS </font><font color=#1DB100>机制</font>，并不会对数据加锁，而是<font color=#1DB100>通过对比数据的时间戳或者版本号</font>，来实现乐观锁需要的版本判断。<hr><hr>3.锁44、说一下数据库<font color=#1DB100>表锁</font>和<font color=#1DB100>行锁</font>吧<hr>表锁<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#FF644E>不会出现死锁</font>，<font color=#1DB100>发生锁冲突几率高，并发低</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;MyISAM在执行<font color=#1DB100>查询语句（</font><font color=#1DB100>select</font><font color=#1DB100>）前</font>，会自动给涉及的<font color=#1DB100>所有表加读锁</font>，在执行增删改操作前，会自动给涉及的表加写锁。<br>&emsp;&emsp;<br>&emsp;&emsp;MySQL的表级锁有两种模式：<font color=#1DB100>表共享读锁和表独占写锁</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#1DB100>读锁会阻塞写，写锁会阻塞读和写</font><br>&emsp;&emsp;<br>&emsp;&emsp;- 对MyISAM表的读操作，不会阻塞其它进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。<br>&emsp;&emsp;- 对MyISAM表的写操作，会阻塞其它进程对同一表的读和写操作，只有当写锁释放后，才会执行其它进程的读写操作。<br>&emsp;&emsp;<br>&emsp;&emsp;MyISAM不适合做写为主表的引擎，因为写锁后，其它线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#1DB100>行锁</font><br>&emsp;&emsp;<br>&emsp;&emsp;会出现死锁，发生锁冲突几率低，并发高。<br>&emsp;&emsp;<br>&emsp;&emsp;在MySQL的InnoDB引擎支持行锁，与Oracle不同，MySQL的<font color=#1DB100>行锁是通过索引加载的</font>，也就是说，行锁是加在索引响应的行上的，要是对应的SQL<font color=#1DB100>语句没有走索引，则会全表扫描</font>，行锁则无法实现，<font color=#1DB100>取而代之的是表锁</font>，此时其它事务无法对当前表进行更新或插入操作。<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;行锁的实现需要注意：<br>&emsp;&emsp;<br>&emsp;&emsp;- 行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了。<br>&emsp;&emsp;- 如果是共享锁，两个事务可以锁同一个索引，排它锁则不能。<br>&emsp;&emsp;- <font color=#1DB100>insert</font><font color=#1DB100>，</font><font color=#1DB100>delete</font><font color=#1DB100>，</font><font color=#1DB100>update</font>在事务中都会自动默认加上排它锁。<br>&emsp;&emsp;<br>&emsp;&emsp;行锁的适用场景：<br>&emsp;&emsp;<br>&emsp;&emsp;A用户消费，service层先查询该用户的账户余额，若余额足够，则进行后续的扣款操作；<font color=#FEAE00>这种情况查询的时候应该对该记录进行加锁。</font><br>&emsp;&emsp;<br>&emsp;&emsp;否则，B用户在A用户查询后消费前先一步将A用户账号上的钱转走，而此时A用户已经进行了用户余额是否足够的判断，则可能会出现余额已经不足但却扣款成功的情况。<br>&emsp;&emsp;<br>&emsp;&emsp;为了避免此情况，需要在A用户操作该记录的时候进行for update加锁<hr><hr>3.隔离10、数据库<font color=#1DB100>隔离级别</font><hr>- <font color=#1DB100>未提交读</font>，事务中发生了修改，<font color=#1DB100>即使没有提交，其他事务也是可见的</font>，比如对于一个数A原来50修改为100，但是我还没有提交修改，另一个事务看到这个修改，而这个时候原事务发生了回滚，这时候A还是50，但是另一个事务看到的A是100.可能<font color=#1DB100>会导致脏读、幻读或不可重复读</font><br>&emsp;&emsp;- <font color=#1DB100>提交读</font>，对于一个事务从<font color=#FEAE00>开始直到提交之前</font>，所做的<font color=#1DB100>任何修改是其他事务不可见的</font>，举例就是对于一个数A原来是50，然后提交修改成100，这个时候另一个事务在A提交修改之前，读取的A是50，刚读取完，A就被修改成100，这个时候另一个事务再进行读取发现A就突然变成100了；可以阻止脏读，但是幻读或不可重复读仍有可能发生<br>&emsp;&emsp;- <font color=#1DB100>重复读</font>，就是对一个记录<font color=#FEAE00>读取多次的记录是相同的</font>，比如对于一个数A读取的话一直是A，前后两次读取的A是一致的；可以<font color=#FEAE00>阻止脏读和不可重复读</font>，但幻读仍有可能发生<br>&emsp;&emsp;- <font color=#1DB100>可串行化读</font>，在并发情况下，和串行化的读取的结果是一致的，没有什么不同，比如不会发生脏读和幻读；该级别可以防止脏读、不可重复读以及幻读<br>&emsp;&emsp;<br>&emsp;&emsp;| 隔离级别                        |        脏读 | 不可重复读 | 幻读 |<br>&emsp;&emsp;| READ-UNCOMMITTED <font color=#FEAE00>未提交读</font> | √    | √          | √      |<br>&emsp;&emsp;| READ-COMMITTED <font color=#FEAE00>提交读</font>          | ×    | √          | √      |<br>&emsp;&emsp;| REPEATABLE-READ <font color=#FEAE00>重复读</font>          | ×    | ×          | √      |<br>&emsp;&emsp;| SERIALIZABLE 可串行化读           | ×    | ×          | ×      |<br>&emsp;&emsp;<br>&emsp;&emsp;MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）<br>&emsp;&emsp;<br>&emsp;&emsp;这里需要注意的是：与 SQL 标准不同的地方在于InnoDB 存储引擎在 REPEATABLE-READ（可重读）事务隔离级别 下使用的是<font color=#FEAE00>Next-Key Lock </font><font color=#FEAE00>锁</font><font color=#FEAE00>算法，因此可以避免幻读的产生</font>，这与其他数据库系统(如 SQL Server)是不同的。所以 说InnoDB 存储引擎的默认支持的隔离级别是<font color=#1DB100> REPEATABLE-READ</font><font color=#1DB100>（可重读）</font><font color=#1DB100> </font><font color=#1DB100>已经可以完全保证事务的隔离性要</font><font color=#1DB100> </font><font color=#1DB100>求</font>，即达到了 SQL标准的SERIALIZABLE(可串行化)隔离级别。<br>&emsp;&emsp;<br>&emsp;&emsp;因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是<font color=#FEAE00>READ-COMMITTED(</font><font color=#FEAE00>读取提交内</font><font color=#FEAE00> </font><font color=#FEAE00>容</font><font color=#FEAE00>):</font>，但是你要知道的是InnoDB 存储引擎默认使用 REPEATABLE-READ（可重读）并不会有任何性能损失。<br>&emsp;&emsp;<br>&emsp;&emsp;InnoDB 存储引擎在分布式事务 的情况下一般会用到SERIALIZABLE(可串行化)隔离级别。<hr><hr>3.隔离20、<font color=#FEAE00>不可重复读</font>和<font color=#FEAE00>幻读</font>区别是什么？可以举个例子吗？<hr>不可重复读的重点是<font color=#FEAE00>修改</font>，幻读的重点在于<font color=#FEAE00>新增或者删除</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;- 例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导致A再读自己的工资时工资变为 2000；<font color=#FEAE00>这就是不可重复读</font>。<br>&emsp;&emsp;- 例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记 录就<font color=#FEAE00>变为了</font><font color=#FEAE00>5</font><font color=#FEAE00>条，这样就导致了幻读。</font><hr><hr>4.1 <font color=#FEAE00>Read View</font> 在 MVCC 里如何工作的？<hr>我们需要了解两个知识：<br>&emsp;&emsp;	•	<font color=#FEAE00>Read View </font><font color=#FEAE00>中四个字段作用；</font><br>&emsp;&emsp;	•	<font color=#FEAE00>聚簇索引记录</font>中两个跟事务<font color=#FEAE00>有关的隐藏列；</font><br>&emsp;&emsp;那 Read View 到底是个什么东西？<br>&emsp;&emsp;￼<br>&emsp;&emsp;Read View 有四个重要的字段：<br>&emsp;&emsp;	•	<font color=#00AB8E>m_ids</font> ：指的是在创建 Read View 时，当前数据库中「活跃事务」的<font color=#FEAE00>事务</font><font color=#FEAE00> id </font><font color=#FEAE00>列表</font>，注意是一个列表<font color=#FEAE00>，</font><font color=#FEAE00>“</font><font color=#FEAE00>活跃事务</font><font color=#FEAE00>”</font><font color=#FEAE00>指的就是，启动了但还没提交的事务</font><font color=#FEAE00>。</font><br>&emsp;&emsp;	•	<font color=#00AB8E>min_trx_id</font> ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 <font color=#FEAE00>id </font><font color=#FEAE00>最小的事务</font>，也就是 m_ids 的最小值。<br>&emsp;&emsp;	•	<font color=#00AB8E>max_trx_id</font> ：这个并不是 m_ids 的最大值，而是<font color=#FEAE00>创建</font><font color=#FEAE00> Read View </font><font color=#FEAE00>时当前数据库中应该给下一个事务的</font><font color=#FEAE00> id </font><font color=#FEAE00>值</font><font color=#FEAE00>，</font>也就是全局事务中最大的事务 id 值 + 1；<br>&emsp;&emsp;	•	<font color=#00AB8E>creator_trx_id</font> ：指的是<font color=#FEAE00>创建该</font><font color=#FEAE00> Read View </font><font color=#FEAE00>的事务的事务</font><font color=#FEAE00> id</font><font color=#FEAE00>。</font><br>&emsp;&emsp;知道了 Read View 的字段，我们还需要了解聚簇索引记录中的<font color=#FEAE00>两个隐藏列</font>。<br>&emsp;&emsp;假设在账户余额表插入一条小林余额为 100 万的记录，然后我把这两个隐藏列也画出来，该记录的整个示意图如下：<br>&emsp;&emsp;￼<br>&emsp;&emsp;对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：<br>&emsp;&emsp;	•	trx_id，当一个事务对某条聚簇索引记录进行改动时，就会<font color=#FEAE00>把该事务的事务</font><font color=#FEAE00> id </font><font color=#FEAE00>记录在</font><font color=#FEAE00> trx_id </font><font color=#FEAE00>隐藏列里</font><font color=#FEAE00>；</font><br>&emsp;&emsp;	•	roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<font color=#FEAE00>这个隐藏列是个指针，指向每一个旧版本记录</font><font color=#FEAE00>，</font>于是就可以通过它找到修改前的记录。<br>&emsp;&emsp;在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：<br>&emsp;&emsp;￼<br>&emsp;&emsp;一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：<br>&emsp;&emsp;	•	如果记录的 <font color=#FEAE00>trx_id </font><font color=#FEAE00>值小于</font> Read View 中的 <font color=#4D647F>min_trx_id</font> 值，表示这个版本的记录是在创建 Read View <font color=#FEAE00>前</font>已经提交的事务生成的，所以该版本的记录对<font color=#FEAE00>当前事务</font><font color=#FEAE00>可见</font>。<br>&emsp;&emsp;	•	如果记录的 <font color=#FEAE00>trx_id </font><font color=#FEAE00>值大于等于</font> Read View 中的 <font color=#4D647F>max_trx_id</font> 值，表示这个版本的记录是在创建 Read <font color=#FEAE00>View </font><font color=#FEAE00>后</font>才启动的事务生成的，所以该版本的记录对当前事务<font color=#FEAE00>不可见</font>。<br>&emsp;&emsp;	•	如果记录的 trx_id 值在 Read View 的 <font color=#4D647F>min_trx_id</font> 和 <font color=#4D647F>max_trx_id</font> 之间，需要判断 trx_id <font color=#FEAE00>是否在</font><font color=#FEAE00> m_ids </font><font color=#FEAE00>列表中：</font><br>&emsp;&emsp;	◦	如果记录的 trx_id <font color=#FEAE00>在</font> <font color=#4D647F>m_ids</font> 列表中，表示生成该版本记录的活跃事务<font color=#FEAE00>依然活跃着（还没提交事务）</font>，所以该版本的记录对当前事务<font color=#FEAE00>不可见</font><font color=#FEAE00>。</font><br>&emsp;&emsp;	◦	如果记录的 trx_id<font color=#FEAE00> </font><font color=#FEAE00>不在</font><font color=#FEAE00> </font><font color=#4D647F>m_ids</font>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<font color=#FEAE00>可见</font><font color=#FEAE00>。</font><br>&emsp;&emsp;<font color=#FEAE00>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫</font><font color=#FEAE00> MVCC</font><font color=#FEAE00>（多版本并发控制）。</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>4.1 事务有哪些<font color=#FEAE00>特性</font>？ <hr>事务是由 MySQL 的引擎来实现的，我们常见的 InnoDB 引擎它是支持事务的。<br>&emsp;&emsp;	不过并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务，也正是这样，所以大多数 MySQL 的引擎都是用 InnoDB。<br>&emsp;&emsp;事务看起来感觉简单，但是要实现事务必须要遵守 4 个特性，分别如下：<br>&emsp;&emsp;<font color=#374EF4>	</font><font color=#FEAE00>•	</font><font color=#FEAE00>原子性（</font><font color=#FEAE00>Atomicity</font><font color=#FEAE00>）</font>：一个事务中的所有操作，<font color=#FEAE00>要么全部完成，要么全部不完成</font>，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。<br>&emsp;&emsp;<font color=#374EF4>	</font><font color=#FEAE00>•	</font><font color=#FEAE00>一致性（</font><font color=#FEAE00>Consistency</font><font color=#FEAE00>）</font>：<font color=#FEAE00>是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态</font>。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。<br>&emsp;&emsp;<font color=#374EF4>	</font><font color=#FEAE00>•	</font><font color=#FEAE00>隔离性（</font><font color=#FEAE00>Isolation</font><font color=#FEAE00>）</font>：数据库允许<font color=#FEAE00>多个并发事务同时对其数据进行读写和修改的能力</font>，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。<br>&emsp;&emsp;<font color=#FEAE00>	•	</font><font color=#FEAE00>持久性（</font><font color=#FEAE00>Durability</font><font color=#FEAE00>）</font>：事务处理结束后，对数据的<font color=#FEAE00>修改就是永久的</font>，即便系统故障也不会丢失。<br>&emsp;&emsp;# InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？<br>&emsp;&emsp;	•	<font color=#FEAE00>持久性是通过</font><font color=#FEAE00> redo log </font><font color=#FEAE00>（重做日志）</font>来保证的；<br>&emsp;&emsp;	•	<font color=#FEAE00>原子性是通过</font><font color=#FEAE00> undo log</font><font color=#FEAE00>（回滚日志）</font> 来保证的；<br>&emsp;&emsp;	•	<font color=#FEAE00>隔离性是通过</font><font color=#FEAE00> MVCC</font><font color=#FEAE00>（多版本并发控制）</font> 或锁机制来保证的；<br>&emsp;&emsp;	•	一致性则是通过<font color=#FEAE00>持久性</font><font color=#FEAE00>+</font><font color=#FEAE00>原子性</font><font color=#FEAE00>+</font><font color=#FEAE00>隔离性</font>来保证；<br>&emsp;&emsp;这次将<font color=#FEAE00>重点介绍事务的隔离性</font>，这也是面试时最常问的知识的点。<br>&emsp;&emsp;为什么事务要有隔离性，我们就要知道并发事务时会引发什么问题。<hr><hr>4.1 事务的<font color=#FEAE00>隔离级别</font>有哪些？<hr>前面我们提到，当多个事务并发执行时可能会遇到「<font color=#FEAE00>脏读、不可重复读、幻读</font>」的现象，这些现象会对事务的一致性产生不同程序的影响。<br>&emsp;&emsp;	•	脏读：读到其他事务未提交的数据；<br>&emsp;&emsp;	•	不可重复读：前后读取的数据不一致；<br>&emsp;&emsp;	•	幻读：前后读取的记录数量不一致。<br>&emsp;&emsp;这三个现象的严重性排序如下：<br>&emsp;&emsp;￼<br>&emsp;&emsp;SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：<br>&emsp;&emsp;<font color=#FEAE00>	•	</font><font color=#FEAE00>读未提交</font><font color=#374EF4>（</font><font color=#7414AF>read uncommitted</font><font color=#374EF4>）</font>，指一个事务还没提交时，它做的变更就能被其他事务看到；<br>&emsp;&emsp;<font color=#374EF4>	</font><font color=#FEAE00>•	</font><font color=#FEAE00>读提交</font><font color=#374EF4>（</font><font color=#7414AF>read committed</font><font color=#374EF4>）</font>，指一个事务提交之后，它做的变更才能被其他事务看到；<br>&emsp;&emsp;<font color=#FEAE00>	•	</font><font color=#FEAE00>可重复读</font><font color=#374EF4>（</font><font color=#7414AF>repeatable read</font><font color=#374EF4>）</font>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<font color=#FEAE00>MySQL InnoDB </font><font color=#FEAE00>引擎的默认隔离级别</font><font color=#FEAE00>；</font><br>&emsp;&emsp;<font color=#FEAE00>	•	</font><font color=#FEAE00>串行化</font><font color=#374EF4>（</font><font color=#7414AF>serializable</font><font color=#374EF4> </font><font color=#374EF4>）</font>；<font color=#FEAE00>会对记录加上读写锁</font>，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；<br>&emsp;&emsp;<font color=#FEAE00>按隔离水平高低排序</font>如下：<br>&emsp;&emsp;￼<br>&emsp;&emsp;针对不同的隔离级别，并发事务时可能发生的现象也会不同。<br>&emsp;&emsp;￼<br>&emsp;&emsp;也就是说：<br>&emsp;&emsp;	•	在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；<br>&emsp;&emsp;	•	在「读提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象；<br>&emsp;&emsp;	•	在「可重复读」隔离级别下，可能发生幻读现象，但是不可能脏读和不可重复读现象；<br>&emsp;&emsp;	•	在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。<br>&emsp;&emsp;所以，<font color=#FEAE00>要解决脏读现象，就要升级到「读提交」以上的隔离级别；要解决不可重复读现象，就要升级到「可重复读」的隔离级别</font><font color=#FEAE00>。</font><br>&emsp;&emsp;不过，要解决幻读现象不建议将隔离级别升级到「串行化」，因为这样会导致数据库在并发事务时性能很差。<br>&emsp;&emsp;<font color=#FEAE00>InnoDB </font><font color=#FEAE00>引擎的默认隔离级别虽然是「可重复读」，但是它通过</font><font color=#00AB8E>next-key lock </font><font color=#00AB8E>锁（行锁和间隙锁的组合）</font><font color=#FEAE00>来锁住记录之间的</font><font color=#FEAE00>“</font><font color=#FEAE00>间隙</font><font color=#FEAE00>”</font><font color=#FEAE00>和记录本身，防止其他事务在这个记录之间插入新的记录，这样就避免了幻读现象。</font><br>&emsp;&emsp;接下来，举个具体的例子来说明这四种隔离级别，有一张账户余额表，里面有一条记录：<br>&emsp;&emsp;然后有两个并发的事务，事务 A 只负责查询余额，事务 B 则会将我的余额改成 200 万，下面是按照时间顺序执行两个事务的行为：<br>&emsp;&emsp;￼<br>&emsp;&emsp;在不同隔离级别下，事务 A 执行过程中查询到的余额可能会不同：<br>&emsp;&emsp;	•	在「读未提交」隔离级别下，事务 B 修改余额后，虽然没有提交事务，但是此时的余额已经可以被事务 A 看见了，于是事务 A 中余额 V1 查询的值是 200 万，余额 V2、V3 自然也是 200 万了；<br>&emsp;&emsp;	•	在「读提交」隔离级别下，事务 B 修改余额后，因为没有提交事务，所以事务 A 中余额 V1 的值还是 100 万，等事务 B 提交完后，最新的余额数据才能被事务 A 看见，因此额 V2、V3 都是 200 万；<br>&emsp;&emsp;	•	在「可重复读」隔离级别下，事务 A 只能看见启动事务时的数据，所以余额 V1、余额 V2 的值都是 100 万，当事务 A 提交事务后，就能看见最新的余额数据了，所以余额 V3 的值是 200 万；<br>&emsp;&emsp;	•	在「串行化」隔离级别下，事务 B 在执行将余额 100 万修改为 200 万时，由于此前事务 A 执行了读操作，这样就发生了读写冲突，于是就会被锁住，直到事务 A 提交后，事务 B 才可以继续执行，所以从 A 的角度看，余额 V1、V2 的值是 100 万，余额 V3 的值是 200万。<br>&emsp;&emsp;这四种隔离级别具体是如何实现的呢？<br>&emsp;&emsp;	•	对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；<br>&emsp;&emsp;	•	对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；<br>&emsp;&emsp;	•	对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 <font color=#FEAE00>Read View </font><font color=#FEAE00>来实现的，它们的区别在于创建</font><font color=#FEAE00> Read View </font><font color=#FEAE00>的时机不同，大家可以把</font><font color=#FEAE00> Read View </font><font color=#FEAE00>理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。</font><font color=#00AB8E>「读提交」隔离级别是在「每个语句执行前」</font><font color=#FEAE00>都会重新生成一个</font><font color=#FEAE00> Read View</font><font color=#FEAE00>，而</font><font color=#00AB8E>「可重复读」隔离级别是「启动事务时」</font><font color=#FEAE00>生成一个</font><font color=#FEAE00> Read View</font><font color=#FEAE00>，然后整个事务期间都在用这个</font><font color=#FEAE00> Read View</font><font color=#FEAE00>。</font><br>&emsp;&emsp;注意，执行「开始事务」命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令，分别是：<br>&emsp;&emsp;	•	第一种：<font color=#FEAE00>begin/start transaction </font><font color=#FEAE00>命令</font>；<br>&emsp;&emsp;	•	第二种：<font color=#FEAE00>start transaction with consistent snapshot </font><font color=#FEAE00>命令；</font><br>&emsp;&emsp;这两种开启事务的命令，事务的启动时机是不同的：<br>&emsp;&emsp;	•	执行了 begin/start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机；<br>&emsp;&emsp;	•	执行了 <font color=#FEAE00>start transaction with consistent snapshot </font><font color=#FEAE00>命令，就会马上启动事务</font>。<br>&emsp;&emsp;接下来详细说下，Read View 在 MVCC 里如何工作的？<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>4.1 事务<font color=#FEAE00>隔离级别</font>是怎么实现的？<hr>这是我的钱包，共有 100 万元。<br>&emsp;&emsp;￼<br>&emsp;&emsp;今天我心情好，我决定给你的转账 100 万，最后的结果肯定是我的余额变为 0 元，你的余额多了 100 万元，是不是想到就很开心？<br>&emsp;&emsp;转账这一动作在程序里会涉及到一系列的操作，假设我向你转账 100 万的过程是有下面这几个步骤组成的：<br>&emsp;&emsp;￼<br>&emsp;&emsp;可以看到这个<font color=#FEAE00>转账的过程涉及到了两次修改数据库</font>的操作。<br>&emsp;&emsp;假设在执行第三步骤之后，服务器忽然掉电了，就会发生一个蛋疼的事情，我的账户扣了 100 万，但是钱并没有到你的账户上，也就是说<font color=#FEAE00>这</font><font color=#FEAE00> 100 </font><font color=#FEAE00>万消失了！</font><br>&emsp;&emsp;要解决这个问题，就要保证转账业务里的所有数据库的操作是不可分割的，要么全部执行成功 ，要么全部失败，不允许出现中间状态的数据。<br>&emsp;&emsp;数据库中的「<font color=#FEAE00>事务</font><font color=#374EF4>（</font><font color=#7414AF>Transaction</font><font color=#374EF4>）</font>」就能达到这样的效果。<br>&emsp;&emsp;我们在<font color=#FEAE00>转账操作前先开启事务</font>，等所有数据库操作执行完成后，才提交事务，对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，如果<font color=#FEAE00>中途发生发生中断或错误，那么该事务期间对数据库所做的修改将会被回滚到没执行该事务之前的状态。</font><br>&emsp;&emsp;没错，今天就来图解 MySQL 事务啦，开车！<br>&emsp;&emsp;￼<hr><hr><font color=#FEAE00>4.1 </font><font color=#FEAE00>可重复读</font>是如何工作的？<hr><font color=#FEAE00>可重复读隔离级别是启动事务时生成一个</font><font color=#FEAE00> Read View</font><font color=#FEAE00>，然后整个事务期间都在用这个</font><font color=#FEAE00> Read View</font><font color=#FEAE00>。</font><br>&emsp;&emsp;假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，那这两个事务创建的 Read View 如下：<br>&emsp;&emsp;￼<br>&emsp;&emsp;事务 A 和 事务 B 的 Read View 具体内容如下：<br>&emsp;&emsp;	•	在事务 A 的 Read View 中，它的事务 id 是 51，由于它是第一个启动的事务，所以此时活跃事务的事务 id 列表就只有 51，活跃事务的事务 id 列表中最小的事务 id 是事务 A 本身，下一个事务 id 则是 52。<br>&emsp;&emsp;	•	在事务 B 的 Read View 中，它的事务 id 是 52，由于事务 A 是活跃的，所以此时活跃事务的事务 id 列表是 51 和 52，<font color=#FEAE00>活跃的事务</font><font color=#FEAE00> id </font><font color=#FEAE00>中最小的事务</font><font color=#FEAE00> id </font><font color=#FEAE00>是事务</font><font color=#FEAE00> A</font>，下一个事务 id 应该是 53。<br>&emsp;&emsp;接着，在可重复读隔离级别下，事务 A 和事务 B 按顺序执行了以下操作：<br>&emsp;&emsp;	•	事务 B 读取小林的账户余额记录，读到余额是 100 万；<br>&emsp;&emsp;	•	事务 A 将小林的账户余额记录修改成 200 万，并没有提交事务；<br>&emsp;&emsp;	•	事务 B 读取小林的账户余额记录，读到余额还是 100 万；<br>&emsp;&emsp;	•	事务 A 提交事务；<br>&emsp;&emsp;	•	事务 B 读取小林的账户余额记录，读到余额依然还是 100 万；<br>&emsp;&emsp;接下来，跟大家具体分析下。<br>&emsp;&emsp;事务 B 第一次读小林的账户余额记录，在找到记录后，它会先看这条记录的 trx_id，此时<font color=#FEAE00>发现</font><font color=#FEAE00> trx_id </font><font color=#FEAE00>为</font><font color=#FEAE00> 50</font><font color=#FEAE00>，比事务</font><font color=#FEAE00> B </font><font color=#FEAE00>的</font><font color=#FEAE00> Read View </font><font color=#FEAE00>中的</font><font color=#FEAE00> min_trx_id </font><font color=#FEAE00>值（</font><font color=#FEAE00>51</font><font color=#FEAE00>）还小，这意味着修改这条记录的事务早就在事务</font><font color=#FEAE00> B </font><font color=#FEAE00>启动前提交过了，所以该版本的记录对事务</font><font color=#FEAE00> B </font><font color=#FEAE00>可见的</font><font color=#FEAE00>，</font>也就是事务 B 可以获取到这条记录。<br>&emsp;&emsp;接着，事务 A 通过 update 语句将这条记录修改了（还未提交事务），将小林的余额改成 200 万，这时 MySQL 会记录相应的 undo log，并以链表的方式串联起来，形成<font color=#FEAE00>版本链</font><font color=#FEAE00>，</font>如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;你可以在上图的「记录的字段」看到，由于事务 A 修改了该记录，以前的记录就变成旧版本记录了，于是最新记录和旧版本记录通过链表的方式串起来，而且最新记录的 trx_id 是事务 A 的事务 id（trx_id = 51）。<br>&emsp;&emsp;然后事务 B 第二次去读取该记录，<font color=#FEAE00>发现这条记录的</font><font color=#FEAE00> trx_id </font><font color=#FEAE00>值为</font><font color=#FEAE00> 51</font><font color=#FEAE00>，在事务</font><font color=#FEAE00> B </font><font color=#FEAE00>的</font><font color=#FEAE00> Read View </font><font color=#FEAE00>的</font><font color=#FEAE00> min_trx_id </font><font color=#FEAE00>和</font><font color=#FEAE00> max_trx_id </font><font color=#FEAE00>之间，则需要判断</font><font color=#FEAE00> trx_id </font><font color=#FEAE00>值是否在</font><font color=#FEAE00> m_ids </font><font color=#FEAE00>范围内，判断的结果是在的，那么说明这条记录是被还未提交的事务修改的，这时事务</font><font color=#FEAE00> B </font><font color=#FEAE00>并不会读取这个版本的记录。而是沿着</font><font color=#FEAE00> undo log </font><font color=#FEAE00>链条往下找旧版本的记录，直到找到</font><font color=#FEAE00> trx_id </font><font color=#FEAE00>「小于」事务</font><font color=#FEAE00> B </font><font color=#FEAE00>的</font><font color=#FEAE00> Read View </font><font color=#FEAE00>中的</font><font color=#FEAE00> min_trx_id </font><font color=#FEAE00>值的第一条记录</font>，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。<br>&emsp;&emsp;最后，当事物 A 提交事务后<font color=#FEAE00>，</font><font color=#FEAE00>由于隔离级别时「可重复读」，所以事务</font><font color=#FEAE00> B </font><font color=#FEAE00>再次读取记录时，还是基于启动事务时创建的</font><font color=#FEAE00> Read View </font><font color=#FEAE00>来判断当前版本的记录是否可见。所以，即使事物</font><font color=#FEAE00> A </font><font color=#FEAE00>将小林余额修改为</font><font color=#FEAE00> 200 </font><font color=#FEAE00>万并提交了事务，</font><font color=#FEAE00> </font><font color=#FEAE00>事务</font><font color=#FEAE00> B </font><font color=#FEAE00>第三次读取记录时，读到的记录都是小林余额是</font><font color=#FEAE00> 100 </font><font color=#FEAE00>万的这条记录</font><font color=#FEAE00>。</font><br>&emsp;&emsp;就是通过这样的方式实现了，「可重复读」隔离级别下在事务期间读到的记录都是事务启动前的记录。<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr><font color=#FEAE00>4.1 </font><font color=#FEAE00>并行事务</font>会引发什么问题？<hr>MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。<br>&emsp;&emsp;那么<font color=#FEAE00>在同时处理多个事务的时候，就可能出现脏读（</font><font color=#FEAE00>dirty read</font><font color=#FEAE00>）、不可重复读（</font><font color=#FEAE00>non-repeatable read</font><font color=#FEAE00>）、幻读（</font><font color=#FEAE00>phantom read</font><font color=#FEAE00>）的问题</font><font color=#FEAE00>。</font><br>&emsp;&emsp;接下来，通过举例子给大家说明，这些问题是如何发生的。<br>&emsp;&emsp;# 脏读<br>&emsp;&emsp;<font color=#FEAE00>如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</font><br>&emsp;&emsp;举个栗子。<br>&emsp;&emsp;	假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后再执行更新操作，如果此时事务 A 还没有提交事务，而此时正好事务 B 也从数据库中读取小林的余额数据，那么事务 B 读取到的余额数据是刚才事务 A 更新后的数据，即使没有提交事务。<br>&emsp;&emsp;￼<br>&emsp;&emsp;因为事务 A 是还没提交事务的，也就是<font color=#FEAE00>它随时可能发生回滚</font>操作，<font color=#FEAE00>如果在上面这种情况事务</font><font color=#FEAE00> A </font><font color=#FEAE00>发生了回滚，那么事务</font><font color=#FEAE00> B </font><font color=#FEAE00>刚才得到的数据就是过期的数据，这种现象就被称为脏读。</font><br>&emsp;&emsp;# 不可重复读<br>&emsp;&emsp;<font color=#FEAE00>在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</font><br>&emsp;&emsp;举个栗子。<br>&emsp;&emsp;假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后继续执行代码逻辑处理，<font color=#FEAE00>在这过程中如果事务</font><font color=#FEAE00> B </font><font color=#FEAE00>更新了这条数据，</font><font color=#00AB8E>并提交了事务</font><font color=#FEAE00>，那么当事务</font><font color=#FEAE00> A </font><font color=#FEAE00>再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;# 幻读<br>&emsp;&emsp;<font color=#FEAE00>在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的</font><font color=#00AB8E>记录数量</font><font color=#FEAE00>不一样的情况，就意味着发生了「幻读」现象。</font><br>&emsp;&emsp;举个栗子。<br>&emsp;&emsp;假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库查询账户余额大于 100 万的记录，发现共有 5 条，然后事务 B 也按相同的搜索条件也是查询出了 5 条记录。<br>&emsp;&emsp;￼<br>&emsp;&emsp;接下来，事务 A 插入了一条余额超过 100 万的账号，并提交了事务，此时数据库超过 100 万余额的账号个数就变为 6。<br>&emsp;&emsp;然后事务 B 再次查询账户余额大于 100 万的记录，此时查询到的记录数量有 6 条，<font color=#FEAE00>发现和前一次读到的记录数量不一样了，就感觉发生了幻觉一样，这种现象就被称为幻读。</font><br>&emsp;&emsp;<hr><hr>4.1 总结<hr>事务是在 MySQL 引擎层实现的，我们常见的 InnoDB 引擎是支持事务的，事务的四大特性是<font color=#FEAE00>原子性、一致性、隔离性、持久性</font>，我们这次主要讲的是隔离性。<br>&emsp;&emsp;当多个事务并发执行的时候，会引发脏读、不可重复读、幻读这些问题，那为了避免这些问题，<font color=#FEAE00>SQL </font><font color=#FEAE00>提出了四种隔离级别</font>，分别是<font color=#FEAE00>读未提交、读已提交、可重复读、串行化</font>，从左往右隔离级别顺序递增，隔离级别越高，意味着性能越差，InnoDB 引擎的默认隔离级别是可重复读。<br>&emsp;&emsp;<font color=#FEAE00>要解决脏读现象，就要将隔离级别升级到读已提交以上的隔离级别，要解决不可重复读现象，就要将隔离级别升级到可重复读以上的隔离级别。</font><br>&emsp;&emsp;而对于幻读现象，不建议将隔离级别升级为串行化，因为这会导致数据库并发时性能很差。InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它通过 <font color=#FEAE00>next-key lock </font><font color=#FEAE00>锁（行锁</font><font color=#FEAE00>+</font><font color=#FEAE00>间隙锁的组合）</font>来锁住记录之间的“间隙”和记录本身，防止其他事务在这个记录之间插入新的记录，这样就避免了幻读现象。<br>&emsp;&emsp;对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：<br>&emsp;&emsp;	•	「读提交」隔离级别是在<font color=#FEAE00>每个</font><font color=#FEAE00> select </font><font color=#FEAE00>都会生成一个新的</font><font color=#FEAE00> Read View</font>，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。<br>&emsp;&emsp;	•	「可重复读」隔离级别是<font color=#FEAE00>启动事务时生成一个</font><font color=#FEAE00> Read View</font><font color=#FEAE00>，</font>然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。<br>&emsp;&emsp;这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 <font color=#FEAE00>MVCC</font><font color=#FEAE00>（多版本并发控制）。</font><br>&emsp;&emsp;在可重复读隔离级别中，普通的 select 语句就是基于 MVCC 实现的快照读，也就是不会加锁的。而 select .. for update 语句就不是快照读了，而是当前读了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。<hr><hr><font color=#FEAE00>4.1 </font><font color=#FEAE00>读提交</font>是如何工作的？<hr><font color=#FEAE00>读提交隔离级别是在每次读取数据时，都会生成一个新的</font><font color=#FEAE00> Read View</font><font color=#FEAE00>。</font><br>&emsp;&emsp;也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。<br>&emsp;&emsp;那读提交隔离级别是怎么工作呢？我们还是以前面的例子来聊聊。<br>&emsp;&emsp;假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，接着按顺序执行了以下操作：<br>&emsp;&emsp;	•	事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；<br>&emsp;&emsp;	•	事务 A 修改数据（还没提交事务），将小林的账户余额从 100 万修改成了 200 万；<br>&emsp;&emsp;	•	事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；<br>&emsp;&emsp;	•	事务 A 提交事务；<br>&emsp;&emsp;	•	事务 B 读取数据（创建 Read View），小林的账户余额为 200 万；<br>&emsp;&emsp;那具体怎么做到的呢？我们重点看<font color=#FEAE00>事务</font><font color=#FEAE00> B </font><font color=#FEAE00>每次读取数据时创建的</font><font color=#FEAE00> Read View</font><font color=#FEAE00>。</font>前两次 事务 B 读取数据时创建的 Read View 如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;我们来分析下为什么事务 B 第二次读数据时，读不到事务 A （还未提交事务）修改的数据？<br>&emsp;&emsp;事务 B 在找到小林这条记录时，会看这条记录的 trx_id 是 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，接下来需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明<font color=#FEAE00>这条记录是被还未提交的事务修改的，这时事务</font><font color=#FEAE00> B </font><font color=#FEAE00>并不会读取这个版本的记录</font><font color=#FEAE00>。</font>而是，沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。<br>&emsp;&emsp;# 我们来分析下为什么事务 A 提交后，事务 B 就可以读到事务 A 修改的数据？<br>&emsp;&emsp;在事务 A 提交后<font color=#FEAE00>，</font><font color=#FEAE00>由于隔离级别是「读提交」，所以事务</font><font color=#FEAE00> B </font><font color=#FEAE00>在每次读数据的时候，会重新创建</font><font color=#FEAE00> Read View</font><font color=#FEAE00>，</font>此时事务 B 第三次读取数据时创建的 Read View 如下：<br>&emsp;&emsp;￼<br>&emsp;&emsp;事务 B 在找到小林这条记录时<font color=#FEAE00>，</font><font color=#FEAE00>会发现这条记录的</font><font color=#FEAE00> trx_id </font><font color=#FEAE00>是</font><font color=#FEAE00> 51</font><font color=#FEAE00>，比事务</font><font color=#FEAE00> B </font><font color=#FEAE00>的</font><font color=#FEAE00> Read View </font><font color=#FEAE00>中的</font><font color=#FEAE00> min_trx_id </font><font color=#FEAE00>值（</font><font color=#FEAE00>52</font><font color=#FEAE00>）还小，这意味着修改这条记录的事务早就在创建</font><font color=#FEAE00> Read View </font><font color=#FEAE00>前提交过了，所以该版本的记录对事务</font><font color=#FEAE00> B </font><font color=#FEAE00>是可见的</font><font color=#FEAE00>。</font><br>&emsp;&emsp;正是因为在读提交隔离级别下，事务每次读数据时都重新创建 Read View，那么在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。<hr><hr>4.2 <font color=#FEAE00>幻读</font>是怎么被解决的？<hr>大家好，我是小林。<br>&emsp;&emsp;我之前写过一篇数据库事务的文章「<font color=#FEAE00> </font><font color=#FEAE00>事务、事务隔离级别和</font><font color=#FEAE00>MVCC</font>，这篇我说过什么是<font color=#FEAE00>幻读。</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;然后前几天有位读者跟我说，我这个幻读例子不是已经被「<font color=#FEAE00>可重复读</font>」隔离级别解决了吗？为什么还要<font color=#FEAE00>有</font><font color=#FEAE00> next-key</font> 呢？<br>&emsp;&emsp;他有这个质疑，是因为他做了这个实验。<br>&emsp;&emsp;实验的数据库表 t_stu 如下，其中 id 为主键。<br>&emsp;&emsp;￼<br>&emsp;&emsp;然后在可重复读隔离级别下，有两个事务的执行顺序如下：<br>&emsp;&emsp;￼<br>&emsp;&emsp;从这个实验结果可以看到，即使事务 B 中途插入了一条记录，事务 A 前后两次查询的结果集都是一样的，并没有出现所谓的幻读现象。<br>&emsp;&emsp;读者做的实验之所以看不到幻读现象，是因为在可重复读隔离级别下，<font color=#FEAE00>普通的查询是快照读，是不会看到别的事务插入的数据的</font><font color=#FEAE00>。</font><br>&emsp;&emsp;可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是启动事务后，在执行第一个查询语句后，会创建一个 Read View，然后后续的查询语句利用这个 Read View，通过 Read View<font color=#FEAE00> </font><font color=#FEAE00>就可以在</font><font color=#FEAE00> undo log </font><font color=#FEAE00>版本链找</font>到事务开始时的数据，所以每次查询的数据都是一样的。如果你还不清楚 MVCC 的实现，快去看这篇复习一下：<font color=#FEAE00>事务隔离级别是怎么实现的？</font><font color=#5478F6><br>&emsp;&emsp;</font>MySQL 里除了<font color=#FEAE00>普通查询是快照读，其他都是</font><font color=#FEAE00>当前读</font>，比如<font color=#FEAE00>update</font><font color=#FEAE00>、</font><font color=#FEAE00>insert</font><font color=#FEAE00>、</font><font color=#FEAE00>delete</font>，这些语句执行前都会查询最新版本的数据，然后再做进一步的操作。<br>&emsp;&emsp;这很好理解，假设你要 update 一个记录，另一个事务已经 delete 这条记录并且提交事务了，这样不是会产生冲突吗，所以 <font color=#FEAE00>update </font><font color=#FEAE00>的时候肯定要知道最新的数据。</font><br>&emsp;&emsp;另外，<font color=#FEAE00>select ... for update </font>这种查询语句是<font color=#FEAE00>当前读</font>，每次执行的时候都是读取最新的数据。<br>&emsp;&emsp;<font color=#FEAE00>因此，要讨论「可重复读」隔离级别的幻读现象，是要建立在「当前读」的情况下。</font><br>&emsp;&emsp;接下来，我们假设<font color=#4D647F>select ... for update</font>当前读是不会加锁的（实际上是会加锁的），在做一遍读者那个实验。<br>&emsp;&emsp;￼<br>&emsp;&emsp;这时候，事务 B 插入的记录，就会被事务 A 的第二条查询语句查询到（因为是当前读），这样就会出现前后两次查询的结果集合不一样，这就出现了幻读。<br>&emsp;&emsp;所以，<font color=#FEAE00>Innodb </font><font color=#FEAE00>引擎为了解决「可重复读」隔离级别使用「当前读」而造成的幻读问题，就引出了</font><font color=#FEAE00> next-key </font><font color=#FEAE00>锁</font><font color=#FEAE00>，</font>就是记录锁和间隙锁的组合。<br>&emsp;&emsp;	•	<font color=#FEAE00>记录锁，锁的是记录本身；</font><br>&emsp;&emsp;	•	<font color=#FEAE00>间隙锁，锁的就是两个值之间的空隙，</font>以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。<br>&emsp;&emsp;比如，执行这条语句的时候，会锁住，然后期间如果有其他事务在这个锁住的范围插入数据就会被阻塞。<br>&emsp;&emsp;￼<br>&emsp;&emsp;next-key 锁的加锁规则其实挺复杂的，在一些场景下会退化成<font color=#FEAE00>记录锁或间隙锁</font>，我之前也写一篇加锁规则，详细可以看这篇「<font color=#FEAE00>MySQL </font><font color=#FEAE00>是怎么加锁的？</font><br>&emsp;&emsp;需要注意的是，如果 update 语句的 where 条件没有用到索引列，那么就会<font color=#FEAE00>全表扫描</font>，在一行行扫描的过程中，不仅给行数据加上了行锁，还给行两边的空隙也加上了间隙锁，相当于锁住整个表，然后直到事务结束才会释放锁。<br>&emsp;&emsp;所以，<font color=#FEAE00>在线上千万不要执行没有带索引的</font><font color=#FEAE00> update </font><font color=#FEAE00>语句</font>，不然会造成业务停滞，我有个读者就因为干了这个事情，然后被老板教育了一波，详细可以看这篇「<font color=#FEAE00>update </font><font color=#FEAE00>没加索引会锁全表？</font><font color=#FEAE00><br>&emsp;&emsp;(opens new window)</font><hr><hr>4.tidb底层的key v是怎么存储的<hr>lsm tree？<hr><hr>4.tidb的架构是什么？<hr><hr>4.todo<br>&emsp;&emsp;分布式mvcc怎么实现？<hr><hr>4.todo percolater的具体实现？<hr><hr>4.todo 什么是2pc 同步阻塞？<hr><hr>4、有MySQL不就够用了吗？为什么要用Redis这种新的数据库？<hr>主要是因为 Redis 具备<font color=#1DB100>高性能和高并发</font>两种特性。<br>&emsp;&emsp;<br>&emsp;&emsp;- 高性能：假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！<br>&emsp;&emsp;- 高并发：直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。<hr><hr><font color=#FEAE00>5.1 MySQL</font> 有哪些锁？<hr>大家好，我是小林。<br>&emsp;&emsp;这次，来说说<font color=#FEAE00> </font><font color=#FEAE00>MySQL </font><font color=#FEAE00>的锁</font>，主要是 Q&A 的形式，看起来会比较轻松。<br>&emsp;&emsp;不多 BB 了，<font color=#FEAE00>发车！</font><br>&emsp;&emsp;在 MySQL 里，根据加锁的范围，可以分为<font color=#FEAE00>全局锁、表级锁和行锁</font>三类。<br>&emsp;&emsp;￼<hr><hr>5.2 MySQL 是<font color=#FEAE00>怎么加锁</font>的？<hr>大家好，我是小林。<br>&emsp;&emsp;在前一篇文章我讲了下 MySQL 的<font color=#FEAE00>全局锁、表级锁和行级别锁，</font>其中行级锁只提了概念，并没有具体说。<br>&emsp;&emsp;因为行级锁加锁规则比较复杂，不同的场景，加锁的形式还不同，所以这次就来好好介绍下行级锁。<br>&emsp;&emsp;对记录加锁时，<font color=#FEAE00>加锁的基本单位是</font><font color=#FEAE00> next-key lock</font>，它是由记录锁和间隙锁组合而成的，<font color=#FEAE00>next-key lock </font><font color=#FEAE00>是前开后闭区间，而间隙锁是前开后开区间</font><font color=#FEAE00>。</font><br>&emsp;&emsp;但是，next-key lock 在一些场景下会退化成记录锁或间隙锁。<br>&emsp;&emsp;那到底是什么场景呢？今天，我们就以下面这个表来进行实验说明。<br>&emsp;&emsp;￼<br>&emsp;&emsp;其中，id 是主键索引（唯一索引），b 是普通索引（非唯一索引），a 是普通的列。<br>&emsp;&emsp;注意，<font color=#FEAE00>我的</font><font color=#FEAE00> MySQL </font><font color=#FEAE00>的版本是</font><font color=#FEAE00> 8.0.26</font><font color=#FEAE00>，不同版本的加锁规则可能是不同的</font><font color=#FEAE00>。</font><br>&emsp;&emsp;￼<hr><hr>6、使用Redis的好处有哪些？<hr>1、访问速度快，因为数据存在内存中，类似于Java中的HashMap或者C++中的哈希表（如unordered_map/unordered_set），这两者的优势就是查找和操作的时间复杂度都是O(1)<br>&emsp;&emsp;<br>&emsp;&emsp;2、数据类型丰富，支持String，list，set，sorted set，hash这五种数据结构<br>&emsp;&emsp;<br>&emsp;&emsp;3、支持事务，<font color=#FEAE00>Redis</font><font color=#FEAE00>中的操作都是原子性</font>，换句话说就是对数据的更改要么全部执行，要么全部不执行，这就是原子性的定义<br>&emsp;&emsp;<br>&emsp;&emsp;4、特性丰富：Redis可用于缓存，消息，按key设置过期时间，过期后将会自动删除。<hr><hr>7、Memcached与Redis的区别都有哪些？<hr>1、存储方式<br>&emsp;&emsp;<br>&emsp;&emsp;- Memecache把数据全部存在内存之中，断电后会挂掉，没有持久化功能，数据不能超过内存大小。<br>&emsp;&emsp;- Redis有部份存在硬盘上，这样能保证数据的持久性。<br>&emsp;&emsp;<br>&emsp;&emsp;2、数据支持类型<br>&emsp;&emsp;<br>&emsp;&emsp;- Memcache对数据类型支持相对简单,只有String这一种类型<br>&emsp;&emsp;- Redis有复杂的数据类型。Redis不仅仅支持简单的k/v类型的数据，同时还提供 list，set，zset，hash等数据结构的存储。<br>&emsp;&emsp;<br>&emsp;&emsp;3、使用底层模型不同<br>&emsp;&emsp;<br>&emsp;&emsp;- 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。<br>&emsp;&emsp;- <font color=#FEAE00>Redis</font><font color=#FEAE00>直接自己构建了</font><font color=#FEAE00>VM </font><font color=#FEAE00>机制</font><font color=#FEAE00> </font>，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。<br>&emsp;&emsp;<br>&emsp;&emsp;4、集群模式：Memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；<font color=#FEAE00>但是</font><font color=#FEAE00> Redis </font><font color=#FEAE00>目前</font><font color=#FEAE00> </font><font color=#FEAE00>是原生支持</font><font color=#FEAE00> cluster </font><font color=#FEAE00>模式的</font><font color=#FEAE00>.</font><br>&emsp;&emsp;<br>&emsp;&emsp;5、Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。<br>&emsp;&emsp;<br>&emsp;&emsp;6、Value 值大小不同：Redis 最大可以达到 512MB；Memcached 只有 1MB。<hr><hr>8、Redis比Memcached的优势在哪里？<hr>1、Memcached所有的值均是简单字符串，Redis作为<font color=#FEAE00>其替代者，支持更为丰富的数据类型</font><br>&emsp;&emsp;<br>&emsp;&emsp;2、Redis 的速度比 Memcached 快很多<br>&emsp;&emsp;<br>&emsp;&emsp;3、<font color=#FEAE00>Redis</font><font color=#FEAE00>可以做到持久化数据</font><hr><hr>B+ 树是如何进行查询的？<hr>	上面我们都是在说一个数据页中的记录检索，因为一个数据页中的记录是有限的，且主键值是有序的，所以通过对所有记录进行分组，然后将组号（槽号）存储到页目录，使其起到索引作用，通过<font color=#FEAE00>二分查找</font>的方法快速检索到记录在哪个分组，来降低检索的时间复杂度。<br>&emsp;&emsp;	但是，当我们需要存储<font color=#FEAE00>大量的记录时</font>，就需要多个数据页，这时我们就需要考虑如何建立合适的索引，才能方便定位记录所在的页。<br>&emsp;&emsp;	为了解决这个问题，<font color=#FEAE00>InnoDB </font><font color=#FEAE00>采用了</font><font color=#FEAE00> B+ </font><font color=#FEAE00>树作为索引</font>。磁盘的 I/O 操作次数对索引的使用效率至关重要，因此在构造索引的时候，我们更倾向于采用“<font color=#FEAE00>矮胖</font>”的 B+ 树数据结构，这样所需要进行的磁盘 I/O 次数更少，而且 B+ 树 更适合进行关键字的范围查询。<br>&emsp;&emsp;InnoDB 里的 B+ 树中的<font color=#FEAE00>每个节点都是一个数据页</font>，结构示意图如下：<br>&emsp;&emsp;￼<br>&emsp;&emsp;通过上图，我们看出 B+ 树的特点：<br>&emsp;&emsp;	•	<font color=#FEAE00>只有叶子节点（最底层的节点</font>）才存放了数据，非叶子节点（其他上层节）<font color=#FEAE00>仅用来存放目录项</font>作为索引。<br>&emsp;&emsp;	•	非叶子节点分为不同层次，通过分层来降低每一层的搜索量；<br>&emsp;&emsp;	•	所有节点按照<font color=#FEAE00>索引键大小排序</font>，构成一个双向链表，便于范围查询；<br>&emsp;&emsp;我们再看看 B+ 树如何实现快速查找主键为 6 的记录，以上图为例子：<br>&emsp;&emsp;	•	从根节点开始，通过<font color=#FEAE00>二分法</font>快速定位到符合页内范围包含查询值的页，因为查询的主键值为 6，在[1, 7)范围之间，所以到页 30 中查找更详细的目录项；<br>&emsp;&emsp;	•	在非叶子节点（页30）中，继续通过二分法快速定位到符合页内范围包含查询值的页，主键值大于 5，所以就到叶子节点（页16）查找记录；<br>&emsp;&emsp;	•	接着，在叶子节点（页16）中，通过槽查找记录时，使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到主键为 6 的记录。<br>&emsp;&emsp;	可以看到，在定位记录所在哪一个页时，也是通过二分法快速定位到包含该记录的页。定位到该页后，又会在该页内进行二分法快速定位记录<font color=#FEAE00>所在的分组（槽号）</font>，最后在分组内进行遍历查找。<br>&emsp;&emsp;<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>CMU 15445 10. 连接<hr>为什么我们需要连接？<br>&emsp;&emsp;我们规范化关系数据库中的表，以避免<font color=#FEAE00>不必要的信息重复。</font><br>&emsp;&emsp; 我们使用<font color=#FEAE00>join</font><font color=#FEAE00>操作</font>来重建原始元组<font color=#FEAE00>而不会丢失任何信息。</font><br>&emsp;&emsp;不同算法的成本分析<br>&emsp;&emsp;￼<br>&emsp;&emsp;image.png<br>&emsp;&emsp;下面一共会介绍5种连接算法。<br>&emsp;&emsp; 分别是<br>&emsp;&emsp;	▪	<font color=#FEAE00>simple loop</font> join<br>&emsp;&emsp;	▪	<font color=#FEAE00>block loop</font> join<br>&emsp;&emsp;	▪<font color=#FEAE00>	index loop</font> join<br>&emsp;&emsp;	▪	<font color=#FEAE00>sort-merge</font> join<br>&emsp;&emsp;	▪	<font color=#FEAE00>hash join</font><br>&emsp;&emsp;simple loop join<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;block loop join<br>&emsp;&emsp;优化1，读取整块，2变各读取整块后，开始循环这2个整块 然后JOIN。<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;利用全BUFFER 提速<br>&emsp;&emsp;我们假设有B个BUFFER， <font color=#FEAE00>B-2</font><font color=#FEAE00>个用来扫描外层表。一个扫描内层表</font>，一个用来存储OUTPUT。<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;利用INDEX提速<br>&emsp;&emsp;￼<br>&emsp;&emsp; Assume the cost of each index probe is some<br>&emsp;&emsp; constant C per tuple.<br>&emsp;&emsp; Cost: M + (m ∙ C)<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#FEAE00>Sort-Merge</font> Join<br>&emsp;&emsp;分为2个阶段，<br>&emsp;&emsp;	1.	使用外排序算法对<font color=#FEAE00>2</font><font color=#FEAE00>个</font><font color=#FEAE00>TABLE</font><font color=#FEAE00>做排序</font><br>&emsp;&emsp;	2.	<font color=#FEAE00>使用</font><font color=#FEAE00>MERGE</font>，找到MATCHING的元组 ￼￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;什么时候使用SORT-MERGE JOIN比较好？<br>&emsp;&emsp;当一个或者2个TABLE已经按照JOIN KEY 排好序了。<br>&emsp;&emsp; 输出必须要在<font color=#FEAE00>JOIN KEY</font><font color=#FEAE00>上排好序的。</font><br>&emsp;&emsp;Hash join<br>&emsp;&emsp;Hash Join 的思想就是2边都按JOIN KEY 做HASH，那么JOIN <font color=#FEAE00>KEY</font><font color=#FEAE00>相等的肯定在一个</font><font color=#FEAE00>HASH</font><font color=#FEAE00>分块里。</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<hr><hr>CMU 15445 11. Query 优化<br>&emsp;&emsp;<hr>SQL是<font color=#FEAE00>声明性的</font>。 这意味着用户告诉DBMS他们想要什么答案，而不是如何得到答案。 因此，DBMS需要将<font color=#FEAE00>SQL</font><font color=#FEAE00>语句转换为可执行的查询计划</font>。 但是有不同的方法来执行查询（例如，<font color=#FEAE00>join</font><font color=#FEAE00>的算法</font>），这些计划的性能会有所不同。 因此，DBMS需要一种方法来为给定查询选择“最佳”计划。 这是DBMS优化器的工作。<br>&emsp;&emsp;有2种优化的策略：<br>&emsp;&emsp;	1.	<font color=#FEAE00>基于规则的</font>： 通过重写QUERY来消除不高效，不需要一个成本模型。<br>&emsp;&emsp;	2.	<font color=#FEAE00>基于成本的</font>： 使用<font color=#FEAE00>成本模型来评估</font>多种<font color=#FEAE00>等价计划</font>然后选择成本最小的。<br>&emsp;&emsp;￼<br>&emsp;&emsp;基于规则的优化<br>&emsp;&emsp;主要有2种手段。<font color=#FEAE00>where</font><font color=#FEAE00>下沉</font>。表达式简化。<br>&emsp;&emsp;where 下沉<br>&emsp;&emsp;￼<br>&emsp;&emsp;上述方法可以让filter<font color=#FEAE00>提前过滤掉很多数据</font>，使得只有少部分数据需要<font color=#FEAE00>传输和</font><font color=#FEAE00>join</font>，从而来提高效率。<br>&emsp;&emsp;<font color=#FEAE00>表达式简化</font><br>&emsp;&emsp;移除不必要的条件。<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;<font color=#FEAE00>合并条件。</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;基于<font color=#FEAE00>成本分析</font>的优化<br>&emsp;&emsp;DBMS的优化器将使用<font color=#FEAE00>内部成本模型来估计特定查询计划的执行成本</font>。 这提供了一种估计，以确定一个计划是否优于另一个计划而不必实际运行查询（这对于数千个计划来说会很慢）。<br>&emsp;&emsp; 此估计值是一个<font color=#FEAE00>内部指标与实际指标不具有可比性</font>，但可以通过估算不同资源的使用情况得出：<br>&emsp;&emsp; 磁盘，内存，cpu，网络<br>&emsp;&emsp;为此，DBMS在其<font color=#FEAE00>内部目录中存储有关表</font>，<font color=#FEAE00>属性和索引的内部统计信息</font>。 不同的系统会在不同时间更新统计信息。 与开源系统相比，商业DBMS具有更强大和准确的统计数据。 这些是估算值，因此成本估算通常是不准确的<br>&emsp;&emsp;Derivable 统计<br>&emsp;&emsp;￼<br>&emsp;&emsp;存储统计<br>&emsp;&emsp;维护一个<font color=#FEAE00>直方图</font>，来预估一个谓词会涉及到多少<br>&emsp;&emsp; 如果不均匀的话，就以<font color=#FEAE00>桶的形式</font>使得每个高度尽可能接近。<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;当然也可以使用<font color=#FEAE00>抽样法。</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;搜索最少COST的算法<br>&emsp;&emsp;￼<br>&emsp;&emsp;<font color=#FEAE00>枚举顺序</font>，枚举计划针对每个算子，枚举获取方式对每个表。使用动态规划减少成本估计的数量。<hr><hr>CMU 15445 12. 并发模型<br>&emsp;&emsp;<hr>背景<br>&emsp;&emsp;所有并行执行查询的DBMS都提供了以下几个好处：<br>&emsp;&emsp;	▪	<font color=#FEAE00>提高吞吐量和延迟性能</font>。<br>&emsp;&emsp;	▪	提高<font color=#FEAE00>可用性</font>。<br>&emsp;&emsp;	▪	可能<font color=#FEAE00>降低总体拥有成本（</font><font color=#FEAE00>TCO</font><font color=#FEAE00>）</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;在并行或分布式DBMS中，数据库分布在多个资源上以提高并行性。<br>&emsp;&emsp; 数据库“<font color=#FEAE00>显示</font>”为应用程序的<font color=#FEAE00>单个数据库实例。</font>单节点DBMS的SQL查询应该在<font color=#FEAE00>并行或分布式</font><font color=#FEAE00>DBMS</font>上生成相同的结果。<br>&emsp;&emsp;并行DBMS：<br>&emsp;&emsp;	▪	节点在<font color=#FEAE00>物理上彼此靠近</font>。<br>&emsp;&emsp;	▪	节点与<font color=#FEAE00>高速</font><font color=#FEAE00>LAN</font><font color=#FEAE00>连接</font>。<br>&emsp;&emsp;	▪	假设节点之间的<font color=#FEAE00>通信成本快速可靠</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;分布式DBMS：<br>&emsp;&emsp;	▪	节点可以<font color=#FEAE00>相距很远。</font><br>&emsp;&emsp;	▪	节点使用<font color=#FEAE00>公共网络连接。</font><br>&emsp;&emsp;	▪	节点之间的<font color=#FEAE00>通信成本较慢，故障也不容忽视</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;并行的类型<br>&emsp;&emsp;	▪	Inter-Query：（查询之间的）DBMS<font color=#FEAE00>同时执行不同的查询</font>。这可以提高吞吐量并减少延迟。查询更新数据库时，<font color=#FEAE00>并发性很棘手。</font><br>&emsp;&emsp;	▪	Intra-Query：（同一个查询）DBMS<font color=#FEAE00>并行执行单个查询的操作</font>。这减少了长时间运行的查询的延迟。<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;Process Models<br>&emsp;&emsp;<font color=#FEAE00>DBMS Process Model</font>定义了系统如何支持来自多用户应用程序/环境的并发请求。<br>&emsp;&emsp; DBMS由更多或更多的Worker组成，他们负责代表客户端执行任务并返回结果。<br>&emsp;&emsp;方法＃1  - Process per Worker：<br>&emsp;&emsp;	▪	每个worker都是一个<font color=#FEAE00>单独的</font><font color=#FEAE00>OS</font><font color=#FEAE00>进程</font>，因此依赖于OS调度程序。<br>&emsp;&emsp;	▪	将<font color=#FEAE00>共享内存用于全局数据结构。</font><br>&emsp;&emsp;	▪	进程崩溃不会导致整个系统崩溃。<br>&emsp;&emsp;<br>&emsp;&emsp;方法＃2  - 进程池：<br>&emsp;&emsp;	▪	Worker使用池中<font color=#FEAE00>任何可用的任何进程。</font><br>&emsp;&emsp;	▪	仍然依赖于OS调度程序和共享内存。<br>&emsp;&emsp;	▪	由于无法保证在<font color=#FEAE00>查询之间使用相同的进程</font>，因此这种方法可能对<font color=#FEAE00>CPU</font><font color=#FEAE00>缓存局部性不利。</font><br>&emsp;&emsp;<br>&emsp;&emsp;方法＃3  - 每个WORKER<font color=#FEAE00>一个线程：</font><br>&emsp;&emsp;	▪	具有多个工作线程的单个进程。<br>&emsp;&emsp;	▪	DBMS<font color=#FEAE00>必须管理自己的计划。</font><br>&emsp;&emsp;	▪	可能会或可能不会使用调度线程。<br>&emsp;&emsp;	▪	虽然<font color=#FEAE00>线程崩溃（可能）会导致整个系统崩溃</font>，但我们必须确保编写<font color=#FEAE00>高质量的代码</font>以确保不会发生这种情况。<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;使用<font color=#FEAE00>多线程体系结构</font>的优点是每个<font color=#FEAE00>上下文切换的开销更少</font>，并且您不必管理共享模型。 每个工作者模型的线程并不意味着您具有<font color=#FEAE00>查询内并行性（</font><font color=#FEAE00>intra-query parallelism</font><font color=#FEAE00>）。</font><br>&emsp;&emsp; 对于每个查询计划，DBMS必须决定执行的位置，时间和方式：<br>&emsp;&emsp; • 它应该使用多少个任务？<br>&emsp;&emsp; • 它应该使用多少个CPU核心？<br>&emsp;&emsp; • 任务执行的CPU核心是什么？<br>&emsp;&emsp; • 任务应在何处存储其输出？<br>&emsp;&emsp;多个QUERY的并行<br>&emsp;&emsp;如果都是读，比较简单。涉及到写，很难做对。要用到<font color=#FEAE00>隔离或者锁</font>。我会在之后的<font color=#FEAE00>2PL,OCC,MVCC</font>里介绍<br>&emsp;&emsp;单个QUERY的并行<br>&emsp;&emsp;此类并行性的目标是<font color=#FEAE00>通过并行执行其运算符来提高单个查询的性能</font>。 每个<font color=#FEAE00>关系运算符都有并行算法。</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;Intra-Operator Parallelism<br>&emsp;&emsp;	▪	查询计划的<font color=#FEAE00>运算符被分解为独立实例</font>，这些实例在不同的数据子集上执行相同的函数。<br>&emsp;&emsp;	▪	DBMS在查询计划中<font color=#FEAE00>插入</font><font color=#FEAE00>exchange</font><font color=#FEAE00>运算符</font>，以合并来自子运算符的结果。<br>&emsp;&emsp;<br>&emsp;&emsp;交换运算符阻止DBMS在计划中执行它上面的运算符，直到它<font color=#FEAE00>从子节点接收到所有数据</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;Inter-Operator Parallelism<br>&emsp;&emsp;	▪	<font color=#FEAE00>操作重叠</font>，以便将数据从一个阶段传递到下一个阶段而不实现。这有时称为<font color=#FEAE00>流水线并行。</font><br>&emsp;&emsp;	▪	此方法未在传统关系DBMS中广泛使用。 并非所有算子都能在他们看到孩子们的所有元组之前发出输出。 这在流处理系统中更常见，该系统是在输入元组流上不断执行查询的系统。 ￼<br>&emsp;&emsp;<br>&emsp;&emsp;IO 并行<br>&emsp;&emsp;如果磁盘始终是主要瓶颈，则使用其他进程/线程并行执行查询将无法提高性能。因此，我们需要一种方法将数据库<font color=#FEAE00>拆分为多个存储设备。</font><br>&emsp;&emsp;多磁盘并行<br>&emsp;&emsp;配置OS /硬件以将DBMS的文件存储在<font color=#FEAE00>多个存储设备中</font>。可以通过存储设备和RAID配置来完成。这对DBMS是透明的。它不能让Worker在不同的设备上运行，因为它不知道潜在的并行性。<br>&emsp;&emsp;基于文件的分区<br>&emsp;&emsp;某些DBMS允许您指定每个单独数据库的磁盘位置。缓冲池管理器将页面映射到磁盘位置。如果DBMS将每个数据库存储在单独的目录中，这在文件系统级别也很容易。但是，可能会共享日志文件。<br>&emsp;&emsp;逻辑分区<br>&emsp;&emsp;将单个逻辑表拆分为<font color=#FEAE00>单独存储</font><font color=#FEAE00>/</font><font color=#FEAE00>管理的不相交的物理段。</font>这种分区对于应用程序来说理想地是透明的。也就是说，应用程序应该能够访问逻辑表而无需关心事物的存储方式。<br>&emsp;&emsp;垂直分区：<br>&emsp;&emsp;	▪	将<font color=#FEAE00>表的属性存储在单独的位置</font>（如列存储）。<br>&emsp;&emsp;	▪	必须存储元组信息以重建原始记录。 ￼<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;水平分区：<br>&emsp;&emsp;	▪	根据<font color=#FEAE00>某些分区键将表的元组划分为不相交的段。</font><br>&emsp;&emsp;	▪	有不同的方法来决定如何分区（例如，<font color=#FEAE00>散列，范围或谓词分区</font>）。每种方法的功效取决于查询。 ￼<hr><hr>CMU 15445 13.并发控制理论<br>&emsp;&emsp;<hr>ACID<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;原子性：一个事务的所有的操作要么全发生，要么全不发生<br>&emsp;&emsp; 一致性：如果在事务的开始，数据库的状态是一致的，那么可以确保在事务结束的时候也是一致的。<br>&emsp;&emsp; 隔离性：一个事务的操作对其他事务是隔离的。<br>&emsp;&emsp; <font color=#FEAE00>持久性</font>：如果事务提交，那么对db的改动是持久的。<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;原子性有<font color=#FEAE00>2</font><font color=#FEAE00>种实现方式。</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;一致性<br>&emsp;&emsp;数据库<font color=#FEAE00>准确地模拟现实世界并遵循完整性约束。</font><br>&emsp;&emsp;将来的事务会看到过去在数据库中提交的事务的影响。<br>&emsp;&emsp;如果数据库在事务开始之前是一致的（单独运行），那么它之后也将是一致的。<br>&emsp;&emsp;事务一致性是应用程序的责任。<br>&emsp;&emsp;隔离性<br>&emsp;&emsp;DBMS为事务提供了它们在系统中单独运行的错觉。 他们没有看到并发事务的影响。 这相当于以<font color=#FEAE00>串行顺序（即，一次一个）</font>执行事务的系统。 但是为了获得更好的性能，DBMS必须交错并发事务的操作。<br>&emsp;&emsp; 这就需要并行协议来保证。<br>&emsp;&emsp;并行协议<br>&emsp;&emsp;有2类并行协议，一类是<font color=#FEAE00>悲观的，一类是乐观的。</font><br>&emsp;&emsp; 1.悲观：DBMS认为事务会发生冲突，因此在一开始就做预防措施。<br>&emsp;&emsp; 2.乐观：DBMS假设交易之间的冲突很少，因此它选择在冲突发生时再补救。<br>&emsp;&emsp;当dbms交替的执行操作，就会出现一些问题。有如下三类。<br>&emsp;&emsp;<font color=#FEAE00>读</font><font color=#FEAE00> - </font><font color=#FEAE00>写冲突（“不可重复读取”）</font>：事务处理时多次读取同一个对象，无法获得相同的值。<br>&emsp;&emsp;<font color=#FEAE00>写</font><font color=#FEAE00> - </font><font color=#FEAE00>读冲突（“脏读”）</font>：事务看到另一个事务的写入的值在那个事务提交前。<br>&emsp;&emsp;<font color=#FEAE00>写</font><font color=#FEAE00> - </font><font color=#FEAE00>写冲突（“覆盖未提交数据”）</font>：一个事务<font color=#FEAE00>覆盖另一个并发事务</font>的未提交数据。<br>&emsp;&emsp;Conflict Serializability 和 View Serializability<br>&emsp;&emsp;￼<br>&emsp;&emsp;<font color=#FEAE00>Conflict Serializability</font>就是移动了指令的先后顺序对整体不会有影响。<br>&emsp;&emsp; 第一张图是Conflict Serializability，第二张不是。<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;验证算法<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;如果是无环图的话， 就是可序列化的<br>&emsp;&emsp;<br>&emsp;&emsp;View Serializability<br>&emsp;&emsp;<font color=#FEAE00>View Serializability</font>比较抽象，他可以允许有环。如下图其实是等价的，但是我们画依赖图也是有环的。<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;View Serializability允许所有Conflict Serializability<font color=#FEAE00>和“盲写”的计划</font>。 因此，允许比Conflict Serializability稍微更多的计划，但难以有效地执行。 这是因为DBMS现在不知道应用程序将如何“解释”值。<br>&emsp;&emsp;持久性<br>&emsp;&emsp;同样也是用<font color=#FEAE00>log </font><font color=#FEAE00>和</font><font color=#FEAE00> shadow paging</font><font color=#FEAE00>来实现</font><br>&emsp;&emsp;<hr><hr>CMU 15445 14.二阶段锁定 ppt 17<hr>DBMS包含一个<font color=#FEAE00>锁管理器</font>，用于决定<font color=#FEAE00>事务是否可以锁定</font>。 它了解系统内部的最新情况。<br>&emsp;&emsp; •<font color=#FEAE00>共享锁</font>（<font color=#EA36D4>S-LOCK</font>）：允许多个事务同时读取同一对象的锁。 如果<font color=#FEAE00>一个事务持有共享锁</font>，则另一个事务可以获取该共享锁。<br>&emsp;&emsp; •<font color=#FEAE00>独占锁定</font>（<font color=#EA40C3>X-LOCK</font>）：允许<font color=#FEAE00>事务修改对象</font>。 此锁与任何其他锁不兼容。 一次只能有一个事务持有独占锁。<br>&emsp;&emsp;<br>&emsp;&emsp;使用锁执行SQL：<br>&emsp;&emsp; 1.事务从锁管理器<font color=#FEAE00>请求锁（或升级）</font>。<br>&emsp;&emsp; 2.锁管理器根据其他事务当前持有的锁<font color=#FEAE00>来授予或阻止请求</font>。<br>&emsp;&emsp; 3.当不再需要时，<font color=#FEAE00>事务释放锁。</font><br>&emsp;&emsp; 4.锁管理器<font color=#FEAE00>更新其内部锁表</font>，然后<font color=#FEAE00>把锁给其他等待的事务。</font><br>&emsp;&emsp;<br>&emsp;&emsp;二阶段锁定<br>&emsp;&emsp;<font color=#FEAE00>两阶段锁定（</font><font color=#FEAE00>2PL</font><font color=#FEAE00>）</font>是一种<font color=#FEAE00>悲观的并发控制</font>协议，用于确定是否允许事务访问数据库中的对象。协议不需要知道事务将提前执行的所有查询。<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;阶段＃1：膨胀Growing<br>&emsp;&emsp; •每个事务都从DBMS的锁管理器<font color=#FEAE00>请求它所需的锁。</font><br>&emsp;&emsp; •锁管理器<font color=#FEAE00>授予</font><font color=#FEAE00>/</font><font color=#FEAE00>拒绝锁定请求。</font><br>&emsp;&emsp; 阶段＃2：收缩Shrinking<br>&emsp;&emsp; •事务在<font color=#FEAE00>释放第一个锁后立即进入此阶段。</font><br>&emsp;&emsp; •允许事务<font color=#FEAE00>仅释放先前获取的锁</font>。<font color=#FEAE00>它无法在此阶段获得新锁</font>。<br>&emsp;&emsp; 就其本身而言，2PL足以保证conflict serializability。它生成precedence graph是<font color=#FEAE00>无环的</font>。<br>&emsp;&emsp;<br>&emsp;&emsp; 2个缺点：<br>&emsp;&emsp; 但它很容易<font color=#FEAE00>出现级联中止</font>，即<font color=#FEAE00>当事务中止并且现在必须回滚另一个事务时，这会导致浪费很多资源</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;还有一些<font color=#FEAE00>可序列化的潜在计划</font>，但2PL不允许这种计划（锁会限制并发）。<br>&emsp;&emsp;<br>&emsp;&emsp;严格的2pl<br>&emsp;&emsp;事务<font color=#FEAE00>只在完成时释放锁</font>。 确实没有像普通2PL<font color=#FEAE00>那样</font><font color=#FEAE00>shrinking</font><font color=#FEAE00>的阶段。</font><br>&emsp;&emsp; 如果事务写入的值在该事务完成之前未被其他事务读取或覆盖，则调度是严格的。<br>&emsp;&emsp; 这种方法的优点是DBMS不会导致级联中止。<br>&emsp;&emsp; 同时只要把原来的值赋值回去就可以实现abort了。<br>&emsp;&emsp;为什么呢？<br>&emsp;&emsp; 我们看一下s2pl的时序图<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;再看下<font color=#FEAE00>abort</font><font color=#FEAE00>是怎么做的</font><br>&emsp;&emsp; 先<font color=#FEAE00>undo</font><font color=#FEAE00>，随后记</font><font color=#FEAE00>log</font><font color=#FEAE00>，然后</font><font color=#FEAE00>unlock</font><br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;下面要解决的就是<font color=#FEAE00>2pl </font><font color=#FEAE00>的死锁问题</font><br>&emsp;&emsp;<font color=#FEAE00>死锁问题的解决思路分为</font><font color=#FEAE00>2</font><font color=#FEAE00>种，一种是死锁预防，一种是死锁检测。</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;死锁检测<br>&emsp;&emsp;DBMS <font color=#FEAE00>创建</font><font color=#FEAE00> wait-for</font><font color=#FEAE00>图</font>：如果事务Ti等待事务Tj释放锁，从Ti到Tj有一条边。<font color=#FEAE00>系统将定期检查等待图中的环</font>，<font color=#FEAE00>然后决定如何打破它。</font><br>&emsp;&emsp; •当DBMS检测到死锁时，它将<font color=#FEAE00>选择“受害者”事务进行回滚以中断循环。</font><br>&emsp;&emsp; •受害者事务将重新启动或中止，具体取决于应用程序如何调用它<br>&emsp;&emsp;- 在检查死锁的频率和死锁在打断前应该等待多少时间有一个权衡<br>&emsp;&emsp; •选择受害者时<font color=#FEAE00>需要考虑多个事务属性</font>。没有一个选择比其他选择更好。 2PL DBMS都做不同的事情：<br>&emsp;&emsp; 1.<font color=#FEAE00>按年龄</font>（最新或最旧的时间戳）。<br>&emsp;&emsp; 2.<font color=#FEAE00>按进度</font>（执行的最少/大多数查询）。<br>&emsp;&emsp; 3.<font color=#FEAE00>已锁定的项目数量。</font><br>&emsp;&emsp; 4.通过我们必须<font color=#FEAE00>用它回滚的＃个事务。</font><br>&emsp;&emsp; 5.<font color=#FEAE00>过去重启事务的次数</font><br>&emsp;&emsp; •<font color=#FEAE00>回滚长度</font>：选择要中止的受害者事务后，DBMS还可以决定回滚事务的更改的距离。可以是整个事务，也可以是足够的操作（部分事务）足以来打破僵局<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;死锁预防<br>&emsp;&emsp;当txn尝试获取另一个txn持有的锁时<font color=#FEAE00>，</font><font color=#FEAE00>DBMS</font><font color=#FEAE00>会杀死其中一个以防止死锁。</font><br>&emsp;&emsp; 该方法不需要wait-for图或检测算法。<br>&emsp;&emsp;<br>&emsp;&emsp;根据<font color=#FEAE00>时间戳分配优先级（例如，旧的意味着更高的优先级）</font>。<br>&emsp;&emsp; 这些方案保证没有死锁，因为在等待锁时只允许一个方向。 当事务重新启动时，其（新）优先级是其旧时间戳。<br>&emsp;&emsp; •Wait-Die（“Old等待Young”）：如果<font color=#FEAE00>T1</font><font color=#FEAE00>具有更高的优先级</font>，则T1等待T2。 否则T1中止<br>&emsp;&emsp; •wound-wait（“Young等待old”）：如果T1具有更高的优先级，则T2中止。 否则T1会等待。<br>&emsp;&emsp;<br>&emsp;&emsp;关于<font color=#FEAE00>死锁检测</font><font color=#FEAE00> </font><font color=#FEAE00>和</font><font color=#FEAE00> </font><font color=#FEAE00>死锁预防</font>，把作业搞懂 应该就没啥问题了。<br>&emsp;&emsp; https://15445.courses.cs.cmu.edu/fall2018/files/hw4-sols.pdf<br>&emsp;&emsp;粒度锁<br>&emsp;&emsp;如果一个事务要更新十亿个元组，它必须向DBMS的锁管理器询问十亿个锁。<br>&emsp;&emsp; 这将是缓慢的，因为我们必须在锁管理器的内部锁表数据结构中获取锁存器。<br>&emsp;&emsp;相反，我们希望<font color=#FEAE00>使用锁层次结构</font>，允许事务在系统中<font color=#FEAE00>采用更粗粒度的锁。</font> 为此层次结构中的某些内容获取锁定会隐式获取其所有子项的锁定。<br>&emsp;&emsp;<font color=#FEAE00>意图锁定</font>允许更高级别的节点以共享或独占模式锁定，而无需检查所有后代节点。 <font color=#FEAE00>如果节点处于意图模式，则在较低级别进行显式锁定。</font><br>&emsp;&emsp;•Intention-Shared（IS）：表示使用共享锁在较低级别显式锁定。<br>&emsp;&emsp; •Intention-Exclusive（IX）：表示使用独占锁或共享锁在较低级别显式锁定。<br>&emsp;&emsp; •Shared + Intention-Exclusive（SIX）：以该节点为根的子树在共享模式下显式锁定，<font color=#FEAE00>显式锁定在低级别使用独占模式锁定。</font><br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;同样把作业里的QUESTION 3理解清楚就搞清楚这个了。<br>&emsp;&emsp;总结<br>&emsp;&emsp;应用程序通常不会手动设置锁。 <font color=#FEAE00>但有时它可以为</font><font color=#FEAE00>DBMS</font><font color=#FEAE00>提供一些提示来帮助它提高并发性：</font><br>&emsp;&emsp; SELECT ... FOR UPDATE：执行选择，然后在<font color=#FEAE00>获取的元组上设置独占锁</font><br>&emsp;&emsp; 2PL几乎用于所有DBMS。 它自动提供<font color=#FEAE00>正确的交错事务操作。</font><font color=#FEAE00><br>&emsp;&emsp; </font><font color=#FEAE00>但它必须能够应对死锁的问题。</font><br>&emsp;&emsp;<hr><hr>CMU 15445 15. TO + OCC<br>&emsp;&emsp;<hr>￼<br>&emsp;&emsp;<font color=#FEAE00>时间戳排序（</font><font color=#FEAE00>T / O</font><font color=#FEAE00>）</font>是一种乐观的并发控制协议类，其中DBMS假定事务冲突很少。 DBMS不是要求事务在允许读取/写入数据库对象之前获取锁，而是使用<font color=#FEAE00>时间戳来确定事务的可序列化顺序</font>。<br>&emsp;&emsp;大致思路是给每个事务一个时间戳<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;当事务要拿一个未来时间的object，它会abort或者重启。<br>&emsp;&emsp;我们看下读的规则。<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;写的规则<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;2个example<br>&emsp;&emsp;成功的例子<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;回滚的例子<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#FEAE00>thomas-write </font><font color=#FEAE00>规则</font><br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;如果您不使用托马斯写入规则，则基本T / O协议会生成conflict serializable 的计划。 因为没有事务等待它不会有死锁。 但如果短事务不断引发冲突，那么长期事务就有可能出现饥饿。<br>&emsp;&emsp; 它还是不可恢复的计划。 如果事务仅在所有读取或提交更改的事务之后提交，则可以<font color=#FEAE00>恢复调度</font>。 否则，DBMS无法保证事务读取将在从崩溃中恢复后将恢复的数据。<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;OCC<br>&emsp;&emsp;对于假设事务不会发生冲突的常见情况，OCC可能是更好的方法。<br>&emsp;&emsp; <font color=#FEAE00>当冲突数量很少时，</font>OCC运作良好。 这是当所有事务都是只读或当事务访问不相交的数据子集时。<font color=#FEAE00> </font><font color=#FEAE00>如果数据库很大并且工作负载没有偏差</font>，那么冲突的可能性很小，因此加锁是浪费的。<br>&emsp;&emsp;DBMS为每个事务创建一个私有工作区：<br>&emsp;&emsp;	▪	所有修改都应用于<font color=#FEAE00>私有工作区。</font><br>&emsp;&emsp;	▪	将读取的任何对象复制到工作空间中。<br>&emsp;&emsp;	▪	没有其他事务可以读取其私有工作空间中另一个事务所做的更改。<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;当事务提交时，DBMS会比较事务的工作空间写入集，以查看它是否与其他事务冲突。 如果没有冲突，<font color=#FEAE00>则将写入集覆盖到“全局”数据库中</font><br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;验证阶段<br>&emsp;&emsp;这是DBMS检查事务是否与其他事务冲突的地方。 DBMS需要保证只允许可序列化的计划。 DBMS在进入验证阶段时分配事务时间戳。<br>&emsp;&emsp; Ti检查<font color=#FEAE00>RW</font><font color=#FEAE00>和</font><font color=#FEAE00>WW</font><font color=#FEAE00>冲突的其他事务</font>，并确保所有冲突都是单向的（从旧事务到年轻事务）。 DBMS使用所有其他正在运行的事务检查提交事务的时间戳顺序<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;<hr><hr>CMU 15445 9. 排序和聚合算法<br>&emsp;&emsp;<hr># 数据库中的排序<br>&emsp;&emsp;	我们<font color=#FEAE00>需要排序，</font>因为在关系模型中，表中的元组没有特定的顺序排序，但可能在<font color=#FEAE00>ORDER BY</font><font color=#FEAE00>，</font><font color=#FEAE00>GROUP BY</font><font color=#FEAE00>，</font><font color=#FEAE00>JOIN</font><font color=#FEAE00>和</font><font color=#FEAE00>DISTINCT</font>运算符中使用。<br>&emsp;&emsp;	我们可以通过从左到右扫描叶子节点来<font color=#FEAE00>使用群集</font><font color=#FEAE00>B +</font><font color=#FEAE00>树加速排序</font>。 但是，如果我们使用<font color=#FEAE00>非聚集</font><font color=#FEAE00>B +</font><font color=#FEAE00>树进行排序</font>，这是一个坏主意，因为它会导致大量I / O读取（通过<font color=#FEAE00>指针追踪随机访问</font>）。<br>&emsp;&emsp;	如果我们需要排序的数据适合内存，那么我们可以使用标准排序算法，如<font color=#FEAE00>quicksort</font>。 如果数据不合适，我们需要使用能够根据需要溢出到磁盘的<font color=#FEAE00>外部排序</font>。<br>&emsp;&emsp;# 外部排序<br>&emsp;&emsp;外部排序 分为2个部分。首先在<font color=#FEAE00>内存里排序部分</font><font color=#FEAE00>data</font>然后<font color=#FEAE00>写入磁盘</font>。 随后把小块的文件合并成一个排完序的大文件。<br>&emsp;&emsp;## 2路归并<br>&emsp;&emsp;第1个pass：把<font color=#FEAE00>每</font><font color=#FEAE00>B</font><font color=#FEAE00>个</font><font color=#FEAE00> PAGES(B </font><font color=#FEAE00>取决于</font><font color=#FEAE00>buffer pool </font><font color=#FEAE00>支持的最大</font><font color=#FEAE00>page </font><font color=#FEAE00>数量</font>）读到内存。排序，随后把他们写回磁盘。每一个排序的<font color=#FEAE00>page</font><font color=#FEAE00>组称为一个</font><font color=#FEAE00>run</font><br>&emsp;&emsp;之后的pass：<font color=#FEAE00>递归的合并每一对</font><font color=#FEAE00>run</font>，成为下一个run。每一次都会少掉一半的run。<br>&emsp;&emsp;￼<br>&emsp;&emsp;number of pass的公式 比较直接因为是<font color=#FEAE00>指数级减少</font>，所以就是log，n 是page总数。<br>&emsp;&emsp;io次数主要<font color=#FEAE00>每一个</font><font color=#FEAE00>pass</font><font color=#FEAE00>里都会涉及到一次读一次写</font>。<br>&emsp;&emsp;所以是2n （# of passes)<br>&emsp;&emsp;2路归并的问题在于 只利用了3个buffer page，2个读，一个写。 有更多的就用不到。没有有效的利用整个buffer pool。<br>&emsp;&emsp;## k路归并<br>&emsp;&emsp;读完b个page之后，对这整个page做排序。<br>&emsp;&emsp;随后在合并的时候，n/b 个大page要merge<br>&emsp;&emsp;￼<br>&emsp;&emsp;在合并的时候，我们可以用<font color=#FEAE00>b-1</font><font color=#FEAE00>个来并发</font>。因为<font color=#FEAE00>还要留一个</font><font color=#FEAE00>page</font><font color=#FEAE00>去写。</font><br>&emsp;&emsp;所以有上图公式。<br>&emsp;&emsp;还有一些情况可以不用外部排序，比如说是<font color=#FEAE00>聚集的</font><font color=#FEAE00>b+</font><font color=#FEAE00>树索引。</font>我们可以简单去<font color=#FEAE00>遍历树的叶子节点来做聚合</font>。但是非聚集的索引就不方便。<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;# 聚合<br>&emsp;&emsp;一般<font color=#FEAE00>聚合函数有</font>sum,count,min,max等。<br>&emsp;&emsp;实现聚合的主要手段又2种。一种是<font color=#FEAE00>排序，一种是</font><font color=#FEAE00>hash</font><br>&emsp;&emsp;## 排序<br>&emsp;&emsp;首先对<font color=#FEAE00>GROUP BY</font><font color=#FEAE00>键上的元组进行排序</font>。 如果内存足够，则放入缓冲池,使用<font color=#FEAE00>内存排序算法</font>（例如，快速排序）<br>&emsp;&emsp;如果数据大小超过内存，外部合并排序算法。<br>&emsp;&emsp;然后，DBMS对已排序的数据执行顺序扫描<font color=#FEAE00>以计算聚合。</font><font color=#FEAE00> </font>operator的输出将按key排序。<br>&emsp;&emsp;## hash<br>&emsp;&emsp;<font color=#FEAE00>散列计算聚合</font>比排序计算聚合更高效。 DBMS在扫描表时填充哈希表。 对于每条记录，检查哈希表中是否已有条目并执行适当的修改。<br>&emsp;&emsp;如果哈希表的大小太大而无法容纳在内存中，那么DBMS必须<font color=#FEAE00>将其溢出到磁盘：</font><br>&emsp;&emsp;	•	阶段＃1：分区<br>&emsp;&emsp;	•	使用散列函数h1将元组拆分为基于目标散列键的磁盘上的分区。 这会将匹配的所有元组放入同一个分区。 DBMS通过输出缓冲区将分区溢出到磁盘。<br>&emsp;&emsp;	•	阶段＃2：ReHash<br>&emsp;&emsp;	•	对于磁盘上的每个分区，将其页面读入内存并基于第二个散列函数h2（其中h1 != h2）构建内存中的散列表。 然后遍历此哈希表的每个桶，将匹配的元组汇集在一起以计算聚合。 请注意，这假设每个分区都适合内存。<br>&emsp;&emsp;在<font color=#FEAE00>ReHash</font><font color=#FEAE00>阶段</font>，DBMS可以存储表单对（GroupByKey→RunningValue）来计算聚合。 RunningValue的内容取决于聚合函数。 要将新元组插入哈希表：<br>&emsp;&emsp;•如果我们找到匹配的GroupByKey，只需适当更新RunningValue。<br>&emsp;&emsp;•否则插入新的（GroupByKey→RunningValue）对。<br>&emsp;&emsp;￼<hr><hr><font color=#FEAE00>InnoDB</font> 是如何<font color=#FEAE00>存储数据</font>的？<hr>	MySQL 支持多种存储引擎，不同的存储引擎，存储数据的方式也是不同的，我们最常使用的是 InnoDB 存储引擎，所以就跟大家图解下InnoDB 是如何存储数据的。<br>&emsp;&emsp;	记录是按照<font color=#FEAE00>行来存储的</font>，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。<br>&emsp;&emsp;因此，<font color=#FEAE00>InnoDB </font><font color=#FEAE00>的数据是按「数据页」为单位来读写的</font>，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。<br>&emsp;&emsp;数据库的 I/O 操作的最小单位是页，<font color=#FEAE00>InnoDB </font><font color=#FEAE00>数据页的默认大小是</font><font color=#FEAE00> 16KB</font>，意味着数据库每次读写都是<font color=#FEAE00>以</font><font color=#FEAE00> 16KB </font><font color=#FEAE00>为单位的</font>，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。<br>&emsp;&emsp;数据页包括七个部分，结构如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;这 7 个部分的作用如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;在 <font color=#FEAE00>File Header </font>中有两个<font color=#FEAE00>指针</font>，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个<font color=#FEAE00>双向的链表</font>，如下图所示：<br>&emsp;&emsp;￼<br>&emsp;&emsp;采用链表的结构是让数据页之间不需要是物理上的连续的，而是<font color=#FEAE00>逻辑上的连续</font>。<br>&emsp;&emsp;数据页的主要作用是<font color=#FEAE00>存储记录</font>，也就是数据库的数据，所以重点说一下数据页中的 User Records 是怎么组织数据的。<br>&emsp;&emsp;<font color=#FEAE00>数据页中的记录按照「主键」顺序组成单向链表</font>，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。<br>&emsp;&emsp;因此，数据页中有一个<font color=#FEAE00>页目录</font>，起到记录的索引作用，就像我们书那样，针对书中内容的每个章节设立了一个<font color=#FEAE00>目录</font>，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。<br>&emsp;&emsp;那 InnoDB 是如何给记录创建页目录的呢？<font color=#FEAE00>页目录与记录</font>的关系如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;页目录创建的过程如下：<br>&emsp;&emsp;	1	将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；<br>&emsp;&emsp;	2	每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）<br>&emsp;&emsp;	3	<font color=#FEAE00>页目录</font>用来存储<font color=#FEAE00>每组最后一条记录的地址偏移量</font>，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为<font color=#FEAE00>槽（</font><font color=#FEAE00>slot</font><font color=#FEAE00>）</font>，<font color=#FEAE00>每个槽相当于指针指向了不同组的最后一个记录</font><font color=#FEAE00>。</font><br>&emsp;&emsp;从图可以看到，<font color=#FEAE00>页目录就是由多个槽组成的，槽相当于分组记录的索引</font>。然后，因为记录是按照「主键值」从小到大排序的，所以<font color=#FEAE00>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</font>，无需从最小记录开始遍历整个页中的记录链表。<br>&emsp;&emsp;以上面那张图举个例子，5 个槽的编号分别为 0，1，2，3，4，我想查找主键为 11 的用户记录：<br>&emsp;&emsp;	•	先二分得出槽中间位是 (0+4)/2=2 ，2号槽里最大的记录为 8。因为 11 > 8，所以需要从 2 号槽后继续搜索记录；<br>&emsp;&emsp;	•	再使用二分搜索出 2 号和 4 槽的中间位是 (2+4)/2= 3，3 号槽里最大的记录为 12。因为 11 < 12，所以主键为 11 的记录在 3 号槽里；<br>&emsp;&emsp;	•	这里有个问题，<font color=#FEAE00>「槽对应的值都是这个组的主键最大的记录，如何找到组里最小的记录」</font>？比如槽 3 对应最大主键是 12 的记录，那如何找到最小记录 9。解决办法是：通过槽 3 找到 槽 2 对应的记录，也就是主键为 8 的记录。主键为 8 的记录的下一条记录就是槽 3 当中主键最小的 9 记录，然后开始向下搜索 2 次，定位到主键为 11 的记录，取出该条记录的信息即为我们想要查找的内容。<br>&emsp;&emsp;看到第三步的时候，可能有的同学会疑问，如果某个槽内的记录很多，然后因为记录都是单向链表串起来的，那这样在槽内查找某个记录的时间复杂度不就是 O(n) 了吗？<br>&emsp;&emsp;这点不用担心，InnoDB 对每个分组中的记录条数都是有规定的，槽内的记录就只有几条：<br>&emsp;&emsp;	•	第一个分组中的记录<font color=#FEAE00>只能有</font><font color=#FEAE00> 1 </font><font color=#FEAE00>条记录</font>；<br>&emsp;&emsp;	•	最后一个分组中的记录条数范围<font color=#FEAE00>只能在</font><font color=#FEAE00> 1-8 </font><font color=#FEAE00>条之间</font>；<br>&emsp;&emsp;	•	剩下的分组中记录条数范围只能在 4-8 条之间。<hr><hr>LSM树是什么? 和 B+ 的区别?<hr><hr>MVCC<hr>MVCC<br>&emsp;&emsp;核心特性是<br>&emsp;&emsp;<font color=#FEAE00>Writers don’t block the readers. Readers don’t block the writers.</font><font color=#5A5E62><br>&emsp;&emsp;</font><br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#FEAE00>只读事务可以在不获取锁的情况下读取一致的快照</font>。 时间戳用于确定<font color=#FEAE00>可见性。</font><br>&emsp;&emsp; 轻松支持DBMS可以在时间点快照上执行的时间旅行查询。<br>&emsp;&emsp; 有四个重要的MVCC设计决策：<br>&emsp;&emsp;<font color=#FEAE00> 1.</font><font color=#FEAE00>并发控制协议（</font><font color=#FEAE00>T / O</font><font color=#FEAE00>，</font><font color=#FEAE00>OCC</font><font color=#FEAE00>，</font><font color=#FEAE00>2PL</font><font color=#FEAE00>等）。</font><font color=#FEAE00><br>&emsp;&emsp; 2.</font><font color=#FEAE00>版本存储</font><font color=#FEAE00><br>&emsp;&emsp; 3.</font><font color=#FEAE00>垃圾收集</font><font color=#FEAE00><br>&emsp;&emsp; 4.</font><font color=#FEAE00>索引管理</font><br>&emsp;&emsp;版本存储<br>&emsp;&emsp;就是关于DBMS如何存储逻辑对象的不同物理版本。<br>&emsp;&emsp; DBMS使用元组的指针字段为每个逻辑元组创建一个版本链。 这允许DBMS在运行时查找特定事务可见的版本。 <font color=#FEAE00>索引总是指向链的头部。</font><font color=#FEAE00> </font><font color=#FEAE00>线程遍历链，直到找到可见的版本</font>。 不同的存储方案确定每个版本的存储位置/内容。<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;APPEND ONLY<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;TIME TRAVEL<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;DELTA STORAGE<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;垃圾回收<br>&emsp;&emsp;DBMS需要随着时间的推移从数据库中删除可回收的物理版本。<br>&emsp;&emsp; →<font color=#FEAE00>DBMS</font><font color=#FEAE00>中没有活动的</font><font color=#FEAE00>txn</font><font color=#FEAE00>可以“看到”该版本（</font><font color=#FEAE00>SI</font><font color=#FEAE00>）</font>。<br>&emsp;&emsp; →版本是由<font color=#FEAE00>中止的</font><font color=#FEAE00>txn</font><font color=#FEAE00>创建的。</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;方法＃1：元组级垃圾收集 - 通过直接检查元组查找旧版本<br>&emsp;&emsp; •Background Vacuuming：单独的线程定期扫描表并查找可回收的版本，适用于任何版本的存储方案。<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;•协作清理：工作线程在遍历版本链时识别可回收的版本。 仅适用于OLD2NEW。<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;方法＃2：事务级别 - 每个事务都跟踪自己的读/写集。 当事务完成时，垃圾收集器可以使用它来识别要回收的元组。 DBMS确定完成的事务创建的所有版本何时不再可见。<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><hr>MySQL 中的 B+ 树<hr>MySQL 的<font color=#FEAE00>存储方式根据存储引擎</font>的不同而不同，我们最常用的就是 <font color=#FEAE00>Innodb</font> 存储引擎，它就是采用了 B+ 树作为了索引的数据结构。<br>&emsp;&emsp;下图就是 Innodb 里的 B+ 树：<br>&emsp;&emsp;￼<br>&emsp;&emsp;但是 Innodb 使用的 B+ 树有一些特别的点，比如：<br>&emsp;&emsp;	•	B+ 树的叶子节点之间是用「<font color=#FEAE00>双向链表</font>」进行连接，这样的好处是既能向右遍历，也能向左遍历。<br>&emsp;&emsp;	•	B+ 树点节点内容是<font color=#FEAE00>数据页</font>，数据页里存放了用户的记录以及各种信息，每个数据页默认大小是 16 KB。<br>&emsp;&emsp;Innodb 根据索引类型不同，分为<font color=#FEAE00>聚集和二级索引</font>。他们区别在于，聚集索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚集索引的叶子节点，而二级索引的叶子节点存放的是主键值，而不是实际数据。<br>&emsp;&emsp;因为表的数据都是存放在聚集索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚集索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个，而二级索引可以创建多个。<br>&emsp;&emsp;更多关于 Innodb 的 B+ 树，可以看我之前写的这篇：<font color=#FEAE00>从数据页的角度看</font><font color=#FEAE00> B+ </font><font color=#FEAE00>树</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>Raft 的由来与宗旨<hr>Paxos 过于复杂, 难以理解和证明<br>&emsp;&emsp;易于学习, 实践性和可理解性<br>&emsp;&emsp;---<br>&emsp;&emsp;众所周知，Paxos 是一个非常划时代的共识算法。在 Raft 出现之前的 10 年里，Paxos 几乎统治着共识算法这一领域：因为绝大多数共识算法的实现都是基于 Paxos 或者受其影响，同时 Paxos 也成为了教学领域里讲解共识问题时的示例。<br>&emsp;&emsp;但是不幸的是，尽管有很多工作都在尝试降低 Paxos 的复杂性，但是它依然十分难以理解。并且，Paxos 自身的算法结构需要进行大幅的修改才能够应用到实际的系统中。这些都导致了工业界和学术界都对 Paxos 算法感到十分头疼。比如 Google Chubby 的论文就提到，因为 Paxos 的描述和现实差距太大，所以最终人们总会实现一套未经证实的类 Paxos 协议。<br>&emsp;&emsp;基于以上背景，Diego Ongaro 在就读博士期间，深入研究 Paxos 协议后提出了 Raft 协议，旨在提供更为易于理解的共识算法。Raft 的宗旨在于可实践性和可理解性，并且相比 Paxos 几乎没有牺牲多少性能。<br>&emsp;&emsp;<font color=#525458>趣闻：</font><font color=#4087E2>Raft </font><font color=#4087E2>名字的来源</font><font color=#525458>。简而言之，其名字即来自于</font><font color=#525458> </font><font color=#525458>R{eliable|plicated|dundant} And Fault-Tolerant</font><font color=#525458>，</font><font color=#525458> </font><font color=#525458>也来自于这是一艘可以帮助你逃离</font><font color=#525458> Paxos </font><font color=#525458>小岛的救生筏（</font><font color=#525458>Raft</font><font color=#525458>）。</font><font color=#525458><br>&emsp;&emsp;</font><hr><hr>Raft 节点状态 / 数据结构<hr>持久化: currentTerm, votedFor, log[] <br>&emsp;&emsp;非持久化: commitIndex, lastApplied<br>&emsp;&emsp;leader 非持久: nextIndex[] matchIndex[]<br>&emsp;&emsp;---<br>&emsp;&emsp;每一个节点都应该有的持久化状态：<br>&emsp;&emsp;	•	currentTerm：当前任期，保证重启后任期不丢失。<br>&emsp;&emsp;	•	votedFor：在当前 term，给哪个节点投了票，值为 null 或 candidate id。即使节点重启，Raft 算法也能保证每个任期最多只有一个 leader。<br>&emsp;&emsp;	•	log[]：已经 committed 的日志，保证状态机可恢复。<br>&emsp;&emsp;每一个节点都应该有的非持久化状态：<br>&emsp;&emsp;	•	commitindex：已提交的最大 index。leader 节点重启后可以通过 appendEntries rpc 逐渐得到不同节点的 matchIndex，从而确认 commitIndex，follower 只需等待 leader 传递过来的 commitIndex 即可。<br>&emsp;&emsp;	•	lastApplied：已被状态机应用的最大 index。raft 算法假设了状态机本身是易失的，所以重启后状态机的状态可以通过 log[] （部分 log 可以压缩为 snapshot) 来恢复。<br>&emsp;&emsp;leader 的非持久化状态：<br>&emsp;&emsp;	•	nextindex[]：为每一个 follower 保存的，应该发送的下一份 entry index；初始化为本地 last index + 1。<br>&emsp;&emsp;	•	matchindex[]：已确认的，已经同步到每一个 follower 的 entry index。初始化为 0，根据复制状态不断递增，<br>&emsp;&emsp;	•	（注：每次选举后，leader 的此两个数组都应该立刻重新初始化并开始探测）<hr><hr>Redis 持久化1<br>&emsp;&emsp;- Redis 如何实现数据不丢失？<br>&emsp;&emsp;- AOF 日志是如何实现的？<br>&emsp;&emsp;- 为什么先执行命令，再把数据写入日志呢？<br>&emsp;&emsp;- <font color=#FEAE00>AOF </font><font color=#FEAE00>写回策略</font>有几种？<hr># Redis 如何实现数据不丢失？<br>&emsp;&emsp;Redis 的读写操作都是在内存中，所以 Redis 性能才会高，但是当 Redis 重启后，内存中的数据就会丢失，那为了保证内存中的数据不会丢失，Redis 实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在 Redis 重启就能够从磁盘中恢复原有的数据。<br>&emsp;&emsp;Redis 共有三种数据持久化的方式：<br>&emsp;&emsp;<font color=#374EF4>	•	</font><font color=#FEAE00>AOF </font><font color=#FEAE00>日志</font>：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；<br>&emsp;&emsp;<font color=#374EF4>	•	</font><font color=#FEAE00>RDB </font><font color=#FEAE00>快照</font>：将某一时刻的内存数据，以二进制的方式写入磁盘；<br>&emsp;&emsp;<font color=#374EF4>	</font><font color=#FEAE00>•	</font><font color=#FEAE00>混合持久化方式</font>：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；<br>&emsp;&emsp;# AOF 日志是如何实现的？<br>&emsp;&emsp;Redis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。<br>&emsp;&emsp;￼<br>&emsp;&emsp;我这里以「<font color=#7414AF>set name xiaolin</font>」命令作为例子，Redis 执行了这条命令后，记录在 AOF 日志里的内容如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;我这里给大家解释下。<br>&emsp;&emsp;「*3」表示当前命令有三个部分，每部分都是以「$+数字」开头，后面紧跟着具体的命令、键或值。然后，这里的「数字」表示这部分中的命令、键或值一共有多少字节。例如，「$3 set」表示这部分有 3 个字节，也就是「set」命令这个字符串的长度。<br>&emsp;&emsp;# 为什么先执行命令，再把数据写入日志呢？<br>&emsp;&emsp;Reids 是先执行写操作命令后，才将该命令记录到 AOF 日志里的，这么做其实有两个好处。<br>&emsp;&emsp;<font color=#374EF4>	</font><font color=#FEAE00>•	</font><font color=#FEAE00>避免额外的检查开销</font><font color=#FEAE00>：</font>因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行<font color=#FEAE00>命令语法检查</font>，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。<br>&emsp;&emsp;<font color=#374EF4>	</font><font color=#FEAE00>•	</font><font color=#FEAE00>不会阻塞当前写操作命令的执行</font><font color=#FEAE00>：</font>因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。<br>&emsp;&emsp;当然，这样做也会带来风险：<br>&emsp;&emsp;<font color=#374EF4>	</font><font color=#FEAE00>•	</font><font color=#FEAE00>数据可能会丢失：</font> 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发<font color=#FEAE00>生宕机了</font>，这个数据就会有<font color=#FEAE00>丢失的风险</font>。<br>&emsp;&emsp;<font color=#FEAE00>	•	</font><font color=#FEAE00>可能阻塞其他操作：</font><font color=#FEAE00> </font>由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前命令的执行，但因为 AOF 日志也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是<font color=#FEAE00>会阻塞后续的操作无法执行</font>。<br>&emsp;&emsp;# <font color=#FEAE00>AOF </font><font color=#FEAE00>写回策略</font>有几种？<br>&emsp;&emsp;先来看看，Redis 写入 AOF 日志的过程，如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;具体说说：<br>&emsp;&emsp;	1	Redis 执行完写操作命令后，会将命令追加到 <font color=#FEAE00>server.aof_buf</font> 缓冲区；<br>&emsp;&emsp;	2	然后<font color=#FEAE00>通过</font><font color=#FEAE00> write() </font><font color=#FEAE00>系统调用</font>，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区<font color=#FEAE00> page cache</font>，等待内核将数据写入硬盘；<br>&emsp;&emsp;	3	具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。<br>&emsp;&emsp;Redis 提供了 3 种写回硬盘的策略，控制的就是上面说的第三步的过程。 在 Redis.conf 配置文件中的 <font color=#FEAE00>appendfsync</font> 配置项可以有以下 3 种参数可填：<br>&emsp;&emsp;<font color=#374EF4>	</font><font color=#FEAE00>•	Always</font>，这个单词的意思是「总是」，所以它的意思是<font color=#FEAE00>每次写操作命令执行完后，同步将</font><font color=#FEAE00> AOF </font><font color=#FEAE00>日志数据写回硬盘；</font><br>&emsp;&emsp;<font color=#374EF4>	</font><font color=#FEAE00>•	Everysec</font><font color=#FEAE00>，</font>这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；<br>&emsp;&emsp;<font color=#FEAE00>	•	No</font><font color=#FEAE00>，</font>意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。<br>&emsp;&emsp;我也把这 3 个写回策略的优缺点总结成了一张表格：<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><hr>Redis 持久化2<br>&emsp;&emsp;- AOF 日志过大，会触发什么机制？<br>&emsp;&emsp;- 重写 AOF 日志的过程是怎样的？<br>&emsp;&emsp;- <hr># AOF 日志过大，会触发什么机制？<br>&emsp;&emsp;AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。 如果当 AOF 日志文件过大就会带来性能问题，比如重启 Redis 后，需要读 AOF 文件的内容以恢复数据，如果文件过大，整个恢复的过程就会很慢。<br>&emsp;&emsp;所以，Redis 为了避免 AOF 文件越写越大，提供了<font color=#FEAE00> </font><font color=#FEAE00>AOF </font><font color=#FEAE00>重写机制</font>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。<br>&emsp;&emsp;AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。<br>&emsp;&emsp;举个例子，在没有使用重写机制前，假设前后执行了「<font color=#7414AF>set name xiaolin</font>」和「<font color=#7414AF>set name xiaolincoding</font>」这两个命令的话，就会将这两个命令记录到 AOF 文件。<br>&emsp;&emsp;￼<br>&emsp;&emsp;但是<font color=#FEAE00>在使用重写机制后，就会读取</font><font color=#FEAE00> name </font><font color=#FEAE00>最新的</font><font color=#FEAE00> value</font><font color=#FEAE00>（键值对）</font><font color=#FEAE00> </font><font color=#FEAE00>，然后用一条</font><font color=#FEAE00> </font><font color=#FEAE00>「</font><font color=#FEAE00>set name xiaolincoding</font><font color=#FEAE00>」命令记录到新的</font><font color=#FEAE00> AOF </font><font color=#FEAE00>文件</font>，之前的第一个命令就没有必要记录了，因为它属于「历史」命令，没有作用了。这样一来，一个键值对在重写日志中只用一条命令就行了。<br>&emsp;&emsp;重写工作完成后，就会将新的 AOF 文件覆盖现有的 AOF 文件，这就相当于压缩了 AOF 文件，使得 AOF 文件体积变小了。<br>&emsp;&emsp;# 重写 AOF 日志的过程是怎样的？<br>&emsp;&emsp;Redis 的<font color=#FEAE00>重写</font><font color=#FEAE00> AOF </font><font color=#FEAE00>过程是由后台子进程</font><font color=#FEAE00> bgrewriteaof </font><font color=#FEAE00>来完成的</font>，这么做可以达到两个好处：<br>&emsp;&emsp;	•	子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；<br>&emsp;&emsp;	•	子进程带有主进程的数据副本，这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。<br>&emsp;&emsp;触发重写机制后，主进程就会创建重写 AOF 的子进程，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读，重写 AOF 子进程会读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志（新的 AOF 文件）。<br>&emsp;&emsp;<font color=#FEAE00>但是重写过程中，主进程依然可以正常处理命令</font>，那问题来了，重写 AOF 日志过程中，如果主进程修改了已经存在 key-value，那么会发生写时复制，此时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢？<br>&emsp;&emsp;为了解决这种数据不一致问题，Redis 设置了一个<font color=#FEAE00> </font><font color=#FEAE00>AOF </font><font color=#FEAE00>重写缓冲区</font>，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。<br>&emsp;&emsp;在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会<font color=#FEAE00>同时将这个写命令写入到</font><font color=#FEAE00> </font><font color=#FEAE00>「</font><font color=#FEAE00>AOF </font><font color=#FEAE00>缓冲区」和</font><font color=#FEAE00> </font><font color=#FEAE00>「</font><font color=#FEAE00>AOF </font><font color=#FEAE00>重写缓冲区」</font><font color=#FEAE00>。</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;也就是说，在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:<br>&emsp;&emsp;	•	执行客户端发来的命令；<br>&emsp;&emsp;	•	将执行后的写命令追加到 「AOF 缓冲区」；<br>&emsp;&emsp;	•	将执行后的写命令追加到 「AOF 重写缓冲区」；<br>&emsp;&emsp;当子进程完成 AOF 重写工作（<font color=#7414AF>扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</font>）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。<br>&emsp;&emsp;主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：<br>&emsp;&emsp;	•	将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；<br>&emsp;&emsp;	•	新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。<br>&emsp;&emsp;信号函数执行完后，主进程就可以继续像往常一样处理命令了。<br>&emsp;&emsp;TIP<br>&emsp;&emsp;AOF 日志的内容就暂时提这些，想更详细了解 AOF 日志的工作原理，可以详细看这篇：<font color=#FEAE00>AOF </font><font color=#FEAE00>持久化是怎么实现的</font><font color=#5478F6><br>&emsp;&emsp;</font># RDB 快照是如何实现的呢？<br>&emsp;&emsp;因为 AOF 日志记录的是操作命令，不是实际的数据，所以用 AOF 方法做故障恢复时，需要全量把日志都执行一遍，一旦 AOF 日志非常多，势必会造成 Redis 的恢复操作缓慢。<br>&emsp;&emsp;为了解决这个问题，<font color=#FEAE00>Redis </font><font color=#FEAE00>增加了</font><font color=#FEAE00> RDB </font><font color=#FEAE00>快照</font>。所谓的快照，就是记录某一个瞬间东西，比如当我们给风景拍照时，那一个瞬间的画面和信息就记录到了一张照片。<br>&emsp;&emsp;所以，RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。<br>&emsp;&emsp;因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。<br>&emsp;&emsp;RDB 做快照时会阻塞线程吗？<br>&emsp;&emsp;Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行：<br>&emsp;&emsp;	•	执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<font color=#FEAE00>会阻塞主线程</font><font color=#FEAE00>；</font><br>&emsp;&emsp;	•	执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以<font color=#FEAE00>避免主线程的阻塞</font><font color=#FEAE00>；</font><br>&emsp;&emsp;Redis 还可以通过配置文件的选项来实现每隔一段时间自动执行一次 bgsave 命令，默认会提供以下配置：<br>&emsp;&emsp;save <font color=#AA5925>900</font> <font color=#AA5925>1</font><br>&emsp;&emsp;save <font color=#AA5925>300</font> <font color=#AA5925>10</font><br>&emsp;&emsp;save <font color=#AA5925>60</font> <font color=#AA5925>10000</font><br>&emsp;&emsp;别看选项名叫 save，实际上执行的是 bgsave 命令，也就是会创建子进程来生成 RDB 快照文件。 只要满足上面条件的任意一个，就会执行 bgsave，它们的意思分别是：<br>&emsp;&emsp;	•	900 秒之内，对数据库进行了至少 1 次修改；<br>&emsp;&emsp;	•	300 秒之内，对数据库进行了至少 10 次修改；<br>&emsp;&emsp;	•	60 秒之内，对数据库进行了至少 10000 次修改。<br>&emsp;&emsp;这里提一点，Redis 的快照是<font color=#FEAE00>全量快照</font>，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。所以执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。<br>&emsp;&emsp;RDB 在执行快照的时候，数据能修改吗？<br>&emsp;&emsp;可以的，执行 bgsave 过程中，Redis 依然<font color=#FEAE00>可以继续处理操作命令</font>的，也就是数据是能被修改的，关键的技术就在于<font color=#FEAE00>写时复制技术（</font><font color=#FEAE00>Copy-On-Write, COW</font><font color=#FEAE00>）。</font><br>&emsp;&emsp;执行 bgsave 命令的时候，会通过 fork() 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，此时如果主线程执行读操作，则主线程和 bgsave 子进程互相不影响。<br>&emsp;&emsp;￼<br>&emsp;&emsp;如果主线程执行写操作，则被修改的数据会复制一份副本，然后 bgsave 子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。<br>&emsp;&emsp;￼<br>&emsp;&emsp;TIP<br>&emsp;&emsp;RDB 快照的内容就暂时提这些，想更详细了解 RDB 快照的工作原理，可以详细看这篇：<font color=#FEAE00>RDB </font><font color=#FEAE00>快照是怎么实现的？</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>Redis 数据结构<br>&emsp;&emsp;- Redis 数据类型以及使用场景分别是什么？<br>&emsp;&emsp;- 五种常见的 Redis 数据类型是怎么实现？<hr><br>&emsp;&emsp;# Redis 数据类型以及使用场景分别是什么？<br>&emsp;&emsp;Redis 提供了丰富的数据类型，常见的有五种数据类型：<font color=#FEAE00>String</font><font color=#FEAE00>（字符串），</font><font color=#FEAE00>Hash</font><font color=#FEAE00>（哈希），</font><font color=#FEAE00>List</font><font color=#FEAE00>（列表），</font><font color=#FEAE00>Set</font><font color=#FEAE00>（集合）、</font><font color=#FEAE00>Zset</font><font color=#FEAE00>（有序集合）</font><font color=#FEAE00>。</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;随着 Redis 版本的更新，后面又支持了四种数据类型： <font color=#FEAE00>BitMap</font><font color=#FEAE00>（</font><font color=#FEAE00>2.2 </font><font color=#FEAE00>版新增）、</font><font color=#FEAE00>HyperLogLog</font><font color=#FEAE00>（</font><font color=#FEAE00>2.8 </font><font color=#FEAE00>版新增）、</font><font color=#FEAE00>GEO</font><font color=#FEAE00>（</font><font color=#FEAE00>3.2 </font><font color=#FEAE00>版新增）、</font><font color=#FEAE00>Stream</font><font color=#FEAE00>（</font><font color=#FEAE00>5.0 </font><font color=#FEAE00>版新增）</font>。 Redis 五种数据类型的应用场景：<br>&emsp;&emsp;	•	String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。<br>&emsp;&emsp;	•	List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。<br>&emsp;&emsp;	•	Hash 类型：缓存对象、购物车等。<br>&emsp;&emsp;	•	Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。<br>&emsp;&emsp;	•	Zset 类型：排序场景，比如排行榜、电话和姓名排序等。<br>&emsp;&emsp;Redis <font color=#FEAE00>后续版本又支持四种数据类型</font>，它们的应用场景如下：<br>&emsp;&emsp;	•	BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；<br>&emsp;&emsp;	•	HyperLogLog（2.8 版新增）：<font color=#FEAE00>海量数据基数统计的场景</font>，比如百万级网页 UV 计数等；<br>&emsp;&emsp;	•	GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；<br>&emsp;&emsp;	•	<font color=#FEAE00>Stream</font><font color=#FEAE00>（</font><font color=#FEAE00>5.0 </font><font color=#FEAE00>版新增）</font>：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。<br>&emsp;&emsp;TIP<br>&emsp;&emsp;想深入了解这 9 种数据类型，可以看这篇：<font color=#FEAE00>2</font><font color=#FEAE00>万字</font><font color=#FEAE00> + 20 </font><font color=#FEAE00>张图</font><font color=#FEAE00> </font><font color=#FEAE00>｜</font><font color=#FEAE00> </font><font color=#FEAE00>细说</font><font color=#FEAE00> Redis </font><font color=#FEAE00>常见数据类型和应用场景</font><font color=#5478F6><br>&emsp;&emsp;</font># 五种常见的 Redis 数据类型是怎么实现？<br>&emsp;&emsp;我画了一张 Redis<font color=#FEAE00> </font><font color=#FEAE00>数据类型和底层数据结构的对应关图</font>，左边是 Redis 3.0版本的，也就是《Redis 设计与实现》这本书讲解的版本，现在看还是有点过时了，右边是现在 Redis 7.0 版本的。<br>&emsp;&emsp;￼<br>&emsp;&emsp;## String 类型内部实现<br>&emsp;&emsp;String 类型的底层的数据结构实现主要是<font color=#FEAE00> SDS</font><font color=#FEAE00>（简单动态字符串</font>）。 SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：<br>&emsp;&emsp;<font color=#374EF4>	</font><font color=#FEAE00>•	SDS </font><font color=#FEAE00>不仅可以保存文本数据，还可以保存二进制数据</font>。因为 SDS 使用<font color=#FEAE00> len </font><font color=#FEAE00>属性</font>的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。<br>&emsp;&emsp;<font color=#374EF4>	</font><font color=#FEAE00>•	SDS </font><font color=#FEAE00>获取字符串长度的时间复杂度是</font><font color=#FEAE00> O(1)</font><font color=#FEAE00>。</font>因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)。<br>&emsp;&emsp;<font color=#374EF4>	</font><font color=#FEAE00>•	Redis </font><font color=#FEAE00>的</font><font color=#FEAE00> SDS API </font><font color=#FEAE00>是安全的，拼接字符串不会造成缓冲区溢出</font><font color=#FEAE00>。</font>因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以<font color=#FEAE00>不会导致缓冲区溢出的问题。</font><br>&emsp;&emsp;## List 类型内部实现<br>&emsp;&emsp;List 类型的底层数据结构是由<font color=#FEAE00>双向链表或压缩列表</font>实现的：<br>&emsp;&emsp;	•	如果列表的元素个数小于 512 个（默认值，可由 list-max-ziplist-entries 配置），列表每个元素的值都小于 64 字节（默认值，可由 list-max-ziplist-value 配置），Redis 会使用<font color=#FEAE00>压缩列表</font>作为 List 类型的底层数据结构；<br>&emsp;&emsp;	•	如果列表的元素不满足上面的条件，Redis 会使用<font color=#FEAE00>双向链表</font>作为 List 类型的底层数据结构；<br>&emsp;&emsp;但是<font color=#FEAE00>在</font><font color=#FEAE00> Redis 3.2 </font><font color=#FEAE00>版本之后，</font><font color=#FEAE00>List </font><font color=#FEAE00>数据类型底层数据结构就只由</font><font color=#FEAE00> quicklist </font><font color=#FEAE00>实现了，替代了双向链表和压缩列表</font><font color=#FEAE00>。</font><br>&emsp;&emsp;## Hash 类型内部实现<br>&emsp;&emsp;Hash 类型的底层数据结构是由<font color=#FEAE00>压缩列表或哈希表</font>实现的：<br>&emsp;&emsp;	•	如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用<font color=#FEAE00>压缩列表</font>作为 Hash 类型的底层数据结构；<br>&emsp;&emsp;	•	如果哈希类型元素不满足上面条件，Redis 会使用<font color=#FEAE00>哈希表</font>作为 Hash 类型的底层数据结构。<br>&emsp;&emsp;<font color=#FEAE00>在</font><font color=#FEAE00> Redis 7.0 </font><font color=#FEAE00>中，压缩列表数据结构已经废弃了，交由</font><font color=#FEAE00> listpack </font><font color=#FEAE00>数据结构来实现了</font><font color=#FEAE00>。</font><br>&emsp;&emsp;## Set 类型内部实现<br>&emsp;&emsp;Set 类型的底层数据结构是由<font color=#FEAE00>哈希表或整数集合</font>实现的：<br>&emsp;&emsp;	•	如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用<font color=#FEAE00>整数集合</font>作为 Set 类型的底层数据结构；<br>&emsp;&emsp;	•	如果集合中的元素不满足上面条件，则 Redis 使用<font color=#FEAE00>哈希表</font>作为 Set 类型的底层数据结构。<br>&emsp;&emsp;## ZSet 类型内部实现<br>&emsp;&emsp;Zset 类型的底层数据结构是由<font color=#FEAE00>压缩列表或跳表</font>实现的：<br>&emsp;&emsp;	•	如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用<font color=#FEAE00>压缩列表</font>作为 Zset 类型的底层数据结构；<br>&emsp;&emsp;	•	如果有序集合的元素不满足上面的条件，Redis 会使用<font color=#FEAE00>跳表</font>作为 Zset 类型的底层数据结构；<br>&emsp;&emsp;<font color=#FEAE00>在</font><font color=#FEAE00> Redis 7.0 </font><font color=#FEAE00>中，压缩列表数据结构已经废弃了，交由</font><font color=#FEAE00> listpack </font><font color=#FEAE00>数据结构来实现了。</font><br>&emsp;&emsp;TIP<br>&emsp;&emsp;想深入了解这 9 种数据结构，可以看这篇：<font color=#FEAE00>2</font><font color=#FEAE00>万字</font><font color=#FEAE00> + 40 </font><font color=#FEAE00>张图</font><font color=#FEAE00> </font><font color=#FEAE00>｜</font><font color=#FEAE00> </font><font color=#FEAE00>细说</font><font color=#FEAE00> Redis </font><font color=#FEAE00>数据结构</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>Redis 线程模型<br>&emsp;&emsp;- Redis 是单线程吗？<br>&emsp;&emsp;- Redis 单线程模式是怎样的<br>&emsp;&emsp;- Redis 6.0 之前为什么使用单线程？<br>&emsp;&emsp;- Redis 6.0 之后为什么引入了多线程？<br>&emsp;&emsp;- <hr><br>&emsp;&emsp;# Redis 是单线程吗？<br>&emsp;&emsp;<font color=#FEAE00>Redis </font><font color=#FEAE00>单线程指的是「接收客户端请求</font><font color=#FEAE00>-></font><font color=#FEAE00>解析请求</font><font color=#FEAE00> -></font><font color=#FEAE00>进行数据读写等操作</font><font color=#FEAE00>-></font><font color=#FEAE00>发送数据给客户端」这个过程是由一个线程（主线程）来完成的</font><font color=#FEAE00>，</font>这也是我们常说 Redis 是单线程的原因。<br>&emsp;&emsp;但是，<font color=#FEAE00>Redis </font><font color=#FEAE00>程序并不是单线程的</font>，Redis 在启动的时候，是会<font color=#FEAE00>启动后台线程</font><font color=#FEAE00>（</font><font color=#FEAE00>BIO</font><font color=#FEAE00>）</font>的：<br>&emsp;&emsp;<font color=#FEAE00>	•	Redis </font><font color=#FEAE00>在</font><font color=#FEAE00> 2.6 </font><font color=#FEAE00>版本</font>，会启动 2 个后台线程，分别<font color=#FEAE00>处理关闭文件、</font><font color=#FEAE00>AOF </font><font color=#FEAE00>刷盘</font>这两个任务；<br>&emsp;&emsp;<font color=#FEAE00>	•	Redis </font><font color=#FEAE00>在</font><font color=#FEAE00> 4.0 </font><font color=#FEAE00>版本之后</font>，新增了一个新的后台线程，用来异<font color=#FEAE00>步释放</font><font color=#FEAE00> Redis </font><font color=#FEAE00>内存</font>，也就是<font color=#FEAE00> lazyfree </font><font color=#FEAE00>线程</font>。例如执行 unlink key / flushdb async / flushall async 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 Redis 主线程卡顿。因此，当我们要删除一个大 key 的时候，不要使用 del 命令删除，因为 del 是在主线程处理的，这样会导致 Redis 主线程卡顿，因此我们应该使用 <font color=#FEAE00>unlink </font><font color=#FEAE00>命令来异步删除大</font><font color=#FEAE00>key</font><font color=#FEAE00>。</font><br>&emsp;&emsp;之所以 Redis 为「关闭文件、AOF 刷盘、释放内存」这些任务创建单独的线程来处理，是因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了。<br>&emsp;&emsp;<font color=#FEAE00>后台线程相当于一个消费者</font>，生产者把耗时任务丢到任务队列中，<font color=#FEAE00>消费者（</font><font color=#FEAE00>BIO</font><font color=#FEAE00>）不停轮询这个队列</font>，拿出任务就去执行对应的方法即可。<br>&emsp;&emsp;￼<br>&emsp;&emsp;关闭文件、AOF 刷盘、释放内存这三个任务都有各自的任务队列：<br>&emsp;&emsp;	•	<font color=#FEAE00>BIO_CLOSE_FILE</font>，关闭文件任务队列：当队列有任务后，后台线程会调用 close(fd) ，将文件关闭；<br>&emsp;&emsp;	•	<font color=#FEAE00>BIO_AOF_FSYNC</font>，AOF刷盘任务队列：当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到队列中。当发现队列有任务后，后台线程会调用 fsync(fd)，将 AOF 文件刷盘，<br>&emsp;&emsp;	•	<font color=#FEAE00>BIO_LAZY_FREE</font>，lazy free 任务队列：当队列有任务后，后台线程会 free(obj) 释放对象 / free(dict) 删除数据库所有对象 / free(skiplist) 释放跳表对象；<br>&emsp;&emsp;# Redis 单线程模式是怎样的？<br>&emsp;&emsp;Redis 6.0 版本之前的单线模式如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;图中的蓝色部分是一个事件循环，是由主线程负责的，可以看到<font color=#FEAE00>网络</font><font color=#FEAE00> I/O </font><font color=#FEAE00>和命令处理都是单线程</font>。 Redis 初始化的时候，会做下面这几件事情：<br>&emsp;&emsp;	•	首先，调用 <font color=#FEAE00>epoll_create()</font> 创建一个 epoll 对象和调用 socket() 一个服务端 socket<br>&emsp;&emsp;	•	然后，调用 <font color=#FEAE00>bind() </font>绑定端口和调用 <font color=#FEAE00>listen() </font>监听该 socket；<br>&emsp;&emsp;	•	然后，将调用 epoll_ctl() 将 listen socket 加入到 epoll，同时注册「连接事件」处理函数。<br>&emsp;&emsp;初始化完后，主线程就进入到一个<font color=#FEAE00>事件循环函数</font>，主要会做以下事情：<br>&emsp;&emsp;	•	首先，先调用<font color=#FEAE00>处理发送队列函数</font>，看是发送队列里是否有任务，如果有发送任务，则通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。<br>&emsp;&emsp;	•	接着，调用 epoll_wait 函数等待事件的到来：<br>&emsp;&emsp;	◦	如果是<font color=#FEAE00>连接事件</font>到来，则会调用<font color=#FEAE00>连接事件处理函数</font>，该函数会做这些事情：调用 accpet 获取已连接的 socket -> 调用 epoll_ctl 将已连接的 socket 加入到 epoll -> 注册「读事件」处理函数；<br>&emsp;&emsp;	◦	如果是<font color=#FEAE00>读事件</font>到来，则会调用<font color=#FEAE00>读事件处理函数</font>，该函数会做这些事情：调用 read 获取客户端发送的数据 -> 解析命令 -> 处理命令 -> 将客户端对象添加到发送队列 -> 将执行结果写到发送缓存区等待发送；<br>&emsp;&emsp;	◦	如果是<font color=#FEAE00>写事件</font>到来，则会调用<font color=#FEAE00>写事件处理函数</font>，该函数会做这些事情：通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会继续注册写事件处理函数，等待 epoll_wait 发现可写后再处理 。<br>&emsp;&emsp;以上就是 Redis 单线模式的工作方式，如果你想看源码解析，可以参考这一篇：<font color=#FEAE00>为什么单线程的</font><font color=#FEAE00> Redis </font><font color=#FEAE00>如何做到每秒数万</font><font color=#FEAE00> QPS </font><font color=#FEAE00>？</font><font color=#5478F6><br>&emsp;&emsp;</font># Redis 采用单线程为什么还这么快？<br>&emsp;&emsp;官方使用基准测试的结果是，<font color=#FEAE00>单线程的</font><font color=#FEAE00> Redis </font><font color=#FEAE00>吞吐量可以达到</font><font color=#FEAE00> 10W/</font><font color=#FEAE00>每秒</font>，如下图所示：<br>&emsp;&emsp;￼<br>&emsp;&emsp;之所以 Redis 采用单线程（网络 I/O 和执行命令）那么快，有如下几个原因：<br>&emsp;&emsp;	•	Redis 的大部分操作<font color=#FEAE00>都在内存中完成</font>，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；<br>&emsp;&emsp;	•	Redis 采用单线程模型可以<font color=#FEAE00>避免了多线程之间的竞争</font>，省去了多线程切换带来的时间和性能上的开销，而且也不会导致死锁问题。<br>&emsp;&emsp;	•	Redis 采用了<font color=#FEAE00> </font><font color=#FEAE00>I/O </font><font color=#FEAE00>多路复用机制</font>处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。<br>&emsp;&emsp;# Redis 6.0 之前为什么使用单线程？<br>&emsp;&emsp;我们都知道单线程的程序是无法利用服务器的多核 CPU 的，那么早期 Redis 版本的主要工作（网络 I/O 和执行命令）为什么还要使用单线程呢？我们不妨先看一下Redis官方给出的<br>&emsp;&emsp;￼<br>&emsp;&emsp;核心意思是：<font color=#FEAE00>CPU </font><font color=#FEAE00>并不是制约</font><font color=#FEAE00> Redis </font><font color=#FEAE00>性能表现的瓶颈所在</font>，更多情况下是受到<font color=#FEAE00>内存大小和网络</font><font color=#FEAE00>I/O</font><font color=#FEAE00>的限制</font>，所以 Redis 核心网络模型使用单线程并没有什么问题，如果你想要使用服务的多核CPU，可以在一台服务器上<font color=#FEAE00>启动多个节点或者采用分片集群的方式。</font><br>&emsp;&emsp;除了上面的官方回答，选择单线程的原因也有下面的考虑。<br>&emsp;&emsp;使用了单线程后，可维护性高，多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，<font color=#FEAE00>增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗</font><font color=#FEAE00>。</font><br>&emsp;&emsp;# Redis 6.0 之后为什么引入了多线程？<br>&emsp;&emsp;虽然 Redis 的主要工作（网络 I/O 和执行命令）一直是单线程模型，但是<font color=#FEAE00>在</font><font color=#FEAE00> Redis 6.0 </font><font color=#FEAE00>版本之后，也采用了多个</font><font color=#FEAE00> I/O </font><font color=#FEAE00>线程来处理网络请求</font><font color=#FEAE00>，</font><font color=#FEAE00>这是因为随着网络硬件的性能提升，</font><font color=#FEAE00>Redis </font><font color=#FEAE00>的性能瓶颈有时会出现在网络</font><font color=#FEAE00> I/O </font><font color=#FEAE00>的处理上</font><font color=#FEAE00>。</font><br>&emsp;&emsp;所以为了提高网络 I/O 的并行度，Redis 6.0 对于网络 I/O 采用多线程来处理。<font color=#FEAE00>但是对于命令的执行，</font><font color=#FEAE00>Redis </font><font color=#FEAE00>仍然使用单线程来处理，所以大家不要误解</font> Redis 有多线程同时执行命令。<br>&emsp;&emsp;Redis 官方表示<font color=#FEAE00>，</font><font color=#FEAE00>Redis 6.0 </font><font color=#FEAE00>版本引入的多线程</font><font color=#FEAE00> I/O </font><font color=#FEAE00>特性对性能提升至少是一倍以上</font><font color=#FEAE00>。</font><br>&emsp;&emsp;Redis 6.0 版本支持的 I/O 多线程特性，默认情况下 I/O 多线程只针对<font color=#FEAE00>发送响应数据（</font><font color=#FEAE00>write client socket</font><font color=#FEAE00>）</font>，并不会以多线程的方式处理读请求（read client socket）。要想开启多线程处理客户端读请求，就需要把 Redis.conf 配置文件中的 io-threads-do-reads 配置项设为 yes。<br>&emsp;&emsp;<font color=#666666>//</font><font color=#666666>读请求也使用</font><font color=#666666>io</font><font color=#666666>多线程</font><br>&emsp;&emsp;io<font color=#519696>-</font>threads<font color=#519696>-</font><font color=#5E3563>do</font><font color=#519696>-</font>reads yes <br>&emsp;&emsp;同时， Redis.conf 配置文件中提供了 IO 多线程个数的配置项。<br>&emsp;&emsp;<font color=#666666>// io-threads N</font><font color=#666666>，表示启用</font><font color=#666666> N-1 </font><font color=#666666>个</font><font color=#666666> I/O </font><font color=#666666>多线程（主线程也算一个</font><font color=#666666> I/O </font><font color=#666666>线程）</font><br>&emsp;&emsp;io<font color=#519696>-</font>threads <font color=#AA5925>4</font> <br>&emsp;&emsp;关于线程数的设置，官方的建议是如果为 4 核的 CPU，建议线程数设置为 2 或 3，如果为 8 核 CPU 建议线程数设置为 6，线程数一定要小于机器核数，线程数并不是越大越好。<br>&emsp;&emsp;因此， Redis 6.0 版本之后，Redis 在启动的时候，默认情况下会创建<font color=#FEAE00> 6 </font><font color=#FEAE00>个线程</font>：<br>&emsp;&emsp;	•	<font color=#FEAE00>Redis-server</font> ： Redis的主线程，主要负责执行命令；<br>&emsp;&emsp;	•	<font color=#FEAE00>bio_close_file</font><font color=#FEAE00>、</font><font color=#FEAE00>bio_aof_fsync</font><font color=#FEAE00>、</font><font color=#FEAE00>bio_lazy_free</font>：三个后台线程，分别异步处理关闭文件任务、AOF刷盘任务、释放内存任务；<br>&emsp;&emsp;	•	<font color=#FEAE00>io_thd_1</font><font color=#FEAE00>、</font><font color=#FEAE00>io_thd_2</font><font color=#FEAE00>、</font><font color=#FEAE00>io_thd_3</font>：三个 I/O 线程，io-threads 默认是 4 ，所以会启动 3（4-1）个 I/O 多线程，用来分担 Redis 网络 I/O 的压力。<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr><font color=#FEAE00>WHERE</font> 子句中的 <font color=#FEAE00>OR</font><hr>	在 WHERE 子句中，如果在 O<font color=#FEAE00>R </font><font color=#FEAE00>前的条件列</font>是<font color=#FEAE00>索引列</font>，而在 OR 后的条件列不是索引列，那么索引会失效。<br>&emsp;&emsp;	举个例子，比如下面的查询语句，id 是主键，age 是普通列，从执行计划的结果看，是走了全表扫描。<br>&emsp;&emsp;select * from t_user where id = 1 or age = 18;<br>&emsp;&emsp;￼<br>&emsp;&emsp;	这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。<br>&emsp;&emsp;要解决办法很简单，将 age 字段设置为索引即可。<br>&emsp;&emsp;￼<br>&emsp;&emsp;	可以看到 <font color=#FEAE00>type=index merge</font><font color=#FEAE00>，</font><font color=#FEAE00> index merge</font> 的意思就是对 id 和 age 分别进行了扫描，然后将这两个结果<font color=#FEAE00>集进行了合并</font>，这样做的好处就是避免了全表扫描。<br>&emsp;&emsp;	感觉是类似 inner join 的处理方法吧<hr><hr>binlog的不同实现?<hr><hr>buffer pool 缓存池的作用? 和虚拟内存的区别?<hr><hr>db select一定要加锁么?<hr><hr>join中两种实现方法的优缺点? <br>&emsp;&emsp;hash join, sort merge join<hr><hr>lru 和 lfu比较? 优缺点? 应用场景<hr><hr>percolator 相比 2PC 3PC有什么好处<hr><hr>percolator 解决了什么问题<hr><hr>raft applyIndex 和 commitIndex 的区别及联系<hr><hr>raft 任期 term <br>&emsp;&emsp;日志<br>&emsp;&emsp;安全性保证<hr>Term: 选举,单增,split Vote, 充当逻辑时钟<br>&emsp;&emsp;日志: entry:单条, log:整个的日志<br>&emsp;&emsp;保证: Election Safety(最多一个 Leader), Log Matching, State Machine Safety... <br>&emsp;&emsp;---<br>&emsp;&emsp;任期<br>&emsp;&emsp;￼<font color=#4087E2><br>&emsp;&emsp;</font>Raft 将时间划分成为任意不同长度的 term。term 用连续的数字进行表示。每一个 term 的开始都是一次选举，一个或多个 candidate 会试图成为 leader。如果一个 candidate 赢得了选举，<font color=#FEAE00>它就会在该</font><font color=#FEAE00> term </font><font color=#FEAE00>担任</font><font color=#FEAE00> leader</font><font color=#FEAE00>。</font>在某些情况下，<font color=#FEAE00>选票会被均分，</font>即 split vote（例如总数为偶数节点时两个 candidate 节点各获得了两票），此时无法选出该 term 的 leader，那么在该 term 的选举超时后将会开始另一个 term 的选举。<br>&emsp;&emsp;不同的服务器节点可能多次观察<font color=#FEAE00>到</font><font color=#FEAE00> term </font><font color=#FEAE00>之间的转换</font>，但在某些情况下，一个节点也可能观察不到任何一次选举或者整个 term 全程。term 在 Raft 算法中充当<font color=#FEAE00>逻辑时钟（类似于</font><font color=#FEAE00> Lamport timestamp</font><font color=#FEAE00>）的作用</font>，这会允许服务器节点查明一些过期的信息比如过期的 leader。<br>&emsp;&emsp;每个节点都会存储当前 term 号，这一编号在整个时间内单调增长。当服务器之间通信的时候会交换当前 term 号；如果一个服务器的当前 term 号比其他人小，那么他会更新自己的 term 到较大的 term 值。如果一个 candidate 或者 leader 发现自己的 term 过期了，那么他会立即退回 follower。如果一个节点接收到一个包含过期 term 号的请求，那么它会拒绝或忽略这个请求。这实际上就是一个 Lamport 逻辑时钟的具体实现。<br>&emsp;&emsp;<br>&emsp;&emsp;日志<br>&emsp;&emsp;	•	entry：Raft 中，将每一个事件都称为一个 entry，每一个 entry 都有一个<font color=#FEAE00>表明它在</font><font color=#FEAE00> log </font><font color=#FEAE00>中位置的</font><font color=#FEAE00> index</font>（之所以从 1 开始是为了方便 prevLogIndex 从 0 开始）。只有 leader 可以创建 entry。entry 的内容为 <term, index, cmd>，其中 cmd 是可以应用到状态机的操作。在 raft 组大部分节点都接收这条 entry 后，entry 可以被称为是 committed 的。<br>&emsp;&emsp;	•	<font color=#FEAE00>log</font><font color=#FEAE00>：由</font><font color=#FEAE00> entry </font><font color=#FEAE00>构成的数组，只有</font><font color=#FEAE00> leader </font><font color=#FEAE00>可以改变其他节点的</font><font color=#FEAE00> log</font>。 entry 总是先被 leader 添加进本地的 log 数组中去，然后才发起共识请求，获得 quorum 同意后才会被 leader 提交给状态机。follower 只能从 leader 获取新日志和当前的 commitIndex，然后应用对应的 entry 到自己的状态机。<br>&emsp;&emsp;<br>&emsp;&emsp;保证<br>&emsp;&emsp;	•	Election Safety：每个 term 最多只会有一个 leader；集群同时最多只会有一个可以读写的 leader。<br>&emsp;&emsp;	•	Leader Append-Only：leader 的日志是只增的。<br>&emsp;&emsp;	•	Log Matching：如果两个节点的日志中有两个 entry 有相同的 index 和 term，那么它们就是相同的 entry。<br>&emsp;&emsp;	•	Leader Completeness：一旦一个操作被提交了，那么在之后的 term 中，该操作都会存在于日志中。<br>&emsp;&emsp;	•	State Machine Safety：一致性，一旦一个节点应用了某个 index 的 entry 到状态机，那么其他所有节点应用的该 index 的操作都是一致的。<br>&emsp;&emsp;<hr><hr>raft 日志压缩<hr>Raft 的日志在正常运行期间会增长以合并更多的客户请求，但是在实际的系统中，Raft 的日志无法不受限制地增长。随着日志的增长，日志会占用更多空间，并且需要花费更多时间进行重放。如果没有某种机制可以丢弃日志中累积的过时信息，这最终将导致可用性问题。因此需要定时去做 snapshot。<br>&emsp;&emsp;snapshot 会包括：<br>&emsp;&emsp;	•	状态机当前的状态。<br>&emsp;&emsp;	•	状态机最后一条应用的 entry 对应的 index 和 term。<br>&emsp;&emsp;	•	集群最新配置信息。<br>&emsp;&emsp;	•	为了保证 exactly-once 线性化语义的去重表（之后会介绍到）。<br>&emsp;&emsp;各个节点自行择机完成自己的 snapshot 即可，如果 leader 发现需要发给某一个 follower 的 nextIndex 已经被做成了 snapshot，则需要将 snapshot 发送给该 follower。注意 follower 拿到非过期的 snapshot 之后直接覆盖本地所有状态即可，不需要留有部分 entry，也不会出现 snapshot 之后还存在有效的 entry。因此 follower 只需要判断 InstallSnapshot RPC 是否过期即可。过期则直接丢弃，否则直接替换全部状态即可。<br>&emsp;&emsp;snapshot 可能会带来两个问题：<br>&emsp;&emsp;	1	做 snapshot 的策略？<br>&emsp;&emsp;一般为定时或者定大小，达到阈值即做 snapshot，做完后对状态机和 raft log 进行原子性替换即可。<br>&emsp;&emsp;	2	做 snapshot 时是否还可继续提供写请求？<br>&emsp;&emsp;一般情况下，做 snapshot 期间需要保证状态机不发生变化，也就是需要保证 snapshot 期间状态机不处理写请求。当然 raft 层依然可以去同步，只是状态机不能变化，即不能 apply 新提交的日志到状态机中而已。要想做的更好，可以对状态机采用 copy-on-write 的复制来不阻塞写请求。<hr><hr>raft 日志同步 <hr>leader 被选举后，则负责所有的客户端请求。每一个客户端请求都包含一个命令，该命令可以被作用到 RSM。<br>&emsp;&emsp;leader 收到客户端请求后，会生成一个 entry，包含 <index, term, cmd>，再将这个 entry 添加到自己的日志末尾后，向所有的节点广播该 entry。<br>&emsp;&emsp;follower 如果同意接受该 entry，则在将 entry 添加到自己的日志后，返回同意。<br>&emsp;&emsp;如果 leader 收到了多数的成功答复，则将该 entry 应用到自己的 RSM， 之后可以称该 entry 是 committed 的。该 committed 信息会随着随后的 AppendEntries 或 Heartbeat RPC 被传达到其他节点。<br>&emsp;&emsp;￼<font color=#4087E2><br>&emsp;&emsp;</font>Raft 保证下列两个性质：<br>&emsp;&emsp;	•	如果在两个日志（节点）里，有两个 entry 拥有相同的 index 和 term，那么它们一定有相同的 cmd；<br>&emsp;&emsp;	•	如果在两个日志（节点）里，有两个 entry 拥有相同的 index 和 term，那么它们前面的 entry 也一定相同。<br>&emsp;&emsp;通过”仅有 leader 可以生成 entry”来确保第一个性质， 第二个性质则通过一致性检查（consistency check）来保证，该检查包含几个步骤：<br>&emsp;&emsp;leader 在通过 AppendEntriesRPC 和 follower 通讯时，会带上上一块 entry 的信息， 而 follower 在收到后会对比自己的日志，如果发现这个 entry 的信息（index、term）和自己日志内的不符合，则会拒绝该请求。一旦 leader 发现有 follower 拒绝了请求，则会与该 follower 再进行一轮一致性检查， 找到双方最大的共识点，然后用 leader 的 entries 记录覆盖 follower 所有在最大共识点之后的数据。<br>&emsp;&emsp;寻找共识点时，leader 还是通过 AppendEntriesRPC 和 follower 进行一致性检查， 方法是发送再上一块的 entry， 如果 follower 依然拒绝，则 leader 再尝试发送更前面的一块，直到找到双方的共识点。 因为分歧发生的概率较低，而且一般很快能够得到纠正，所以这里的逐块确认一般不会造成性能问题。当然，在这里进行二分查找或者某些规则的查找可能也能够在理论上得到收益。<br>&emsp;&emsp;每个 leader 都会为每一个 follower 保存一个 nextIndex 的变量， 标志了下一个需要发送给该 follower 的 entry 的 index。 在 leader 刚当选时，该值初始化为该 leader 的 log 的 index+1。 一旦 follower 拒绝了 entry，则 leader 会执行 nextIndex—，然后再次发送。直到 follower 接收后将 matchIndex 设置为此时的 nextIndex - 1，然后开始正常的复制。这里还可以做一些更细粒度的优化，比如在正常复制时可以批量复制日志以减少系统调用的开销；在寻找共识点时可以只携带一条日志以减少不必要的流量传输，具体可以参考 etcd 的 <font color=#4087E2>设计</font>。<hr><hr>raft 的三个节点类型<br>&emsp;&emsp;<hr>三个节点类型: Leader Candidate Follower<br>&emsp;&emsp;---<br>&emsp;&emsp;Raft 将所有节点分为三个身份：<br>&emsp;&emsp;	•	Leader：集群内最多只会有一个 leader，负责发起心跳，响应客户端，创建日志，同步日志。<br>&emsp;&emsp;	•	Candidate：leader 选举过程中的临时角色，由 follower 转化而来，发起投票参与竞选。<br>&emsp;&emsp;	•	Follower：接受 leader 的心跳和日志同步数据，投票给 candidate。<br>&emsp;&emsp;￼<font color=#4087E2><br>&emsp;&emsp;</font>上图可以看出 Raft 中节点状态之间变迁的条件。<br>&emsp;&emsp;在博士论文和实际生产系统中，其实又增加了两种身份：<br>&emsp;&emsp;	•	Learner：不具有选举权，参与日志复制过程但不计数的节点。可以作为新节点加入集群时的过渡状态以提升可用性，也可以作为一种类似于 binlog 的对 leader 日志流进行订阅的角色，比如可以参考 PingCAP 公司 tikv 和 tiflash 的架构。<br>&emsp;&emsp;	•	Pre candidate：刚刚发起竞选，还在等待 Pre-Vote 结果的临时状态， 取决于 Pre-Vote 的结果，可能进化为 candidate，可能退化为 follower。<br>&emsp;&emsp;---<br>&emsp;&emsp;<br>&emsp;&emsp;<hr><hr>raft 领导人选举阶段<br>&emsp;&emsp;选举限制? <br>&emsp;&emsp;<br>&emsp;&emsp;<hr>使用心跳维持, electionTimeout electionElapsed <br>&emsp;&emsp;timeout: 发起选举 -> candidate: 自增 term, 发送 RequstVote, 状态持续到: 赢得 | 其他赢得 | 无人胜出, 此时收到心跳: term 一样(退出) | term 小于(拒绝并返回当前)<br>&emsp;&emsp;<br>&emsp;&emsp;选出的 leader 包含所有已经 commited 的日志, RequestVote带上最后一个 entry 的信息, 比对后,如果(term更大 || index 更大), 拒绝投票. <br>&emsp;&emsp;<br>&emsp;&emsp;是否投票取决于:  todo<br>&emsp;&emsp;---<br>&emsp;&emsp;Raft 使用心跳来维持 leader 身份。任何节点都以 follower 的身份启动。 leader 会定期的发送心跳给所有的 follower 以确保自己的身份。 每当 follower 收到心跳后，就刷新自己的 electionElapsed，重新计时。<br>&emsp;&emsp;（后文中，会将预设的选举超时称为 electionTimeout，而将当前经过的选举耗时称为 electionElapsed）<br>&emsp;&emsp;一旦一个 follower 在指定的时间内没有收到任何 RPC（称为 electionTimeout），则会发起一次选举。 当 follower 试图发起选举后，其身份转变为 candidate，在增加自己的 term 后， 会向所有节点发起 RequestVoteRPC 请求，candidate 的状态会一直持续直到：<br>&emsp;&emsp;	•	赢得选举<br>&emsp;&emsp;	•	其他节点赢得选举<br>&emsp;&emsp;	•	一轮选举结束，无人胜出<br>&emsp;&emsp;选举的方式非常简单，谁能获取到多数选票 (N/2 + 1)，谁就成为 leader。 在一个 candidate 节点等待投票响应的时候，它有可能会收到其他节点声明自己是 leader 的心跳， 此时有两种情况：<br>&emsp;&emsp;	•	该请求的 term 和自己一样或更大：说明对方已经成为 leader，自己立刻退为 follower。<br>&emsp;&emsp;	•	该请求的 term 小于自己：拒绝请求并返回当前 term 以让请求节点更新 term。<br>&emsp;&emsp;为了防止在同一时间有太多的 follower 转变为 candidate 导致无法选出绝对多数， Raft 采用了随机选举超时（randomized election timeouts）的机制， 每一个 candidate 在发起选举后，都会随机化一个新的选举超时时间， 一旦超时后仍然没有完成选举，则增加自己的 term，然后发起新一轮选举。 在这种情况下，应该能在较短的时间内确认出 leader。 （因为 term 较大的有更大的概率压倒其他节点）<br>&emsp;&emsp;etcd 中将随机选举超时设置为 [electiontimeout, 2 * electiontimeout - 1]。<br>&emsp;&emsp;通过一个节点在一个 term 只能给一个节点投票，Raft 保证了对于给定的一个 term 最多只有一个 leader，从而避免了选举导致的 split brain 以确保 safety；通过不同节点每次随机化选举超时时间，Raft 在实践中（注意：并没有在理论上）避免了活锁以确保 liveness。<br>&emsp;&emsp;---<br>&emsp;&emsp;选举限制<br>&emsp;&emsp;因为 leader 的强势地位，所以 Raft 在投票阶段就确保选举出的 leader <font color=#FEAE00>一定包含了整个集群中目前已</font><font color=#FEAE00> committed </font><font color=#FEAE00>的所有日志。</font><br>&emsp;&emsp;当 candidate 发送 RequestVoteRPC 时，会带上最后一个 entry 的信息。 所有的节点收到该请求后，都会比对自己的日志，如果发现自己的日志更新一些，则会拒绝投票给该 candidate。 （Pre-Vote 同理，如果 follower 认为 Pre-Candidate 没有资格的话，会拒绝 PreVote）<br>&emsp;&emsp;判断日志新旧的方式：获取请求的 entry 后，比对自己日志中的最后一个 entry。 首先比对 term，如果自己的 term 更大，则拒绝请求。 如果 term 一样，则比对 index，如果自己的 index 更大（说明自己的日志更长），则拒绝请求。<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;在上图中，raft 为了避免出现一致性问题，要求 leader 绝不会提交过去的 term 的 entry （即使该 entry 已经被复制到了多数节点上）。leader 永远只提交当前 term 的 entry， 过去的 entry 只会随着当前的 entry 被一并提交。（上图中的 c，term2 只会跟随 term4 被提交。）<br>&emsp;&emsp;如果一个 candidate 能取得多数同意，说明它的日志已经是多数节点中最完备的， 那么也就可以认为该 candidate 已经包含了整个集群的所有 committed entries。<br>&emsp;&emsp;因此 leader 当选后，应当立刻发起 AppendEntriesRPC 提交一个 no-op entry。注意，这是一个 Must，不是一个 Should，否则会有许多 corner case 存在问题。比如：<br>&emsp;&emsp;	•	读请求：leader 此时的状态机可能并不是最新的，若服务读请求可能会违反线性一致性，即出现 safety 的问题；若不服务读请求则可能会有 liveness 的问题。<br>&emsp;&emsp;	•	配置变更：可能会导致数据丢失，具体原因和例子可以参考此 <font color=#4087E2>博客</font>。<br>&emsp;&emsp;实际上，leader 当选后提交一个 no-op entry 日志的做法就是 Raft 算法解决 “幽灵复现” 问题的解法，感兴趣的可以看看此 <font color=#4087E2>博客</font>。<br>&emsp;&emsp;<hr><hr>raft哪些state 需要持久化<hr><hr>raft成员变更 单步成员变更 和 联合成员变更<hr><hr>raft的选举机制? <hr><hr>redis 5、C++中的Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存？<hr>严格意义上来说缓存分为本地缓存和分布式缓存。<br>&emsp;&emsp;<br>&emsp;&emsp;那<font color=#FEAE00>以</font><font color=#FEAE00> C++ </font><font color=#FEAE00>语言为例，我们可以使用</font><font color=#FEAE00> STL </font><font color=#FEAE00>下自带的容器</font><font color=#FEAE00> map </font><font color=#FEAE00>来实现缓存，但只能实现本地缓存</font>，它最主要的特点是轻量以及快速，但是其生命周期随着程序的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;//todo 这里的多实例？<br>&emsp;&emsp;使用 Redis 或 Memcached 之类的称为<font color=#FEAE00>分布式缓存，在多实例的情况下，各实例共享一份缓存数据</font>，缓存具有一致性。这是Redis或者Memcached的优点所在，但它也有缺点，那就是需要保持 Redis 或 Memcached服务的高可用，整个程序架构上较为复杂。<hr><hr>redis 9、缓存中常说的热点数据和冷数据是什么？<hr>其实就是名字上的意思，热数据就是访问次数较多的数据，冷数据就是访问很少或者从不访问的数据。<br>&emsp;&emsp;<br>&emsp;&emsp;需要注意的是只有热点数据，缓存才有价值 对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。<br>&emsp;&emsp;<br>&emsp;&emsp;数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。<hr><hr>redis lru?<hr><hr>redis中的<font color=#FEAE00>zset</font>是什么做的?<hr><hr>redis做缓存的问题? 如何解决? 缓存穿透 缓存击穿, 缓存雪崩, 缓存一致性?<br>&emsp;&emsp;可能重复?<hr><hr>rookeeper<hr><hr>rookeeper的选主<hr><hr>td<br>&emsp;&emsp;<br>&emsp;&emsp;29、sdown 和 odown 转换机制<hr>- sdown 是主观宕机，就一个哨兵如果自己觉得一个 master 宕机了，那么就是主观宕机<br>&emsp;&emsp;- odown 是客观宕机，如果 quorum 数量的哨兵都觉得一个 master 宕机了，那么就是客观宕机<br>&emsp;&emsp;<br>&emsp;&emsp;sdown 达成的条件很简单，如果一个哨兵 ping 一个 master，超过了 `is-master-down-after-milliseconds` 指定的毫秒数之后，就主观认为 master 宕机了；如果一个哨兵在指定时间内，收到了 quorum 数量的其它哨兵也认为那个 master 是 sdown 的，那么就认为是 odown 了。<hr><hr>td<br>&emsp;&emsp;21、如何解决Redis的并发竞争Key问题<hr>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！<br>&emsp;&emsp;<br>&emsp;&emsp;推荐一种方案：分布式锁（zookeeper 和 Redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问 题，不要使用分布式锁，这样会影响性能）<br>&emsp;&emsp;<br>&emsp;&emsp;基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的 与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有 序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁 无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。<br>&emsp;&emsp;<br>&emsp;&emsp;在实践中，当然是从以可靠性为主。所以首推Zookeeper。<hr><hr>td<br>&emsp;&emsp;27、Redis集群模式的工作原理是什么？<hr>#### 基本通信原理<br>&emsp;&emsp;<br>&emsp;&emsp;集群元数据的维护有两种方式：集中式、Gossip 协议。Redis cluster 节点间采用 gossip 协议进行通信。<br>&emsp;&emsp;<br>&emsp;&emsp;集中式是将集群元数据（节点信息、故障等等）集中存储在某个节点上。集中式元数据集中存储的一个典型代表，就是大数据领域的 `storm` 。它是分布式的大数据实时计算引擎，是集中式的元数据存储的结构，底层基于 zookeeper（分布式协调的中间件）对所有元数据进行存储维护。<br>&emsp;&emsp;<br>&emsp;&emsp;![zookeeper-centralized-storage](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202208092301899.png)<br>&emsp;&emsp;<br>&emsp;&emsp;Redis 维护集群元数据采用另一个方式， `gossip` 协议，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。<br>&emsp;&emsp;<br>&emsp;&emsp;![Redis-gossip](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202208092301027.png)<br>&emsp;&emsp;<br>&emsp;&emsp;集中式的好处在于，元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；不好在于，所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。<br>&emsp;&emsp;<br>&emsp;&emsp;gossip 好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；不好在于，元数据的更新有延时，可能导致集群中的一些操作会有一些滞后。<br>&emsp;&emsp;<br>&emsp;&emsp;- 10000 端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如 7001，那么用于节点间通信的就是 17001 端口。每个节点每隔一段时间都会往另外几个节点发送 `ping` 消息，同时其它几个节点接收到 `ping` 之后返回 `pong` 。<br>&emsp;&emsp;- 交换的信息：信息包括故障信息，节点的增加和删除，hash slot 信息等等。<br>&emsp;&emsp;<br>&emsp;&emsp;#### gossip 协议<br>&emsp;&emsp;<br>&emsp;&emsp;gossip 协议包含多种消息，包含 `ping` , `pong` , `meet` , `fail` 等等。<br>&emsp;&emsp;<br>&emsp;&emsp;- meet：某个节点发送 meet 给新加入的节点，让新节点加入集群中，然后新节点就会开始与其它节点进行通信。<br>&emsp;&emsp;<br>&emsp;&emsp;```bash<br>&emsp;&emsp;Redis-trib.rb add-nodeCopy to clipboardErrorCopied<br>&emsp;&emsp; <br>&emsp;&emsp;        @阿秀: 代码已成功复制到剪贴板<br>&emsp;&emsp;    <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;1<br>&emsp;&emsp;<br>&emsp;&emsp;其实内部就是发送了一个 gossip meet 消息给新加入的节点，通知那个节点去加入我们的集群。<br>&emsp;&emsp;<br>&emsp;&emsp;- ping：每个节点都会频繁给其它节点发送 ping，其中包含自己的状态还有自己维护的集群元数据，互相通过 ping 交换元数据。<br>&emsp;&emsp;- pong：返回 ping 和 meet，包含自己的状态和其它信息，也用于信息广播和更新。<br>&emsp;&emsp;- fail：某个节点判断另一个节点 fail 之后，就发送 fail 给其它节点，通知其它节点说，某个节点宕机啦。<br>&emsp;&emsp;<br>&emsp;&emsp;#### ping 消息深入<br>&emsp;&emsp;<br>&emsp;&emsp;ping 时要携带一些元数据，如果很频繁，可能会加重网络负担。<br>&emsp;&emsp;<br>&emsp;&emsp;每个节点每秒会执行 10 次 ping，每次会选择 5 个最久没有通信的其它节点。当然如果发现某个节点通信延时达到了 `cluster_node_timeout / 2` ，那么立即发送 ping，避免数据交换延时过长，落后的时间太长了。比如说，两个节点之间都 10 分钟没有交换数据了，那么整个集群处于严重的元数据不一致的情况，就会有问题。所以 `cluster_node_timeout` 可以调节，如果调得比较大，那么会降低 ping 的频率。<br>&emsp;&emsp;<br>&emsp;&emsp;每次 ping，会带上自己节点的信息，还有就是带上 1/10 其它节点的信息，发送出去，进行交换。至少包含 `3` 个其它节点的信息，最多包含 `总节点数减 2` 个其它节点的信息。<br>&emsp;&emsp;<br>&emsp;&emsp;### 分布式寻址算法<br>&emsp;&emsp;<br>&emsp;&emsp;- hash 算法（大量缓存重建）<br>&emsp;&emsp;- 一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）<br>&emsp;&emsp;- Redis cluster 的 hash slot 算法<br>&emsp;&emsp;<br>&emsp;&emsp;#### hash 算法<br>&emsp;&emsp;<br>&emsp;&emsp;来了一个 key，首先计算 hash 值，然后对节点数取模。然后打在不同的 master 节点上。一旦某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去取数据。这会导致大部分的请求过来，全部无法拿到有效的缓存，导致大量的流量涌入数据库。<br>&emsp;&emsp;<br>&emsp;&emsp;![hash](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202208092301343.png)<br>&emsp;&emsp;<br>&emsp;&emsp;#### 一致性 hash 算法<br>&emsp;&emsp;<br>&emsp;&emsp;一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置。<br>&emsp;&emsp;<br>&emsp;&emsp;来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，遇到的第一个 master 节点就是 key 所在位置。<br>&emsp;&emsp;<br>&emsp;&emsp;在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理。<br>&emsp;&emsp;<br>&emsp;&emsp;燃鹅，一致性哈希算法在节点太少时，容易因为节点分布不均匀而造成缓存热点的问题。为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡。<br>&emsp;&emsp;<br>&emsp;&emsp;![consistent-hashing-algorithm](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202208092301991.png)<br>&emsp;&emsp;<br>&emsp;&emsp;#### Redis cluster 的 hash slot 算法<br>&emsp;&emsp;<br>&emsp;&emsp;Redis cluster 有固定的 `16384` 个 hash slot，对每个 `key` 计算 `CRC16` 值，然后对 `16384` 取模，可以获取 key 对应的 hash slot。<br>&emsp;&emsp;<br>&emsp;&emsp;Redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有 5000 多个 hash slot。hash slot 让 node 的增加和移除很简单，增加一个 master，就将其他 master 的 hash slot 移动部分过去，减少一个 master，就将它的 hash slot 移动到其他 master 上去。移动 hash slot 的成本是非常低的。客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 `hash tag` 来实现。<br>&emsp;&emsp;<br>&emsp;&emsp;任何一台机器宕机，另外两个节点，不影响的。因为 key 找的是 hash slot，不是机器。<br>&emsp;&emsp;<br>&emsp;&emsp;![hash-slot](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202208092301481.png)<br>&emsp;&emsp;<br>&emsp;&emsp;### Redis cluster 的高可用与主备切换原理<br>&emsp;&emsp;<br>&emsp;&emsp;Redis cluster 的高可用的原理，几乎跟哨兵是类似的。<br>&emsp;&emsp;<br>&emsp;&emsp;#### 判断节点宕机<br>&emsp;&emsp;<br>&emsp;&emsp;如果一个节点认为另外一个节点宕机，那么就是 `pfail` ，主观宕机。如果多个节点都认为另外一个节点宕机了，那么就是 `fail` ，客观宕机，跟哨兵的原理几乎一样，sdown，odown。<br>&emsp;&emsp;<br>&emsp;&emsp;在 `cluster-node-timeout` 内，某个节点一直没有返回 `pong` ，那么就被认为 `pfail` 。<br>&emsp;&emsp;<br>&emsp;&emsp;如果一个节点认为某个节点 `pfail` 了，那么会在 `gossip ping` 消息中， `ping` 给其他节点，如果超过半数的节点都认为 `pfail` 了，那么就会变成 `fail` 。<br>&emsp;&emsp;<br>&emsp;&emsp;#### 从节点过滤<br>&emsp;&emsp;<br>&emsp;&emsp;对宕机的 master node，从其所有的 slave node 中，选择一个切换成 master node。<br>&emsp;&emsp;<br>&emsp;&emsp;检查每个 slave node 与 master node 断开连接的时间，如果超过了 `cluster-node-timeout * cluster-slave-validity-factor` ，那么就没有资格切换成 `master` 。<br>&emsp;&emsp;<br>&emsp;&emsp;#### 从节点选举<br>&emsp;&emsp;<br>&emsp;&emsp;每个从节点，都根据自己对 master 复制数据的 offset，来设置一个选举时间，offset 越大（复制数据越多）的从节点，选举时间越靠前，优先进行选举。<br>&emsp;&emsp;<br>&emsp;&emsp;所有的 master node 开始 slave 选举投票，给要进行选举的 slave 进行投票，如果大部分 master node `（N/2 + 1）` 都投票给了某个从节点，那么选举通过，那个从节点可以切换成 master。<br>&emsp;&emsp;<br>&emsp;&emsp;从节点执行主备切换，从节点切换为主节点。<br>&emsp;&emsp;<br>&emsp;&emsp;#### 与哨兵比较<br>&emsp;&emsp;<br>&emsp;&emsp;整个流程跟哨兵相比，非常类似，所以说，Redis cluster 功能强大，直接集成了 replication 和 sentinel 的功能。<hr><hr>td<br>&emsp;&emsp;28、Redis 哨兵主备切换的数据丢失问题<hr>### 导致数据丢失的两种情况<br>&emsp;&emsp;<br>&emsp;&emsp;主备切换的过程，可能会导致数据丢失：<br>&emsp;&emsp;<br>&emsp;&emsp;- 异步复制导致的数据丢失<br>&emsp;&emsp;<br>&emsp;&emsp;因为 master->slave 的复制是异步的，所以可能有部分数据还没复制到 slave，master 就宕机了，此时这部分数据就丢失了。<br>&emsp;&emsp;<br>&emsp;&emsp;![async-replication-data-lose-case](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202208092301730.png)<br>&emsp;&emsp;<br>&emsp;&emsp;- 脑裂导致的数据丢失<br>&emsp;&emsp;<br>&emsp;&emsp;脑裂，也就是说，某个 master 所在机器突然脱离了正常的网络，跟其他 slave 机器不能连接，但是实际上 master 还运行着。此时哨兵可能就会认为 master 宕机了，然后开启选举，将其他 slave 切换成了 master。这个时候，集群里就会有两个 master ，也就是所谓的脑裂。<br>&emsp;&emsp;<br>&emsp;&emsp;此时虽然某个 slave 被切换成了 master，但是可能 client 还没来得及切换到新的 master，还继续向旧 master 写数据。因此旧 master 再次恢复的时候，会被作为一个 slave 挂到新的 master 上去，自己的数据会清空，重新从新的 master 复制数据。而新的 master 并没有后来 client 写入的数据，因此，这部分数据也就丢失了。<br>&emsp;&emsp;<br>&emsp;&emsp;![Redis-cluster-split-brain](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202208092301262.png)<br>&emsp;&emsp;<br>&emsp;&emsp;### 数据丢失问题的解决方案<br>&emsp;&emsp;<br>&emsp;&emsp;进行如下配置：<br>&emsp;&emsp;<br>&emsp;&emsp;```bash<br>&emsp;&emsp;min-slaves-to-write 1<br>&emsp;&emsp;min-slaves-max-lag 10Copy to clipboardErrorCopied<br>&emsp;&emsp; <br>&emsp;&emsp;        @阿秀: 代码已成功复制到剪贴板<br>&emsp;&emsp;    <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;1<br>&emsp;&emsp;2<br>&emsp;&emsp;<br>&emsp;&emsp;表示，要求至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒。<br>&emsp;&emsp;<br>&emsp;&emsp;如果说一旦所有的 slave，数据复制和同步的延迟都超过了 10 秒钟，那么这个时候，master 就不会再接收任何请求了。<br>&emsp;&emsp;<br>&emsp;&emsp;- 减少异步复制数据的丢失<br>&emsp;&emsp;<br>&emsp;&emsp;有了 `min-slaves-max-lag` 这个配置，就可以确保说，一旦 slave 复制数据和 ack 延时太长，就认为可能 master 宕机后损失的数据太多了，那么就拒绝写请求，这样可以把 master 宕机时由于部分数据未同步到 slave 导致的数据丢失降低的可控范围内。<br>&emsp;&emsp;<br>&emsp;&emsp;- 减少脑裂的数据丢失<br>&emsp;&emsp;<br>&emsp;&emsp;如果一个 master 出现了脑裂，跟其他 slave 丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的 slave 发送数据，而且 slave 超过 10 秒没有给自己 ack 消息，那么就直接拒绝客户端的写请求。因此在脑裂场景下，最多就丢失 10 秒的数据。<hr><hr>td<br>&emsp;&emsp;29、Redis 的并发竞争问题是什么？如何解决这个问题？了解 Redis 事务的 CAS 方案吗？<hr>这个也是线上非常常见的一个问题，就是多客户端同时并发写一个 key，可能本来应该先到的数据后到了，导致数据版本错了；或者是多客户端同时获取一个 key，修改值之后再写回去，只要顺序错了，数据就错了。<br>&emsp;&emsp;<br>&emsp;&emsp;而且 Redis 自己就有天然解决这个问题的 CAS 类的乐观锁方案。<br>&emsp;&emsp;<br>&emsp;&emsp;某个时刻，多个系统实例都去更新某个 key。可以基于 zookeeper 实现分布式锁。每个系统通过 zookeeper 获取分布式锁，确保同一时间，只能有一个系统实例在操作某个 key，别人都不允许读和写。<br>&emsp;&emsp;<br>&emsp;&emsp;![zookeeper-distributed-lock](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202208092301751.png)<br>&emsp;&emsp;<br>&emsp;&emsp;你要写入缓存的数据，都是从 mysql 里查出来的，都得写入 mysql 中，写入 mysql 中的时候必须保存一个时间戳，从 mysql 查出来的时候，时间戳也查出来。<br>&emsp;&emsp;<br>&emsp;&emsp;每次要写之前，先判断一下当前这个 value 的时间戳是否比缓存里的 value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。<hr><hr>td 0.范式29、数据库三大范式精要总结<hr>### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-02-MySQL.html#_1-简单归纳)（1）简单归纳：<br>&emsp;&emsp;<br>&emsp;&emsp;第一范式（1NF）：字段不可分； 　　第二范式（2NF）：有主键，非主键字段依赖主键； 　　第三范式（3NF）：非主键字段不能相互依赖。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-02-MySQL.html#_2-解释)（2）解释：<br>&emsp;&emsp;<br>&emsp;&emsp;1NF：原子性。 字段不可再分,否则就不是关系数据库;； 　　2NF：唯一性 。一个表只说明一个事物； 　　3NF：每列都与主键有直接关系，不存在传递依赖。<hr><hr>td 1.语法12: 窗口函数<br>&emsp;&emsp;	<br>&emsp;&emsp;!!! todo 其他的<hr>row_number() over partition by <br>&emsp;&emsp;只有这一种, 在牛客上<hr><hr>td 1.语法8、说一说Drop、Delete与Truncate的共同点和区别<hr>### 第一种回答<br>&emsp;&emsp;<br>&emsp;&emsp;Drop、Delete、Truncate都表示删除，但是三者有一些差别： Delete用来删除表的全部或者一部分数据行，执行delete之后，用户需要提交(commmit)或者回滚(rollback)来执行删除或者撤销删除，会触发这个表上所有的delete触发器。 Truncate删除表中的所有数据，这个操作不能回滚，也不会触发这个表上的触发器，TRUNCATE比delete更快，占用的空间更小。 Drop命令从数据库中删除表，所有的数据行，索引和权限也会被删除，所有的DML触发器也不会被触发，这个命令也不能回滚。<br>&emsp;&emsp;<br>&emsp;&emsp;因此，在不再需要一张表的时候，用Drop；在想删除部分数据行时候，用Delete；在保留表而删除所有数据的时候用Truncate。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-01-MySQL.html#第二种回答)第二种回答<br>&emsp;&emsp;<br>&emsp;&emsp;- Drop直接删掉表;<br>&emsp;&emsp;- Truncate删除表中数据，再插入时自增长id又从1开始 ;<br>&emsp;&emsp;- Delete删除表中数据，可以加where字句。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-01-MySQL.html#具体解析)具体解析<br>&emsp;&emsp;<br>&emsp;&emsp;1. DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。<br>&emsp;&emsp;2. 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。<br>&emsp;&emsp;3. 一般而言，drop > truncate > delete<br>&emsp;&emsp;4. 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view<br>&emsp;&emsp;5. TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。<br>&emsp;&emsp;6. truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。<br>&emsp;&emsp;7. delete语句为DML（Data Manipulation Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。<br>&emsp;&emsp;8. truncate、drop是DDL（Data Define Language),操作立即生效，原数据不放到 rollback segment中，不能回滚<br>&emsp;&emsp;9. 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果与事务无关，用truncate即可实现。如果和事务有关，或老是想触发trigger,还是用delete。<br>&emsp;&emsp;10. Truncate table 表名 速度快,而且效率高,因为: truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。<br>&emsp;&emsp;11. TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。<br>&emsp;&emsp;12. 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。<hr><hr>td 12、了解Redis的线程模型吗？可以大致说说吗？<hr>如果你打开看过 Redis 的源码就会发现Redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220024968.png)<br>&emsp;&emsp;<br>&emsp;&emsp;文件事件处理器的结构包含 4 个部分：<br>&emsp;&emsp;<br>&emsp;&emsp;- 多个 socket<br>&emsp;&emsp;- IO多路复用程序<br>&emsp;&emsp;- 文件事件分派器<br>&emsp;&emsp;- 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）<br>&emsp;&emsp;<br>&emsp;&emsp;使用 I/O 多路复用程序来同时监听多个套接字， 并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。<br>&emsp;&emsp;<br>&emsp;&emsp;多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。<br>&emsp;&emsp;<br>&emsp;&emsp;一句话总结就是：“I/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。”<hr><hr>td 14、定期和惰性一定能保证删除数据吗？如果不能，Redis会有什么应对措施？<hr>并不能保证一定删除，Redsi有一个Redis 内存淘汰机制来确保数据一定会被删除。<br>&emsp;&emsp;<br>&emsp;&emsp;首先介一下定期删除和惰性删除的工作流程：<br>&emsp;&emsp;<br>&emsp;&emsp;1、定期删除，Redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，Redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，Redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。<br>&emsp;&emsp;<br>&emsp;&emsp;2、于是，惰性删除派上用场。也就是说在你获取某个key的时候，Redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。<br>&emsp;&emsp;<br>&emsp;&emsp;3、采用定期删除+惰性删除就没其他问题了么? 不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，Redis<br>&emsp;&emsp;<br>&emsp;&emsp;4、内存会越来越高。那么就应该采用内存淘汰机制。<br>&emsp;&emsp;<br>&emsp;&emsp;在Redis.conf中有一行配置:maxmemory-policy volatile-lru<br>&emsp;&emsp;<br>&emsp;&emsp;该配置就是配内存淘汰策略的，主要有以下六种方案： volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰 volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰 allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 no-enviction（驱逐）：禁止驱逐数据，新写入操作会报错 ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。<hr><hr>td 2.B树12、文件索引和数据库索引为什么使用B+树?（第9个问题的详细回答）<hr>文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上。而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，因此B+树相比B树更为合适。数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，而红黑树这种结构，高度明显要深的多，并且由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性。<br>&emsp;&emsp;<br>&emsp;&emsp;最重要的是，B+树还有一个最大的好处：方便扫库。<br>&emsp;&emsp;<br>&emsp;&emsp;B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持，这是数据库选用B+树的最主要原因。<br>&emsp;&emsp;<br>&emsp;&emsp;B+树查找效率更加稳定，B树有可能在中间节点找到数据，稳定性不够。<br>&emsp;&emsp;<br>&emsp;&emsp;B+tree的磁盘读写代价更低：B+tree的内部结点并没有指向关键字具体信息的指针(红色部分)，因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一块盘中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了；<br>&emsp;&emsp;<br>&emsp;&emsp;B+tree的查询效率更加稳定：由于内部结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，所以，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；<hr><hr>td 2.索引21、MySQL中有四种索引类型，可以简单说说吗？<hr>- FULLTEXT ：即为全文索引，目前只有MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引，需要注意的是MySQL5.6以后支持全文索引了，5.6之前是不支持的。<br>&emsp;&emsp;- HASH ：由于HASH的唯一（几乎100%的唯一）及类似键值对的形式，很适合作为索引。 HASH索引可以一次定位，不需要像树形索引那样逐层查找,因此具有极高的效率。但是，这种高效是有条件的，即只在“=”和“in”条件下高效，对于范围查询、排序及组合索引仍然效率不高。<br>&emsp;&emsp;- BTREE ：BTREE索引就是一种将索引值按一定的算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，依次遍历node，获取leaf。这是MySQL里默认和最常用的索引类型。<br>&emsp;&emsp;- RTREE ：RTREE在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。 相对于BTREE，RTREE的优势在于范围查找。<hr><hr>td 3.ACID31、事务四大特性（<font color=#1DB100>ACID</font>）？<hr>原子性、一致性、隔离性、持久性<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-02-MySQL.html#第一种回答)第一种回答<br>&emsp;&emsp;<br>&emsp;&emsp;原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。 。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。<br>&emsp;&emsp;<br>&emsp;&emsp;一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。<br>&emsp;&emsp;<br>&emsp;&emsp;隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。<br>&emsp;&emsp;<br>&emsp;&emsp;持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-02-MySQL.html#第二种回答)第二种回答<br>&emsp;&emsp;<br>&emsp;&emsp;原子性（Atomicity）<br>&emsp;&emsp;<br>&emsp;&emsp;- 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。<br>&emsp;&emsp;<br>&emsp;&emsp;一致性（Consistency）<br>&emsp;&emsp;<br>&emsp;&emsp;- 事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。<br>&emsp;&emsp;<br>&emsp;&emsp;隔离性（Isolation）<br>&emsp;&emsp;<br>&emsp;&emsp;- 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。<br>&emsp;&emsp;<br>&emsp;&emsp;同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。 关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。   持久性（Durability）<br>&emsp;&emsp;<br>&emsp;&emsp;- 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。<hr><hr>td 3.隔离16、数据库<font color=#1DB100>并发事务</font>会带来哪些问题？<hr>数据库并发会带来<font color=#1DB100>脏读、幻读、丢弃更改、不可重复读</font>这四个常见问题，其中：<br>&emsp;&emsp;<br>&emsp;&emsp;脏读：在第一个修改事务和读取事务进行的时候，读取事务读到的数据为100，这是修改之后的数据，但是之后该事务满足一致性等特性而做了回滚操作，那么读取事务得到的结果就是<font color=#00AB8E>脏数据</font>了。<br>&emsp;&emsp;<br>&emsp;&emsp;幻读：一般是<font color=#1DB100>T1</font><font color=#1DB100>在某个范围内进行修改操作</font>（增加或者删除），而T2读取该范围导致读到的数据是修改之间的了，强调<font color=#1DB100>范围</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;丢弃修改：两个写事务T1 T2同时对A=0进行递增操作，结果T2覆盖T1，导致最终结果是1 而不是2，事务被覆盖<br>&emsp;&emsp;<br>&emsp;&emsp;不可重复读：T2 读取一个数据，然后T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-01-MySQL.html#脏读)脏读<br>&emsp;&emsp;<br>&emsp;&emsp;![脏读](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220024781.png)<br>&emsp;&emsp;<br>&emsp;&emsp;第一个事务首先读取var变量为50，接着准备更新为100的时，并未提交，第二个事务已经读取var为100，此时第一个事务做了回滚。最终第二个事务读取的var和数据库的var不一样。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-01-MySQL.html#幻读-幻影读)幻读（幻影读）<br>&emsp;&emsp;<br>&emsp;&emsp;![幻读](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220024132.png)<br>&emsp;&emsp;<br>&emsp;&emsp;T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-01-MySQL.html#丢弃修改)丢弃修改<br>&emsp;&emsp;<br>&emsp;&emsp;![丢弃修改](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220024561.png)<br>&emsp;&emsp;<br>&emsp;&emsp;T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。例如：事务1读取某表中的数据A=50，事务2也读取A=50，事务1修改A=A+50，事务2也修改A=A+50，最终结果A=100，事务1的修改被丢失。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/04-01-01-MySQL.html#不可重复读)不可重复读<br>&emsp;&emsp;<br>&emsp;&emsp;![不可重复读](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220024930.png)<br>&emsp;&emsp;<br>&emsp;&emsp;T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。<hr><hr>td 3、Redis常见数据结构以及使用场景分别是什么？<hr>### String<br>&emsp;&emsp;<br>&emsp;&emsp;String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用； 常规计数：微博数，粉丝数等。<br>&emsp;&emsp;<br>&emsp;&emsp;### Hash<br>&emsp;&emsp;<br>&emsp;&emsp;Hash 是一个 string 类型的 ﬁeld 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅 仅修改这个对象中的某个字段的值。 比如我们可以Hash数据结构来存储用户信息，商品信息等。<br>&emsp;&emsp;<br>&emsp;&emsp;### List<br>&emsp;&emsp;<br>&emsp;&emsp;list 就是链表，Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表， 消息列表等功能都可以用Redis的 list 结构来实现。<br>&emsp;&emsp;<br>&emsp;&emsp;Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。<br>&emsp;&emsp;<br>&emsp;&emsp;另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功 能，基于 Redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。<br>&emsp;&emsp;<br>&emsp;&emsp;### Set<br>&emsp;&emsp;<br>&emsp;&emsp;set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。<br>&emsp;&emsp;<br>&emsp;&emsp;当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在 一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。<br>&emsp;&emsp;<br>&emsp;&emsp;比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常 方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，具体命令如下：`sinterstore key1 key2 key3`将交集存在key1内。<br>&emsp;&emsp;<br>&emsp;&emsp;### Sorted Set<br>&emsp;&emsp;<br>&emsp;&emsp;和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。<br>&emsp;&emsp;<br>&emsp;&emsp;举例： 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维 度的消息排行榜）等信息，适合使用 Redis 中的 SortedSet 结构进行存储。<hr><hr>td CAP是什么? 和 ACID 中的 C 哪里不一样?<hr><hr>td redis 16、缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存击穿、缓存降级全搞定！<hr>### 缓存雪崩<br>&emsp;&emsp;<br>&emsp;&emsp;缓存雪崩指的是缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。<br>&emsp;&emsp;<br>&emsp;&emsp;看不懂？那我说人话。<br>&emsp;&emsp;<br>&emsp;&emsp;我们可以简单的理解为：由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃。<br>&emsp;&emsp;<br>&emsp;&emsp;解决办法<br>&emsp;&emsp;<br>&emsp;&emsp;- 事前：尽量保证整个 Redis 集群的高可用性，发现机器宕机尽快补上，选择合适的内存淘汰策略。<br>&emsp;&emsp;- 事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉， 通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。<br>&emsp;&emsp;- 事后：利用 Redis 持久化机制保存的数据尽快恢复缓存<br>&emsp;&emsp;<br>&emsp;&emsp;### 缓存穿透<br>&emsp;&emsp;<br>&emsp;&emsp;一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量 请求而崩掉。<br>&emsp;&emsp;<br>&emsp;&emsp;这也看不懂？那我再换个说法好了。<br>&emsp;&emsp;<br>&emsp;&emsp;缓存穿透是指查询一个一定不存在的数据，由于缓存不命中，接着查询数据库也无法查询出结果，因此也不会写入到缓存中，这将会导致每个查询都会去请求数据库，造成缓存穿透。<br>&emsp;&emsp;<br>&emsp;&emsp;解决办法<br>&emsp;&emsp;<br>&emsp;&emsp;1、布隆过滤器<br>&emsp;&emsp;<br>&emsp;&emsp;这是最常见的一种解决方法了，它是将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压 力。<br>&emsp;&emsp;<br>&emsp;&emsp;对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；<br>&emsp;&emsp;<br>&emsp;&emsp;这里稍微科普一下布隆过滤器。<br>&emsp;&emsp;<br>&emsp;&emsp;> 布隆过滤器是引入了k(k>1)k(k>1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。 它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。<br>&emsp;&emsp;><br>&emsp;&emsp;> 该算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是布隆过滤器的基本思想，一般用于在大数据量的集合中判定某元素是否存在。<br>&emsp;&emsp;<br>&emsp;&emsp;2、缓存空对象<br>&emsp;&emsp;<br>&emsp;&emsp;当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；如果一个查询返回的数据为空（不管是数据不存 在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。<br>&emsp;&emsp;<br>&emsp;&emsp;但是这种方法会存在两个问题：<br>&emsp;&emsp;<br>&emsp;&emsp;1、如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；<br>&emsp;&emsp;<br>&emsp;&emsp;2、即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。<br>&emsp;&emsp;<br>&emsp;&emsp;我们可以从适用场景和维护成本两方面对这两汇总方法进行一个简单比较：<br>&emsp;&emsp;<br>&emsp;&emsp;适用场景：缓存空对象适用于1、数据命中不高 2、数据频繁变化且实时性较高 ；而布隆过滤器适用1、数据命中不高 2、数据相对固定即实时性较低<br>&emsp;&emsp;<br>&emsp;&emsp;维护成本：缓存空对象的方法适合1、代码维护简单 2、需要较多的缓存空间 3、数据会出现不一致的现象；布隆过滤器适合 1、代码维护较复杂 2、缓存空间要少一些<br>&emsp;&emsp;<br>&emsp;&emsp;缓存预热<br>&emsp;&emsp;<br>&emsp;&emsp;缓存预热是指系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。用户会直接查询事先被预热的缓存数据！<br>&emsp;&emsp;<br>&emsp;&emsp;解决思路 1、直接写个缓存刷新页面，上线时手工操作下； 2、数据量不大，可以在项目启动的时候自动进行加载； 3、定时刷新缓存；<br>&emsp;&emsp;<br>&emsp;&emsp;### 缓存更新<br>&emsp;&emsp;<br>&emsp;&emsp;除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：定时删除和惰性删除，其中： （1）定时删除：定时去清理过期的缓存； （2）惰性删除：当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。 两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。<br>&emsp;&emsp;<br>&emsp;&emsp;### 缓存击穿<br>&emsp;&emsp;<br>&emsp;&emsp;缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。<br>&emsp;&emsp;<br>&emsp;&emsp;比如常见的电商项目中，某些货物成为“爆款”了，可以对一些主打商品的缓存直接设置为永不过期。即便某些商品自己发酵成了爆款，也是直接设为永不过期就好了。mutex key互斥锁基本上是用不上的，有个词叫做大道至简。<br>&emsp;&emsp;<br>&emsp;&emsp;缓存降级<br>&emsp;&emsp;<br>&emsp;&emsp;当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。 降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。 以参考日志级别设置预案： （1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级； （2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警； （3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级； （4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。<br>&emsp;&emsp;<br>&emsp;&emsp;服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。<hr><hr>td steal 和 force<hr><hr>td1.6、说一下MySQL是<font color=#FEAE00>如何执行一条</font><font color=#FEAE00>SQL</font><font color=#FEAE00>的</font>？具体步骤有哪些？<hr>Server层按顺序执行sql的步骤为：<br>&emsp;&emsp;<br>&emsp;&emsp;1. 客户端请求-><br>&emsp;&emsp;2. 连接器（验证用户身份，给予权限） -><br>&emsp;&emsp;3. 查询缓存（存在缓存则直接返回，不存在则执行后续操作）-><br>&emsp;&emsp;4. 分析器（对SQL进行词法分析和语法分析操作） -><br>&emsp;&emsp;5. 优化器（主要对执行的sql优化选择最优的执行方案方法） -><br>&emsp;&emsp;6. 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）-><br>&emsp;&emsp;7. 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）<br>&emsp;&emsp;<br>&emsp;&emsp;简单概括：<br>&emsp;&emsp;<br>&emsp;&emsp;- <font color=#FEAE00>连接器</font><font color=#FEAE00>：管理连接、权限验证；</font><font color=#FEAE00><br>&emsp;&emsp;</font>- <font color=#FEAE00>查询缓存</font><font color=#FEAE00>：命中缓存则直接返回结果；</font><font color=#FEAE00><br>&emsp;&emsp;</font>- <font color=#FEAE00>分析器</font><font color=#FEAE00>：对</font><font color=#FEAE00>SQL</font><font color=#FEAE00>进行词法分析、语法分析；（判断查询的</font><font color=#FEAE00>SQL</font><font color=#FEAE00>字段是否存在也是在这步）</font><font color=#FEAE00><br>&emsp;&emsp;</font>- <font color=#FEAE00>优化器</font><font color=#FEAE00>：执行计划生成、选择索引；</font><font color=#FEAE00><br>&emsp;&emsp;</font>- <font color=#FEAE00>执行器</font><font color=#FEAE00>：操作引擎、返回结果；</font><font color=#FEAE00><br>&emsp;&emsp;</font>- <font color=#FEAE00>存储引擎</font><font color=#FEAE00>：存储数据、提供读写接口。</font><br>&emsp;&emsp;<br>&emsp;&emsp;![SQL执行的全部过程](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220024265.png)<hr><hr>td1.语法9 组合查询<br>&emsp;&emsp;Union / Union all <br>&emsp;&emsp;//todo 怎么用?<hr><hr>td17、假如MySQL有1000万数据，采用Redis作为中间缓存，取其中的10万，如何保证Redis中的数据都是热点数据？<hr>可以使用Redis的数据淘汰策略，Redis 内存数据集大小上升到一定大小的时候，就会施行这种策略。具体说来，主要有 6种内存淘汰策略：<br>&emsp;&emsp;<br>&emsp;&emsp;- voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰<br>&emsp;&emsp;- volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰<br>&emsp;&emsp;- volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰<br>&emsp;&emsp;- allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰<br>&emsp;&emsp;- allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰<br>&emsp;&emsp;- no-enviction（驱逐）：禁止驱逐数据<hr><hr>td2.主键27、数据库中的主键、超键、候选键、外键是什么？（很棒）<hr>- 超键：在关系中能唯一标识元组的属性集称为关系模式的超键<br>&emsp;&emsp;- 候选键：不含有多余属性的超键称为候选键。也就是在候选键中，若再删除属性，就不是键了！<br>&emsp;&emsp;- 主键：用户选作元组标识的一个候选键程序主键<br>&emsp;&emsp;- 外键：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。<br>&emsp;&emsp;<br>&emsp;&emsp;举例：<br>&emsp;&emsp;<br>&emsp;&emsp;| 学号     | 姓名   | 性别 | 年龄 | 系别   | 专业     |<br>&emsp;&emsp;| -------- | ------ | ---- | ---- | ------ | -------- |<br>&emsp;&emsp;| 20020612 | 李辉   | 男   | 20   | 计算机 | 软件开发 |<br>&emsp;&emsp;| 20060613 | 张明   | 男   | 18   | 计算机 | 软件开发 |<br>&emsp;&emsp;| 20060614 | 王小玉 | 女   | 19   | 物理   | 力学     |<br>&emsp;&emsp;| 20060615 | 李淑华 | 女   | 17   | 生物   | 动物学   |<br>&emsp;&emsp;| 20060616 | 赵静   | 男   | 21   | 化学   | 食品化学 |<br>&emsp;&emsp;| 20060617 | 赵静   | 女   | 20   | 生物   | 植物学   |<br>&emsp;&emsp;<br>&emsp;&emsp;1. 超键：于是我们从例子中可以发现 学号是标识学生实体的唯一标识。那么该元组的超键就为学号。除此之外我们还可以把它跟其他属性组合起来，比如：(`学号`，`性别`)，(`学号`，`年龄`)<br>&emsp;&emsp;2. 候选键：根据例子可知，学号是一个可以唯一标识元组的唯一标识，因此学号是一个候选键，实际上，候选键是超键的子集，比如 （学号，年龄）是超键，但是它不是候选键。因为它还有了额外的属性。<br>&emsp;&emsp;3. 主键：简单的说，例子中的元组的候选键为学号，但是我们选定他作为该元组的唯一标识，那么学号就为主键。<br>&emsp;&emsp;4. 外键是相对于主键的，比如在学生记录里，主键为学号，在成绩单表中也有学号字段，因此学号为成绩单表的外键，为学生表的主键。<br>&emsp;&emsp;<br>&emsp;&emsp;主键为候选键的子集，候选键为超键的子集，而外键的确定是相对于主键的。<hr><hr>td25、Redis 的高并发和高可用是如何保证的？<hr>这样的问题主要是在并发读写访问的时候，缓存和数据相互交叉执行。<br>&emsp;&emsp;<br>&emsp;&emsp;### Redis的主从架构模式<br>&emsp;&emsp;<br>&emsp;&emsp;Rdis的主从架构模式是实现高并发的主要依赖，一般很多项目只需要一主多从就可以实现其所需要的功能。通常使用单主用来写入数据，单机几万 QPS；多从一般是查询数据，多个从实例可以提供每秒 10w 的 QPS。<br>&emsp;&emsp;<br>&emsp;&emsp;一些项目需要在实现高并发的同时，尽可能多的容纳大量的数据，这时需要使用Redis 集群，使用Redis 集群之后，可以提供每秒几十万的读写并发。<br>&emsp;&emsp;<br>&emsp;&emsp;Redis 高可用，如果是做主从架构部署，那么加上哨兵就可以实现，任何一个实例宕机，可以进行主备切换。<br>&emsp;&emsp;<br>&emsp;&emsp;单机的 Redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高并发。<br>&emsp;&emsp;<br>&emsp;&emsp;![Redis-master-slave](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202208092302036.png)<br>&emsp;&emsp;<br>&emsp;&emsp;Redis replication -> 主从架构 -> 读写分离 -> 水平扩容支撑读高并发<br>&emsp;&emsp;<br>&emsp;&emsp;### Redis replication 的核心机制<br>&emsp;&emsp;<br>&emsp;&emsp;- Redis 采用异步方式复制数据到 slave 节点，不过 Redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；<br>&emsp;&emsp;- 一个 master node 是可以配置多个 slave node 的；<br>&emsp;&emsp;- slave node 也可以连接其他的 slave node；<br>&emsp;&emsp;- slave node 做复制的时候，不会 block master node 的正常工作；<br>&emsp;&emsp;- slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；<br>&emsp;&emsp;- slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。<br>&emsp;&emsp;<br>&emsp;&emsp;注意，如果采用了主从架构，那么建议必须开启 master node 的持久化，不建议用 slave node 作为 master node 的数据热备，因为那样的话，如果你关掉 master 的持久化，可能在 master 宕机重启的时候数据是空的，然后可能一经过复制， slave node 的数据也丢了。<br>&emsp;&emsp;<br>&emsp;&emsp;另外，master 的各种备份方案，也需要做。万一本地的所有文件丢失了，从备份中挑选一份 rdb 去恢复 master，这样才能确保启动的时候，是有数据的，即使采用了后续讲解的高可用机制，slave node 可以自动接管 master node，但也可能 sentinel 还没检测到 master failure，master node 就自动重启了，还是可能导致上面所有的 slave node 数据被清空。<br>&emsp;&emsp;<br>&emsp;&emsp;### Redis 主从复制的核心原理<br>&emsp;&emsp;<br>&emsp;&emsp;当启动一个 slave node 的时候，它会发送一个 `PSYNC` 命令给 master node。<br>&emsp;&emsp;<br>&emsp;&emsp;如果这是 slave node 初次连接到 master node，那么会触发一次 `full resynchronization` 全量复制。此时 master 会启动一个后台线程，开始生成一份 `RDB` 快照文件，同时还会将从客户端 client 新收到的所有写命令缓存在内存中。 `RDB` 文件生成完毕后， master 会将这个 `RDB` 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中，接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。<br>&emsp;&emsp;<br>&emsp;&emsp;![Redis-master-slave-replication](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202208092302031.png)<br>&emsp;&emsp;<br>&emsp;&emsp;### 主从复制的断点续传<br>&emsp;&emsp;<br>&emsp;&emsp;从 Redis2.8 开始，就支持主从复制的断点续传，如果主从复制过程中，网络连接断掉了，那么可以接着上次复制的地方，继续复制下去，而不是从头开始复制一份。<br>&emsp;&emsp;<br>&emsp;&emsp;master node 会在内存中维护一个 backlog，master 和 slave 都会保存一个 replica offset 还有一个 master run id，offset 就是保存在 backlog 中的。如果 master 和 slave 网络连接断掉了，slave 会让 master 从上次 replica offset 开始继续复制，如果没有找到对应的 offset，那么就会执行一次 `resynchronization` 。<br>&emsp;&emsp;<br>&emsp;&emsp;> 如果根据 host+ip 定位 master node，是不靠谱的，如果 master node 重启或者数据出现了变化，那么 slave node 应该根据不同的 run id 区分。<br>&emsp;&emsp;<br>&emsp;&emsp;### 无磁盘化复制<br>&emsp;&emsp;<br>&emsp;&emsp;master 在内存中直接创建 `RDB` ，然后发送给 slave，不会在自己本地落地磁盘了。只需要在配置文件中开启 `repl-diskless-sync yes` 即可。<br>&emsp;&emsp;<br>&emsp;&emsp;```bash<br>&emsp;&emsp;repl-diskless-sync yes<br>&emsp;&emsp;<br>&emsp;&emsp;# 等待 5s 后再开始复制，因为要等更多 slave 重新连接过来<br>&emsp;&emsp;repl-diskless-sync-delay 5Copy to clipboardErrorCopied<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;### 过期 key 处理<br>&emsp;&emsp;<br>&emsp;&emsp;slave 不会过期 key，只会等待 master 过期 key。如果 master 过期了一个 key，或者通过 LRU 淘汰了一个 key，那么会模拟一条 del 命令发送给 slave。<br>&emsp;&emsp;<br>&emsp;&emsp;### 复制的完整流程<br>&emsp;&emsp;<br>&emsp;&emsp;slave node 启动时，会在自己本地保存 master node 的信息，包括 master node 的 `host` 和 `ip` ，但是复制流程没开始。<br>&emsp;&emsp;<br>&emsp;&emsp;slave node 内部有个定时任务，每秒检查是否有新的 master node 要连接和复制，如果发现，就跟 master node 建立 socket 网络连接。然后 slave node 发送 `ping` 命令给 master node。如果 master 设置了 requirepass，那么 slave node 必须发送 masterauth 的口令过去进行认证。master node 第一次执行全量复制，将所有数据发给 slave node。而在后续，master node 持续将写命令，异步复制给 slave node。<br>&emsp;&emsp;<br>&emsp;&emsp;![Redis-master-slave-replication-detail](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202208092302833.png)<br>&emsp;&emsp;<br>&emsp;&emsp;### 全量复制<br>&emsp;&emsp;<br>&emsp;&emsp;- master 执行 bgsave ，在本地生成一份 rdb 快照文件。<br>&emsp;&emsp;- master node 将 rdb 快照文件发送给 slave node，如果 rdb 复制时间超过 60 秒（repl-timeout），那么 slave node 就会认为复制失败，可以适当调大这个参数(对于千兆网卡的机器，一般每秒传输 100MB，6G 文件，很可能超过 60s)<br>&emsp;&emsp;- master node 在生成 rdb 时，会将所有新的写命令缓存在内存中，在 slave node 保存了 rdb 之后，再将新的写命令复制给 slave node。<br>&emsp;&emsp;- 如果在复制期间，内存缓冲区持续消耗超过 64MB，或者一次性超过 256MB，那么停止复制，复制失败。<br>&emsp;&emsp;<br>&emsp;&emsp;```bash<br>&emsp;&emsp;client-output-buffer-limit slave 256MB 64MB 60Copy to clipboardErrorCopied<br>&emsp;&emsp; <br>&emsp;&emsp;        @阿秀: 代码已成功复制到剪贴板<br>&emsp;&emsp;    <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;1<br>&emsp;&emsp;<br>&emsp;&emsp;- slave node 接收到 rdb 之后，清空自己的旧数据，然后重新加载 rdb 到自己的内存中，同时基于旧的数据版本对外提供服务。<br>&emsp;&emsp;- 如果 slave node 开启了 AOF，那么会立即执行 BGREWRITEAOF，重写 AOF。<br>&emsp;&emsp;<br>&emsp;&emsp;### 增量复制<br>&emsp;&emsp;<br>&emsp;&emsp;- 如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接 master 时，会触发增量复制。<br>&emsp;&emsp;- master 直接从自己的 backlog 中获取部分丢失的数据，发送给 slave node，默认 backlog 就是 1MB。<br>&emsp;&emsp;- master 就是根据 slave 发送的 psync 中的 offset 来从 backlog 中获取数据的。<br>&emsp;&emsp;<br>&emsp;&emsp;### heartbeat<br>&emsp;&emsp;<br>&emsp;&emsp;主从节点互相都会发送 heartbeat 信息。<br>&emsp;&emsp;<br>&emsp;&emsp;master 默认每隔 10 秒发送一次 heartbeat，slave node 每隔 1 秒发送一个 heartbeat。<br>&emsp;&emsp;<br>&emsp;&emsp;### 异步复制<br>&emsp;&emsp;<br>&emsp;&emsp;master 每次接收到写命令之后，先在内部写入数据，然后异步发送给 slave node。<hr><hr>td27、Redis集于哨兵集群实现高可用？<hr>### 哨兵的介绍<br>&emsp;&emsp;<br>&emsp;&emsp;sentinel，中文名是哨兵。哨兵是 Redis 集群架构中非常重要的一个组件，主要有以下功能：<br>&emsp;&emsp;<br>&emsp;&emsp;- 集群监控：负责监控 Redis master 和 slave 进程是否正常工作。<br>&emsp;&emsp;- 消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。<br>&emsp;&emsp;- 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。<br>&emsp;&emsp;- 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。<br>&emsp;&emsp;<br>&emsp;&emsp;哨兵用于实现 Redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。<br>&emsp;&emsp;<br>&emsp;&emsp;- 故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举的问题。<br>&emsp;&emsp;- 即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，因为如果一个作为高可用机制重要组成部分的故障转移系统本身是单点的，那就很坑爹了。<br>&emsp;&emsp;<br>&emsp;&emsp;### 哨兵的核心知识<br>&emsp;&emsp;<br>&emsp;&emsp;- 哨兵至少需要 3 个实例，来保证自己的健壮性。<br>&emsp;&emsp;- 哨兵 + Redis 主从的部署架构，是不保证数据零丢失的，只能保证 Redis 集群的高可用性。<br>&emsp;&emsp;- 对于哨兵 + Redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。<br>&emsp;&emsp;<br>&emsp;&emsp;哨兵集群必须部署 2 个以上节点，如果哨兵集群仅仅部署了 2 个哨兵实例，quorum = 1。<br>&emsp;&emsp;<br>&emsp;&emsp;```text<br>&emsp;&emsp;+----+         +----+<br>&emsp;&emsp;| M1 |---------| R1 |<br>&emsp;&emsp;| S1 |         | S2 |<br>&emsp;&emsp;+----+         +----+<br>&emsp;&emsp;<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;配置 `quorum=1` ，如果 master 宕机， s1 和 s2 中只要有 1 个哨兵认为 master 宕机了，就可以进行切换，同时 s1 和 s2 会选举出一个哨兵来执行故障转移。但是同时这个时候，需要 majority，也就是大多数哨兵都是运行的。<br>&emsp;&emsp;<br>&emsp;&emsp;```text<br>&emsp;&emsp;2 个哨兵，majority=2<br>&emsp;&emsp;3 个哨兵，majority=2<br>&emsp;&emsp;4 个哨兵，majority=2<br>&emsp;&emsp;5 个哨兵，majority=3<br>&emsp;&emsp;...<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;如果此时仅仅是 M1 进程宕机了，哨兵 s1 正常运行，那么故障转移是 OK 的。但是如果是整个 M1 和 S1 运行的机器宕机了，那么哨兵只有 1 个，此时就没有 majority 来允许执行故障转移，虽然另外一台机器上还有一个 R1，但是故障转移不会执行。<br>&emsp;&emsp;<br>&emsp;&emsp;经典的 3 节点哨兵集群是这样的：<br>&emsp;&emsp;<br>&emsp;&emsp;```text<br>&emsp;&emsp;       +----+<br>&emsp;&emsp;       | M1 |<br>&emsp;&emsp;       | S1 |<br>&emsp;&emsp;       +----+<br>&emsp;&emsp;          |<br>&emsp;&emsp;+----+    |    +----+<br>&emsp;&emsp;| R2 |----+----| R3 |<br>&emsp;&emsp;| S2 |         | S3 |<br>&emsp;&emsp;+----+         +----+<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;配置 `quorum=2` ，如果 M1 所在机器宕机了，那么三个哨兵还剩下 2 个，S2 和 S3 可以一致认为 master 宕机了，然后选举出一个来执行故障转移，同时 3 个哨兵的 majority 是 2，所以还剩下的 2 个哨兵运行着，就可以允许执行故障转移。<hr><hr>td30、哨兵集群的自动发现机制<hr>哨兵互相之间的发现，是通过 Redis 的 `pub/sub` 系统实现的，每个哨兵都会往 `__sentinel__:hello` 这个 channel 里发送一个消息，这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在。<br>&emsp;&emsp;<br>&emsp;&emsp;每隔两秒钟，每个哨兵都会往自己监控的某个 master+slaves 对应的 `__sentinel__:hello` channel 里发送一个消息，内容是自己的 host、ip 和 runid 还有对这个 master 的监控配置。<br>&emsp;&emsp;<br>&emsp;&emsp;每个哨兵也会去监听自己监控的每个 master+slaves 对应的 `__sentinel__:hello` channel，然后去感知到同样在监听这个 master+slaves 的其他哨兵的存在。<br>&emsp;&emsp;<br>&emsp;&emsp;每个哨兵还会跟其他哨兵交换对 `master` 的监控配置，互相进行监控配置的同步。<br>&emsp;&emsp;<br>&emsp;&emsp;### slave 配置的自动纠正<br>&emsp;&emsp;<br>&emsp;&emsp;哨兵会负责自动纠正 slave 的一些配置，比如 slave 如果要成为潜在的 master 候选人，哨兵会确保 slave 复制现有 master 的数据；如果 slave 连接到了一个错误的 master 上，比如故障转移之后，那么哨兵会确保它们连接到正确的 master 上。<br>&emsp;&emsp;<br>&emsp;&emsp;### slave->master 选举算法<br>&emsp;&emsp;<br>&emsp;&emsp;如果一个 master 被认为 odown 了，而且 majority 数量的哨兵都允许主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个 slave 来，会考虑 slave 的一些信息：<br>&emsp;&emsp;<br>&emsp;&emsp;- 跟 master 断开连接的时长<br>&emsp;&emsp;- slave 优先级<br>&emsp;&emsp;- 复制 offset<br>&emsp;&emsp;- run id<br>&emsp;&emsp;<br>&emsp;&emsp;如果一个 slave 跟 master 断开连接的时间已经超过了 `down-after-milliseconds` 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master。<br>&emsp;&emsp;<br>&emsp;&emsp;```text<br>&emsp;&emsp;(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_stateCopy to clipboardErrorCopied<br>&emsp;&emsp; <br>&emsp;&emsp;        @阿秀: 代码已成功复制到剪贴板<br>&emsp;&emsp;    <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;1<br>&emsp;&emsp;<br>&emsp;&emsp;接下来会对 slave 进行排序：<br>&emsp;&emsp;<br>&emsp;&emsp;- 按照 slave 优先级进行排序，slave priority 越低，优先级就越高。<br>&emsp;&emsp;- 如果 slave priority 相同，那么看 replica offset，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。<br>&emsp;&emsp;- 如果上面两个条件都相同，那么选择一个 run id 比较小的那个 slave。<br>&emsp;&emsp;<br>&emsp;&emsp;### quorum 和 majority<br>&emsp;&emsp;<br>&emsp;&emsp;每次一个哨兵要做主备切换，首先需要 quorum 数量的哨兵认为 odown，然后选举出一个哨兵来做切换，这个哨兵还需要得到 majority 哨兵的授权，才能正式执行切换。<br>&emsp;&emsp;<br>&emsp;&emsp;如果 quorum < majority，比如 5 个哨兵，majority 就是 3，quorum 设置为 2，那么就 3 个哨兵授权就可以执行切换。<br>&emsp;&emsp;<br>&emsp;&emsp;但是如果 quorum >= majority，那么必须 quorum 数量的哨兵都授权，比如 5 个哨兵，quorum 是 5，那么必须 5 个哨兵都同意授权，才能执行切换。<br>&emsp;&emsp;<br>&emsp;&emsp;### configuration epoch<br>&emsp;&emsp;<br>&emsp;&emsp;哨兵会对一套 Redis master+slaves 进行监控，有相应的监控的配置。<br>&emsp;&emsp;<br>&emsp;&emsp;执行切换的那个哨兵，会从要切换到的新 master（salve->master）那里得到一个 configuration epoch，这就是一个 version 号，每次切换的 version 号都必须是唯一的。<br>&emsp;&emsp;<br>&emsp;&emsp;如果第一个选举出的哨兵切换失败了，那么其他哨兵，会等待 failover-timeout 时间，然后接替继续执行切换，此时会重新获取一个新的 configuration epoch，作为新的 version 号。<br>&emsp;&emsp;<br>&emsp;&emsp;### configuration 传播<br>&emsp;&emsp;<br>&emsp;&emsp;哨兵完成切换之后，会在自己本地更新生成最新的 master 配置，然后同步给其他的哨兵，就是通过之前说的 `pub/sub` 消息机制。<br>&emsp;&emsp;<br>&emsp;&emsp;这里之前的 version 号就很重要了，因为各种消息都是通过一个 channel 去发布和监听的，所以一个哨兵完成一次新的切换之后，新的 master 配置是跟着新的 version 号的。其他的哨兵都是根据版本号的大小来更新自己的 master 配置的。<hr><hr>todo23、数据为什么会出现不一致的情况？<hr>这样的问题主要是在并发读写访问的时候，缓存和数据相互交叉执行。<br>&emsp;&emsp;<br>&emsp;&emsp;### 一、单库情况下<br>&emsp;&emsp;<br>&emsp;&emsp;同一时刻发生了并发读写请求，例如为A(写) B (读)2个请求<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220023694.png)<br>&emsp;&emsp;<br>&emsp;&emsp;1. A请求发送一个写操作到服务端，第一步会淘汰cache，然后因为各种原因卡主了，不在执行后面业务(例：大量的业务操作、调用其他服务处理消耗了1s）。<br>&emsp;&emsp;2. B请求发送一个读操作，读cache，因为cache淘汰，所以为空<br>&emsp;&emsp;3. B请求继续读DB，读出一个脏数据，并写入cache<br>&emsp;&emsp;4. A请求终于执行完全，在写入数据到DB<br>&emsp;&emsp;<br>&emsp;&emsp;总结：因最后才把写操作数据入DB，并没同步。cache里面一直保持脏数据<br>&emsp;&emsp;<br>&emsp;&emsp;脏数据是指源系统中的数据不在给定的范围内或对于实际业务毫无意义，或是数据格式非法，以及在源系统中存在不规范的编码和含糊的业务逻辑。<br>&emsp;&emsp;<br>&emsp;&emsp;### 二、主从同步，读写分离的情况下，读从库而产生脏数据<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220023284.png)<br>&emsp;&emsp;<br>&emsp;&emsp;1. A请求发送一个写操作到服务端，第一步会淘汰cache<br>&emsp;&emsp;2. A请求写主数据库，写了最新的数据。<br>&emsp;&emsp;3. B请求发送一个读操作，读cache，因为cache淘汰，所以为空<br>&emsp;&emsp;4. B请求继续读DB，读的是从库，此时主从同步还没同步成功。读出脏数据，然后脏数据入cache<br>&emsp;&emsp;5. 最后数据库主从同步完成<br>&emsp;&emsp;<br>&emsp;&emsp;总结：这种情况下请求A和请求B操作时序没问题，是主从同步的时延问题(假设1s)，导致读请求读取从库读到脏数据导致的数据不一致<br>&emsp;&emsp;<br>&emsp;&emsp;根本原因:<br>&emsp;&emsp;<br>&emsp;&emsp;单库下，逻辑处理中消耗1s，可能读到旧数据入缓存<br>&emsp;&emsp;<br>&emsp;&emsp;主从+读写分离，在1s的主从同步时延中，到从库的旧数据入缓存<hr><hr>todo24、常见的数据优化方案你了解吗？<hr>![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220023822.png)<br>&emsp;&emsp;<br>&emsp;&emsp;一、缓存双淘汰法<br>&emsp;&emsp;<br>&emsp;&emsp;1. 先淘汰缓存<br>&emsp;&emsp;2. 再写数据库<br>&emsp;&emsp;3. 往消息总线esb发送一个淘汰消息，发送立即返回。写请求的处理时间几乎没有增加，这个方法淘汰了缓存两次。因此被称为“缓存双淘汰法“，而在消息总线下游，有一个异步淘汰缓存的消费者，在拿到淘汰消息在1s后淘汰缓存，这样，即使在一秒内有脏数据入缓存，也能够被淘汰掉。<br>&emsp;&emsp;<br>&emsp;&emsp;二、异步淘汰缓存<br>&emsp;&emsp;<br>&emsp;&emsp;上述的步骤，都是在业务线里面执行，新增一个线下的读取binlog异步淘汰缓存模块，读取binlog总的数据，然后进行异步淘汰。<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220023992.png)<br>&emsp;&emsp;<br>&emsp;&emsp;这里简单提供一个思路<br>&emsp;&emsp;<br>&emsp;&emsp;1.思路：<br>&emsp;&emsp;<br>&emsp;&emsp;MySQL binlog增量发布订阅消费+消息队列+增量数据更新到Redis<br>&emsp;&emsp;<br>&emsp;&emsp;1）读请求走Redis：热数据基本都在Redis<br>&emsp;&emsp;<br>&emsp;&emsp;2）写请求走MySQL: 增删改都操作MySQL<br>&emsp;&emsp;<br>&emsp;&emsp;3）更新Redis数据：MySQ的数据操作binlog，来更新到Redis<br>&emsp;&emsp;<br>&emsp;&emsp;2.Redis更新<br>&emsp;&emsp;<br>&emsp;&emsp;1）数据操作主要分为两块：<br>&emsp;&emsp;<br>&emsp;&emsp;- 一个是全量(将全部数据一次写入到Redis)<br>&emsp;&emsp;- 一个是增量（实时更新）<br>&emsp;&emsp;<br>&emsp;&emsp;这里说的是增量,指的是mysql的update、insert、delate变更数据。这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新，就无需在从业务线去操作缓存内容。<hr><hr>为什么要通过遍历的方式来计数？<hr>你可以会好奇，为什么 count 函数需要通过遍历的方式来统计记录个数？<br>&emsp;&emsp;我前面将的案例都是基于 Innodb 存储引擎来说明的，但是在 MyISAM 存储引擎里，执行 count 函数的方式是不一样的，通常在没有任何查询条件下的 count(*)，<font color=#FEAE00>MyISAM </font><font color=#FEAE00>的查询速度要明显快于</font><font color=#FEAE00> InnoDB</font><font color=#FEAE00>。</font><br>&emsp;&emsp;使用 MyISAM 引擎时，执行 count 函数只需要 O(1 )复杂度，这是因为每张 <font color=#FEAE00>MyISAM </font><font color=#FEAE00>的数据表都有一个</font><font color=#FEAE00> meta </font><font color=#FEAE00>信息有存储了</font><font color=#FEAE00>row_count</font><font color=#FEAE00>值</font>，由<font color=#FEAE00>表级锁保证一致性</font>，所以直接读取 row_count 值就是 count 函数的执行结果。<br>&emsp;&emsp;而 InnoDB 存储引擎是支持事务的，<font color=#FEAE00>同一个时刻的多个查询，由于多版本并发控制（</font><font color=#FEAE00>MVCC</font><font color=#FEAE00>）的原因</font>，InnoDB 表“应该返回多少行”也是不确定的，所以无法像 MyISAM一样，只维护一个 row_count 变量。<br>&emsp;&emsp;举个例子，假设表 t_order 有 100 条记录，现在有两个会话并行以下语句：<br>&emsp;&emsp;￼<br>&emsp;&emsp;在会话 A 和会话 B的最后一个时刻，同时查表 t_order 的记录总个数，可以发现，显示的结果是不一样的。所以，在使用 InnoDB 存储引擎时，<font color=#FEAE00>就需要扫描表来统计具体的记录。</font><br>&emsp;&emsp;而当带上 where 条件语句之后，MyISAM 跟 InnoDB 就没有区别了，它们都需要扫描表来进行记录个数的统计。<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>什么时候<font color=#FEAE00>需要</font><font color=#FEAE00> / </font><font color=#FEAE00>不需要</font>创建索引？<hr>需要: <br>&emsp;&emsp;	唯一性, <br>&emsp;&emsp;	where 字段, <br>&emsp;&emsp;	group by / order by,<br>&emsp;&emsp;	可以避免回表的时候<br>&emsp;&emsp;不需要: <br>&emsp;&emsp;	大量重复字段, <br>&emsp;&emsp;	不在 where 里面, <br>&emsp;&emsp;	经常更新的字段<br>&emsp;&emsp;###<br>&emsp;&emsp;索引最大的好处是<font color=#FEAE00>提高查询速度</font>，但是索引也是有缺点的，比如：<br>&emsp;&emsp;	•	需要<font color=#FEAE00>占用物理空间</font>，数量越大，占用空间越大；<br>&emsp;&emsp;	•	<font color=#FEAE00>创建索引和维护索引要耗费时间</font>，这种时间随着数据量的增加而增大；<br>&emsp;&emsp;	•	会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。<br>&emsp;&emsp;所以，索引不是万能钥匙，它也是根据场景来使用的。<br>&emsp;&emsp;# 什么时候适用索引？<br>&emsp;&emsp;	•	字段有<font color=#FEAE00>唯一性限制</font>的，比如商品编码；<br>&emsp;&emsp;	•	<font color=#FEAE00>经常</font>用于 <font color=#FEAE00>WHERE </font><font color=#FEAE00>查询条件的字段</font>，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。<br>&emsp;&emsp;	•	经常用于 <font color=#FEAE00>GROUP BY </font><font color=#FEAE00>和</font><font color=#FEAE00> ORDER BY </font><font color=#FEAE00>的字段</font>，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。<br>&emsp;&emsp;# 什么时候<font color=#FEAE00>不需要</font>创建索引？<br>&emsp;&emsp;<font color=#4D647F>	•	</font><font color=#4D647F>WHERE</font> 条件，<font color=#4D647F>GROUP BY</font>，<font color=#4D647F>ORDER BY</font> 里用不到的字段，索引的价值是快速定位，如果<font color=#FEAE00>起不到定位的字段通常是不需要创建索引的</font>，因为索引是会占用物理空间的。<br>&emsp;&emsp;	•	字段中存在<font color=#FEAE00>大量重复数据</font>，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。<br>&emsp;&emsp;	•	<font color=#FEAE00>表数据太少的时候</font>，不需要创建索引；<br>&emsp;&emsp;	•	<font color=#FEAE00>经常更新的字段</font>不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>什么是 2PC 3PC 有啥优缺点?<br>&emsp;&emsp;问题重复<hr><hr>什么是 B 树<hr>自平衡二叉树虽然能保持查询操作的时间复杂度在O(logn)，但是因为它本质上是一个二叉树，每个节点只能有 2 个子节点，那么当节点个数越多的时候，树的高度也会相应变高，这样就会增加磁盘的 I/O 次数，从而影响数据查询的效率。<br>&emsp;&emsp;为了解决<font color=#FEAE00>降低树的高度的问题</font>，后面就出来了 B 树，它不再限制一个节点就只能有 2 个子节点，而是允许 M 个子节点 (M>2)，从而降低树的高度。<br>&emsp;&emsp;B 树的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶，所以 <font color=#FEAE00>B </font><font color=#FEAE00>树就是一个多叉树</font>。<br>&emsp;&emsp;假设 M = 3，那么就是一棵 3 阶的 B 树，特点就是每个节点最多有 2 个（M-1个）数据和最多有 3 个（M个）子节点，超过这些要求的话，就会分裂节点<br>&emsp;&emsp;我们来看看一棵 3 阶的 B 树的查询过程是怎样的？<br>&emsp;&emsp;￼<br>&emsp;&emsp;假设我们在上图一棵 3 阶的 B 树中要查找的索引值是 9 的记录那么步骤可以分为以下几步：<br>&emsp;&emsp;	1	与根节点的索引(4，8）进行比较，9 大于 8，那么往右边的子节点走；<br>&emsp;&emsp;	2	然后该子节点的索引为（10，12），因为 9 小于 10，所以会往该节点的左边子节点走；<br>&emsp;&emsp;	3	走到索引为9的节点，然后我们找到了索引值 9 的节点。<br>&emsp;&emsp;可以看到，一棵 3 阶的 B 树在查询叶子节点中的数据时，由于树的高度是 3 ，所以在查询过程中会发生<font color=#FEAE00> 3 </font><font color=#FEAE00>次磁盘</font><font color=#FEAE00> I/O </font><font color=#FEAE00>操作</font>。<br>&emsp;&emsp;而如果同样的节点数量在平衡二叉树的场景下，树的高度就会很高，意味着磁盘 I/O 操作会更多。所以，B 树在数据查询中比平衡二叉树效率要高。<br>&emsp;&emsp;但是 B 树的每个节点都<font color=#FEAE00>包含数据（索引</font><font color=#FEAE00>+</font><font color=#FEAE00>记录）</font>，而<font color=#FEAE00>用户的记录数据的大小很有可能远远超过了索引数据</font>，这就需要花费更多的磁盘 I/O 操作次数来读到「有用的索引数据」。<br>&emsp;&emsp;而且，在我们查询位于底层的某个节点（比如 A 记录）过程中，「非 A 记录节点」里的记录数据会从磁盘加载到内存，但是这些记录数据是没用的，我们只是想读取这些节点的索引数据来做比较查询，而「非 A 记录节点」里的记录数据对我们是没用的，这样不仅增多磁盘 I/O 操作次数，也占用内存资源。<br>&emsp;&emsp;另外，如果使用 B 树来做范围查询的话，需要使用<font color=#FEAE00>中序遍历，</font>这会涉及多个节点的磁盘 I/O 问题，从而导致整体速度下降。<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>什么是 B+ 树？<hr>B+ 树就是对 B 树做了一个升级，MySQL 中索引的数据结构就是采用了 B+ 树，B+ 树结构如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;B+ 树与 B 树差异的点，主要是以下这几点：<br>&emsp;&emsp;	•	<font color=#FEAE00>叶子节点</font>（最底部的节点）才会存放<font color=#FEAE00>实际数据</font>（索引+记录），非叶子节点只会存放索引；<br>&emsp;&emsp;	•	所有索引都会在叶子节点出现，<font color=#FEAE00>叶子节点之间构成一个有序链表</font>；<br>&emsp;&emsp;	•	非叶子节点的索引也会同时存在在子节点中，并且是在子节点中所有索引的最大（或最小）。<br>&emsp;&emsp;	•	非叶子节点中有多少个子节点，就有多少个索引；<br>&emsp;&emsp;下面通过三个方面，比较下 B+ 和 B 树的性能区别。<br>&emsp;&emsp;# 1、单点查询<br>&emsp;&emsp;	B 树进行单个索引查询时，最快可以在 O(1) 的时间代价内就查到，而从平均时间代价来看，<font color=#FEAE00>会比</font><font color=#FEAE00> B+ </font><font color=#FEAE00>树稍快一些</font>。<br>&emsp;&emsp;	但是 B 树的<font color=#FEAE00>查询波动会比较大</font>，因为每个节点即存索引又存记录，所以有时候访问到了非叶子节点就可以找到索引，而有时需要访问到叶子节点才能找到索引。<br>&emsp;&emsp;	<font color=#FEAE00>B+ </font><font color=#FEAE00>树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的</font><font color=#FEAE00> B </font><font color=#FEAE00>树，</font><font color=#FEAE00>B+</font><font color=#FEAE00>树的非叶子节点可以存放更多的索引，因此</font><font color=#FEAE00> B+ </font><font color=#FEAE00>树可以比</font><font color=#FEAE00> B </font><font color=#FEAE00>树更「</font><font color=#00AB8E>矮胖</font><font color=#FEAE00>」，查询底层节点的磁盘</font><font color=#FEAE00> I/O</font><font color=#FEAE00>次数会更少</font><font color=#FEAE00>。</font><br>&emsp;&emsp;# 2、插入和删除效率<br>&emsp;&emsp;B+ 树有大量的<font color=#FEAE00>冗余节点</font>，这样使得删除一个节点的时候，可以直接从叶子节点中删除，甚至可以<font color=#FEAE00>不动非叶子节点，这样删除非常快，</font><br>&emsp;&emsp;比如下面这个动图是删除 B+ 树 0004 节点的过程，因为非叶子节点有 0004 的冗余节点，所以在删除的时候，树形结构变化很小：<br>&emsp;&emsp;￼<br>&emsp;&emsp;注意，：B+ 树对于非叶子节点的子节点和索引的个数，定义方式可能会有不同，有的是说非叶子节点的子节点的个数为 M 阶，而索引的个数为 M-1（这个是维基百科里的定义），因此我本文关于 B+ 树的动图都是基于这个。但是我在前面介绍 B+ 树与 B+ 树的差异时，说的是「非叶子节点中有多少个子节点，就有多少个索引」，主要是 MySQL 用到的 B+ 树就是这个特性。<br>&emsp;&emsp;下面这个动图是删除 B 树 0008 节点的过程，可能会导致树的复杂变化：<br>&emsp;&emsp;￼<br>&emsp;&emsp;甚至，B+ 树在删除根节点的时候，由于存在冗余的节点，所以不会发生复杂的树的变形，比如下面这个动图是删除 B+ 树根节点的过程：<br>&emsp;&emsp;￼<br>&emsp;&emsp;B 树则不同，<font color=#FEAE00>B </font><font color=#FEAE00>树没有冗余节点，删除节点的时候非常复杂</font>，比如删除根节点中的数据，可能涉及复杂的树的变形，比如下面这个动图是删除 B 树根节点的过程：<br>&emsp;&emsp;￼<br>&emsp;&emsp;B+ 树的插入也是一样，有冗余节点，插入可能存在节点的分裂（如果节点饱和），但是最多只涉及树的一条路径。而且 B+ 树会自动平衡，不需要像更多复杂的算法，类似红黑树的旋转操作等。<br>&emsp;&emsp;因此，<font color=#FEAE00>B+ </font><font color=#FEAE00>树的插入和删除效率更高</font><font color=#FEAE00>。</font><br>&emsp;&emsp;# 3、范围查询<br>&emsp;&emsp;B 树和 B+ 树等值查询原理基本一致，先从根节点查找，然后对比目标数据的范围，最后递归的进入子节点查找。<br>&emsp;&emsp;因为<font color=#FEAE00> </font><font color=#FEAE00>B+ </font><font color=#FEAE00>树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助</font><font color=#FEAE00>，</font>比如说我们想知道 12 月 1 日和 12 月 12 日之间的订单，这个时候可以先查找到 12 月 1 日所在的叶子节点，然后利用链表向右遍历，直到找到 12 月12 日的节点，这样就不需要从根节点查询了，进一步节省查询需要的时间。<br>&emsp;&emsp;而 B 树没有将所有叶子节点用链表串联起来的结构，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。<br>&emsp;&emsp;因此，存在大量范围检索的场景，适合使用 B+树，比如数据库。而对于<font color=#FEAE00>大量的单个索引查询的场景，可以考虑</font><font color=#FEAE00> B </font><font color=#FEAE00>树</font>，比如 nosql 的MongoDB。<br>&emsp;&emsp;<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>什么是二分查找树？<hr>	用<font color=#FEAE00>数组来实现线性排序</font>的数据虽然简单好用，但是<font color=#FEAE00>插入新元素</font>的时候性能太低。<br>&emsp;&emsp;	因为插入一个元素，需要将这个元素之后的所有元素后移一位，如果这个操作发生在磁盘中呢？这必然是灾难性的。因为磁盘的速度比内存慢几十万倍，所以我们不能用一种线性结构将磁盘排序。<br>&emsp;&emsp;	其次，有序的数组在使用二分查找的时候，每次查找都要不断计算中间的位置。<br>&emsp;&emsp;	那我们能不能设计一个<font color=#FEAE00>非线形且天然适合二分查找</font>的数据结构呢？<br>&emsp;&emsp;	有的，请看下图这个神奇的操作，找到所有二分查找中用到的所有中间节点，<font color=#FEAE00>把他们用指针连起来</font>，并将<font color=#FEAE00>最中间的节点作为根节点。</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;	怎么样？是不是变成了二叉树，不过它不是普通的二叉树，它是一个<font color=#00AB8E>二叉查找树</font>。<br>&emsp;&emsp;	<font color=#FEAE00>二叉查找树的特点是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点</font><font color=#FEAE00>，</font>这样我们在查询数据时，不需要计算中间节点的位置了，只需将<font color=#FEAE00>查找的数据与节点的数据</font>进行比较。<br>&emsp;&emsp;假设，我们查找索引值为 key 的节点：<br>&emsp;&emsp;	1	如果 key 大于根节点，则在右子树中进行查找；<br>&emsp;&emsp;	2	如果 key 小于根节点，则在左子树中进行查找；<br>&emsp;&emsp;	3	如果 key 等于根节点，也就是找到了这个节点，返回根节点即可。<br>&emsp;&emsp;二叉查找树查找某个节点的动图演示如下，比如要查找节点 3 ：<br>&emsp;&emsp;￼<br>&emsp;&emsp;	另外，二叉查找树解决了<font color=#FEAE00>插入新节点</font>的问题，因为二叉查找树是一个<font color=#FEAE00>跳跃结构</font>，不必连续排列。这样在插入的时候，新节点可以放在任何位置，不会像线性结构那样插入一个元素，所有元素都需要向后排列。<br>&emsp;&emsp;下面是二叉查找树插入某个节点的动图演示：<br>&emsp;&emsp;￼<br>&emsp;&emsp;	因此，二叉查找树解决了连续结构插入新元素开销很大的问题，同时又保持着天然的二分结构。<br>&emsp;&emsp;那是不是二叉查找树就可以<font color=#FEAE00>作为索引的数据结构</font>了呢？<br>&emsp;&emsp;	不行不行，二叉查找树存在一个极端情况，会导致它变成一个瘸子！<br>&emsp;&emsp;	<font color=#FEAE00>当每次插入的元素都是二叉查找树中最大的元素，二叉查找树就会退化成了一条链表，查找数据的时间复杂度变成了</font><font color=#FEAE00> O(n)</font><font color=#FEAE00>，</font>如下动图演示：<br>&emsp;&emsp;￼<br>&emsp;&emsp;	由于树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作（<font color=#7414AF>假设一个节点的大小「小于」操作系统的最小读写单位块的大小</font>），也就是说<font color=#FEAE00>树的高度就等于每次查询数据时磁盘</font><font color=#FEAE00> IO </font><font color=#FEAE00>操作的次数</font>，所以树的高度越高，就会影响查询性能。<br>&emsp;&emsp;	二叉查找树由于存在退化成链表的可能性，会使得查询操作的时间复杂度从<font color=#FEAE00> O(logn) </font><font color=#FEAE00>升为</font><font color=#FEAE00> O(n)</font><font color=#FEAE00>。</font><br>&emsp;&emsp;	而且会随着插入的元素越多，树的高度也变高，意味着需要磁盘 IO 操作的次数就越多，这样导致查询性能严重下降，再加上<font color=#FEAE00>不能范围查询</font>，所以不适合作为数据库的索引结构。<hr><hr>什么是二分查找？<hr>	索引数据最好能按顺序排列，这样可以使用「二分查找法」高效定位数据。<br>&emsp;&emsp;	假设我们现在用数组来存储索引，比如下面有一个排序的数组，如果要从中找出数字 3，最简单办法就是从头依次遍历查询，这种方法的时间复杂度是 O(n)，查询效率并不高。因为该数组是有序的，所以我们可以采用<font color=#FEAE00>二分查找法</font>，比如下面这张采用二分法的查询过程图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;	可以看到，二分查找法每次都把查询的范围减半，这样时间复杂度就降到了 O(logn)，但是每次查找都需要不断<font color=#FEAE00>计算中间位置。</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>什么是索引？<hr>	当你想查阅书中某个知识的内容，你会选择一页一页的找呢？还是在<font color=#FEAE00>书的目录</font>去找呢？<br>&emsp;&emsp;	傻瓜都知道时间是宝贵的，当然是选择在书的目录去找，找到后再翻到对应的页。书中的<font color=#FEAE00>目录</font>，就是充当<font color=#FEAE00>索引</font>的角色，方便我们快速查找书中的内容，所以索引是以空间换时间的设计思想。<br>&emsp;&emsp;	那换到数据库中，索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是<font color=#FEAE00>索引是数据的目录</font>。<br>&emsp;&emsp;	所谓的存储引擎，说白了就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。MySQL 存储引擎有 MyISAM 、InnoDB、Memory，其中 InnoDB 是在 MySQL 5.5 之后成为默认的存储引擎。<br>&emsp;&emsp;	下图是 MySQL 的结构图，索引和数据就是位于存储引擎中：<br>&emsp;&emsp;￼<hr><hr>什么是自平衡二叉树？<hr>为了解决二叉查找树会在极端情况下退化成链表的问题，后面就有人提出<font color=#FEAE00>平衡二叉查找树（</font><font color=#FEAE00>AVL </font><font color=#FEAE00>树）</font><font color=#FEAE00>。</font><br>&emsp;&emsp;主要是在二叉查找树的基础上增加了一些条件约束：<font color=#FEAE00>每个节点的左子树和右子树的高度差不能超过</font><font color=#FEAE00> 1</font>。也就是说节点的左子树和右子树仍然为平衡二叉树，这样查询操作的时间复杂度就会一直维持在 <font color=#FEAE00>O(logn) </font><font color=#FEAE00>。</font><br>&emsp;&emsp;下图是每次插入的元素都是平衡二叉查找树中最大的元素，可以看到，它会<font color=#FEAE00>维持自平衡：</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;除了平衡二叉查找树，还有很多自平衡的二叉树，比如<font color=#FEAE00>红黑树，</font>它也是通过一些约束条件来达到自平衡，不过红黑树的约束条件比较复杂，不是本篇的重点重点，大家可以看《数据结构》相关的书籍来了解红黑树的约束条件。<br>&emsp;&emsp;下面是红黑树插入节点的过程，这左旋右旋的操作，就是为了自平衡。<br>&emsp;&emsp;￼<br>&emsp;&emsp;<font color=#FEAE00>不管平衡二叉查找树还是红黑树，都会随着插入的元素增多，而导致树的高度变高，这就意味着磁盘</font><font color=#FEAE00> I/O </font><font color=#FEAE00>操作次数多，会影响整体数据查询的效率</font><font color=#FEAE00>。</font><br>&emsp;&emsp;比如，下面这个平衡二叉查找树的高度为 5，那么在访问最底部的节点时，就需要磁盘 5 次 I/O 操作。<br>&emsp;&emsp;￼<br>&emsp;&emsp;根本原因是因为它们都是二叉树，也就是每个节点只能保存 2 个子节点 ，如果我们把二叉树改成<font color=#FEAE00> M </font><font color=#FEAE00>叉树（</font><font color=#FEAE00>M>2</font><font color=#FEAE00>）</font>呢？<br>&emsp;&emsp;比如，当 M=3 时，在同样的节点个数情况下，三叉树比二叉树的树高要矮。<br>&emsp;&emsp;￼<br>&emsp;&emsp;因此<font color=#FEAE00>，</font><font color=#FEAE00>当树的节点越多的时候，并且树的分叉数</font><font color=#FEAE00> M </font><font color=#FEAE00>越大的时候，</font><font color=#FEAE00>M </font><font color=#FEAE00>叉树的高度会远小于二叉树的高度</font><font color=#FEAE00>。</font><hr><hr><font color=#FEAE00>全局锁</font><hr># 全局锁是怎么用的？<br>&emsp;&emsp;要使用全局锁，则要执行这条命：<br>&emsp;&emsp;flush <font color=#5E3563>tables</font> <font color=#5E3563>with</font> <font color=#5E3563>read</font> <font color=#5E3563>lock</font><br>&emsp;&emsp;执行后，<font color=#FEAE00>整个数据库就处于只读状态了</font>，这时其他线程执行以下操作，都会被阻塞：<br>&emsp;&emsp;	•	对数据的增删改操作，比如 insert、delete、update等语句；<br>&emsp;&emsp;	•	对表结构的更改操作，比如 alter table、drop table 等语句。<br>&emsp;&emsp;<font color=#FEAE00>如果要释放全局锁，则要执行这条命令：</font><br>&emsp;&emsp;<font color=#5E3563>unlock</font> <font color=#5E3563>tables</font><br>&emsp;&emsp;当然，当会话断开了，全局锁会被自动释放。<br>&emsp;&emsp;# 全局锁应用场景是什么？<br>&emsp;&emsp;锁主要应用于做<font color=#FEAE00>全库逻辑备份</font>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。<br>&emsp;&emsp;举个例子大家就知道了。<br>&emsp;&emsp;在全库逻辑备份期间，假设不加全局锁的场景，看看会出现什么意外的情况。<br>&emsp;&emsp;如果在全库逻辑备份期间，有用户购买了一件商品，一般购买商品的业务逻辑是会涉及到多张数据库表的更新，比如在用户表更新该用户的余额，然后在商品表更新被购买的商品的库存。<br>&emsp;&emsp;那么，有可能出现这样的顺序：<br>&emsp;&emsp;	1	<font color=#FEAE00>先备份了用户表</font>的数据；<br>&emsp;&emsp;	2	然后有用户发起了购买商品的操作；<br>&emsp;&emsp;	3	<font color=#FEAE00>接着再备份商品表</font>的数据。<br>&emsp;&emsp;也就是在备份用户表和商品表之间，有用户购买了商品。<br>&emsp;&emsp;这种情况下，备份的结果是用户表中该用户的余额并没有扣除，反而商品表中该商品的库存被减少了，如果后面用这个备份文件恢复数据库数据的话，用户钱没少，而库存少了，等于用户白嫖了一件商品。<br>&emsp;&emsp;所以，在<font color=#FEAE00>全库逻辑备份期间，加上全局锁</font>，就不会出现上面这种情况了。<br>&emsp;&emsp;# 加全局锁又会带来什么缺点呢？<br>&emsp;&emsp;加上全局锁，意味着<font color=#FEAE00>整个数据库都是只读状态</font>。<br>&emsp;&emsp;那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。<br>&emsp;&emsp;# 既然备份数据库数据的时候，<font color=#FEAE00>使用全局锁会影响业务，</font>那有什么其他方式可以避免？<br>&emsp;&emsp;有的，如果数据库的引擎支持的事务支持<font color=#FEAE00>可重复读的隔离级别</font>，那么在备份数据库之前<font color=#FEAE00>先开启事务，会先创建</font><font color=#FEAE00> Read View</font>，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。<br>&emsp;&emsp;因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。<br>&emsp;&emsp;备份数据库的工具是 <font color=#FEAE00>mysqldump</font>，在使用 mysqldump 时加上 <font color=#4D647F>–</font><font color=#FEAE00>single-transaction</font> 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。<br>&emsp;&emsp;<font color=#FEAE00>InnoDB</font><font color=#FEAE00> </font><font color=#FEAE00>存储引擎默认的事务隔离级别正是可重复读</font>，因此可以采用这种方式来备份数据库。<br>&emsp;&emsp;但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr><font color=#FEAE00>共识算法</font>是什么?<hr>整体工作, 允许故障, 源于复制状态机(日志顺序的一致性)<br>&emsp;&emsp;一般满足四个特性: 非拜占庭条件下的一致性,多数节点存活可用, 不依赖于时间, 多数节点一致后就返回结果<br>&emsp;&emsp;---<br>&emsp;&emsp;共识算法允许一组节点像一个整体一样一起工作，即使其中一些节点出现故障也能够继续工作下去，其正确性主要源于<font color=#FEAE00>复制状态机的性质</font>：<br>&emsp;&emsp;<font color=#525458>任何初始状态一样的状态机，如果执行的命令序列一样，则最终达到的状态也一样。如果将此特性应用在多参与者进行协商共识上，可以理解为系统中存在多个</font><font color=#FEAE00>具有完全相同的状态机</font><font color=#525458>（参与者），这些状态机能最终保持一致的关键就是起始状态完全一致和执行命令序列完全一致。</font><font color=#525458><br>&emsp;&emsp;</font>共识算法常被用来确保每一个节点上的状态机一定都<font color=#FEAE00>会按相同的顺序执行相同的命令</font>， 并且<font color=#FEAE00>最终会处于相同的状态</font>。换句话说，可以理解为共识算法就是用来确保每个节点上的<font color=#FEAE00>日志顺序都是一致的</font>。（不过需要注意的是，只确保“提交给状态机的日志”顺序是一致的，而有些日志项可能只是暂时添加，尚未决定要提交给状态机）。正因为如此，共识算法在构建可容错的大规模分布式系统中扮演着重要的角色。<br>&emsp;&emsp;￼<font color=#4087E2><br>&emsp;&emsp;</font>上图就是每个节点的状态机，日志模块，共识模块与客户端交互的过程。<br>&emsp;&emsp;当然，实际使用系统中的共识算法一般满足以下特性：<br>&emsp;&emsp;	•	<font color=#FEAE00>在非拜占庭条件下保证共识的一致性</font>。（非拜占庭条件，指的就是每一个节点都是诚实可信的，每一次信息的传递都是真实的且符合协议要求的，当节点无法满足协议所要求的条件时，就停止服务，节点仅会因为网络延迟或崩溃出现不一致，而不会有节点传递错误的数据或故意捏造假数据。）<br>&emsp;&emsp;	•	<font color=#FEAE00>在多数节点存活时，保持可用性</font>。（“多数”永远指的是配置文件中所有节点的多数，而不是存活节点的多数。）<br>&emsp;&emsp;	•	<font color=#FEAE00>不依赖于时间</font>，<font color=#FEAE00>错误的时钟和高延迟只会导致可用性问题</font>，而不会导致一致性问题。<br>&emsp;&emsp;	•	<font color=#FEAE00>在多数节点一致后就返回结果</font>，而不会受到个别慢节点的影响。<br>&emsp;&emsp;<hr><hr>关于<font color=#FEAE00>数据系统</font>的思考<hr>我们通常认为，数据库、消息队列、缓存等工具分属于几个差异显著的类别。虽然数据库和消息队列表面上有一些相似性——它们都会存储一段时间的数据——但它们有迥然不同的访问模式，这意味着迥异的性能特征和实现手段。<br>&emsp;&emsp;那我们为什么要把这些东西放在 <font color=#FEAE00>数据系统（</font><font color=#FEAE00>data system</font><font color=#FEAE00>）</font> 的总称之下混为一谈呢？<br>&emsp;&emsp;近些年来，出现了许多新的<font color=#FEAE00>数据存储工具与数据处理工具</font>。它们针对不同应用场景进行优化，因此不再适合生硬地归入传统类别【1】。类别之间的界限变得越来越模糊，例如：数据存储可以被当成消息队列用（Redis），<font color=#FEAE00>消息队列则带有类似数据库的持久保证（</font><font color=#FEAE00>Apache Kafka</font><font color=#FEAE00>）</font>。<br>&emsp;&emsp;其次，越来越多的应用程序有着各种严格而广泛的要求，单个工具不足以满足所有的数据处理和存储需求。取而代之的是，总体工作被拆分成一系列能被单个工具高效完成的任务，并通过应用代码将它们缝合起来。<br>&emsp;&emsp;例如，如果将<font color=#FEAE00>缓存（应用管理的缓存层，</font><font color=#FEAE00>Memcached</font><font color=#FEAE00>或同类产品</font>）和<font color=#FEAE00>全文搜索（全文搜索服务器，例如</font><font color=#FEAE00>Elasticsearch</font><font color=#FEAE00>或</font><font color=#FEAE00>Solr</font>）功能从主数据库剥离出来，那么使<font color=#FEAE00>缓存</font><font color=#FEAE00>/</font><font color=#FEAE00>索引与主数据库保持同步</font>通常是应用代码的责任。<font color=#5281BF>图</font><font color=#5281BF>1-1</font> 给出了这种架构可能的样子（细节将在后面的章节中详细介绍）。<br>&emsp;&emsp;￼<br>&emsp;&emsp;图1-1 一个可能的组合使用多个组件的数据系统架构<br>&emsp;&emsp;当你将多个工具组合在一起提供服务时，服务的接口或应用程序编程接口（<font color=#FEAE00>API, Application Programming Interface</font>）通常向客户端隐藏这些实现细节。现在，你基本上已经使用较小的通用组件创建了一个全新的、专用的数据系统。这个新的复合数据系统可能会提供特定的保证，例如：缓存在写入时会作废或更新，以便外部客户端获取一致的结果。现在你不仅是应用程序开发人员，还是数据系统设计人员了。<br>&emsp;&emsp;设计数据系统或服务时可能会遇到很多棘手的问题，例如：当系统出问题时，如何确保数据的正确性和完整性？当部分系统退化降级时，如何为客户提供始终如一的良好性能？当负载增加时，如何扩容应对？什么样的API才是好的API？<br>&emsp;&emsp;影响数据系统设计的因素很多，包括参与人员的技能和经验、历史遗留问题、系统路径依赖、交付时限、公司的风险容忍度、监管约束等，这些因素都需要具体问题具体分析。<br>&emsp;&emsp;本书着重讨论三个在大多数软件系统中都很重要的问题：<br>&emsp;&emsp;<font color=#FEAE00>可靠性（</font><font color=#FEAE00>Reliability</font><font color=#FEAE00>）</font><br>&emsp;&emsp;系统在<font color=#FEAE00>困境（</font><font color=#FEAE00>adversity</font><font color=#FEAE00>）</font><font color=#FEAE00>（硬件故障、软件故障、人为错误</font>）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。<br>&emsp;&emsp;<font color=#FEAE00>可扩展性（</font><font color=#FEAE00>Scalability</font><font color=#FEAE00>）</font><br>&emsp;&emsp;有合理的办法应对系统的增长（数据量、流量、复杂性）（参阅“<font color=#5281BF>可扩展性</font>”）<br>&emsp;&emsp;<font color=#FEAE00>可维护性（</font><font color=#FEAE00>Maintainability</font><font color=#FEAE00>）</font><br>&emsp;&emsp;许多不同的人（工程师、运维）在不同的生命周期，都能高效地在系统上工作（使系统保持现有行为，并适应新的应用场景）。（参阅”<font color=#5281BF>可维护性</font>“）<br>&emsp;&emsp;人们经常追求这些词汇，却没有清楚理解它们到底意味着什么。为了工程的严谨性，本章的剩余部分将探讨可靠性、可扩展性、可维护性的含义。为实现这些目标而使用的各种技术，架构和算法将在后续的章节中研究。<br>&emsp;&emsp;<hr><hr>分布式事务<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>no-force + steal <br>&emsp;&emsp;Steal/No-Steal:是否允许未 commit 的数据落盘<br>&emsp;&emsp;	需要 undo log 保证原子性<br>&emsp;&emsp;Force/No-Force:是否要求 commit 之后将所有数据更新落盘<br>&emsp;&emsp;	需要 redo log 保证持久性<br>&emsp;&emsp;￼<br>&emsp;&emsp;2PC: <br>&emsp;&emsp;同步阻塞: 协调者宕机了可能会发生 block<br>&emsp;&emsp;￼<br>&emsp;&emsp;3PC:<br>&emsp;&emsp;引入额外阶段: 超时以后自动提交<br>&emsp;&emsp;￼<br>&emsp;&emsp;spanner 利用共识算法使得 协调者高可用<br>&emsp;&emsp;￼<br>&emsp;&emsp;Percolator 利用共识算法, 将 decision log高可用<br>&emsp;&emsp;Primary Key 和 Secondary Key￼<br>&emsp;&emsp;并发控制: <br>&emsp;&emsp;2PL<br>&emsp;&emsp;OCC:<br>&emsp;&emsp;	三个阶段: 读取, 检查版本号师傅匹配, 进行提交,递增版本? <br>&emsp;&emsp;￼<br>&emsp;&emsp;时间排序:: <br>&emsp;&emsp;存储引擎::<hr><hr>可扩展性<hr>系统今天能可靠运行，并不意味未来也能可靠运行。服务 <font color=#FEAE00>降级（</font><font color=#FEAE00>degradation</font><font color=#FEAE00>）</font><font color=#FEAE00> </font><font color=#FEAE00>的一个常见原因是负载增加</font>，例如：系统负载已经从一万个并发用户增长到十万个并发用户，或者从一百万增长到一千万。也许现在处理的数据量级要比过去大得多。<br>&emsp;&emsp;<font color=#FEAE00>可扩展性（</font><font color=#FEAE00>Scalability</font><font color=#FEAE00>）</font> 是用来描述系统<font color=#FEAE00>应对负载增长能力的术语</font>。但是请注意，这不是贴在系统上的一维标签：说“X可扩展”或“Y不可扩展”是没有任何意义的。相反，讨论可扩展性意味着考虑诸如“如果系统以特定方式增长，有什么选项可以应对增长？”和“如何增加计算资源来处理额外的负载？”等问题。<br>&emsp;&emsp;<font color=#FEAE00>描述负载</font><br>&emsp;&emsp;在讨论增长问题（如果负载加倍会发生什么？）前，首先要能简要描述系统的当前负载。负载可以用一些称为 <font color=#FEAE00>负载参数（</font><font color=#FEAE00>load parameters</font><font color=#FEAE00>）</font><font color=#FEAE00> </font>的数字来描述。参数的最佳选择取决于<font color=#FEAE00>系统架构</font>，它可能是每秒向Web服务器发出的请求、数据库中的<font color=#FEAE00>读写比率</font>、聊天室中同时活跃的用户数量、<font color=#FEAE00>缓存命中率或其他东西</font>。除此之外，也许平均情况对你很重要，也许你的<font color=#FEAE00>瓶颈是少数极端场景。</font><br>&emsp;&emsp;为了使这个概念更加具体，我们以推特在2012年11月发布的数据【16】为例。推特的两个主要业务是：<br>&emsp;&emsp;<font color=#FEAE00>发布推文</font><br>&emsp;&emsp;用户可以向其粉丝发布新消息（平均 4.6k请求/秒，<font color=#FEAE00>峰值超过</font><font color=#FEAE00> 12k</font><font color=#FEAE00>请求</font><font color=#FEAE00>/</font><font color=#FEAE00>秒</font>）。<br>&emsp;&emsp;主页时间线<br>&emsp;&emsp;用户可以查阅他们关注的人发布的推文（300k请求/秒）。<br>&emsp;&emsp;处理每秒12,000次写入（发推文的速率峰值）还是很简单的。然而推特的扩展性挑战并不是主要来自推特量，而是<font color=#FEAE00>来自</font><font color=#FEAE00>扇出（</font><font color=#FEAE00>fan-out</font><font color=#FEAE00>）</font>——每个用户关注了很多人，也被很多人关注。<br>&emsp;&emsp;<font color=#7A7A7A>ii. </font><font color=#7A7A7A>扇出：从电子工程学中借用的术语，它描述了输入连接到另一个门输出的逻辑门数量。</font><font color=#7A7A7A> </font><font color=#7A7A7A>输出需要提供足够的电流来驱动所有连接的输入。</font><font color=#7A7A7A> </font><font color=#7A7A7A>在</font><font color=#FEAE00>事务处理系统中，我们使用它来描述为了服务一个传入请求而需要执行其他服务的请求数量。</font><font color=#5281BF> </font><font color=#5281BF>↩</font><font color=#7A7A7A><br>&emsp;&emsp;</font>大体上讲，这一对操作有两种实现方式。<br>&emsp;&emsp;	1	发布推文时，只需将<font color=#FEAE00>新推文插入全局推文集合即可。</font>当一个用户请求自己的主页时间线时，<font color=#FEAE00>首先查找他关注的所有人，查询这些被关注用户发布的推文并按时间顺序合并</font>。在如<font color=#5281BF>图</font><font color=#5281BF>1-2</font>所示的关系型数据库中，可以编写这样的查询：<br>&emsp;&emsp; <font color=#825BA3>SELECT</font> tweets.*, <font color=#825BA3>users</font>.*<br>&emsp;&emsp;	2	   <font color=#825BA3>FROM</font> tweets<br>&emsp;&emsp;	3	   <font color=#825BA3>JOIN</font> <font color=#825BA3>users</font>   <font color=#825BA3>ON</font> tweets.sender_id = <font color=#825BA3>users</font>.<font color=#825BA3>id</font><br>&emsp;&emsp;	4	   <font color=#825BA3>JOIN</font> <font color=#825BA3>follows</font> <font color=#825BA3>ON</font> <font color=#825BA3>follows</font>.followee_id = <font color=#825BA3>users</font>.<font color=#825BA3>id</font><br>&emsp;&emsp;	5	   <font color=#825BA3>WHERE</font> <font color=#825BA3>follows</font>.follower_id = <font color=#825BA3>current_user</font><br>&emsp;&emsp;	6	<br>&emsp;&emsp;￼<br>&emsp;&emsp;图1-2 推特主页时间线的关系型模式简单实现<br>&emsp;&emsp;	2.	为每个用户的主页时间线<font color=#FEAE00>维护一个缓存</font>，就像每个用户的推文收件箱（<font color=#5281BF>图</font><font color=#5281BF>1-3</font>）。 当一个用户发布推文时，查找所有关注该用户的人，并将新的推文插入到每个主页时间线缓存中。 因此读取<font color=#FEAE00>主页时间线的请求开销很小，</font>因为<font color=#FEAE00>结果已经提前计算好了</font>。<br>&emsp;&emsp;￼<br>&emsp;&emsp;图1-3 用于分发推特至关注者的数据流水线，2012年11月的负载参数【16】<br>&emsp;&emsp;推特的第一个版本使用了方法1，但系统很难跟上主页时间线查询的负载。所以公司转向了方法2，方法2的效果更好，因为<font color=#FEAE00>发推频率比查询主页时间线的频率几乎低了两个数量级</font>，所以在这种情况下，最好在<font color=#FEAE00>写入时做更多的工作，而在读取时做更少的工作</font>。<br>&emsp;&emsp;然而方法2的缺点是，发推现在<font color=#FEAE00>需要大量的额外工作</font>。平均来说，一条推文会发往约75个关注者，所以<font color=#FEAE00>每秒</font><font color=#FEAE00>4.6k</font><font color=#FEAE00>的发推写入</font>，变成了对<font color=#FEAE00>主页时间线缓存每秒</font><font color=#FEAE00>345k</font><font color=#FEAE00>的写入</font>。但这个平均值隐藏了用户粉丝数差异巨大这一现实，一些用户有超过3000万的粉丝，这意味着一条推文就可能会导致主页时间线缓存的3000万次写入！及时完成这种操作是一个巨大的挑战 —— 推特尝试在5秒内向粉丝发送推文。<br>&emsp;&emsp;在推特的例子中，<font color=#FEAE00>每个用户粉丝数的分布（可能按这些用户的发推频率来加权）</font>是探讨可扩展性的一个关键负载参数，因为它决定了扇出负载。你的应用程序可能具有非常不同的特征，但可以采用相似的原则来考虑它的负载。<br>&emsp;&emsp;推特轶事的最终转折：现在已经稳健地实现了方法2，推特逐步转向了两种方法的混合。大多数用户发的推文会被扇出写入其粉丝主页时间线缓存中。但是<font color=#FEAE00>少数拥有海量粉丝的用户（即名流）会被排除在外</font>。当用户读取主页时间线时，分别地获取出该用户所关注的每位名流的推文，再与用户的主页时间线缓存合并，如方法1所示。这种混合方法能始终如一地提供良好性能。在<font color=#5281BF>第</font><font color=#5281BF>12</font><font color=#5281BF>章</font>中我们将重新讨论这个例子，这在覆盖更多技术层面之后。<hr><hr>可维护性<hr>众所周知，软件的大部分开销并不在最初的开发阶段，而是在<font color=#FEAE00>持续的维护阶段，</font>包括修复漏洞、保持系统正常运行、调查失效、适配新的平台、为新的场景进行修改、偿还技术债、添加新的功能等等。<br>&emsp;&emsp;不幸的是，许多从事软件系统行业的人不喜欢维护所谓的<font color=#FEAE00>遗留（</font><font color=#FEAE00>legacy</font><font color=#FEAE00>）</font><font color=#FEAE00>系统</font>，——也许因为涉及修复其他人的错误、和过时的平台打交道，或者系统被迫使用于一些份外工作。每一个遗留系统都以自己的方式让人不爽，所以很难给出一个通用的建议来和它们打交道。<br>&emsp;&emsp;但是我们可以，也应该以这样一种方式来设计软件：在设计之初就尽量考虑尽可能减少维护期间的痛苦，从而避免自己的软件系统变成遗留系统。为此，我们将特别关注软件系统的三个设计原则：<br>&emsp;&emsp;<font color=#FEAE00>可操作性（</font><font color=#FEAE00>Operability</font><font color=#FEAE00>）</font><br>&emsp;&emsp;便于运维团队保持系统平稳运行。<br>&emsp;&emsp;简单性（Simplicity）<br>&emsp;&emsp;从系统中消除尽可能多的复杂度（complexity），使新工程师也能轻松理解系统。（注意这和用户接口的简单性不一样。）<br>&emsp;&emsp;可演化性（evolability）<br>&emsp;&emsp;使工程师在未来能轻松地对系统进行更改，当需求变化时为新应用场景做适配。也称为可扩展性（extensibility），可修改性（modifiability）或可塑性（plasticity）。<br>&emsp;&emsp;和之前提到的可靠性、可扩展性一样，实现这些目标也没有简单的解决方案。不过我们会试着想象具有可操作性，简单性和可演化性的系统会是什么样子。<br>&emsp;&emsp;可操作性：人生苦短，关爱运维<br>&emsp;&emsp;有人认为，“良好的运维经常可以绕开垃圾（或不完整）软件的局限性，而再好的软件摊上垃圾运维也没法可靠运行”。尽管运维的某些方面可以，而且应该是自动化的，但在最初建立正确运作的自动化机制仍然取决于人。<br>&emsp;&emsp;运维团队对于保持软件系统顺利运行至关重要。一个优秀运维团队的典型职责如下（或者更多）【29】：<br>&emsp;&emsp;	•	监控系统的运行状况，并在服务状态不佳时快速恢复服务<br>&emsp;&emsp;	•	跟踪问题的原因，例如系统故障或性能下降<br>&emsp;&emsp;	•	及时更新软件和平台，比如安全补丁<br>&emsp;&emsp;	•	了解系统间的相互作用，以便在异常变更造成损失前进行规避。<br>&emsp;&emsp;	•	预测未来的问题，并在问题出现之前加以解决（例如，容量规划）<br>&emsp;&emsp;	•	建立部署，配置、管理方面的良好实践，编写相应工具<br>&emsp;&emsp;	•	执行复杂的维护任务，例如将应用程序从一个平台迁移到另一个平台<br>&emsp;&emsp;	•	当配置变更时，维持系统的安全性<br>&emsp;&emsp;	•	定义工作流程，使运维操作可预测，并保持生产环境稳定。<br>&emsp;&emsp;	•	铁打的营盘流水的兵，维持组织对系统的了解。<br>&emsp;&emsp;良好的可操作性意味着更轻松的日常工作，进而运维团队能专注于高价值的事情。数据系统可以通过各种方式使日常任务更轻松：<br>&emsp;&emsp;	•	通过良好的监控，提供对系统内部状态和运行时行为的可见性（visibility）<br>&emsp;&emsp;	•	为自动化提供良好支持，将系统与标准化工具相集成<br>&emsp;&emsp;	•	避免依赖单台机器（在整个系统继续不间断运行的情况下允许机器停机维护）<br>&emsp;&emsp;	•	提供良好的文档和易于理解的操作模型（“如果做X，会发生Y”）<br>&emsp;&emsp;	•	提供良好的默认行为，但需要时也允许管理员自由覆盖默认值<br>&emsp;&emsp;	•	有条件时进行自我修复，但需要时也允许管理员手动控制系统状态<br>&emsp;&emsp;	•	行为可预测，最大限度减少意外<br>&emsp;&emsp;简单性：管理复杂度<br>&emsp;&emsp;小型软件项目可以使用简单讨喜的、富表现力的代码，但随着项目越来越大，代码往往变得非常复杂，难以理解。这种复杂度拖慢了所有系统相关人员，进一步增加了维护成本。一个陷入复杂泥潭的软件项目有时被描述为 烂泥潭（a big ball of mud） 【30】。<br>&emsp;&emsp;复杂度（complexity） 有各种可能的症状，例如：状态空间激增、模块间紧密耦合、纠结的依赖关系、不一致的命名和术语、解决性能问题的Hack、需要绕开的特例等等，现在已经有很多关于这个话题的讨论【31,32,33】。<br>&emsp;&emsp;因为复杂度导致维护困难时，预算和时间安排通常会超支。在复杂的软件中进行变更，引入错误的风险也更大：当开发人员难以理解系统时，隐藏的假设、无意的后果和意外的交互就更容易被忽略。相反，降低复杂度能极大地提高软件的可维护性，因此简单性应该是构建系统的一个关键目标。<br>&emsp;&emsp;简化系统并不一定意味着减少功能；它也可以意味着消除额外的（accidental）的复杂度。 Moseley和Marks【32】把 额外复杂度 定义为：由具体实现中涌现，而非（从用户视角看，系统所解决的）问题本身固有的复杂度。<br>&emsp;&emsp;用于消除额外复杂度的最好工具之一是抽象（abstraction）。一个好的抽象可以将大量实现细节隐藏在一个干净，简单易懂的外观下面。一个好的抽象也可以广泛用于各类不同应用。比起重复造很多轮子，重用抽象不仅更有效率，而且有助于开发高质量的软件。抽象组件的质量改进将使所有使用它的应用受益。<br>&emsp;&emsp;例如，高级编程语言是一种抽象，隐藏了机器码、CPU寄存器和系统调用。 SQL也是一种抽象，隐藏了复杂的磁盘/内存数据结构、来自其他客户端的并发请求、崩溃后的不一致性。当然在用高级语言编程时，我们仍然用到了机器码；只不过没有直接（directly）使用罢了，正是因为编程语言的抽象，我们才不必去考虑这些实现细节。<br>&emsp;&emsp;抽象可以帮助我们将系统的复杂度控制在可管理的水平，不过，找到好的抽象是非常困难的。在分布式系统领域虽然有许多好的算法，但我们并不清楚它们应该打包成什么样抽象。<br>&emsp;&emsp;本书将紧盯那些允许我们将大型系统的部分提取为定义明确的、可重用的组件的优秀抽象。<br>&emsp;&emsp;可演化性：拥抱变化<br>&emsp;&emsp;系统的需求永远不变，基本是不可能的。更可能的情况是，它们处于常态的变化中，例如：你了解了新的事实、出现意想不到的应用场景、业务优先级发生变化、用户要求新功能、新平台取代旧平台、法律或监管要求发生变化、系统增长迫使架构变化等。<br>&emsp;&emsp;在组织流程方面， 敏捷（agile） 工作模式为适应变化提供了一个框架。敏捷社区还开发了对在频繁变化的环境中开发软件很有帮助的技术工具和模式，如 测试驱动开发（TDD, test-driven development） 和 重构（refactoring） 。<br>&emsp;&emsp;这些敏捷技术的大部分讨论都集中在相当小的规模（同一个应用中的几个代码文件）。本书将探索在更大数据系统层面上提高敏捷性的方法，可能由几个不同的应用或服务组成。例如，为了将装配主页时间线的方法从方法1变为方法2，你会如何“重构”推特的架构 ？<br>&emsp;&emsp;修改数据系统并使其适应不断变化需求的容易程度，是与简单性和抽象性密切相关的：简单易懂的系统通常比复杂系统更容易修改。但由于这是一个非常重要的概念，我们将用一个不同的词来指代数据系统层面的敏捷性： 可演化性（evolvability） 【34】。<hr><hr>可靠性<hr>人们对于一个<font color=#FEAE00>东西是否可靠</font>，都有一个直观的想法。人们对可靠软件的典型期望包括：<br>&emsp;&emsp;	•	应用程序表现出用户<font color=#FEAE00>所期望的功能</font>。<br>&emsp;&emsp;	•	<font color=#FEAE00>允许用户犯错</font>，允许用户以出乎意料的方式使用软件。<br>&emsp;&emsp;	•	在预期的负载和数据量下，<font color=#FEAE00>性能满足要</font>求。<br>&emsp;&emsp;	•	系统能防止未经授权的访问和滥用。<br>&emsp;&emsp;如果所有这些在一起意味着“正确工作”，那么可以把可靠性粗略理解为“即使出现问题，也能继续正确工作”。<br>&emsp;&emsp;造成错误的原因叫做<font color=#FEAE00>故障（</font><font color=#FEAE00>fault</font><font color=#FEAE00>）</font>，能预料并应对故障的系统特性可称为<font color=#FEAE00>容错（</font><font color=#FEAE00>fault-tolerant</font><font color=#FEAE00>）</font><font color=#FEAE00>或</font><font color=#FEAE00>韧性（</font><font color=#FEAE00>resilient</font><font color=#FEAE00>）</font>。“容错”一词可能会产生误导，因为它暗示着系统可以容忍所有可能的错误，但在实际中这是不可能的。比方说，如果整个地球（及其上的所有服务器）都被黑洞吞噬了，想要容忍这种错误，需要把网络托管到太空中——这种预算能不能批准就祝你好运了。所以在讨论容错时，只有谈论特定类型的错误才有意义。<br>&emsp;&emsp;注意<font color=#FEAE00>故障（</font><font color=#FEAE00>fault</font><font color=#FEAE00>）</font><font color=#FEAE00>不同于</font><font color=#FEAE00>失效（</font><font color=#FEAE00>failure</font><font color=#FEAE00>）</font>【2】。故障通常定义为系统的一部分状态偏离其标准，而失效则是系统作为一个整体停止向用户提供服务。故障的概率不可能降到零，因此最好设计容错机制以防因故障而导致失效。本书中我们将介绍几种用不可靠的部件构建可靠系统的技术。<br>&emsp;&emsp;反直觉的是，在这类容错系统中，通过<font color=#FEAE00>故意触发来</font><font color=#FEAE00>提高</font><font color=#FEAE00>故障率是有意义</font>的，例如：在没有警告的情况下随机地杀死单个进程。许多高危漏洞实际上是由糟糕的错误处理导致的【3】，因此我们可以通过<font color=#FEAE00>故意引发故障来确保容错机制不断运行并接受考验</font>，从而提高故障自然发生时系统能正确处理的信心。Netflix公司的Chaos Monkey【4】就是这种方法的一个例子。<br>&emsp;&emsp;尽管比起<font color=#FEAE00>阻止错误（</font><font color=#FEAE00>prevent error</font><font color=#FEAE00>）</font><font color=#FEAE00>，我们通常更倾向于</font><font color=#FEAE00>容忍错误</font>。但也有预防胜于治疗的情况（比如不存在治疗方法时）。安全问题就属于这种情况。例如，如果攻击者破坏了系统，并获取了敏感数据，这种事是撤销不了的。但本书主要讨论的是可以恢复的故障种类，正如下面几节所述。<br>&emsp;&emsp;硬件故障<br>&emsp;&emsp;当想到系统失效的原因时，<font color=#FEAE00>硬件故障（</font><font color=#FEAE00>hardware faults</font><font color=#FEAE00>）</font>总会第一个进入脑海。硬盘崩溃、内存出错、机房断电、有人拔错网线……任何与大型数据中心打过交道的人都会告诉你：一旦你拥有很多机器，这些事情总会发生！<br>&emsp;&emsp;据报道称，硬盘的 <font color=#FEAE00>平均无故障时间（</font><font color=#FEAE00>MTTF mean time to failure</font><font color=#FEAE00>）</font><font color=#FEAE00> </font><font color=#FEAE00>约为</font><font color=#FEAE00>10</font><font color=#FEAE00>到</font><font color=#FEAE00>50</font><font color=#FEAE00>年</font>【5】【6】。因此从数学期望上讲，<font color=#FEAE00>在拥有</font><font color=#FEAE00>10000</font><font color=#FEAE00>个磁盘的存储集群上，平均每天会有</font><font color=#FEAE00>1</font><font color=#FEAE00>个磁盘出故障。</font><br>&emsp;&emsp;为了减少系统的故障率，第一反应通常都是<font color=#FEAE00>增加单个硬件的冗余度，</font>例如：磁盘可以组建RAID，服务器可能有双路电源和热插拔CPU，数据中心可能有电池和柴油发电机作为后备电源，某个组件挂掉时冗余组件可以立刻接管。这种方法虽然不能完全防止由硬件问题导致的系统失效，但它简单易懂，通常也足以让机器不间断运行很多年。<br>&emsp;&emsp;直到最近，硬件冗余对于大多数应用来说已经足够了，它使单台机器完全失效变得相当罕见。只要你能快速地把备份恢复到新机器上，故障停机时间对大多数应用而言都算不上灾难性的。只有少量高可用性至关重要的应用才会要求有多套硬件冗余。<br>&emsp;&emsp;但是随着数据量和应用计算需求的增加，越来越多的应用开始大量使用机器，这会相应地增加硬件故障率。此外在一些<font color=#FEAE00>云平台（</font><font color=#FEAE00>如亚马逊网络服务（</font><font color=#FEAE00>AWS, Amazon Web Services</font><font color=#FEAE00>）</font><font color=#FEAE00>）</font>中，虚拟机实例不可用却没有任何警告也是很常见的【7】，因为云平台的设计就是优先考虑<font color=#FEAE00>灵活性（</font><font color=#FEAE00>flexibility</font><font color=#FEAE00>）</font><font color=#FEAE00>和</font><font color=#FEAE00>弹性（</font><font color=#FEAE00>elasticity</font><font color=#FEAE00>）</font><font color=#5281BF>i</font>，<font color=#FEAE00>而不是单机可靠性。</font><br>&emsp;&emsp;如果在硬件冗余的基础上进一步<font color=#FEAE00>引入软件容错机制</font>，那么系统在容忍整个（单台）机器故障的道路上就更进一步了。这样的系统也有运维上的便利，例如：如果需要重启机器（例如应用操作系统安全补丁），单服务器系统就需要计划停机。而允许机器失效的系统则可以一次修复一个节点，无需整个系统停机。<br>&emsp;&emsp;<font color=#7A7A7A>i. </font><font color=#7A7A7A>在</font><font color=#5281BF>应对负载的方法</font><font color=#7A7A7A>一节定义</font><font color=#5281BF> </font><font color=#5281BF>↩</font><font color=#7A7A7A><br>&emsp;&emsp;</font>软件错误<br>&emsp;&emsp;我们通常认为硬件故障是随机的、相互独立的：一台机器的磁盘失效并不意味着另一台机器的磁盘也会失效。<font color=#FEAE00>大量硬件组件不可能同时发生故障</font>，除非它们存在比较弱的相关性（同样的原因导致关联性错误，例如服务器机架的温度）。<br>&emsp;&emsp;另一类错误是内部的<font color=#FEAE00>系统性错误（</font><font color=#FEAE00>systematic error</font><font color=#FEAE00>）</font>【7】。这类错误难以预料，而且因为是跨节点相关的，所以比起不相关的硬件故障往往可能造成更多的<font color=#FEAE00>系统失效</font><font color=#FEAE00>【</font><font color=#FEAE00>5</font><font color=#FEAE00>】</font>。例子包括：<br>&emsp;&emsp;	•	接受特定的错误输入，便导致所有应用服务器实例崩溃的BUG。例如2012年6月30日的闰秒，由于Linux内核中的一个错误，许多应用同时挂掉了。<br>&emsp;&emsp;	•	失控进程会占用一些共享资源，包括CPU时间、内存、磁盘空间或网络带宽。<br>&emsp;&emsp;	•	系统依赖的服务变慢，没有响应，或者开始返回错误的响应。<br>&emsp;&emsp;	•	级联故障，一个组件中的小故障触发另一个组件中的故障，进而触发更多的故障【10】。<br>&emsp;&emsp;导致这类软件故障的BUG通常会潜伏很长时间，直到被异常情况触发为止。这种情况意味着软件对其环境做出了某种假设——虽然这种假设通常来说是正确的，但由于某种原因最后不再成立了【11】。<br>&emsp;&emsp;虽然软件中的系统性故障没有速效药，但我们还是有很多小办法，例如：仔细考虑系统中的假设和交互；彻底的测试；进程隔离；允许进程崩溃并重启；测量、监控并分析生产环境中的系统行为。如果系统能够提供一些保证（例如在一个消息队列中，进入与发出的消息数量相等），那么系统就可以在运行时不断自检，并在出现<font color=#FEAE00>差异（</font><font color=#FEAE00>discrepancy</font><font color=#FEAE00>）</font>时报警【12】。<br>&emsp;&emsp;<font color=#FEAE00>人为错误</font><br>&emsp;&emsp;设计并构建了软件系统的工程师是人类，维持系统运行的运维也是人类。即使他们怀有最大的善意，人类也是不可靠的。举个例子，一项关于大型互联网服务的研究发现，运维配置错误是导致服务中断的首要原因，而硬件故障（服务器或网络）仅导致了10-25％的服务中断【13】。<br>&emsp;&emsp;尽管人类不可靠，但怎么做才能让系统变得可靠？最好的系统会组合使用以下几种办法：<br>&emsp;&emsp;	•	以最小化犯错机会的方式设计系统。例如，精心设计的抽象、API和管理后台使做对事情更容易，搞砸事情更困难。但如果接口限制太多，人们就会忽略它们的好处而想办法绕开。很难正确把握这种微妙的平衡。<br>&emsp;&emsp;	•	将人们最容易犯错的地方与可能导致失效的地方<font color=#FEAE00>解耦（</font><font color=#FEAE00>decouple</font><font color=#FEAE00>）</font>。特别是提供一个功能齐全的非生产环境<font color=#FEAE00>沙箱（</font><font color=#FEAE00>sandbox</font><font color=#FEAE00>）</font>，使人们可以在不影响真实用户的情况下，使用真实数据安全地探索和实验。<br>&emsp;&emsp;	•	在各个层次进行彻底的测试【3】，从单元测试、全系统集成测试到手动测试。<font color=#FEAE00>自动化测试易于理解</font>，已经被广泛使用，特别适合用来覆盖正常情况中少见的<font color=#FEAE00>边缘场景（</font><font color=#FEAE00>corner case</font><font color=#FEAE00>）</font><font color=#FEAE00>。</font><br>&emsp;&emsp;	•	允许从<font color=#FEAE00>人为错误中简单快速地恢复</font>，以最大限度地减少失效情况带来的影响。 例如，快速回滚配置变更，分批发布新代码（以便任何意外错误只影响一小部分用户），并提供数据重算工具（以备旧的计算出错）。<br>&emsp;&emsp;	•	配置详细和明确的监控，比如性能指标和错误率。 在其他工程学科中这指的是<font color=#FEAE00>遥测（</font><font color=#FEAE00>telemetry</font><font color=#FEAE00>）</font>。 （一旦火箭离开了地面，遥测技术对于跟踪发生的事情和理解失败是至关重要的。）<font color=#FEAE00>监控可以向我们发出预警信号</font>，并允许我们检查是否有任何地方违反了假设和约束。当出现问题时，指标数据对于问题诊断是非常宝贵的。<br>&emsp;&emsp;	•	良好的管理实践与充分的培训——一个复杂而重要的方面，但超出了本书的范围。<hr><hr>哪种 count<font color=#FEAE00> </font><font color=#FEAE00>性能最好？</font><br>&emsp;&emsp;count(*) 和 count(1) <hr># 哪种 count 性能最好？<br>&emsp;&emsp;我先直接说结论：<br>&emsp;&emsp;￼<br>&emsp;&emsp;要弄明白这个，我们得要深入 count 的原理，以下内容基于常用的 innodb 存储引擎来说明。<br>&emsp;&emsp;# count() 是什么？<br>&emsp;&emsp;count() 是一个<font color=#FEAE00>聚合函数</font>，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是<font color=#FEAE00>统计符合查询条件的记录中，函数指定的参数不为</font><font color=#FEAE00> NULL </font><font color=#FEAE00>的记录有多少个</font>。<br>&emsp;&emsp;假设 count() 函数的参数是<font color=#FEAE00>字段名</font>，如下：<br>&emsp;&emsp;<font color=#5E3563>select</font> <font color=#AA5925>count</font>(name) <font color=#5E3563>from</font> t_order;<br>&emsp;&emsp;这条语句是统计「 t_order 表中，name 字段不为 NULL 的记录」有多少个。也就是说，如果某一条记录中的 name 字段的值为 NULL，则就不会被统计进去。<br>&emsp;&emsp;再来假设 count() 函数的参数是数字 1 这个表达式，如下：<br>&emsp;&emsp;<font color=#5E3563>select</font> <font color=#AA5925>count</font>(<font color=#AA5925>1</font>) <font color=#5E3563>from</font> t_order;<br>&emsp;&emsp;这条语句是统计「 <font color=#FEAE00>t_order </font><font color=#FEAE00>表中，</font><font color=#FEAE00>1 </font><font color=#FEAE00>这个表达式不为</font><font color=#FEAE00> NULL </font><font color=#FEAE00>的记录</font>」有多少个。<br>&emsp;&emsp;1 这个表达式就是单纯数字，它永远都不是 NULL，所以上面这条语句，其实是在<font color=#FEAE00>统计</font><font color=#FEAE00> t_order </font><font color=#FEAE00>表中有多少个记录。</font><br>&emsp;&emsp;# count(<font color=#FEAE00>主键字段</font>) 执行过程是怎样的？<br>&emsp;&emsp;在通过 count 函数统计有多少个记录时，MySQL 的 server 层会<font color=#FEAE00>维护一个名叫</font><font color=#FEAE00> count </font><font color=#FEAE00>的变量</font>。<br>&emsp;&emsp;server 层会循环向 InnoDB 读取一条记录，如果 count 函数指定的参数不为 NULL，那么就会将变量 count 加 1，直到符合查询的全部记录被读完，就退出循环。最后将 count 变量的值发送给客户端。<br>&emsp;&emsp;InnoDB 是通过 B+ 树来保持记录的，根据索引的类型又分为聚簇索引和二级索引，它们区别在于，聚簇索引的叶子节点存放的是实际数据，而二级索引的叶子节点存放的是主键值，而不是实际数据。<br>&emsp;&emsp;用下面这条语句作为例子：<br>&emsp;&emsp;<font color=#666666>//id </font><font color=#666666>为主键值</font><br>&emsp;&emsp;<font color=#5E3563>select</font> <font color=#AA5925>count</font>(id) <font color=#5E3563>from</font> t_order;<br>&emsp;&emsp;如果表里只有<font color=#FEAE00>主键索引</font>，没有二级索引时，那么，InnoDB 循环遍历聚簇索引，将读取到的记录返回给 server 层，然后读取记录中的 id 值，就会 id 值判断是否为 NULL，如果不为 NULL，就将 count 变量加 1。<br>&emsp;&emsp;￼<br>&emsp;&emsp;但是，如果表里有<font color=#FEAE00>二级索引时</font>，InnoDB 循环遍历的对象就不是聚簇索引，而是二级索引。<br>&emsp;&emsp;￼<br>&emsp;&emsp;这是因为<font color=#FEAE00>相同数量的二级索引记录可以比聚簇索引记录占用更少的存储空间</font>，所以二级索引树比聚簇索引树小，这样遍历二级索引的 I/O 成本比遍历聚簇索引的 I/O 成本小，因此「优化器」优先选择的是二级索引。<br>&emsp;&emsp;# <font color=#FEAE00>count(1) </font>执行过程是怎样的？<br>&emsp;&emsp;用下面这条语句作为例子：<br>&emsp;&emsp;select count(1) from t_order;<br>&emsp;&emsp;如果表里<font color=#FEAE00>只有主键索引</font>，没有二级索引时。<br>&emsp;&emsp;￼<br>&emsp;&emsp;那么，InnoDB 循环遍历聚簇索引（主键索引），将读取到的记录返回给 server 层，<font color=#FEAE00>但是不会读取记录中的任何字段的值</font>，因为 count 函数的参数是 1，不是字段，所以<font color=#FEAE00>不需要读取记录中的字段值。</font>参数 1 很明显并不是 NULL，因此 server 层每从 InnoDB 读取到一条记录，就将 count 变量加 1。<br>&emsp;&emsp;	可以看到，<font color=#FEAE00>count(1) </font><font color=#FEAE00>相比</font><font color=#FEAE00> count(</font><font color=#FEAE00>主键字段</font><font color=#FEAE00>) </font><font color=#FEAE00>少一个步骤</font>，就是不需要读取记录中的字段值，所以通常会说 count(1) 执行效率会比 count(主键字段) 高一点。<br>&emsp;&emsp;但是，如果表里有二级索引时，InnoDB 循环遍历的对象就二级索引了。<br>&emsp;&emsp;￼<br>&emsp;&emsp;# count(*) 执行过程是怎样的？<br>&emsp;&emsp;看到 <font color=#4D647F>*</font> 这个字符的时候，是不是大家觉得是读取记录中的所有字段值？<br>&emsp;&emsp;对于 <font color=#4D647F>selete *</font> 这条语句来说是这个意思，但是在 count(*) 中并不是这个意思。<br>&emsp;&emsp;<font color=#FEAE00>count(\*) </font><font color=#FEAE00>其实等于</font><font color=#FEAE00> count(0)</font>，也就是说，当你使用 count(<font color=#4D647F>*</font>) 时，MySQL 会将 <font color=#FEAE00>* </font><font color=#FEAE00>参数转化为参数</font><font color=#FEAE00> 0</font> 来处理。<br>&emsp;&emsp;￼<br>&emsp;&emsp;所以，<font color=#FEAE00>count(*) </font><font color=#FEAE00>执行过程跟</font><font color=#FEAE00> count(1) </font><font color=#FEAE00>执行过程基本一样的</font>，性能没有什么差异。<br>&emsp;&emsp;在 MySQL 5.7 的官方手册中有这么一句话：<br>&emsp;&emsp;<font color=#7414AF>InnoDB handles SELECT COUNT(</font><font color=#4D647F>\*</font><font color=#7414AF>) and SELECT COUNT(</font><font color=#4D647F>1</font><font color=#7414AF>) operations in the same way. There is no performance difference.</font><br>&emsp;&emsp;<font color=#7414AF>翻译：</font><font color=#7414AF>InnoDB</font><font color=#7414AF>以相同的方式处理</font><font color=#7414AF>SELECT COUNT</font><font color=#7414AF>（</font><font color=#4D647F>\*</font><font color=#7414AF>）和</font><font color=#7414AF>SELECT COUNT</font><font color=#7414AF>（</font><font color=#4D647F>1</font><font color=#7414AF>）操作，没有性能差异。</font><br>&emsp;&emsp;而且 MySQL 会对 count(*) 和 count(1) 有个优化，如果有多个二级索引的时候，优化器会使用<font color=#FEAE00>key_len </font><font color=#FEAE00>最小的二级索引进行扫描。</font><br>&emsp;&emsp;只有当没有二级索引的时候，才会采用主键索引来进行统计。<br>&emsp;&emsp;# count(字段) 执行过程是怎样的？<br>&emsp;&emsp;count(字段) 的执行效率相比前面的 count(1)、 count(*)、 count(主键字段) 执行效率是最差的。<br>&emsp;&emsp;用下面这条语句作为例子：<br>&emsp;&emsp;<font color=#666666>// name</font><font color=#666666>不是索引，普通字段</font><br>&emsp;&emsp;<font color=#5E3563>select</font> <font color=#AA5925>count</font>(name) <font color=#5E3563>from</font> t_order;<br>&emsp;&emsp;对于这个查询来说，<font color=#FEAE00>会采用全表扫描的方式来计数，</font>所以它的执行效率是比较差的。<br>&emsp;&emsp;￼<br>&emsp;&emsp;小结<br>&emsp;&emsp;count(1)、 count(*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就<font color=#FEAE00>会选择二级索引进行扫描。</font><br>&emsp;&emsp;所以，如果要执行 count(1)、 count(*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。<br>&emsp;&emsp;再来，就是<font color=#FEAE00>不要使用</font><font color=#FEAE00> count(</font><font color=#FEAE00>字段</font><font color=#FEAE00>) </font><font color=#FEAE00>来统计记录个数</font>，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你<font color=#FEAE00>非要统计表中该字段不为</font><font color=#FEAE00> NULL </font><font color=#FEAE00>的记录个数，建议给这个字段建立一个二级索引。</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>唯一索引<font color=#FEAE00>等值</font>查询<hr>当我们用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：<br>&emsp;&emsp;<font color=#FEAE00>	•	</font><font color=#FEAE00>当查询的记录是</font><font color=#00AB8E>存在的</font><font color=#FEAE00>，在用「唯一索引进行等值查询」时，</font><font color=#FEAE00>next-key lock </font><font color=#FEAE00>会退化成「记录锁」</font><font color=#FEAE00>。</font><font color=#FEAE00><br>&emsp;&emsp;</font><font color=#FEAE00>	•	</font><font color=#FEAE00>当查询的记录是</font><font color=#00AB8E>不存在的</font><font color=#FEAE00>，在用「唯一索引进行等值查询」时，</font><font color=#FEAE00>next-key lock </font><font color=#FEAE00>会退化成「间隙锁」</font><font color=#FEAE00>。</font><br>&emsp;&emsp;接下里用两个案例来说明。<br>&emsp;&emsp;先看看记录是存在的。<br>&emsp;&emsp;来看下面这个例子：<br>&emsp;&emsp;￼<br>&emsp;&emsp;会话1加锁变化过程如下：<br>&emsp;&emsp;	1	加锁的基本单位是 next-key lock，因此会话1的加锁范围是(8, 16];<br>&emsp;&emsp;	2	但是由于是用唯一索引进行等值查询，且查询的记录存在，所以 <font color=#374EF4>next-key lock </font><font color=#374EF4>退化成记录锁，因此最终加锁的范围是</font><font color=#374EF4> id = 16 </font><font color=#374EF4>这一行</font>。<br>&emsp;&emsp;所以，会话 2 在修改 id=16 的记录时会被锁住，而会话 3 插入 id=9 的记录可以被正常执行。<br>&emsp;&emsp;接下来，看看记录不存在的情况<br>&emsp;&emsp;来看看，下面这个例子：<br>&emsp;&emsp;￼<br>&emsp;&emsp;会话1加锁变化过程如下：<br>&emsp;&emsp;	1	加锁的基本单位是 next-key lock，因此主键索引 id 的加锁范围是(8, 16];<br>&emsp;&emsp;	2	但是由于查询记录不存在，next-key lock 退化成间隙锁，因此最终加锁的范围是 (8,16)。<br>&emsp;&emsp;所以，会话 2 要往这个间隙里面插入 id=9 的记录会被锁住，但是会话 3 修改 id =16 是可以正常执行的，因为 id = 16 这条记录并没有加锁。<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>如何优化<font color=#FEAE00> count(*)</font><font color=#FEAE00>？</font><hr>	如果对一张大表经常用 count(*) 来做统计，其实是很不好的。<br>&emsp;&emsp;比如下面我这个案例，表 t_order 共有 1200+ 万条记录，我也创建了二级索引，但是执行一次 <font color=#4D647F>select count(*) from t_order</font> 要花费差不多 5 秒！<br>&emsp;&emsp;￼<br>&emsp;&emsp;面对大表的记录统计，我们有没有什么其他更好的办法呢？<br>&emsp;&emsp;第一种，<font color=#FEAE00>近似值</font><br>&emsp;&emsp;如果你的业务对于统计个数不需要很精确，比如搜索引擎在搜索关键词的时候，给出的搜索结果条数是一个大概值。<br>&emsp;&emsp;￼<br>&emsp;&emsp;这时，我们就可以使用<font color=#FEAE00> show table status </font><font color=#FEAE00>或者</font><font color=#FEAE00> explain </font><font color=#FEAE00>命令来表进行估算</font>。<br>&emsp;&emsp;执行 explain 命令效率是很高的，因为它并不会真正的去查询，下图中的 rows 字段值就是<font color=#FEAE00> explain </font><font color=#FEAE00>命令对表</font><font color=#FEAE00> t_order </font><font color=#FEAE00>记录的估算值。</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;第二种，<font color=#FEAE00>额外表保存计数值</font><br>&emsp;&emsp;如果是想精确的获取表的记录总数，我们可以将这个计数值<font color=#FEAE00>保存到单独的一张计数表中。</font><br>&emsp;&emsp;当我们在数据表插入一条记录的同时，将计数表中的计数字段 + 1。也就是说，在新增和删除操作时，我们需要<font color=#FEAE00>额外维护这个计数表。</font><hr><hr>对索引使用函数<hr>有时候我们会用一些 MySQL <font color=#FEAE00>自带的函数</font>来得到我们想要的结果，这时候要注意了，如果查询条件中对<font color=#FEAE00>索引字段使用函数，就会导致索引失效。</font><br>&emsp;&emsp;比如下面这条语句查询条件中对 name 字段使用了 <font color=#FEAE00>LENGTH </font><font color=#FEAE00>函数</font>，执行计划中的 type=ALL，代表了全表扫描：<br>&emsp;&emsp;// name 为二级索引<br>&emsp;&emsp;select * from t_user where length(name)=6;<br>&emsp;&emsp;￼<br>&emsp;&emsp;为什么对索引使用函数，就无法走索引了呢？<br>&emsp;&emsp;因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。<br>&emsp;&emsp;不过，从 MySQL 8.0 开始，<font color=#FEAE00>索引特性增加了函数索引</font>，即可以针对函数计算后的值建立一个索引，也就是说<font color=#FEAE00>该索引的值是函数计算后的值</font>，所以就可以通过扫描索引来查询数据。<br>&emsp;&emsp;举个例子，我通过下面这条语句，对 length(name) 的计算结果建立一个名为 idx_name_length 的索引。<br>&emsp;&emsp;<font color=#FEAE00>alter</font> table t_user <font color=#EA35BB>add key idx_name_length ((length(name)));</font><br>&emsp;&emsp;然后我再用下面这条查询语句，这时候就会走索引了。<br>&emsp;&emsp;￼<hr><hr>对索引使用<font color=#FEAE00>左或者左右模糊</font>匹配<hr>当我们使用<font color=#FEAE00>左或者左右模糊匹配</font>的时候，也就是 <font color=#4D647F>like %xx</font> 或者 <font color=#4D647F>like %xx%</font> 这两种方式都会造成<font color=#FEAE00>索引失效。</font><br>&emsp;&emsp;比如下面的 like 语句，查询 name 后缀为「林」的用户，执行计划中的 <font color=#FEAE00>type=ALL </font><font color=#FEAE00>就代表了全表扫描</font>，而没有走索引。<br>&emsp;&emsp;// name 字段为二级索引<br>&emsp;&emsp;select * from t_user where name like '%林';<br>&emsp;&emsp;￼<br>&emsp;&emsp;如果是查询 name 前缀为林的用户，那么就会走索引扫描，执行计划中的 <font color=#FEAE00>type=range</font> 表示走<font color=#FEAE00>索引扫描</font>，key=index_name 看到实际走了 index_name 索引：<br>&emsp;&emsp;// name 字段为二级索引<br>&emsp;&emsp;select * from t_user where name like '林%';<br>&emsp;&emsp;￼<br>&emsp;&emsp;为什么 like 关键字左或者左右模糊匹配无法走索引呢？<br>&emsp;&emsp;<font color=#FEAE00>因为索引</font><font color=#FEAE00> B+ </font><font color=#FEAE00>树是按照「</font><font color=#00AB8E>索引值</font><font color=#FEAE00>」有序排列存储的，只能根据前缀进行比较。</font><br>&emsp;&emsp;举个例子，下面这张二级索引图，是以 name 字段有序排列存储的。<br>&emsp;&emsp;￼<br>&emsp;&emsp;假设我们要查询 name 字段前缀为「林」的数据，也就是 <font color=#4D647F>name like '</font><font color=#4D647F>林</font><font color=#4D647F>%'</font>，扫描索引的过程：<br>&emsp;&emsp;	•	<font color=#FEAE00>首节点查询比较</font>：林这个字的拼音大小比首节点的第一个索引值中的陈字大，但是比首节点的第二个索引值中的周字小，所以选择去节点2继续查询；<br>&emsp;&emsp;	•	节点 2 查询比较：节点2的第一个索引值中的陈字的拼音大小比林字小，所以继续看下一个索引值，发现节点2有与林字前缀匹配的索引值，于是就往叶子节点查询，即叶子节点4；<br>&emsp;&emsp;	•	节点 4 查询比较：节点4的第一个索引值的前缀符合林字，于是就读取该行数据，接着继续往右匹配，直到匹配不到前缀为林的索引值。<br>&emsp;&emsp;如果使用 <font color=#4D647F>name like '%</font><font color=#4D647F>林</font><font color=#4D647F>'</font> 方式来查询，因为查询的结果可能是「陈林、张林、周林」等之类的，所以不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。<br>&emsp;&emsp;想要更详细了解 InnoDB 的 B+ 树查询过程，可以看我写的这篇：<font color=#FEAE00>B+ </font><font color=#FEAE00>树里的节点里存放的是什么呢？查询数据的过程又是怎样的？</font><hr><hr>对索引进行<font color=#FEAE00>表达式计算</font><hr>在查询条件中对索引<font color=#FEAE00>进行表达式计算</font>，也是无法走索引的。<br>&emsp;&emsp;比如，下面这条查询语句，执行计划中 type = ALL，说明是通过全表扫描的方式查询数据的：<br>&emsp;&emsp;explain select * from t_user where id + 1 = 10;<br>&emsp;&emsp;￼<br>&emsp;&emsp;但是，如果把查询语句的条件改成 where id = 10 - 1，这样就不是在索引字段进行表达式计算了，于是就可以走索引查询了。<br>&emsp;&emsp;￼<br>&emsp;&emsp;为什么对索引进行表达式计算，就无法走索引了呢？<br>&emsp;&emsp;原因跟对索引使用函数差不多。<br>&emsp;&emsp;因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。<br>&emsp;&emsp;有的同学可能会说，这种对索引进行简单的表达式计算，在代码特殊处理下，应该是可以做到索引扫描的，比方将 id + 1 = 10 变成 id = 10 - 1。<br>&emsp;&emsp;是的，<font color=#FEAE00>是能够实现，但是</font><font color=#FEAE00> MySQL </font><font color=#FEAE00>还是偷了这个懒，没有实现。</font><br>&emsp;&emsp;我的想法是，可能也是因为，表达式计算的情况多种多样，每种都要考虑的话，代码可能会很臃肿，所以干脆将这种索引失效的场景告诉程序员，<font color=#FEAE00>让程序员自己保证在查询条件中不要对索引进行表达式计算。</font><hr><hr>对索引<font color=#FEAE00>隐式类型转换</font><hr>	如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。<br>&emsp;&emsp;	我在原本的 t_user 表增加了 phone 字段，是二级索引且类型是 varchar。<br>&emsp;&emsp;￼<br>&emsp;&emsp;	然后我在条件查询中，用整型作为输入参数，此时执行计划中 type = ALL，所以是通过<font color=#FEAE00>全表扫描来查询数据的</font>。<br>&emsp;&emsp;select * from t_user where phone = 1300000001;<br>&emsp;&emsp;￼<br>&emsp;&emsp;但是如果<font color=#FEAE00>索引字段是整型类型</font>，查询条件中的输入参数即使字符串，是不会导致索引失效，还是可以走索引扫描。<br>&emsp;&emsp;我们再看第二个例子，id 是整型，但是下面这条语句还是走了索引扫描的。<br>&emsp;&emsp; explain select * from t_user where id = '1';<br>&emsp;&emsp;￼<br>&emsp;&emsp;	为什么第一个例子会导致索引失效，而第二例子不会呢？<br>&emsp;&emsp;	要明白这个原因，首先我们要知道 MySQL 的数据类型转换规则是什么？就是看 <font color=#FEAE00>MySQL </font><font color=#FEAE00>是会将字符串转成数字处理</font>，还是将数字转换成字符串处理。<br>&emsp;&emsp;	我在看《mysql45讲的时候》看到一个简单的测试方式，就是通过 select “10” > 9 的结果来知道MySQL 的数据类型转换规则是什么：<br>&emsp;&emsp;	•	如果规则是 MySQL 会将<font color=#FEAE00>自动「字符串」转换成「数字」</font>，就相当于 select 10 > 9，这个就是数字比较，所以结果应该是 1；<br>&emsp;&emsp;	•	如果规则是 MySQL 会将自动「数字」转换成「字符串」，就相当于 select "10" > "9"，这个是字符串比较，字符串比较大小是逐位从高位到低位逐个比较（按ascii码） ，那么"10"字符串相当于 “1”和“0”字符的组合，所以先是拿 “1” 字符和 “9” 字符比较，因为 “1” 字符比 “9” 字符小，所以结果应该是 0。<br>&emsp;&emsp;在 MySQL 中，执行的结果如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;	上面的结果为 1，说明 <font color=#FEAE00>MySQL </font><font color=#FEAE00>在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</font><font color=#FEAE00>。</font><br>&emsp;&emsp;前面的例子一中的查询语句，我也跟大家说了是会走全表扫描：<br>&emsp;&emsp;//例子一的查询语句<br>&emsp;&emsp;select * from t_user where phone = 1300000001;<br>&emsp;&emsp;这是因为 phone 字段为字符串，所以 MySQL 要会自动把字符串转为数字，所以这条语句相当于：<br>&emsp;&emsp;select * from t_user where <font color=#EA36D5>CAST(phone AS signed int) = 1300000001;</font><br>&emsp;&emsp;可以看到，<font color=#FEAE00>CAST </font><font color=#FEAE00>函数是作用在了</font><font color=#FEAE00> phone </font><font color=#FEAE00>字段，而</font><font color=#FEAE00> phone </font><font color=#FEAE00>字段是索引，也就是对索引使用了函数！而前面我们也说了，对索引使用函数是会导致索引失效的</font><font color=#FEAE00>。</font><br>&emsp;&emsp;例子二中的查询语句，我跟大家说了是会走索引扫描：<br>&emsp;&emsp;//例子二的查询语句<br>&emsp;&emsp;select * from t_user where id = "1";<br>&emsp;&emsp;这时因为字符串部分是输入参数，也就需要将字符串转为数字，所以这条语句相当于：<br>&emsp;&emsp;select * from t_user where id = CAST("1" AS signed int);<br>&emsp;&emsp;可以看到，索引字段并没有用任何函数，CAST 函数是用在了输入参数，因此是可以走索引扫描的。<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>布隆过滤器的作用?<hr><hr>常用的redis 命令<hr><hr>怎样的索引的数据结构是好的？<hr>	MySQL 的数据是<font color=#FEAE00>持久化的</font>，意味着数据（索引+记录）是保存到磁盘上的，因为这样即使设备断电了，数据也不会丢失。<br>&emsp;&emsp;<font color=#FEAE00>磁盘</font>是一个慢的离谱的存储设备，有多离谱呢？<br>&emsp;&emsp;	人家内存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的，也就是说读取同样大小的数据，磁盘中读取的速度比从内存中读取的速度要<font color=#FEAE00>慢上万倍，甚至几十万倍</font>。<br>&emsp;&emsp;	磁盘读写的最小单位是<font color=#FEAE00>扇区</font>，扇区的大小只有 <font color=#4D647F>512B</font> 大小，操作系统一次会读写多个扇区，所以<font color=#FEAE00>操作系统的最小读写单位是块（</font><font color=#FEAE00>Block</font><font color=#FEAE00>）。</font><font color=#FEAE00>Linux </font><font color=#FEAE00>中的块大小为</font><font color=#374EF4> </font><font color=#4D647F>4KB</font>，也就是一次磁盘 I/O 操作会直接读写 8 个扇区。<br>&emsp;&emsp;	由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生<font color=#FEAE00>多次磁盘</font><font color=#FEAE00> I/O</font>，而磁盘 I/O 次数越多，所消耗的时间也就越大。<br>&emsp;&emsp;	所以，我们希望索引的数据结构能在<font color=#FEAE00>尽可能少的磁盘的</font><font color=#FEAE00> I/O </font><font color=#FEAE00>操作</font>中完成查询工作，因为磁盘 I/O 操作越少，所消耗的时间也就越小。<br>&emsp;&emsp;	另外，MySQL 是支持<font color=#FEAE00>范围查找的</font>，所以索引的数据结构不仅要能高效地查询某一个记录，而且也要能高效地执行范围查找。<br>&emsp;&emsp;所以，要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：<br>&emsp;&emsp;	•	能在尽可能少的磁盘的 I/O 操作中完成查询工作；<br>&emsp;&emsp;	•	要能高效地查询某一个记录，也要能高效地执行范围查找；<br>&emsp;&emsp;分析完要求后，我们针对每一个数据结构分析一下。<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>总结: 本章小结<hr>本章探讨了一些关于数据密集型应用的基本思考方式。这些原则将指导我们阅读本书的其余部分，那里将会深入技术细节。<br>&emsp;&emsp;一个应用必须满足各种需求才称得上有用。有一些功能需求（functional requirements）（它应该做什么，比如允许以各种方式存储，检索，搜索和处理数据）以及一些非功能性需求（nonfunctional ）（通用属性，例如安全性，可靠性，合规性，可扩展性，兼容性和可维护性）。在本章详细讨论了可靠性，可扩展性和可维护性。<br>&emsp;&emsp;可靠性（Reliability） 意味着即使发生故障，系统也能正常工作。故障可能发生在硬件（通常是随机的和不相关的），软件（通常是系统性的Bug，很难处理），和人类（不可避免地时不时出错）。 容错技术 可以对终端用户隐藏某些类型的故障。<br>&emsp;&emsp;可扩展性（Scalability） 意味着即使在负载增加的情况下也有保持性能的策略。为了讨论可扩展性，我们首先需要定量描述负载和性能的方法。我们简要了解了推特主页时间线的例子，介绍描述负载的方法，并将响应时间百分位点作为衡量性能的一种方式。在可扩展的系统中可以添加 处理容量（processing capacity） 以在高负载下保持可靠。<br>&emsp;&emsp;可维护性（Maintainability） 有许多方面，但实质上是关于工程师和运维团队的生活质量的。良好的抽象可以帮助降低复杂度，并使系统易于修改和适应新的应用场景。良好的可操作性意味着对系统的健康状态具有良好的可见性，并拥有有效的管理手段。<br>&emsp;&emsp;不幸的是，使应用可靠、可扩展或可维护并不容易。但是某些模式和技术会不断重新出现在不同的应用中。在接下来的几章中，我们将看到一些数据系统的例子，并分析它们如何实现这些目标。<br>&emsp;&emsp;在本书后面的<font color=#5281BF>第三部分</font>中，我们将看到一种模式：几个组件协同工作以构成一个完整的系统（如<font color=#5281BF>图</font><font color=#5281BF>1-1</font>中的例子）<br>&emsp;&emsp;<hr><hr>执行一条 select 语句，期间发生了什么？<hr>大家好，我是小林。<br>&emsp;&emsp;学习 SQL 的时候，大家肯定第一个先学到的就是 select 查询语句了，比如下面这句查询语句：<br>&emsp;&emsp;<font color=#666666>// </font><font color=#666666>在</font><font color=#666666> product </font><font color=#666666>表中，查询</font><font color=#666666> id = 1 </font><font color=#666666>的记录</font><br>&emsp;&emsp;<font color=#5E3563>select</font> <font color=#519696>*</font> <font color=#5E3563>from</font> product <font color=#5E3563>where</font> id <font color=#519696>=</font> <font color=#AA5925>1</font>;<br>&emsp;&emsp;但是有没有想过，<font color=#FEAE00>MySQL </font><font color=#FEAE00>执行一条</font><font color=#FEAE00> select </font><font color=#FEAE00>查询语句，在</font><font color=#FEAE00> MySQL </font><font color=#FEAE00>中期间发生了什么？</font><br>&emsp;&emsp;带着这个问题，我们可以很好的了解 MySQL 内部的架构，所以这次小林就带大家拆解一下 MySQL 内部的结构，看看内部里的每一个“零件”具体是负责做什么的。<br>&emsp;&emsp;# MySQL 执行流程是怎样的？<br>&emsp;&emsp;先来一个上帝视角图，下面就是 MySQL 执行一条 SQL 查询语句的流程，也从图中可以看到 MySQL 内部架构里的各个功能模块。<br>&emsp;&emsp;￼<br>&emsp;&emsp;可以看到， MySQL 的架构共分为两层：<font color=#FEAE00>Server </font><font color=#FEAE00>层和存储引擎层</font><font color=#FEAE00>，</font><br>&emsp;&emsp;<font color=#374EF4>	</font><font color=#FEAE00>•	Server </font><font color=#FEAE00>层负责建立连接、分析和执行</font><font color=#FEAE00> SQL</font>。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。<br>&emsp;&emsp;<font color=#374EF4>	</font><font color=#FEAE00>•	</font><font color=#FEAE00>存储引擎层负责数据的存储和提取</font>。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。<br>&emsp;&emsp;好了，现在我们对 Server 层和存储引擎层有了一个简单认识，接下来，就详细说一条 SQL 查询语句的执行流程，依次看看每一个功能模块的作用。<hr><hr>按<font color=#FEAE00>字段特性</font>分类<hr>从<font color=#FEAE00>字段特性</font>的角度来看，索引分为<font color=#FEAE00>主键索引、唯一索引、普通索引、前缀索引</font>。<br>&emsp;&emsp;# 主键索引<br>&emsp;&emsp;	主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表<font color=#FEAE00>最多只有一个主键索引</font>，索引列的值不允许有空值。<br>&emsp;&emsp;	在创建表时，创建主键索引的方式如下：<br>&emsp;&emsp;<font color=#5E3563>CREATE</font> <font color=#5E3563>TABLE</font> table_name  (<br>&emsp;&emsp;  ....<br>&emsp;&emsp;  <font color=#FEAE00>PRIMARY KEY</font> (index_column_1) <font color=#FEAE00>USING BTREE</font><br>&emsp;&emsp;);<br>&emsp;&emsp;# <font color=#FEAE00>唯一</font>索引<br>&emsp;&emsp;唯一索引建立在 <font color=#FEAE00>UNIQUE </font><font color=#FEAE00>字段上的索引</font>，一张表可以有<font color=#FEAE00>多个唯一索引</font>，索引列的值必须唯一，但是允许有空值。<br>&emsp;&emsp;在创建表时，创建唯一索引的方式如下：<br>&emsp;&emsp;<font color=#5E3563>CREATE</font> <font color=#5E3563>TABLE</font> table_name  (<br>&emsp;&emsp;  ....<br>&emsp;&emsp;  <font color=#FEAE00>UNIQUE KEY</font>(index_column_1,index_column_2,...) <br>&emsp;&emsp;);<br>&emsp;&emsp;<font color=#FEAE00>建表后，如果要创建唯一索引</font>，可以使用这面这条命令：<br>&emsp;&emsp;<font color=#EA34B6>CREATE UNIQUE INDEX</font> index_name<br>&emsp;&emsp;<font color=#EC5DD5>ON</font> table_name(index_column_1,index_column_2,...); <br>&emsp;&emsp;# 普通索引<br>&emsp;&emsp;普通索引就是建立在<font color=#FEAE00>普通字段上的索引</font>，既不要求字段为主键，也不要求字段为 UNIQUE。<br>&emsp;&emsp;在创建表时，创建普通索引的方式如下：<br>&emsp;&emsp;CREATE TABLE table_name  (<br>&emsp;&emsp;  ....<br>&emsp;&emsp;  <font color=#5E3563>INDEX</font>(index_column_1,index_column_2,...) <br>&emsp;&emsp;);<br>&emsp;&emsp;建表后，如果要创建普通索引，可以使用这面这条命令：<br>&emsp;&emsp;<font color=#5E3563>CREATE</font> <font color=#5E3563>INDEX</font> index_name<br>&emsp;&emsp;<font color=#5E3563>ON</font> table_name(index_column_1,index_column_2,...); <br>&emsp;&emsp;# <font color=#FEAE00>前缀</font>索引<br>&emsp;&emsp;前缀索引是指对字符类型字段的<font color=#FEAE00>前几个字符建立的索引</font>，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 <font color=#FEAE00>char</font><font color=#FEAE00>、</font><font color=#FEAE00> varchar</font><font color=#FEAE00>、</font><font color=#FEAE00>binary</font><font color=#FEAE00>、</font><font color=#FEAE00>varbinary </font>的列上。<br>&emsp;&emsp;使用前缀索引的目的是为了<font color=#FEAE00>减少索引占用的存储空间</font>，提升查询效率。<br>&emsp;&emsp;在创建表时，创建前缀索引的方式如下：<br>&emsp;&emsp;<font color=#5E3563>CREATE</font> <font color=#5E3563>TABLE</font> table_name(<br>&emsp;&emsp;    column_list,<br>&emsp;&emsp;    <font color=#5E3563>INDEX</font>(column_name(<font color=#EA39D3>length</font>))<br>&emsp;&emsp;); <br>&emsp;&emsp;建表后，如果要创建前缀索引，可以使用这面这条命令：<br>&emsp;&emsp;<font color=#5E3563>CREATE</font> <font color=#5E3563>INDEX</font> index_name<br>&emsp;&emsp;<font color=#5E3563>ON</font> table_name(column_name(<font color=#EA35C5>length</font>)); <hr><hr>按<font color=#FEAE00>数据结构</font>分类<hr>	从数据结构的角度来看，MySQL 常见索引有 <font color=#FEAE00>B+Tree </font><font color=#FEAE00>索引、</font><font color=#FEAE00>HASH </font><font color=#FEAE00>索引、</font><font color=#FEAE00>Full-Text </font><font color=#FEAE00>索引。</font><br>&emsp;&emsp;	每一种存储引擎支持的索引类型不一定相同，我在表中总结了 MySQL 常见的存储引擎 <font color=#FEAE00>InnoDB</font><font color=#FEAE00>、</font><font color=#FEAE00>MyISAM </font>和 Memory 分别支持的索引类型。<br>&emsp;&emsp;￼<br>&emsp;&emsp;	InnoDB 是在 <font color=#FEAE00>MySQL 5.5</font> 之后成为默认的 MySQL 存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。<br>&emsp;&emsp;	在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：<br>&emsp;&emsp;	•	如果有<font color=#FEAE00>主键</font>，默认会使用主键作为<font color=#FEAE00>聚簇索引的索引键（</font><font color=#FEAE00>key</font><font color=#FEAE00>）；</font><br>&emsp;&emsp;	•	如果<font color=#FEAE00>没有主键</font>，就选择第一个<font color=#FEAE00>不包含</font><font color=#FEAE00> NULL </font><font color=#FEAE00>值的唯一列</font>作为聚簇索引的索引键（key）；<br>&emsp;&emsp;	•	在上面两个都没有的情况下，InnoDB 将自动生成一个<font color=#FEAE00>隐式自增</font><font color=#FEAE00> id </font>列作为聚簇索引的<font color=#FEAE00>索引键（</font><font color=#FEAE00>key</font><font color=#FEAE00>）</font>；<br>&emsp;&emsp;其它索引都属于<font color=#FEAE00>辅助索引（</font><font color=#FEAE00>Secondary Index</font><font color=#FEAE00>）</font>，也被称为<font color=#FEAE00>二级索引或非聚簇索引</font>。<font color=#00AB8E>创建的主键索引和二级索引默认使用的是</font><font color=#00AB8E> B+Tree </font><font color=#00AB8E>索引</font><font color=#00AB8E>。</font><br>&emsp;&emsp;为了让大家理解 B+Tree 索引的存储和查询的过程，接下来我通过一个简单例子，说明一下 B+Tree 索引在存储数据中的具体实现。<br>&emsp;&emsp;先创建一张商品表，id 为主键，如下：<br>&emsp;&emsp;<font color=#5E3563>CREATE</font> <font color=#5E3563>TABLE</font> `product`  (<br>&emsp;&emsp;  `id` <font color=#5E3563>int</font>(<font color=#AA5925>11</font>) <font color=#519696>NOT</font> <font color=#AA5925>NULL</font>,<br>&emsp;&emsp;  `product_no` <font color=#5E3563>varchar</font>(<font color=#AA5925>20</font>)  <font color=#5E3563>DEFAULT</font> <font color=#AA5925>NULL</font>,<br>&emsp;&emsp;  `name` <font color=#5E3563>varchar</font>(<font color=#AA5925>255</font>) <font color=#5E3563>DEFAULT</font> <font color=#AA5925>NULL</font>,<br>&emsp;&emsp;  `price` <font color=#5E3563>decimal</font>(<font color=#AA5925>10</font>, <font color=#AA5925>2</font>) <font color=#5E3563>DEFAULT</font> <font color=#AA5925>NULL</font>,<br>&emsp;&emsp;  <font color=#5E3563>PRIMARY</font> <font color=#5E3563>KEY</font> (`id`) <font color=#00AB8E>USING BTREE</font><br>&emsp;&emsp;) <font color=#5E3563>CHARACTER</font> <font color=#5E3563>SET</font> <font color=#519696>=</font> utf8 <font color=#5E3563>COLLATE</font> <font color=#519696>=</font> utf8_general_ci ROW_FORMAT <font color=#519696>=</font> Dynamic;<br>&emsp;&emsp;商品表里，有这些行数据：<br>&emsp;&emsp;￼<br>&emsp;&emsp;# 这些行数据，存储在 B+Tree 索引时是长什么样子的？<br>&emsp;&emsp;	B+Tree 是一种<font color=#FEAE00>多叉树</font>，叶子节点才存放数据，<font color=#FEAE00>非叶子节点只存放索引</font>，而且每个节点里的数据是<font color=#FEAE00>按主键顺序存放</font>的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在<font color=#FEAE00>叶子节点中</font>，包括了<font color=#FEAE00>所有的索引值信息</font>，并且每一个叶子节点都指向下一个叶子节点，形成一个链表。<br>&emsp;&emsp;	主键索引的 B+Tree 如图所示：<br>&emsp;&emsp;￼<br>&emsp;&emsp;# 通过主键查询商品数据的过程<br>&emsp;&emsp;比如，我们执行了下面这条查询语句，这条语句使用了主键索引查询<font color=#FEAE00> id </font><font color=#FEAE00>号为</font><font color=#FEAE00> 5</font> 的商品。查询过程是这样的，B+Tree 会自顶向下逐层进行查找：<br>&emsp;&emsp;	•	将 5 与根节点的索引数据 (1，10，20) 比较，5 在 1 和 10 之间，所以根据 B+Tree的搜索逻辑，找到第二层的索引数据 (1，4，7)；<br>&emsp;&emsp;	•	在第二层的索引数据 (1，4，7)中进行查找，因为 5 在 4 和 7 之间，所以找到第三层的索引数据（4，5，6）；<br>&emsp;&emsp;	•	在叶子节点的索引数据（4，5，6）中进行查找，然后我们找到了索引值为 5 的行数据。<br>&emsp;&emsp;	数据库的<font color=#FEAE00>索引和数据</font>都是<font color=#FEAE00>存储在硬盘的</font>，我们可以把读取一个节点当作一次磁盘 I/O 操作。那么上面的整个查询过程一共经历了 3 个节点，也就是进行了 <font color=#FEAE00>3 </font><font color=#FEAE00>次</font><font color=#FEAE00> I/O </font>操作。<br>&emsp;&emsp;	B+Tree 存储<font color=#FEAE00>千万级的数据只需要</font><font color=#FEAE00> 3-4 </font><font color=#FEAE00>层</font>高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以<font color=#FEAE00>B+Tree </font><font color=#FEAE00>相比于</font><font color=#FEAE00> B </font><font color=#FEAE00>树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘</font><font color=#FEAE00> I/O </font><font color=#FEAE00>依然维持在</font><font color=#FEAE00> 3-4</font><font color=#FEAE00>次。</font><br>&emsp;&emsp;# 通过二级索引查询商品数据的过程<br>&emsp;&emsp;主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：<br>&emsp;&emsp;	•	<font color=#FEAE00>主键索引的</font><font color=#FEAE00> B+Tree</font> 的<font color=#FEAE00>叶子节点</font>存放的是<font color=#FEAE00>实际数据</font>，所有<font color=#FEAE00>完整的用户记录</font>都存放在主键索引的 B+Tree 的叶子节点里；<br>&emsp;&emsp;	•	<font color=#FEAE00>二级索引</font>的 B+Tree 的<font color=#FEAE00>叶子节点</font>存放的是<font color=#FEAE00>主键值</font>，而不是实际数据。<br>&emsp;&emsp;	我这里将前面的商品表中的 <font color=#FEAE00>product_no </font><font color=#FEAE00>（商品编码）</font>字段设置为二级索引，那么二级索引的 B+Tree 如下图，其中非叶子的 key 值是 product_no（图中橙色部分），叶子节点存储的数据是主键值（图中绿色部分）。<br>&emsp;&emsp;￼<br>&emsp;&emsp;	如果我用 <font color=#FEAE00>product_no </font><font color=#FEAE00>二级索引</font>查询商品，如下查询语句：<br>&emsp;&emsp;<font color=#5E3563>select</font> <font color=#519696>*</font> <font color=#5E3563>from</font> product <font color=#5E3563>where</font> product_no <font color=#519696>=</font> <font color=#4C7F58>'0002'</font>;<br>&emsp;&emsp;	会先检二级索引中的 B+Tree 的索引值（商品编码，product_no），找到<font color=#FEAE00>对应的叶子节点</font>，然后<font color=#FEAE00>获取主键值</font>，然后<font color=#FEAE00>再通过主键索引</font>中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。<font color=#00AB8E>这个过程叫「回表」，也就是说要查两个</font><font color=#00AB8E> B+Tree </font><font color=#00AB8E>才能查到数据</font><font color=#00AB8E>。</font>如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;	不过，当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查，比如下面这条查询语句：<br>&emsp;&emsp;<font color=#5E3563>select</font> id <font color=#5E3563>from</font> product <font color=#5E3563>where</font> product_no <font color=#519696>=</font> <font color=#4C7F58>'0002'</font>;<br>&emsp;&emsp;	<font color=#FEAE00>这种在二级索引的</font><font color=#FEAE00> B+Tree </font><font color=#FEAE00>就能查询到结果的过程就叫作「</font><font color=#00AB8E>覆盖索引</font><font color=#FEAE00>」，也就是只需要查一个</font><font color=#FEAE00> B+Tree </font><font color=#FEAE00>就能找到数据</font><font color=#FEAE00>。</font><br>&emsp;&emsp;# 为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？<br>&emsp;&emsp;	前面已经讲了 B+Tree 的索引原理，现在就来回答一下 B+Tree 相比于 B 树、二叉树或 Hash 索引结构的优势在哪儿？<br>&emsp;&emsp;	之前我也专门写过一篇文章，想详细了解的可以看这篇：「<font color=#929292>女朋友问我：为什么</font><font color=#929292> MySQL </font><font color=#929292>喜欢</font><font color=#929292> B+ </font><font color=#929292>树？我笑着画了</font><font color=#929292> 20 </font><font color=#929292>张图</font>」，这里就简单做个比对。<br>&emsp;&emsp;<font color=#FEAE00>1</font><font color=#FEAE00>、</font><font color=#FEAE00>B+Tree vs B Tree</font><br>&emsp;&emsp;B+Tree 只在叶子节点存储数据，而 <font color=#FEAE00>B </font><font color=#FEAE00>树</font><font color=#FEAE00> </font><font color=#FEAE00>的非叶子节点也要存储数据</font>，所以 <font color=#FEAE00>B+Tree </font>的<font color=#FEAE00>单个节点</font>的数据量更<font color=#FEAE00>小</font>，在相同的磁盘 I/O 次数下，就能<font color=#FEAE00>查询更多的节点</font>。<br>&emsp;&emsp;另外，B+Tree <font color=#FEAE00>叶子节点</font>采用的是<font color=#FEAE00>双链表连接</font>，适合 MySQL 中常见的<font color=#FEAE00>基于范围的顺序查找</font>，而 B 树无法做到这一点。<br>&emsp;&emsp;<font color=#FEAE00>2</font><font color=#FEAE00>、</font><font color=#FEAE00>B+Tree vs </font><font color=#FEAE00>二叉树</font><br>&emsp;&emsp;对于有 N 个叶子节点的 B+Tree，其搜索复杂度为<font color=#FEAE00>O(logdN)</font>，其中 d 表示节点允许的最大子节点个数为 <font color=#FEAE00>d </font><font color=#FEAE00>个。</font><br>&emsp;&emsp;在实际的应用当中， <font color=#FEAE00>d </font><font color=#FEAE00>值是大于</font><font color=#FEAE00>100</font><font color=#FEAE00>的</font>，这样就保证了，即使数据达到<font color=#FEAE00>千万级别时</font>，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 <font color=#FEAE00>3~4 </font><font color=#FEAE00>次的磁盘</font><font color=#FEAE00> I/O </font>操作就能查询到目标数据。<br>&emsp;&emsp;而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为<font color=#FEAE00> O(logN)</font>，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。<br>&emsp;&emsp;<font color=#FEAE00>3</font><font color=#FEAE00>、</font><font color=#FEAE00>B+Tree vs Hash</font><br>&emsp;&emsp;Hash 在做<font color=#FEAE00>等值查询</font>的时候效率贼快，<font color=#FEAE00>搜索复杂度为</font><font color=#FEAE00> O(1)</font>。<br>&emsp;&emsp;但是 Hash 表不适合做<font color=#FEAE00>范围查询</font>，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>按<font color=#FEAE00>物理存储</font>分类<hr>从物理存储的角度来看，索引分为<font color=#FEAE00>聚簇索引</font><font color=#FEAE00>（主键索引）</font>、<font color=#FEAE00>二级索引（辅助索引）</font>。<br>&emsp;&emsp;这两个区别在前面也提到了：<br>&emsp;&emsp;	•	<font color=#FEAE00>主键索引</font>的 B+Tree 的叶子节点存放的是<font color=#FEAE00>实际数据</font>，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；<br>&emsp;&emsp;	•	<font color=#FEAE00>二级索引</font>的 B+Tree 的叶子节点存放的是<font color=#FEAE00>主键值</font>，而不是实际数据。<br>&emsp;&emsp;	所以，在查询时使用了二级索引，如果查询的数据能在<font color=#FEAE00>二级索引里查询的到，那么就不需要回表</font>，这个过程就是<font color=#FEAE00>覆盖索引</font>。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是<font color=#FEAE00>回表</font>。<br>&emsp;&emsp;<hr><hr>描述性能<hr>一旦系统的负载被描述好，就可以研究当负载增加会发生什么。我们可以从两种角度来看：<br>&emsp;&emsp;	•	增加<font color=#FEAE00>负载参数</font>并保持系统资源（CPU、内存、网络带宽等）不变时，<font color=#FEAE00>系统性能将受到什么影响</font>？<br>&emsp;&emsp;	•	增加负载参数并希望保持性能不变时，<font color=#FEAE00>需要增加多少系统资源</font>？<br>&emsp;&emsp;这两个问题都需要性能数据，所以让我们简单地看一下如何描述系统性能。<br>&emsp;&emsp;对于Hadoop这样的批处理系统，通常关心的是<font color=#FEAE00>吞吐量（</font><font color=#FEAE00>throughput</font><font color=#FEAE00>）</font>，即每秒可以处理的记录数量，或者在特定规模数据集上运行作业的总时间<font color=#5281BF>iii</font>。对于在线系统，通常更重要的是服务的<font color=#FEAE00>响应时间（</font><font color=#FEAE00>response time</font><font color=#FEAE00>）</font>，即客户端发送请求到接收响应之间的时间。<br>&emsp;&emsp;<font color=#7A7A7A>iii. </font><font color=#7A7A7A>理想情况下，批量作业的运行时间是</font><font color=#FEAE00>数据集的大小除以吞吐量</font><font color=#7A7A7A>。</font><font color=#7A7A7A> </font><font color=#7A7A7A>在实践中由于</font><font color=#FEAE00>数据倾斜（数据不是均匀分布在每个工作进程中）</font><font color=#7A7A7A>，需要等待最慢的任务完成，所以</font><font color=#FEAE00>运行时间往往更长</font><font color=#7A7A7A>。</font><font color=#5281BF> </font><font color=#5281BF>↩</font><font color=#7A7A7A><br>&emsp;&emsp;</font><font color=#7A7A7A>延迟和响应时间</font><font color=#7A7A7A><br>&emsp;&emsp;</font><font color=#FEAE00>延迟（</font><font color=#FEAE00>latency</font><font color=#FEAE00>）</font><font color=#FEAE00> </font><font color=#FEAE00>和</font><font color=#FEAE00> </font><font color=#FEAE00>响应时间（</font><font color=#FEAE00>response time</font><font color=#FEAE00>）</font><font color=#7A7A7A> </font><font color=#7A7A7A>经常用作同义词，但实际上它们并不一样。</font><font color=#FEAE00>响应时间是客户所看到的</font><font color=#7A7A7A>，除了实际处理请求的时间（</font><font color=#7A7A7A> </font><font color=#7A7A7A>服务时间（</font><font color=#7A7A7A>service time</font><font color=#7A7A7A>）</font><font color=#7A7A7A> </font><font color=#7A7A7A>）之外，还包括网络延迟和排队延迟。</font><font color=#FEAE00>延迟是某个请求等待处理的</font><font color=#FEAE00>持续时长</font><font color=#7A7A7A>，在此期间它处于</font><font color=#7A7A7A> </font><font color=#FEAE00>休眠（</font><font color=#FEAE00>latent</font><font color=#FEAE00>）</font><font color=#7A7A7A> </font><font color=#7A7A7A>状态，并等待服务【</font><font color=#7A7A7A>17</font><font color=#7A7A7A>】。</font><font color=#7A7A7A><br>&emsp;&emsp;</font>即使不断重复发送同样的请求，每次得到的响应时间也都会略有不同。现实世界的系统会处理各式各样的请求，响应时间可能会有很大差异。因此我们需要将响应时间视为一个可以测量的<font color=#FEAE00>数值</font><font color=#FEAE00>分布（</font><font color=#FEAE00>distribution</font><font color=#FEAE00>）</font>，而不是单个数值。<br>&emsp;&emsp;在<font color=#5281BF>图</font><font color=#5281BF>1-4</font>中，每个灰条表代表一次对服务的请求，其高度表示请求花费了多长时间。大多数请求是相当快的，但偶尔会出现需要更长的时间的异常值。这也许是因为缓慢的请求实质上开销更大，例如它们可能会处理更多的数据。但即使（你认为）所有请求都花费相同时间的情况下，随机的附加延迟也会导致结果变化，例如：上下文切换到后台进程，网络数据包丢失与TCP重传，垃圾收集暂停，强制从磁盘读取的页面错误，服务器机架中的震动【18】，还有很多其他原因。<br>&emsp;&emsp;￼<br>&emsp;&emsp;图1-4 展示了一个服务100次请求响应时间的<font color=#FEAE00>均值与百分位数</font><br>&emsp;&emsp;通常报表都会展示服务的<font color=#FEAE00>平均响应时间</font>。 （严格来讲“平均”一词并不指代任何特定公式，但实际上它通常被理解为<font color=#FEAE00>算术平均值（</font><font color=#FEAE00>arithmetic mean</font><font color=#FEAE00>）</font>：给定 n 个值，加起来除以 n ）。然而如果你想知道<font color=#FEAE00>“</font><font color=#FEAE00>典型（</font><font color=#FEAE00>typical</font><font color=#FEAE00>）</font>”响应时间，那么平均值并不是一个非常好的指标，因为它不能告诉你有多少用户实际上经历了这个延迟。<br>&emsp;&emsp;通常使用<font color=#FEAE00>百分位点（</font><font color=#FEAE00>percentiles</font><font color=#FEAE00>）</font>会更好。如果将响应时间列表按最快到最慢排序，那么<font color=#FEAE00>中位数（</font><font color=#FEAE00>median</font><font color=#FEAE00>）</font>就在正中间：举个例子，如果你的响应时间中位数是200毫秒，这意味着一半请求的返回时间少于200毫秒，另一半比这个要长。<br>&emsp;&emsp;如果想知道典型场景下用户需要等待多长时间，那么中位数是一个好的度量标准：一半用户请求的响应时间少于响应时间的中位数，另一半服务时间比中位数长。中位数也被称为第50百分位点，有时缩写为<font color=#FEAE00>p50</font>。注意中位数是关于单个请求的；如果用户同时发出几个请求（在一个会话过程中，或者由于一个页面中包含了多个资源），则至少一个请求比中位数慢的概率远大于50％。<br>&emsp;&emsp;为了弄清异常值有多糟糕，可以看看更高的百分位点，例如<font color=#FEAE00>第</font><font color=#FEAE00>95</font><font color=#FEAE00>、</font><font color=#FEAE00>99</font><font color=#FEAE00>和</font><font color=#FEAE00>99.9</font><font color=#FEAE00>百分位点（缩写为</font><font color=#FEAE00>p95</font><font color=#FEAE00>，</font><font color=#FEAE00>p99</font><font color=#FEAE00>和</font><font color=#FEAE00>p999</font><font color=#FEAE00>）</font>。它们意味着95％，99％或99.9％的请求响应时间要比该阈值快，例如：如果第95百分位点响应时间是1.5秒，则意味着100个请求中的95个响应时间快于1.5秒，而100个请求中的5个响应时间超过1.5秒。如<font color=#5281BF>图</font><font color=#5281BF>1-4</font>所示。<br>&emsp;&emsp;响应时间的<font color=#FEAE00>高百分位点（也称为</font><font color=#FEAE00>尾部延迟（</font><font color=#FEAE00>tail latencies</font><font color=#FEAE00>）</font><font color=#FEAE00>）</font>非常重要，因为它们直接影响用户的服务体验。例如亚马逊在描述<font color=#FEAE00>内部服务的响应时间要求时以</font><font color=#FEAE00>99.9</font><font color=#FEAE00>百分位点为准</font>，即使它只影响一千个请求中的一个。这是因为请求响应最慢的客户往往也是数据最多的客户，也可以说是最有价值的客户 —— 因为他们掏钱了【19】。保证网站响应迅速对于保持客户的满意度非常重要，亚马逊观察到：响应时间增加100毫秒，销售量就减少1％【20】；而另一些报告说：慢 1 秒钟会让客户满意度指标减少16%【21，22】。<br>&emsp;&emsp;另一方面，优化第99.99百分位点（一万个请求中最慢的一个）<font color=#FEAE00>被认为太昂贵了</font>，不能为亚马逊的目标带来足够好处。减小高百分位点处的响应时间相当困难，因为它很容易受到随机事件的影响，这超出了控制范围，而且效益也很小。<br>&emsp;&emsp;百分位点通常用于<font color=#FEAE00>服务级别目标（</font><font color=#FEAE00>SLO, service level objectives</font><font color=#FEAE00>）</font>和<font color=#FEAE00>服务级别协议（</font><font color=#FEAE00>SLA, service level agreements</font><font color=#FEAE00>）</font>，即<font color=#FEAE00>定义服务预期性能和可用性的合同</font>。 SLA可能会声明，如果服务响应时间的中位数小于200毫秒，且99.9百分位点低于1秒，则认为服务工作正常（如果响应时间更长，就认为服务不达标）。这些指标为客户设定了期望值，并允许客户<font color=#FEAE00>在</font><font color=#FEAE00>SLA</font><font color=#FEAE00>未达标的情况下要求退款</font>。<br>&emsp;&emsp;<font color=#FEAE00>排队延迟（</font><font color=#FEAE00>queueing delay</font><font color=#FEAE00>）</font> 通常占了高百分位点处响应时间的很大一部分。由于服务器只能<font color=#FEAE00>并行处理少量的事务</font>（如受其CPU核数的限制），所以只要有少量缓慢的请求就能阻碍后续请求的处理，这种效应有时被称为 <font color=#FEAE00>头部阻塞（</font><font color=#FEAE00>head-of-line blocking</font><font color=#FEAE00>）</font><font color=#FEAE00> </font>。即使后续请求在服务器上处理的非常迅速，由于需要等待先前请求完成，客户端最终看到的是缓慢的总体响应时间。因为存在这种效应，测量客户端的响应时间非常重要。<br>&emsp;&emsp;为测试系统的可扩展性而人为产生负载时，产生负载的客户端要独立于响应时间不断发送请求。如果客户端在发送下一个请求之前等待先前的请求完成，这种行为会产生人为排队的效果，使得测试时的队列比现实情况更短，使测量结果产生偏差【23】。<br>&emsp;&emsp;<font color=#7A7A7A>实践中的百分位点</font><font color=#7A7A7A><br>&emsp;&emsp;</font><font color=#7A7A7A>在多重调用的后端服务里，高百分位数变得特别重要。即使并行调用，最终用户请求仍然需要等待最慢的并行调用完成。如</font><font color=#5281BF>图</font><font color=#5281BF>1-5</font><font color=#7A7A7A>所示，只需要一个缓慢的调用就可以使整个最终用户请求变慢。即使只有一小部分后端调用速度较慢，如果最终用户请求需要多个后端调用，则获得较慢调用的机会也会增加，因此较高比例的最终用户请求速度会变慢（效果称为</font><font color=#FEAE00>尾部延迟放大【</font><font color=#FEAE00>24</font><font color=#FEAE00>】）。</font><font color=#7A7A7A><br>&emsp;&emsp;</font><font color=#7A7A7A>如果您想将响应时间百分点添加到您的服务的监视仪表板，则需要持续有效地计算它们。例如，您可能希望在最近</font><font color=#7A7A7A>10</font><font color=#7A7A7A>分钟内保持请求响应时间的滚动窗口。每一分钟，您都会计算出该窗口中的中值和各种百分数，并将这些度量值绘制在图上。</font><font color=#7A7A7A><br>&emsp;&emsp;</font><font color=#7A7A7A>简单的实现是在时间窗口内保存所有请求的响应时间列表，并且每分钟对列表进行排序。如果对你来说效率太低，那么有一些算法能够以最小的</font><font color=#7A7A7A>CPU</font><font color=#7A7A7A>和内存成本（如前向衰减【</font><font color=#7A7A7A>25</font><font color=#7A7A7A>】，</font><font color=#7A7A7A>t-digest</font><font color=#7A7A7A>【</font><font color=#7A7A7A>26</font><font color=#7A7A7A>】或</font><font color=#7A7A7A>HdrHistogram </font><font color=#7A7A7A>【</font><font color=#7A7A7A>27</font><font color=#7A7A7A>】）来计算百分位数的近似值。请注意，平均百分比（例如，减少时间分辨率或合并来自多台机器的数据）在数学上没有意义</font><font color=#7A7A7A> - </font><font color=#7A7A7A>聚合响应时间数据的正确方法是添加直方图【</font><font color=#7A7A7A>28</font><font color=#7A7A7A>】。</font><font color=#7A7A7A><br>&emsp;&emsp;</font>￼<br>&emsp;&emsp;图1-5 当一个请求需要<font color=#FEAE00>多个后端请求时，单个后端慢请求</font>就会拖慢整个终端用户的请求<br>&emsp;&emsp;应对负载的方法<br>&emsp;&emsp;现在我们已经讨论了用于描述负载的参数和用于衡量性能的指标。可以开始认真讨论可扩展性了：当<font color=#FEAE00>负载参数增加时，如何保持良好的性能</font>？<br>&emsp;&emsp;适应某个级别负载的架构不太可能应付10倍于此的负载。如果你正在开发一个快速增长的服务，那么每次负载发生数量级的增长时，你可能都需要重新考虑架构——或者更频繁。<br>&emsp;&emsp;人们经常讨论<font color=#FEAE00>纵向扩展（</font><font color=#FEAE00>scaling up</font><font color=#FEAE00>）</font><font color=#FEAE00>（</font><font color=#FEAE00>垂直扩展（</font><font color=#FEAE00>vertical scaling</font><font color=#FEAE00>）</font>，转向更强大的机器）和<font color=#FEAE00>横向扩展（</font><font color=#FEAE00>scaling out</font><font color=#FEAE00>）</font><font color=#FEAE00> </font><font color=#FEAE00>（</font><font color=#FEAE00>水平扩展（</font><font color=#FEAE00>horizontal scaling</font><font color=#FEAE00>）</font>，将负载分布到多台小机器上）之间的对立。跨多台机器分配负载也称为“无共享（shared-nothing）”架构。可以在单台机器上运行的系统通常更简单，但高端机器可能非常贵，所以非常密集的负载通常无法避免地需要横向扩展。现实世界中的优秀架构需要将这两种方法务实地结合，因为使用几台足够强大的机器可能比使用大量的小型虚拟机更简单也更便宜。<br>&emsp;&emsp;有些系统是 <font color=#FEAE00>弹性（</font><font color=#FEAE00>elastic</font><font color=#FEAE00>）</font> 的，这意味着可以在检测到负载增加时自动增加计算资源，而其他系统则是手动扩展（人工分析容量并决定向系统添加更多的机器）。如果负载<font color=#FEAE00>极难预测（</font><font color=#FEAE00>highly unpredictable</font><font color=#FEAE00>）</font>，则弹性系统可能很有用，但手动扩展系统更简单，并且意外操作可能会更少（参阅“<font color=#5281BF>重新平衡分区</font>”）。<br>&emsp;&emsp;跨多台机器部署<font color=#FEAE00>无状态服务（</font><font color=#FEAE00>stateless services</font>）非常简单，但将带状态的数据系统从单节点变为分布式配置则可能引入许多额外复杂度。出于这个原因，常识告诉我们应该将数据库放在单个节点上（纵向扩展），直到扩展成本或可用性需求迫使其改为分布式。<br>&emsp;&emsp;随着分布式系统的工具和抽象越来越好，至少对于某些类型的应用而言，这种常识可能会改变。可以预见分布式数据系统将成为未来的默认设置，即使对不处理大量数据或流量的场景也如此。本书的其余部分将介绍多种分布式数据系统，不仅讨论它们在可扩展性方面的表现，还包括易用性和可维护性。<br>&emsp;&emsp;大规模的系统架构通常是应用特定的—— 没有一招鲜吃遍天的通用可扩展架构（不正式的叫法：<font color=#FEAE00>万金油（</font><font color=#FEAE00>magic scaling sauce</font><font color=#FEAE00>）</font> ）。应用的问题可能是读取量、写入量、要存储的数据量、数据的复杂度、响应时间要求、访问模式或者所有问题的大杂烩。<br>&emsp;&emsp;举个例子，用于处理每秒十万个请求（每个大小为1 kB）的系统与用于处理每分钟3个请求（每个大小为2GB）的系统看上去会非常不一样，尽管两个系统有同样的数据吞吐量。<br>&emsp;&emsp;一个良好适配应用的可扩展架构，是围绕着<font color=#FEAE00>假设（</font><font color=#FEAE00>assumption</font><font color=#FEAE00>）</font>建立的：哪些操作是常见的？哪些操作是罕见的？这就是所谓负载参数。如果假设最终是错误的，那么为扩展所做的工程投入就白费了，最糟糕的是适得其反。在早期创业公司或非正式产品中，通常支持产品快速迭代的能力，要比可扩展至未来的假想负载要重要的多。<br>&emsp;&emsp;尽管这些架构是应用程序特定的，但可扩展的架构通常也是从通用的积木块搭建而成的，并以常见的模式排列。在本书中，我们将讨论这些构件和模式。<hr><hr>数据页总结<br>&emsp;&emsp;<hr>InnoDB 的数据是按「<font color=#FEAE00>数据页</font>」为单位来读写的，默认数据页大小为 16 KB。每个数据页之间<font color=#FEAE00>通过双向链表的形式</font>组织起来，物理上不连续，但是逻辑上连续。<br>&emsp;&emsp;数据页内包含用户记录，每个记录之间用单向链表的方式组织起来，为了加快在数据页内高效查询记录，设计了一个<font color=#FEAE00>页目录</font>，页目录存储<font color=#FEAE00>各个槽（分组）</font>，且主键值是有序的，于是可以通过二分查找法的方式进行检索从而提高效率。<br>&emsp;&emsp;为了高效查询记录所在的数据页，InnoDB 采用 b+ 树作为索引，每个节点都是一个数据页。<br>&emsp;&emsp;如果叶子节点存储的是实际数据的就是聚簇索引，一个表只能有一个聚簇索引；如果叶子节点存储的<font color=#FEAE00>不是实际数据</font>，而是主键值则就是二级索引，一个表中可以有多个二级索引。<br>&emsp;&emsp;在使用二级索引进行查找数据时，如果查询的数据能在二级索引找到，那么就是「索引覆盖」操作，如果查询的数据不在二级索引里，就需要先在二级索引找到主键值，需要去聚簇索引中获得数据行，这个过程就叫作「回表」。<br>&emsp;&emsp;关于索引的内容还有很多，比如索引失效、索引优化等等，这些内容我下次在讲啦！<br>&emsp;&emsp;<hr><hr>有什么<font color=#FEAE00>优化索引</font>的方法？<br>&emsp;&emsp;如何防止索引失效?<br>&emsp;&emsp;如何查看执行计划?<br>&emsp;&emsp;<hr>	前缀索引优化:  前几个字符建立, 减少字段大小  cons: 无法 order by, 无法用于覆盖索引<br>&emsp;&emsp;	覆盖索引优化:  sql 中所有字段都有, 避免回表, 只需要经常查询几个字段的时候<br>&emsp;&emsp;	主键索引最好自增: 插入效率非常高, <br>&emsp;&emsp;	主键索引字段长度不要太大<br>&emsp;&emsp;	索引最好是 NOT NULL<br>&emsp;&emsp;<br>&emsp;&emsp;失效: <br>&emsp;&emsp;	左/右模糊匹配<br>&emsp;&emsp;	计算 函数 类型转换等<br>&emsp;&emsp;	最左匹配原则<br>&emsp;&emsp;	OR之前和之后<br>&emsp;&emsp;执行计划: <br>&emsp;&emsp;	ALL全表, Index 索引, range 范围, ref 非唯一, eq_ref唯一, const 主键<br>&emsp;&emsp;<br>&emsp;&emsp;这里说一下几种常见优化索引的方法：<br>&emsp;&emsp;<font color=#FEAE00>	•	</font><font color=#FEAE00>前缀索引优化；</font><font color=#FEAE00><br>&emsp;&emsp;	•	</font><font color=#FEAE00>覆盖索引优化；</font><font color=#FEAE00><br>&emsp;&emsp;	•	</font><font color=#FEAE00>主键索引最好是自增的；</font><font color=#FEAE00><br>&emsp;&emsp;	•	</font><font color=#FEAE00>防止索引失效；</font><br>&emsp;&emsp;# 前缀索引优化<br>&emsp;&emsp;前缀索引顾名思义就是使用某个字段中字符串的<font color=#FEAE00>前几个字符</font>建立索引，那我们为什么需要使用前缀来建立索引呢？<br>&emsp;&emsp;使用前缀索引是为了<font color=#FEAE00>减小索引字段大小</font>，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。<br>&emsp;&emsp;不过，前缀索引有一定的<font color=#FEAE00>局限性</font>，例如：<br>&emsp;&emsp;	•	<font color=#FEAE00>order by</font> 就无法使用前缀索引；<br>&emsp;&emsp;	•	无法把<font color=#FEAE00>前缀索引用作覆盖索引</font>；<br>&emsp;&emsp;# 覆盖索引优化<br>&emsp;&emsp;覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不<font color=#FEAE00>需要通过聚簇索引查询</font>获得，可以<font color=#FEAE00>避免回表</font>的操作。<br>&emsp;&emsp;假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？<br>&emsp;&emsp;我们可以建立一个<font color=#FEAE00>联合索引</font>，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。<br>&emsp;&emsp;所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。<br>&emsp;&emsp;# 主键索引最好是<font color=#FEAE00>自增</font>的<br>&emsp;&emsp;我们在建表的时候，都会默认将主键索引设置为自增的，具体为什么要这样做呢？又什么好处？<br>&emsp;&emsp;InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，<font color=#FEAE00>每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。</font><br>&emsp;&emsp;<font color=#FEAE00>如果我们使用自增主键</font>，那么每次插入的新数据就会按顺序添加到<font color=#FEAE00>当前索引节点的位置</font>，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<font color=#FEAE00>插入一条新记录，都是追加操作，不需要重新移动数据</font>，因此这种<font color=#FEAE00>插入数据的方法效率非常高</font>。<br>&emsp;&emsp;<font color=#FEAE00>如果我们使用非自增主键</font>，由于每次插入主键的索引值都是<font color=#FEAE00>随机的</font>，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<font color=#FEAE00>页分裂</font>。<font color=#FEAE00>页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率</font><font color=#FEAE00>。</font><br>&emsp;&emsp;举个例子，假设某个数据页中的数据是1、3、5、9，且数据页满了，现在准备插入一个数据7，则需要把数据页分割为两个数据页：<br>&emsp;&emsp;￼<br>&emsp;&emsp;出现页分裂时，需要将一个<font color=#FEAE00>页的记录移动到另外一个页</font>，性能会受到影响，同时页空间的利用率下降，造成存储空间的浪费。<br>&emsp;&emsp;而如果记录是顺序插入的，例如插入数据11，则只需开辟新的数据页，也就不会发生页分裂：<br>&emsp;&emsp;￼<br>&emsp;&emsp;因此，在使用 InnoDB 存储引擎时，如果没有特别的业务需求，建议使用<font color=#FEAE00>自增字段作为主键。</font><br>&emsp;&emsp;另外，主键字段的长度不要太大，因为<font color=#FEAE00>主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小</font><font color=#FEAE00>。</font><br>&emsp;&emsp;# 索引最好设置为 NOT NULL<br>&emsp;&emsp;为了更好的利用索引，索引列要设置为 <font color=#FEAE00>NOT NULL </font><font color=#FEAE00>约束</font>。有两个原因：<br>&emsp;&emsp;	•	第一原因：<font color=#FEAE00>索引列存在</font><font color=#FEAE00> NULL </font>就会导致优化器在做索引选择的时候<font color=#FEAE00>更加复杂，更加难以优化</font>，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。<br>&emsp;&emsp;	•	第二个原因：NULL 值是一个没意义的值，但是<font color=#FEAE00>它会占用物理空间</font>，所以会带来的存储空间的问题，会导致更多的存储空间占用，因为 InnoDB 默认行存储格式<font color=#4D647F>COMPACT</font>，会用 1 字节空间存储 NULL 值列表，如下图的黄色部分：<br>&emsp;&emsp;￼<br>&emsp;&emsp;# 防止索引失效<br>&emsp;&emsp;用上了索引并不意味着查询的时候会使用到索引，所以我们心里要清楚有哪些情况会导致索引失效，从而避免写出索引失效的查询语句，否则这样的查询效率是很低的。<br>&emsp;&emsp;我之前写过索引失效的文章，想详细了解的可以去看这篇文章：<font color=#FEAE00>谁还没碰过索引失效呢</font><font color=#FEAE00>?</font><font color=#5478F6><br>&emsp;&emsp;</font>这里简单说一下，发生<font color=#FEAE00>索引失效</font>的情况：<br>&emsp;&emsp;	•	当我们使用<font color=#FEAE00>左或者左右模糊匹配</font>的时候，也就是 <font color=#4D647F>like %xx</font> 或者 <font color=#4D647F>like %xx%</font>这两种方式都会造成索引失效；<br>&emsp;&emsp;	•	当我们在查询条件中对索引列做了<font color=#FEAE00>计算、函数、类型转换操作</font>，这些情况下都会造成索引失效；<br>&emsp;&emsp;	•	联合索引要能正确使用需要遵循<font color=#FEAE00>最左匹配原则</font>，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。<br>&emsp;&emsp;	•	在 WHERE 子句中，如果在 <font color=#FEAE00>OR </font><font color=#FEAE00>前的条件列是索引列，</font>而在 OR 后的条件列不是索引列，那么索引会失效。<br>&emsp;&emsp;我上面说的是常见的索引失效场景，实际过程中，可能会出现其他的索引失效场景，这时我们就需要<font color=#FEAE00>查看执行计划</font>，通过执行计划显示的数据判断查询语句是否使用了索引。<br>&emsp;&emsp;如下图，就是一个没有使用索引，并且是一个全表扫描的查询语句。<br>&emsp;&emsp;￼<br>&emsp;&emsp;对于执行计划，参数有：<br>&emsp;&emsp;	•	possible_keys 字段表示可能用到的索引；<br>&emsp;&emsp;	•	key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；<br>&emsp;&emsp;	•	key_len 表示索引的长度；<br>&emsp;&emsp;	•	rows 表示扫描的数据行数。<br>&emsp;&emsp;	•	type 表示数据扫描类型，我们需要重点看这个。<br>&emsp;&emsp;type 字段就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的<font color=#FEAE00>执行效率从低到高的顺序为</font>：<br>&emsp;&emsp;	•	<font color=#FEAE00>All</font><font color=#FEAE00>（全表扫描）；</font><font color=#FEAE00><br>&emsp;&emsp;	•	index</font><font color=#FEAE00>（全索引扫描）；</font><font color=#FEAE00><br>&emsp;&emsp;	•	range</font><font color=#FEAE00>（索引范围扫描）；</font><font color=#FEAE00><br>&emsp;&emsp;	•	ref</font><font color=#FEAE00>（非唯一索引扫描）；</font><font color=#FEAE00><br>&emsp;&emsp;	•	eq_ref</font><font color=#FEAE00>（唯一索引扫描）；</font><font color=#FEAE00><br>&emsp;&emsp;	•	const</font><font color=#FEAE00>（结果只有一条的主键或唯一索引扫描）。</font><br>&emsp;&emsp;在这些情况里，all 是最坏的情况，因为采用了全表扫描的方式。index 和 all 差不多，只不过 index 对索引表进行全扫描，这样<font color=#FEAE00>做的好处是不再需要对数据进行排序</font>，但是开销依然很大。所以，要尽量避免<font color=#FEAE00>全表扫描和全索引扫描</font>。<br>&emsp;&emsp;range 表示采用了索引范围扫描，一般在 where 子句中使用 < 、>、in、between 等关键词，只检索给定范围的行，属于范围查找。<font color=#FEAE00>从这一级别开始，索引的作用会越来越明显，因此我们需要尽量让</font><font color=#FEAE00> SQL </font><font color=#FEAE00>查询可以使用到</font><font color=#FEAE00> range </font><font color=#FEAE00>这一级别及以上的</font><font color=#FEAE00> type </font><font color=#FEAE00>访问方式</font><font color=#FEAE00>。</font><br>&emsp;&emsp;<font color=#FEAE00>ref </font>类型表示采用了<font color=#FEAE00>非唯一索引</font>，或者是唯一索引的非唯一性前缀，返回数据返回可能是多条。因为虽然使用了索引，但该索引列的值并不唯一，有重复。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个<font color=#FEAE00>非常小的范围内扫描。</font><br>&emsp;&emsp;<font color=#FEAE00>eq_ref</font> 类型是使用<font color=#FEAE00>主键或唯一索引</font>时产生的访问方式，通常使用在多表联查中。比如，对两张表进行联查，关联条件是两张表的 user_id 相等，且 user_id 是唯一索引，那么使用 EXPLAIN 进行执行计划查看的时候，type 就会显示 eq_ref。<br>&emsp;&emsp;<font color=#FEAE00>const </font>类型表示使用了<font color=#FEAE00>主键或者唯一索引与常量值进行比较</font>，比如 select name from product where id=1。<br>&emsp;&emsp;需要说明的是 const 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，<font color=#FEAE00>const </font><font color=#FEAE00>是与常量进行比较，查询效率会更快，而</font><font color=#FEAE00> eq_ref </font><font color=#FEAE00>通常用于多表联查中</font><font color=#FEAE00>。</font><br>&emsp;&emsp;除了关注 type，我们也要关注 <font color=#FEAE00>extra </font><font color=#FEAE00>显示的结果。</font><br>&emsp;&emsp;这里说几个重要的参考指标：<br>&emsp;&emsp;	•	<font color=#FEAE00>Using filesort </font>：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。<br>&emsp;&emsp;	•	<font color=#FEAE00>Using temporary</font><font color=#FEAE00>：</font>使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。<br>&emsp;&emsp;	•	<font color=#FEAE00>Using index</font><font color=#FEAE00>：</font>所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。<hr><hr>第一步：连接器<hr>如果你在 Linux 操作系统里要使用 MySQL，那你第一步肯定是要<font color=#FEAE00>先连接</font><font color=#FEAE00> MySQL </font><font color=#FEAE00>服务</font>，然后才能执行 SQL 语句，普遍我们都是使用下面这条命令进行连接：<br>&emsp;&emsp;<font color=#666666>-h </font><font color=#666666>指定</font><font color=#666666> MySQL </font><font color=#666666>服务得</font><font color=#666666> IP </font><font color=#666666>地址，如果是连接本地的</font><font color=#666666> MySQL</font><font color=#666666>服务，可以不用这个参数；</font><br>&emsp;&emsp;<font color=#666666>-u </font><font color=#666666>指定用户名，管理员角色名为</font><font color=#666666> root</font><font color=#666666>；</font><br>&emsp;&emsp;<font color=#666666>-p </font><font color=#666666>指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码</font><br>&emsp;&emsp;mysql -h<font color=#4C7F58>$ip</font> -u<font color=#4C7F58>$user</font> -p<br>&emsp;&emsp;连接的过程需要先经过 <font color=#FEAE00>TCP </font><font color=#FEAE00>三次握手</font>，因为 MySQL 是基于 TCP 协议进行传输的，如果 MySQL 服务并没有启动，则会收到如下的报错：<br>&emsp;&emsp;￼<br>&emsp;&emsp;如果 MySQL 服务正常运行，完成 TCP 连接的建立后，连接器就要开始验证你的用户名和密码，如果用户名或密码不对，就收到一个"Access denied for user"的错误，然后客户端程序结束执行。<br>&emsp;&emsp;￼<br>&emsp;&emsp;如果用户密码都没有问题，连接器就会<font color=#FEAE00>获取该用户的权限</font>，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断。<br>&emsp;&emsp;所以，如果一个用户已经建立了连接，<font color=#FEAE00>即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限</font>。修改完成后，只有再新建的连接才会使用新的权限设置。<br>&emsp;&emsp;# 如何查看 MySQL 服务被多少个客户端连接了？<br>&emsp;&emsp;如果你想知道当前 MySQL 服务被多少个客户端连接了，你可以执行 <font color=#FEAE00>show processlist</font> 命令进行查看。<br>&emsp;&emsp;￼<br>&emsp;&emsp;比如上图的显示结果，共有两个用户名为 root 的用户连接了 MySQL 服务，其中 id 为 6 的用户的 Command 列的状态为 <font color=#4D647F>Sleep</font> ，这意味着该用户连接完 MySQL 服务就没有再执行过任何命令，也就是说这是一个空闲的连接，并且空闲的时长是 736 秒（ Time 列）。<br>&emsp;&emsp;# 空闲连接会一直占用着吗？<br>&emsp;&emsp;当然不是了，MySQL 定义了<font color=#FEAE00>空闲连接的最大空闲时长</font>，由 <font color=#FEAE00>wait_timeout </font>参数控制的，默认值是<font color=#FEAE00> 8 </font><font color=#FEAE00>小时（</font><font color=#FEAE00>28880</font><font color=#FEAE00>秒）</font>，如果空闲连接超过了这个时间，连接器就会自动将它断开。<br>&emsp;&emsp;mysql<font color=#519696>></font> <font color=#5E3563>show</font> variables <font color=#519696>like</font> <font color=#4C7F58>'wait_timeout'</font>;<br>&emsp;&emsp;<font color=#519696>+</font><font color=#666666>---------------+-------+</font><br>&emsp;&emsp;<font color=#519696>|</font> Variable_name <font color=#519696>|</font> <font color=#5E3563>Value</font> <font color=#519696>|</font><br>&emsp;&emsp;<font color=#519696>+</font><font color=#666666>---------------+-------+</font><br>&emsp;&emsp;<font color=#519696>|</font> wait_timeout  <font color=#519696>|</font> <font color=#AA5925>28800</font> <font color=#519696>|</font><br>&emsp;&emsp;<font color=#519696>+</font><font color=#666666>---------------+-------+</font><br>&emsp;&emsp;<font color=#AA5925>1</font> <font color=#5E3563>row</font> <font color=#519696>in</font> <font color=#5E3563>set</font> (<font color=#AA5925>0.00</font> sec)<br>&emsp;&emsp;当然，我们自己也可以手动断开空闲的连接，使用的是 <font color=#FEAE00>kill connection + id</font> 的命令。<br>&emsp;&emsp;mysql<font color=#519696>></font> <font color=#5E3563>kill</font> connection <font color=#519696>+</font><font color=#AA5925>6</font>;<br>&emsp;&emsp;Query OK, <font color=#AA5925>0</font> <font color=#5E3563>rows</font> affected (<font color=#AA5925>0.00</font> sec)<br>&emsp;&emsp;一个处于空闲状态的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。<br>&emsp;&emsp;# MySQL 的连接数有限制吗？<br>&emsp;&emsp;MySQL 服务支持的最大连接数由 <font color=#FEAE00>max_connections</font> 参数控制，比如我的 MySQL 服务默认是 151 个,超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。<br>&emsp;&emsp;mysql<font color=#519696>></font> <font color=#5E3563>show</font> variables <font color=#519696>like</font> <font color=#4C7F58>'max_connections'</font>;<br>&emsp;&emsp;<font color=#519696>+</font><font color=#666666>-----------------+-------+</font><br>&emsp;&emsp;<font color=#519696>|</font> Variable_name   <font color=#519696>|</font> <font color=#5E3563>Value</font> <font color=#519696>|</font><br>&emsp;&emsp;<font color=#519696>+</font><font color=#666666>-----------------+-------+</font><br>&emsp;&emsp;<font color=#519696>|</font> max_connections <font color=#519696>|</font> <font color=#AA5925>151</font>   <font color=#519696>|</font><br>&emsp;&emsp;<font color=#519696>+</font><font color=#666666>-----------------+-------+</font><br>&emsp;&emsp;<font color=#AA5925>1</font> <font color=#5E3563>row</font> <font color=#519696>in</font> <font color=#5E3563>set</font> (<font color=#AA5925>0.00</font> sec)<br>&emsp;&emsp;MySQL 的连接也跟 HTTP 一样，有<font color=#FEAE00>短连接和长连接</font>的概念，它们的区别如下：<br>&emsp;&emsp;<font color=#666666>// </font><font color=#666666>短连接</font><br>&emsp;&emsp;连接 mysql 服务（TCP 三次握手）<br>&emsp;&emsp;执行sql<br>&emsp;&emsp;断开 mysql 服务（TCP 四次挥手）<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#666666>// </font><font color=#666666>长连接</font><br>&emsp;&emsp;连接 mysql 服务（TCP 三次握手）<br>&emsp;&emsp;执行sql<br>&emsp;&emsp;执行sql<br>&emsp;&emsp;执行sql<br>&emsp;&emsp;....<br>&emsp;&emsp;断开 mysql 服务（TCP 四次挥手）<br>&emsp;&emsp;可以看到，使用长连接的好处就是可以减少建立连接和断开连接的过程，所以一般是推荐使用长连接。<br>&emsp;&emsp;但是，使用长<font color=#FEAE00>连接后可能会占用内存增多</font>，因为 MySQL 在执行查询过程中<font color=#FEAE00>临时使用内存管理连接对象</font>，这些连接对象资源只有在连接断开时才会释放。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象。<br>&emsp;&emsp;# 怎么解决长连接占用内存的问题？<br>&emsp;&emsp;有两种解决方式。<br>&emsp;&emsp;第一种，<font color=#FEAE00>定期断开长连接</font>。既然断开连接后就会释放连接占用的内存资源，那么我们可以定期断开长连接。<br>&emsp;&emsp;第二种，<font color=#FEAE00>客户端主动重置连接</font>。MySQL 5.7 版本实现了 <font color=#FEAE00>mysql_reset_connection()</font> 函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。<br>&emsp;&emsp;至此，连接器的工作做完了，简单总结一下：<br>&emsp;&emsp;	•	与客户端进行 <font color=#FEAE00>TCP </font><font color=#FEAE00>三次握手</font>建立连接；<br>&emsp;&emsp;	•	<font color=#FEAE00>校验客户端的用户名和密码</font>，如果用户名或密码不对，则会报错；<br>&emsp;&emsp;	•	如果用户名和密码都对了，会<font color=#FEAE00>读取该用户的权限</font>，然后后面的权限逻辑判断都<font color=#FEAE00>基于此时读取到的权限</font>；<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>第一章：可靠性，可扩展性，可维护性<hr>现今很多应用程序都是 <font color=#FEAE00>数据密集型（</font><font color=#FEAE00>data-intensive</font>） 的，而非 <font color=#FEAE00>计算密集型（</font><font color=#FEAE00>compute-intensive</font>） 的。因此CPU很少成为这类应用的瓶颈，更大的问题通常来自数据量、数据复杂性、以及数据的变更速度。<br>&emsp;&emsp;数据密集型应用通常由标准组件构建而成，标准组件提供了很多通用的功能；例如，许多应用程序都需要：<br>&emsp;&emsp;	•	<font color=#FEAE00>存储数据</font>，以便自己或其他应用程序之后能再次找到 （数据库（database））<br>&emsp;&emsp;	•	记住开销<font color=#FEAE00>昂贵操作的结果</font>，加快读取速度（<font color=#FEAE00>缓存（</font><font color=#FEAE00>cache</font>））<br>&emsp;&emsp;	•	允许用户按<font color=#FEAE00>关键字搜索数据</font>，或以各种方式对数据进行<font color=#FEAE00>过滤</font>（<font color=#FEAE00>搜索索引（</font><font color=#FEAE00>search indexes</font><font color=#FEAE00>）</font>）<br>&emsp;&emsp;	•	向其他进程发送消息，进行<font color=#FEAE00>异步处理</font>（<font color=#FEAE00>流处理（</font><font color=#FEAE00>stream processing</font><font color=#FEAE00>）</font>）<br>&emsp;&emsp;	•	定期处理累积的大批量数据（<font color=#FEAE00>批处理（</font><font color=#FEAE00>batch processing</font><font color=#FEAE00>）</font>）<br>&emsp;&emsp;如果这些功能听上去平淡无奇，那是因为这些 <font color=#FEAE00>数据系统（</font><font color=#FEAE00>data system</font><font color=#FEAE00>）</font> 是非常成功的抽象：我们一直不假思索地使用它们并习以为常。绝大多数工程师不会幻想从零开始编写存储引擎，因为在开发应用时，数据库已经是足够完美的工具了。<br>&emsp;&emsp;但现实没有这么简单。不同的应用有着不同的需求，因而数据库系统也是百花齐放，有着各式各样的特性。实现缓存有很多种手段，创建搜索索引也有好几种方法，诸如此类。因此在开发应用前，我们依然有必要先弄清楚最适合手头工作的工具和方法。而且当单个工具解决不了你的问题时，组合使用这些工具可能还是有些难度的。<br>&emsp;&emsp;本书将是一趟关于数据系统原理、实践与应用的旅程，并讲述了设计数据密集型应用的方法。我们将探索不同工具之间的共性与特性，以及各自的实现原理。<br>&emsp;&emsp;本章将从我们所要实现的基础目标开始：<font color=#FEAE00>可靠、可扩展、可维护的数据系统。</font>我们将澄清这些词语的含义，概述考量这些目标的方法。并回顾一些后续章节所需的基础知识。在接下来的章节中我们将抽丝剥茧，研究设计数据密集型应用时可能遇到的设计决策。<hr><hr>第三步：解析 SQL<hr>	在正式执行 SQL 查询语句之前， MySQL 会先对 <font color=#FEAE00>SQL </font><font color=#FEAE00>语句做解析</font>，这个工作交由由「解析器」来完成。<br>&emsp;&emsp;# 解析器<br>&emsp;&emsp;解析器会做如下两件事情。<br>&emsp;&emsp;	第一件事情，<font color=#FEAE00>词法分析</font>。MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。<br>&emsp;&emsp;	第二件事情，<font color=#FEAE00>语法分析</font>。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否<font color=#FEAE00>满足</font><font color=#FEAE00> MySQL </font><font color=#FEAE00>语法。</font><br>&emsp;&emsp;	如果我们输入的 SQL 语句语法不对，就会在解析器这个阶段报错。比如，我下面这条查询语句，把 from 写成了 form，这时 MySQL 解析器就会给报错。<br>&emsp;&emsp;￼<br>&emsp;&emsp;	但是注意，<font color=#FEAE00>表不存在或者字段不存在</font>，并不是在解析器里做的，《MySQL 45 讲》说是在解析器做的，但是经过我和朋友看 MySQL 源码（5.7和8.0）得出结论是解析器只负责构建语法树和检查语法，但是不会去查表或者字段存不存在。<br>&emsp;&emsp;	那到底谁来做<font color=#FEAE00>检测表和字段是否存在</font>的工作呢？别急，接下来就是了。<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>第二步：<font color=#FEAE00>查询缓存</font><hr>	连接器得工作完成后，客户端就可以向 MySQL 服务发送 SQL 语句了，MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。<br>&emsp;&emsp;	如果 SQL 是查询语句（select 语句），MySQL 就会先去<font color=#FEAE00>查询缓存（</font><font color=#FEAE00> Query Cache </font><font color=#FEAE00>）</font>里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 <font color=#FEAE00>key-value </font>形式保存在内存中的，<font color=#FEAE00>key </font><font color=#FEAE00>为</font><font color=#FEAE00> SQL </font><font color=#FEAE00>查询语句，</font><font color=#FEAE00>value </font><font color=#FEAE00>为</font><font color=#FEAE00> SQL </font><font color=#FEAE00>语句查询的结果</font>。<br>&emsp;&emsp;	如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。<br>&emsp;&emsp;	这么看，查询缓存还挺有用，但是其实<font color=#FEAE00>查询缓存挺鸡肋</font>的。<br>&emsp;&emsp;	对于更新比较频繁的表，查询缓存的命中率很低的，因为只要一个<font color=#FEAE00>表有更新操作</font>，那么这个<font color=#FEAE00>表的查询缓存就会被清空</font>。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。<br>&emsp;&emsp;	所以，MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。<br>&emsp;&emsp;	对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 DEMAND。<br>&emsp;&emsp;<font color=#FEAE00>TIP</font><br>&emsp;&emsp;	这里说的查询缓存是 <font color=#FEAE00>server </font><font color=#FEAE00>层的</font>，也就是 MySQL 8.0 版本移除的是 server 层的查询缓存，并不是 <font color=#FEAE00>Innodb </font><font color=#FEAE00>存储引擎中的</font><font color=#FEAE00> buffer poll</font><font color=#FEAE00>。</font><hr><hr>第二章总结: <hr>执行一条 SQL 查询语句，期间发生了什么？<br>&emsp;&emsp;	•	<font color=#FEAE00>连接器</font>：建立连接，管理连接、校验用户身份；<br>&emsp;&emsp;	•	<font color=#FEAE00>查询缓存</font>：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；<br>&emsp;&emsp;	•	<font color=#FEAE00>解析</font><font color=#FEAE00> SQL</font>，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；<br>&emsp;&emsp;	•	<font color=#FEAE00>执行</font><font color=#FEAE00> SQL</font>：执行 SQL 共有三个阶段：<br>&emsp;&emsp;	◦	<font color=#FEAE00>预处理阶段</font>：检查表或字段是否存在；将 <font color=#4D647F>select *</font> 中的 <font color=#4D647F>*</font> 符号扩展为表上的所有列。<br>&emsp;&emsp;	◦	<font color=#FEAE00>优化阶段</font>：基于查询成本的考虑， 选择查询成本最小的执行计划；<br>&emsp;&emsp;	◦	<font color=#FEAE00>执行阶段</font>：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；<br>&emsp;&emsp;怎么样？现在再看这张图，是不是很清晰了。<br>&emsp;&emsp;￼<br>&emsp;&emsp;完！<br>&emsp;&emsp;<br>&emsp;&emsp;参考资料：<br>&emsp;&emsp;	•	《MySQL 45 讲》<br>&emsp;&emsp;	•	《MySQL是怎样运行的：从根儿上理解MySQL》<br>&emsp;&emsp;	•	https://gohalo.me/post/mysql-executor.html<br>&emsp;&emsp;	•	http://www.iskm.org/mysql56/sql__executor_8cc_source.html<br>&emsp;&emsp;	•	https://tangocc.github.io/2018/10/11/mysql-sourcecode/<hr><hr>第四步：执行 SQL<hr>经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条<font color=#FEAE00>SELECT</font> 查询语句流程主要可以分为下面这三个阶段：<br>&emsp;&emsp;	•	<font color=#FEAE00>prepare</font> 阶段，也就是<font color=#FEAE00>预处理</font>阶段；<br>&emsp;&emsp;	•	<font color=#FEAE00>optimize</font> 阶段，也就是<font color=#FEAE00>优化阶段</font>；<br>&emsp;&emsp;	•	<font color=#FEAE00>execute</font> 阶段，也就是执行阶段；<br>&emsp;&emsp;# 预处理器<br>&emsp;&emsp;我们先来说说预处理阶段做了什么事情。<br>&emsp;&emsp;	•	检查 SQL 查询语句中的<font color=#FEAE00>表或者字段是否存在</font>；<br>&emsp;&emsp;	•	将 <font color=#4D647F>select *</font> 中的 <font color=#FEAE00>* </font>符号，扩展为表上的<font color=#FEAE00>所有列</font>；<br>&emsp;&emsp;我下面这条查询语句，test 这张表是不存在的，这时 MySQL 就会在执行 SQL 查询语句的 prepare 阶段中报错。<br>&emsp;&emsp;mysql<font color=#519696>></font> <font color=#5E3563>select</font> <font color=#519696>*</font> <font color=#5E3563>from</font> test;<br>&emsp;&emsp;ERROR <font color=#AA5925>1146</font> (<font color=#AA5925>42</font>S02): <font color=#5E3563>Table</font> <font color=#4C7F58>'mysql.test'</font> doesn't exist<br>&emsp;&emsp;	这里贴个 MySQL 8.0 源码来证明表或字段是否存在的判断，不是在解析器里做的，而是在 prepare 阶段。（<font color=#7414AF>PS</font><font color=#7414AF>：下图是公众号「一树一溪」老哥帮我分析的，这位老哥专门写</font><font color=#7414AF> MySQL </font><font color=#7414AF>源码文章，感兴趣的朋友，可以微信搜索关注</font>）<br>&emsp;&emsp;￼<br>&emsp;&emsp;	上面的中间部分是 MySQL 报错表不存在时的函数调用栈，可以看到表不存在的错误是在<font color=#FEAE00>get_table_share() </font>函数里报错的，而这个函数是在 prepare 阶段调用的。<br>&emsp;&emsp;	不过，对于 MySQL 5.7 判断表或字段是否存在的工作，是在词法分析&语法分析之后，prepare 阶段之前做的。结论都一样，不是在解析器里做的。代码我就不放了，正因为 MySQL 5.7 代码结构不好，所以 <font color=#FEAE00>MySQL 8.0</font> 代码结构变化很大，后来判断表或字段是否存在的工作就被放入到 prepare 阶段做了。<br>&emsp;&emsp;# 优化器<br>&emsp;&emsp;	经过预处理阶段后，还需要为 SQL 查询语句先制定一个<font color=#FEAE00>执行计划</font>，这个工作交由「<font color=#FEAE00>优化器</font>」来完成的。<br>&emsp;&emsp;	<font color=#FEAE00>优化器主要负责将</font><font color=#FEAE00> SQL </font><font color=#FEAE00>查询语句的执行方案确定下来</font>，比如在表里面有多个索引的时候，优化器会基于<font color=#FEAE00>查询成本</font>的考虑，来决定选择<font color=#FEAE00>使用哪个索引</font>。<br>&emsp;&emsp;	当然，我们本次的查询语句（select * from product where id = 1）很简单，就是选择使用<font color=#FEAE00>主键索引</font>。<br>&emsp;&emsp;	要想知道优化器选择了哪个索引，我们可以在查询语句最前面加个 <font color=#FEAE00>explain</font> 命令，这样就会输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引，比如下图的 key 为 <font color=#FEAE00>PRIMARY</font> 就是使用了<font color=#FEAE00>主键索引</font>。<br>&emsp;&emsp;￼<br>&emsp;&emsp;	如果查询语句的执行计划里的 <font color=#FEAE00>key </font><font color=#FEAE00>为</font><font color=#FEAE00> null </font>说明<font color=#FEAE00>没有使用索引</font>，那就会<font color=#FEAE00>全表扫描（</font><font color=#FEAE00>type = ALL</font><font color=#FEAE00>）</font>，这种查询扫描的方式是效率最低档次的，如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;	这张 product 表只有一个索引就是主键，现在我在表中将 name 设置为<font color=#FEAE00>普通索引</font>（二级索引）。<br>&emsp;&emsp;￼<br>&emsp;&emsp;	这时 product 表就有<font color=#FEAE00>主键索引（</font><font color=#FEAE00>id</font><font color=#FEAE00>）</font>和<font color=#FEAE00>普通索引（</font><font color=#FEAE00>name</font><font color=#FEAE00>）</font>。假设执行了这条查询语句：<br>&emsp;&emsp;<font color=#5E3563>select</font> id <font color=#5E3563>from</font> product <font color=#5E3563>where</font> id <font color=#519696>></font> <font color=#AA5925>1</font>  <font color=#519696>and</font> name <font color=#519696>like</font> <font color=#4C7F58>'i%'</font>;<br>&emsp;&emsp;	这条查询语句的结果既可以使用主键索引，也可以使用普通索引，但是执行的效率会不同。这时，就需要优化器来决定使用哪个索引了。<br>&emsp;&emsp;	很显然这条查询语句是<font color=#FEAE00>覆盖索引</font>，直接在<font color=#FEAE00>二级索引就能查找到结果</font>（因为二级索引的 B+ 树的叶子节点的数据存储的是主键值），就没必要在主键索引查找了，因为查询主键索引的 B+ 树的成本会比查询二级索引的 B+ 的成本大，优化器基于查询成本的考虑，会选择<font color=#FEAE00>查询代价小的普通索引</font>。<br>&emsp;&emsp;	在下图中执行计划，我们可以看到，执行过程中使用了普通索引（name），Exta 为 <font color=#FEAE00>Using index</font>，这就是表明使用了覆盖索引优化。<br>&emsp;&emsp;￼<br>&emsp;&emsp;# <font color=#FEAE00>执行器</font><br>&emsp;&emsp;经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「<font color=#FEAE00>执行器</font>」完成的。在执行的过程中，执行器就会<font color=#FEAE00>和存储引擎交互</font>了，交互是<font color=#FEAE00>以记录为单位</font>的。<br>&emsp;&emsp;接下来，用<font color=#FEAE00>三种方式执行过程</font>，跟大家说一下<font color=#FEAE00>执行器和存储引擎的交互过程</font>（PS ：为了写好这一部分，特地去看 MySQL 源码，也是第一次看哈哈）。<br>&emsp;&emsp;<font color=#FEAE00>	•	</font><font color=#FEAE00>主键索引查询</font><font color=#FEAE00><br>&emsp;&emsp;	•	</font><font color=#FEAE00>全表扫描</font><font color=#FEAE00><br>&emsp;&emsp;	•	</font><font color=#FEAE00>索引下推</font><br>&emsp;&emsp;# 主键索引查询<br>&emsp;&emsp;以本文开头查询语句为例，看看执行器是怎么工作的。<br>&emsp;&emsp;<font color=#5E3563>select</font> <font color=#519696>*</font> <font color=#5E3563>from</font> product <font color=#5E3563>where</font> id <font color=#519696>=</font> <font color=#AA5925>1</font>;<br>&emsp;&emsp;这条查询语句的查询条件用到了<font color=#FEAE00>主键索引</font>，而且是<font color=#FEAE00>等值查询</font>，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用<font color=#FEAE00>访问类型为</font><font color=#FEAE00> const </font>进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的执行流程是这样的：<br>&emsp;&emsp;	•	执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，<font color=#FEAE00>把条件</font><font color=#FEAE00> id = 1 </font>交给存储引擎，<font color=#FEAE00>让存储引擎定位符合条件的第一条记录</font><font color=#FEAE00>。</font><br>&emsp;&emsp;	•	存储引擎通过主键索引的 B+ 树结构定位到 id = 1的第一条记录，如果记录是<font color=#FEAE00>不存在的</font>，就会向执行器<font color=#FEAE00>上报记录找不到的错误，然后查询结束</font>。如果记录是存在的，就会将记录返回给执行器；<br>&emsp;&emsp;	•	执行器从存储引擎读到记录后，接着<font color=#FEAE00>判断记录是否符合查询条件</font>，如果符合则发送给客户端，如果不符合则跳过该记录。<br>&emsp;&emsp;	•	执行器查询的过程<font color=#FEAE00>是一个</font><font color=#FEAE00> while </font><font color=#FEAE00>循环</font>，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 <font color=#FEAE00>read_record </font>函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被<font color=#FEAE00>指向为一个永远返回</font><font color=#FEAE00> - 1 </font><font color=#FEAE00>的函数</font>，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。<br>&emsp;&emsp;至此，这个语句就执行完成了。<br>&emsp;&emsp;# <font color=#FEAE00>全表扫描</font><br>&emsp;&emsp;举个全表扫描的例子：<br>&emsp;&emsp;select * from product where <font color=#FEAE00>name = 'iphone'</font>;<br>&emsp;&emsp;这条查询语句的查询条件没有用到索引，所以优化器决定选用访问类型为<font color=#FEAE00> ALL </font><font color=#FEAE00>进行查询</font>，也就是全表扫描的方式查询，那么这时执行器与存储引擎的执行流程是这样的：<br>&emsp;&emsp;	•	执行器第一次查询，会调用 <font color=#FEAE00>read_first_record</font> 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，<font color=#FEAE00>让存储引擎读取表中的第一条记录</font><font color=#FEAE00>；</font><br>&emsp;&emsp;	•	执行器会<font color=#FEAE00>判断读到的这条记录的</font><font color=#FEAE00> name </font><font color=#FEAE00>是不是</font><font color=#FEAE00> iphone</font>，如果不是则跳过；如果是则将记录发给客户的（是的没错，<font color=#FEAE00>Server </font><font color=#FEAE00>层每从存储引擎读到一条记录就会发送给客户端</font>，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。<br>&emsp;&emsp;	•	执行器查询的过程是一个 <font color=#FEAE00>while </font><font color=#FEAE00>循环</font>，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 all，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的<font color=#FEAE00>下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（</font><font color=#FEAE00>Server</font><font color=#FEAE00>层）</font>，执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；<br>&emsp;&emsp;	•	一直重复上述过程，直到<font color=#FEAE00>存储引擎把表中的所有记录读完</font>，然后向执行器（Server层） 返回了读取完毕的信息；<br>&emsp;&emsp;	•	执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。<br>&emsp;&emsp;至此，这个语句就执行完成了。<br>&emsp;&emsp;# 索引下推<br>&emsp;&emsp;在这部分非常适合讲<font color=#FEAE00>索引下推</font>（MySQL 5.6 推出的查询优化策略），这样大家能清楚的知道，「下推」这个动作，下推到了哪里。<br>&emsp;&emsp;索引下推能够减少<font color=#FEAE00>二级索引</font>在查询时的<font color=#FEAE00>回表操作</font>，提高查询的效率，因为它将 <font color=#FEAE00>Server </font><font color=#FEAE00>层部分负责的事情，交给存储引擎层去处理了</font>。<br>&emsp;&emsp;举一个具体的例子，方便大家理解，这里一张用户表如下，我对 age 和 reward 字段建立了<font color=#FEAE00>联合索引（</font><font color=#FEAE00>age</font><font color=#FEAE00>，</font><font color=#FEAE00>reward</font><font color=#FEAE00>）</font>：<br>&emsp;&emsp;￼<br>&emsp;&emsp;现在有下面这条查询语句：<br>&emsp;&emsp;<font color=#5E3563>select</font> <font color=#519696>*</font> <font color=#5E3563>from</font> t_user  <font color=#5E3563>where</font> age <font color=#519696>></font> <font color=#AA5925>20</font> <font color=#519696>and</font> reward <font color=#519696>=</font> <font color=#AA5925>100000</font>;<br>&emsp;&emsp;联合索引当遇到范围查询 (>、<、between、like) 就会停止匹配，也就是 <font color=#FEAE00>age </font><font color=#FEAE00>字段能用到联合索引，但是</font><font color=#FEAE00> reward </font><font color=#FEAE00>字段则无法利用到索引</font><font color=#FEAE00>。</font>具体原因这里可以看这篇：<font color=#FEAE00>索引常见面试题</font><font color=#5478F6><br>&emsp;&emsp;	</font>那么，<font color=#FEAE00>不使用索引下推</font>（MySQL 5.6 之前的版本）时，执行器与存储引擎的执行流程是这样的：<br>&emsp;&emsp;	•	Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是<font color=#FEAE00>定位到</font><font color=#FEAE00> age > 20 </font><font color=#FEAE00>的第一条记录；</font><br>&emsp;&emsp;	•	存储引起根据二级索引的 B+ 树快速定位到这条记录后，获取主键值，然后<font color=#FEAE00>进行回表操作</font>，将完整的记录返回给 Server 层；<br>&emsp;&emsp;	•	Server 层在判断该记录的 <font color=#FEAE00>reward </font><font color=#FEAE00>是否等于</font><font color=#FEAE00> 100000</font>，如果成立则将其发送给客户端；否则跳过该记录；<br>&emsp;&emsp;	•	接着，继续向存储引擎索要<font color=#FEAE00>下一条记录</font>，存储引擎在二级索引定位到记录后，获取主键值，然后回表操作，将完整的记录返回给 Server 层；<br>&emsp;&emsp;	•	<font color=#FEAE00>如此往复</font>，直到存储引擎把表中的所有记录读完。<br>&emsp;&emsp;可以看到，没有索引下推的时候，每查询到一条二级索引记录，<font color=#FEAE00>都要进行回表操作</font>，然后将记录返回给 Server，接着 Server 再判断该记录的 reward 是否等于 100000。<br>&emsp;&emsp;	而使用索引下推后，判断记录的 reward 是否等于 100000 的工作<font color=#FEAE00>交给了存储引擎层</font>，过程如下 ：<br>&emsp;&emsp;	•	Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age > 20 的第一条记录；<br>&emsp;&emsp;	•	存储引擎定位到二级索引后，<font color=#FEAE00>先不执行回表</font>操作，而是先判断一下该索引中包含的<font color=#FEAE00>列（</font><font color=#FEAE00>reward</font><font color=#FEAE00>列）的条件（</font><font color=#FEAE00>reward </font><font color=#FEAE00>是否等于</font><font color=#FEAE00> 100000</font><font color=#FEAE00>）是否成立</font>。如果<font color=#FEAE00>条件不成立</font>，则直接<font color=#FEAE00>跳过该二级索引</font>。如果<font color=#FEAE00>成立</font>，则<font color=#FEAE00>执行回表</font>操作，将完成记录返回给 Server 层。<br>&emsp;&emsp;	•	<font color=#FEAE00>Server </font><font color=#FEAE00>层在判断其他的查询条件</font>（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。<br>&emsp;&emsp;	•	如此往复，直到存储引擎把表中的所有记录读完。<br>&emsp;&emsp;可以看到，使用了索引下推后，虽然 reward 列无法使用到联合索引，<font color=#FEAE00>但是因为它包含在联合索引（</font><font color=#FEAE00>age</font><font color=#FEAE00>，</font><font color=#FEAE00>reward</font><font color=#FEAE00>）里</font>，所以直接在存储引擎过滤出满足 reward = 100000 的记录后，<font color=#FEAE00>才去执行回表操作获取整个记录</font>。相比于没有使用索引下推，节省了很多回表操作。<br>&emsp;&emsp;当你发现执行计划里的 Extr 部分显示了 “<font color=#FEAE00>Using index condition</font>”，说明使用了<font color=#FEAE00>索引下推</font>。<br>&emsp;&emsp;￼<br>&emsp;&emsp;<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>索引<font color=#FEAE00>存储结构</font>长什么样？<hr>	我们先来看看<font color=#FEAE00>索引存储结构</font>长什么样？因为只有知道索引的存储结构，才能更好的理解索引失效的问题。<br>&emsp;&emsp;	索引的存储结构跟 MySQL 使用<font color=#FEAE00>哪种存储引</font>擎有关，因为存储引擎就是负责将数据持久化在磁盘中，而不同的存储引擎采用的索引数据结构也会不相同。<br>&emsp;&emsp;	MySQL 默认的存储引擎是 InnoDB，它采用 B+Tree 作为索引的数据结构，至于为什么选择 B+ 树作为索引的数据结构 ，详细的分析可以看我这篇文章：<font color=#FEAE00>为什么</font><font color=#FEAE00> MySQL </font><font color=#FEAE00>喜欢</font><font color=#FEAE00> B+ </font><font color=#FEAE00>树？</font><font color=#5478F6><br>&emsp;&emsp;	</font>在创建表时，InnoDB 存储引擎默认会创建一个<font color=#FEAE00>主键索引</font>，也就是聚簇索引，其它索引都属于二级索引。<br>&emsp;&emsp;	MySQL 的 MyISAM 存储引擎支持多种索引数据结构，比如 <font color=#FEAE00>B+ </font><font color=#FEAE00>树索引、</font><font color=#FEAE00>R </font><font color=#FEAE00>树索引、</font><font color=#FEAE00>Full-Text </font><font color=#FEAE00>索引</font>。MyISAM 存储引擎在创建表时，创建的主键索引默认使用的是 B+ 树索引。<br>&emsp;&emsp;虽然，InnoDB 和 MyISAM 都支持 B+ 树索引，但是它们数据的存储结构实现方式不同。不同之处在于：<br>&emsp;&emsp;	•	InnoDB 存储引擎：B+ 树索引的<font color=#FEAE00>叶子节点保存数据本身；</font><br>&emsp;&emsp;	•	MyISAM 存储引擎：B+ 树索引的<font color=#FEAE00>叶子节点保存数据的物理地址；</font><br>&emsp;&emsp;	接下来，我举个例子，给大家展示下这两种存储引擎的索引存储结构的区别。<br>&emsp;&emsp;	这里有一张 t_user 表，其中 id 字段为主键索引，其他都是普通字段。<br>&emsp;&emsp;￼<br>&emsp;&emsp;	如果使用的是 MyISAM 存储引擎，B+ 树索引的叶子节点保存数据的物理地址，即用户数据的指针，如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;	如果使用的是 InnoDB 存储引擎， B+ 树索引的叶子节点保存数据本身，如下图所示：<br>&emsp;&emsp;￼<br>&emsp;&emsp;	InnoDB 存储引擎根据索引类型不同，分为<font color=#FEAE00>聚簇索引（上图就是聚簇索引）和二级索引</font>。它们区别在于，聚簇索引的叶子节点存放的是<font color=#FEAE00>实际数据</font>，所有完整的用户数据都存放在聚簇索引的叶子节点，而二级索引的叶子节点存放的是主键值，而不是实际数据。<br>&emsp;&emsp;	如果将 name 字段设置为普通索引，那么这个二级索引长下图这样，叶子节点仅存放主键值。<br>&emsp;&emsp;￼<br>&emsp;&emsp;	知道了 InnoDB 存储引擎的聚簇索引和二级索引的存储结构后，接下来举几个查询语句，说下查询过程是怎么选择用哪个索引类型的。<br>&emsp;&emsp;	在我们使用「<font color=#FEAE00>主键索引</font>」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么就会在「聚簇索引」中的 B+ 树检索到对应的叶子节点，然后直接读取要查询的数据。如下面这条语句：<br>&emsp;&emsp;// id 字段为主键索引<br>&emsp;&emsp;select * from t_user where id=1;<br>&emsp;&emsp;在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据都在「聚簇索引」的叶子节点里，那么需要检索两颗B+树：<br>&emsp;&emsp;	•	先在「二级索引」的 B+ 树找到对应的叶子节点，获取主键值；<br>&emsp;&emsp;	•	然后用上一步获取的主键值，在「聚簇索引」中的 B+ 树检索到对应的叶子节点，然后获取要查询的数据。<br>&emsp;&emsp;上面这个过程叫做<font color=#FEAE00>回表</font>，如下面这条语句：<br>&emsp;&emsp;// name 字段为二级索引<br>&emsp;&emsp;select * from t_user where name="林某";<br>&emsp;&emsp;	在我们使用「二级索引」字段作为条件查询的时候，如果要查询的数据在「二级索引」的叶子节点，那么只需要在「二级索引」的 B+ 树找到对应的叶子节点，然后读取要查询的数据，这个过程叫做<font color=#FEAE00>覆盖索引</font>。如下面这条语句：<br>&emsp;&emsp;// name 字段为二级索引<br>&emsp;&emsp;select id from t_user where name="林某";<br>&emsp;&emsp;	上面这些查询语句的条件都用到了索引列，所以在查询过程都用上了索引。<br>&emsp;&emsp;	但是并不意味着，查询条件用上了索引列，就查询过程就一定都用上索引，接下来我们再一起看看哪些情况会导致索引失效，而发生全表扫描。<br>&emsp;&emsp;首先说明下，下面的实验案例，我使用的 MySQL 版本为 <font color=#4D647F>8.0.26</font>。<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>索引总结<hr>总结<br>&emsp;&emsp;这次主要介绍了<font color=#FEAE00>索引的原理、分类和使用。</font>我把重点总结在了下面这个表格<br>&emsp;&emsp;￼<hr><hr>索引按<font color=#FEAE00>字段个数</font>分类<br>&emsp;&emsp;<br>&emsp;&emsp;<hr>联合索引: 多个字段, 最左匹配原则, 索引下推优化, <br>&emsp;&emsp;单列索引: 文件排序<br>&emsp;&emsp;---<br>&emsp;&emsp;从字段个数的角度来看，索引分为<font color=#FEAE00>单列索引、联合索引（复合索引）</font>。<br>&emsp;&emsp;	•	建立在单列上的索引称为单列索引，比如主键索引；<br>&emsp;&emsp;	•	建立在多列上的索引称为联合索引；<br>&emsp;&emsp;# 联合索引<br>&emsp;&emsp;通过将<font color=#FEAE00>多个字段</font>组合成一个索引，该索引就被称为联合索引。比如将商品表中的 product_no 和 name 字段组合成联合索引<font color=#4D647F>(product_no, name)</font>，创建联合索引的方式如下：<br>&emsp;&emsp;<font color=#5E3563>CREATE</font> <font color=#5E3563>INDEX</font> index_product_no_name <font color=#5E3563>ON</font> product(product_no, name);<br>&emsp;&emsp;<font color=#FEAE00>联合索引</font><font color=#4D647F>(product_no, name)</font> 的 B+Tree 示意图如下：<br>&emsp;&emsp;￼<br>&emsp;&emsp;可以看到，<font color=#FEAE00>联合索引</font>的非叶子节点用两个字段的值作为 B+Tree 的 key 值。当在联合索引查询数据时，先按 product_no 字段比较，在 product_no 相同的情况下再按 name 字段比较。<br>&emsp;&emsp;也就是说，联合索引查询的 B+Tree 是<font color=#FEAE00>先按</font><font color=#FEAE00> product_no </font><font color=#FEAE00>进行排序</font>，然后再 product_no 相同的情况再按 name 字段排序。因此，使用联合索引时，存在<font color=#FEAE00>最左匹配原则</font>，也就是按照最左优先的方式进行索引的匹配。<br>&emsp;&emsp;比如，如果创建了一个 <font color=#4D647F>(a, b, c)</font> 联合索引，如果查询条件是以下这几种，就可以<font color=#FEAE00>匹配上联合索引</font>：<br>&emsp;&emsp;	•	where a=1；<br>&emsp;&emsp;	•	where a=1 and b=2 and c=3；<br>&emsp;&emsp;	•	where a=1 and b=2；<br>&emsp;&emsp;需要注意的是，<font color=#FEAE00>因为有查询优化器</font>，所以 a 字段在 where 子句的<font color=#FEAE00>顺序并不重要</font>。<br>&emsp;&emsp;但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:<br>&emsp;&emsp;	•	where b=2；<br>&emsp;&emsp;	•	where c=3；<br>&emsp;&emsp;	•	where b=2 and c=3；<br>&emsp;&emsp;上面这些查询条件之所以<font color=#FEAE00>会失效</font>，是因为<font color=#4D647F>(a, b, c)</font> 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，<font color=#FEAE00>b </font><font color=#FEAE00>和</font><font color=#FEAE00> c </font><font color=#FEAE00>是全局无序，局部相对有序的</font>，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。<br>&emsp;&emsp;我这里举联合索引（a，b）的例子，该联合索引的 B+ Tree 如下：<br>&emsp;&emsp;￼<br>&emsp;&emsp;	可以看到，a 是全局有序的（1, 2, 2, 3, 4, 5, 6, 7 ,8），而 b 是全局是无序的（12，7，8，2，3，8，10，5，2）。因此，直接执行<font color=#4D647F>where b = 2</font>这种查询条件没有办法利用联合索引的，<font color=#FEAE00>利用索引的前提是索引里的</font><font color=#FEAE00> key </font><font color=#FEAE00>是有序的</font><font color=#FEAE00>。</font><br>&emsp;&emsp;	只有在 a 相同的情况才，b 才是有序的，比如 a 等于 2 的时候，b 的值为（7，8），这时就是有序的，这个有序状态是局部的，因此，执行<font color=#4D647F>where a = 2 and b = 7</font>是 a 和 b 字段能用到联合索引的，也就是联合索引生效了。<br>&emsp;&emsp;	但是，如果执行<font color=#4D647F>where a > 1 and b = 2</font>时，a 字段能用到联合索引，而 b 字段用不到联合索引。<font color=#FEAE00>因为</font><font color=#FEAE00> a </font><font color=#FEAE00>的值此时是一个范围，不是固定的，在这个范围内</font><font color=#FEAE00> b </font><font color=#FEAE00>值不是有序的，因此</font><font color=#FEAE00> b </font><font color=#FEAE00>字段用不上联合索引</font><font color=#FEAE00>。</font><br>&emsp;&emsp;	综上所示，<font color=#FEAE00>联合索引的最左匹配原则，在遇到范围查询（</font><font color=#FEAE00>></font><font color=#FEAE00>、</font><font color=#FEAE00><</font><font color=#FEAE00>、</font><font color=#FEAE00>between</font><font color=#FEAE00>、</font><font color=#FEAE00>like </font><font color=#FEAE00>包括</font><font color=#FEAE00>like '</font><font color=#FEAE00>林</font><font color=#FEAE00>%'</font><font color=#FEAE00>这种）的时候，就会停止匹配，也就是范围列可以用到联合索引，但是范围列后面的列无法用到联合索引</font><font color=#FEAE00>。</font><font color=#FEAE00><br>&emsp;&emsp;</font><br>&emsp;&emsp;现在我们知道，对于联合索引（a, b），在执行 <font color=#4D647F>select * from table where a > 1 and b = 2</font> 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？<br>&emsp;&emsp;	•	在 MySQL 5.6 之前，<font color=#FEAE00>只能从</font><font color=#FEAE00> ID2 </font><font color=#FEAE00>（主键值）开始一个个回表，到「主键索引」上找出数据行，再对比</font><font color=#FEAE00> b </font><font color=#FEAE00>字段值。</font><br>&emsp;&emsp;	•	而 MySQL 5.6 引入的<font color=#FEAE00>索引下推优化</font>（index condition pushdown)， <font color=#FEAE00>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</font><font color=#FEAE00>。</font><br>&emsp;&emsp;当你的查询语句的执行计划里，出现了 <font color=#FEAE00>Extra </font><font color=#FEAE00>为</font><font color=#FEAE00> Using index condition</font>，那么说明使用了索引下推的优化。<br>&emsp;&emsp;另外，建立联合索引时的字段顺序，对索引效率也有很大影响。<font color=#1DB100>越靠前的字段</font>被用于<font color=#FEAE00>索引过滤的概率越高</font>，实际开发工作中<font color=#00A2FF>建立联合索引时，要把</font><font color=#FEAE00>区分度大的字段</font><font color=#00A2FF>排在前面，这样区分度大的字段越有可能被更多的</font><font color=#00A2FF> SQL </font><font color=#00A2FF>使用到</font><font color=#00A2FF>。</font><br>&emsp;&emsp;区分度就是某个字段 column 不同值的个数「除以」表的总行数，计算公式如下：<br>&emsp;&emsp;￼<br>&emsp;&emsp;比如，性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，而 UUID 这类字段就比较适合做索引或排在联合索引列的靠前的位置。<br>&emsp;&emsp;因为如果索引的区分度很小，假设字段的值分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 <font color=#FEAE00>MySQL </font><font color=#FEAE00>还有一个查询优化器</font>，查询优化器发现某个值出现在表的数据行中的<font color=#FEAE00>百分比</font>（惯用的百分比界线是"30%"）很高的时候，它一般会<font color=#FEAE00>忽略索引</font>，进行全表扫描。<br>&emsp;&emsp;这里出一个题目，针对针对下面这条 SQL，你怎么通过索引来提高查询效率呢？<br>&emsp;&emsp;<font color=#5E3563>select</font> <font color=#519696>*</font> <font color=#5E3563>from</font> <font color=#5E3563>order</font> <font color=#5E3563>where</font> <font color=#5E3563>status</font> <font color=#519696>=</font> <font color=#AA5925>1</font> <font color=#5E3563>order</font> <font color=#5E3563>by</font> create_time <font color=#5E3563>asc</font><br>&emsp;&emsp;有的同学会认为，单独给 status 建立一个索引就可以了。<br>&emsp;&emsp;	但是更好的方式给 status 和 create_time 列建立一个联合索引，因为这样可以<font color=#FEAE00>避免</font><font color=#FEAE00> MySQL </font><font color=#FEAE00>数据库发生文件排序</font>。<br>&emsp;&emsp;因为在查询时，如果只用到 status 的索引，但是这条语句还要对 create_time 排序，这时就要用<font color=#FEAE00>文件排序</font><font color=#FEAE00> filesort</font>，也就是在 SQL 执行计划中，Extra 列会出现 <font color=#FEAE00>Using filesort</font><font color=#FEAE00>。</font><br>&emsp;&emsp;	所以，要利用索引的有序性，在 status 和 create_time 列建立联合索引，这样根据 status 筛选后的数据就是按照 create_time 排好序的，<font color=#FEAE00>避免在文件排序，提高了查询效率。</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>索引的<font color=#FEAE00>分类</font><font color=#FEAE00><br>&emsp;&emsp;</font>按照四个类别来分类<hr>	你知道索引有哪些吗？大家肯定都能霹雳啪啦地说出聚簇索引、主键索引、二级索引、普通索引、唯一索引、hash索引、B+树索引等等。<br>&emsp;&emsp;	然后再问你，你能将这些索引分一下类吗？可能大家就有点模糊了。其实，要对这些索引进行分类，要清楚这些索引的使用和实现方式，然后再针对有相同特点的索引归为一类。<br>&emsp;&emsp;我们可以按照四个角度来分类索引。<br>&emsp;&emsp;	•	按「<font color=#00AB8E>数据结构</font>」分类：<font color=#FEAE00>B+tree</font><font color=#FEAE00>索引、</font><font color=#FEAE00>Hash</font><font color=#FEAE00>索引、</font><font color=#FEAE00>Full-text</font><font color=#FEAE00>索引</font><font color=#FEAE00>。</font><br>&emsp;&emsp;	•	按「<font color=#00AB8E>物理存储</font>」分类：<font color=#FEAE00>聚簇索引（主键索引）、二级索引（辅助索引）</font><font color=#FEAE00>。</font><br>&emsp;&emsp;	•	按「<font color=#00AB8E>字段特性</font>」分类：<font color=#FEAE00>主键索引、唯一索引、普通索引、前缀索引</font><font color=#FEAE00>。</font><br>&emsp;&emsp;	•	按「<font color=#00AB8E>字段个数</font>」分类：<font color=#FEAE00>单列索引、联合索引</font><font color=#FEAE00>。</font><br>&emsp;&emsp;接下来，按照这些角度来说说各类索引的特点。<hr><hr>联合索引<font color=#FEAE00>非最左匹配</font><hr>	对主键字段建立的索引叫做<font color=#FEAE00>聚簇索引</font>，对普通字段建立的索引叫做二级索引。<br>&emsp;&emsp;那么<font color=#FEAE00>多个普通字段组合在一起创建的索引就叫做联合索引</font>，也叫组合索引。<br>&emsp;&emsp;创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。<br>&emsp;&emsp;联合索引要能正确使用需要遵循<font color=#FEAE00>最左匹配原则</font>，也就是按照最左优先的方式进行索引的匹配。<br>&emsp;&emsp;比如，如果创建了一个 <font color=#4D647F>(a, b, c)</font> 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：<br>&emsp;&emsp;	•	where a=1；<br>&emsp;&emsp;	•	where a=1 and b=2 and c=3；<br>&emsp;&emsp;	•	where a=1 and b=2；<br>&emsp;&emsp;需要注意的是，因为有<font color=#FEAE00>查询优化器</font>，所以 a 字段在 where 子句的顺序并不重要。<br>&emsp;&emsp;但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:<br>&emsp;&emsp;	•	where b=2；<br>&emsp;&emsp;	•	where c=3；<br>&emsp;&emsp;	•	where b=2 and c=3；<br>&emsp;&emsp;有一个比较特殊的查询条件：where a = 1 and c = 3 ，符合最左匹配吗？<br>&emsp;&emsp;这种其实严格意义上来说是属于<font color=#FEAE00>索引截断</font>，不同版本处理方式也不一样。<br>&emsp;&emsp;MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行，然后再比对 c 字段的值。<br>&emsp;&emsp;从 MySQL 5.6 之后，有一个<font color=#FEAE00>索引下推功能</font>，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。<br>&emsp;&emsp;大概原理是：<font color=#FEAE00>截断的字段会被下推到存储引擎层进行条件判断</font>（因为 c 字段的值是在 <font color=#4D647F>(a, b, c)</font> 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在<font color=#FEAE00>引擎层就过滤掉大量的数据</font>，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。<br>&emsp;&emsp;比如下面这条 where a = 1 and c = 0 语句，我们可以从执行计划中的 <font color=#FEAE00>Extra=Using index condition</font> 使用了索引下推功能。<br>&emsp;&emsp;￼<br>&emsp;&emsp;为什么联合索引不遵循最左匹配原则就会失效？<br>&emsp;&emsp;原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。<br>&emsp;&emsp;也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列<font color=#FEAE00>必须是联合索引中从最左边开始连续的列</font>。如果我们仅仅按照第二列搜索，肯定无法走索引。<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>聚簇索引和二级索引<hr>另外，索引又可以分成<font color=#FEAE00>聚簇索引</font>和<font color=#FEAE00>非聚簇索引（二级索引）</font>，它们区别就在于<font color=#FEAE00>叶子节点存放的是什么数据</font>：<br>&emsp;&emsp;	•	聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；<br>&emsp;&emsp;	•	二级索引的叶子节点存放的是主键值，而不是实际数据。<br>&emsp;&emsp;	因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎<font color=#FEAE00>一定会为表创建一个聚簇索引</font>，且由于数据在物理上只会保存一份，所以聚簇索引<font color=#FEAE00>只能有一个</font>。<br>&emsp;&emsp;InnoDB 在创建聚簇索引时，会根据不同的场景选择<font color=#FEAE00>不同的列作为索引</font>：<br>&emsp;&emsp;	•	如果有主键，<font color=#FEAE00>默认会使用主键</font>作为聚簇索引的索引键；<br>&emsp;&emsp;	•	如果没有主键，就选择<font color=#FEAE00>第一个不包含</font><font color=#FEAE00> NULL </font><font color=#FEAE00>值</font>的唯一列作为聚簇索引的索引键；<br>&emsp;&emsp;	•	在上面两个都没有的情况下，InnoDB 将自动<font color=#FEAE00>生成一个隐式自增</font><font color=#FEAE00> id </font>列作为聚簇索引的索引键；<br>&emsp;&emsp;	一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了<font color=#FEAE00>二级索引（非聚簇索引</font><font color=#FEAE00>/</font><font color=#FEAE00>辅助索引）</font>，它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。<br>&emsp;&emsp;二级索引的 B+ 树如下图，数据部分为主键值：<br>&emsp;&emsp;￼<br>&emsp;&emsp;因此，<font color=#FEAE00>如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「</font><font color=#00AB8E>回表</font><font color=#FEAE00>」，也就是说要查两个</font><font color=#FEAE00> B+ </font><font color=#FEAE00>树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「</font><font color=#00AB8E>索引覆盖</font><font color=#FEAE00>」，也就是只需要查一个</font><font color=#FEAE00> B+ </font><font color=#FEAE00>树就能找到数据。</font><br>&emsp;&emsp;<hr><hr><font color=#FEAE00>行级锁</font><hr>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持<font color=#FEAE00>行级锁。</font><br>&emsp;&emsp;行级锁的类型主要有三类：<br>&emsp;&emsp;	•	<font color=#FEAE00>Record Lock</font><font color=#FEAE00>，记录锁</font>，也就是仅仅把一条记录锁上；<br>&emsp;&emsp;	•	<font color=#FEAE00>Gap Lock</font><font color=#FEAE00>，间隙锁</font>，锁定一个范围，但是不包含记录本身；<br>&emsp;&emsp;	•	<font color=#FEAE00>Next-Key Lock</font><font color=#FEAE00>：</font><font color=#FEAE00>Record Lock + Gap Lock </font><font color=#FEAE00>的组合</font>，锁定一个范围，并且锁定记录本身。<br>&emsp;&emsp;前面也提到，普通的 select 语句是不会对记录加锁的，如果要在查询时对记录加行锁，可以使用下面这两个方式：<br>&emsp;&emsp;<font color=#666666>//</font><font color=#666666>对读取的记录加共享锁</font><br>&emsp;&emsp;<font color=#5E3563>select</font> ... <font color=#5E3563>lock</font> <font color=#519696>in</font> <font color=#5E3563>share</font> <font color=#5E3563>mode</font>;<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#666666>//</font><font color=#666666>对读取的记录加独占锁</font><br>&emsp;&emsp;<font color=#5E3563>select</font> ... <font color=#5E3563>for</font> <font color=#5E3563>update</font>;<br>&emsp;&emsp;上面这两条语句必须在一个事务中，<font color=#FEAE00>因为当事务提交了，锁就会被释放</font>，所以在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit = 0。<br>&emsp;&emsp;那具体跟在哪些纪录上加锁，就跟具体的 select 语句有关系了，比较复杂，这个留到下篇再讲啦。<br>&emsp;&emsp;参考资料：《MySQL技术内幕：innodb》、《MySQL实战45讲》、《从根儿上理解MySQL》。<hr><hr><font color=#FEAE00>表级锁</font><hr>MySQL <font color=#FEAE00>表级锁</font>有哪些？具体怎么用的。<br>&emsp;&emsp;MySQL 里面表级别的锁有这几种：<br>&emsp;&emsp;<font color=#FEAE00>	•	</font><font color=#FEAE00>表锁；</font><font color=#FEAE00><br>&emsp;&emsp;	•	</font><font color=#FEAE00>元数据锁（</font><font color=#FEAE00>MDL</font><font color=#FEAE00>）</font><font color=#FEAE00>;<br>&emsp;&emsp;	•	</font><font color=#FEAE00>意向锁；</font><font color=#FEAE00><br>&emsp;&emsp;	•	AUTO-INC </font><font color=#FEAE00>锁；</font><br>&emsp;&emsp;# 表锁<br>&emsp;&emsp;先来说说<font color=#FEAE00>表锁</font>。<br>&emsp;&emsp;如果我们想对学生表（t_student）加表锁，可以使用下面的命令：<br>&emsp;&emsp;<font color=#666666>//</font><font color=#666666>表级别的</font><font color=#FEAE00>共享锁</font><font color=#666666>，也就是读锁；</font><br>&emsp;&emsp;<font color=#5E3563>lock</font> <font color=#5E3563>tables</font> t_student <font color=#5E3563>read</font>;<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#666666>//</font><font color=#666666>表级别的</font><font color=#FEAE00>独占锁</font><font color=#666666>，也就是写锁；</font><br>&emsp;&emsp;<font color=#5E3563>lock</font> <font color=#5E3563>tables</font> t_stuent <font color=#5E3563>write</font>;<br>&emsp;&emsp;需要注意的是，表锁除了会限制别的线程的读写外，也会<font color=#FEAE00>限制本线程接下来的读写操作。</font><br>&emsp;&emsp;也就是说如果本线程对学生表加了「<font color=#FEAE00>共享表锁</font>」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。<br>&emsp;&emsp;要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：<br>&emsp;&emsp;<font color=#5E3563>unlock</font> <font color=#5E3563>tables</font><br>&emsp;&emsp;另外，当会话退出后，也会释放所有表锁。<br>&emsp;&emsp;不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，<font color=#FEAE00>InnoDB </font><font color=#FEAE00>牛逼的地方在于实现了颗粒度更细的行级锁</font><font color=#FEAE00>。</font><br>&emsp;&emsp;# 元数据锁<br>&emsp;&emsp;再来说说<font color=#FEAE00>元数据锁</font><font color=#FEAE00>（</font><font color=#FEAE00>MDL</font><font color=#FEAE00>）。</font><br>&emsp;&emsp;我们不需要显式的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个<font color=#FEAE00>表加上</font><font color=#FEAE00> MDL</font>：<br>&emsp;&emsp;	•	对一张表进行 CRUD 操作时，加的是<font color=#FEAE00> </font><font color=#FEAE00>MDL </font><font color=#FEAE00>读锁</font>；<br>&emsp;&emsp;	•	对一张表做结构变更操作的时候，加的是 <font color=#FEAE00>MDL </font><font color=#FEAE00>写锁</font>；<br>&emsp;&emsp;MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。<br>&emsp;&emsp;当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。<br>&emsp;&emsp;反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 <font color=#FEAE00>CRUD </font><font color=#FEAE00>操作</font>（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。<br>&emsp;&emsp;# MDL 不需要显示调用，那它是在什么时候释放的?<br>&emsp;&emsp;MDL 是在<font color=#FEAE00>事务提交后才会释放</font>，这意味着<font color=#FEAE00>事务执行期间，</font><font color=#FEAE00>MDL </font><font color=#FEAE00>是一直持有的</font><font color=#FEAE00>。</font><br>&emsp;&emsp;那如果数据库有一个<font color=#FEAE00>长事务</font>（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：<br>&emsp;&emsp;	1	首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；<br>&emsp;&emsp;	2	然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；<br>&emsp;&emsp;	3	接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，<font color=#FEAE00>这时线程</font><font color=#FEAE00> C </font><font color=#FEAE00>就无法申请到</font><font color=#FEAE00> MDL </font><font color=#FEAE00>写锁，就会被阻塞，</font><br>&emsp;&emsp;那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。<br>&emsp;&emsp;# 为什么线程 C 因为申请不到 MDL 写锁，而导致<font color=#FEAE00>后续的申请读锁</font>的查询操作也会被阻塞？<br>&emsp;&emsp;这是因为申请 MDL 锁的操作会形成一个队列，队列中<font color=#FEAE00>写锁获取优先级高于读锁</font>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。<br>&emsp;&emsp;所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑<font color=#FEAE00> kill </font><font color=#FEAE00>掉这个长事务</font>，然后再做表结构的变更。<br>&emsp;&emsp;# 意向锁<br>&emsp;&emsp;接着，说说<font color=#FEAE00>意向锁</font><font color=#FEAE00>。</font><br>&emsp;&emsp;	•	在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「<font color=#FEAE00>意向共享锁</font>」；<br>&emsp;&emsp;	•	在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「<font color=#FEAE00>意向独占锁</font>」；<br>&emsp;&emsp;也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。<br>&emsp;&emsp;而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。<br>&emsp;&emsp;不过，select 也是可以对记录加<font color=#FEAE00>共享锁和独占锁的</font>，具体方式如下：<br>&emsp;&emsp;<font color=#666666>//</font><font color=#666666>先在表上加上意向共享锁，然后对读取的记录加共享锁</font><br>&emsp;&emsp;<font color=#5E3563>select</font> ... <font color=#5E3563>lock</font> <font color=#519696>in</font> <font color=#5E3563>share</font> <font color=#5E3563>mode</font>;<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#666666>//</font><font color=#666666>先表上加上意向独占锁，然后对读取的记录加独占锁</font><br>&emsp;&emsp;<font color=#5E3563>select</font> ... <font color=#5E3563>for</font> <font color=#5E3563>update</font>;<br>&emsp;&emsp;<font color=#FEAE00>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（</font><font color=#7414AF>lock tables ... read</font><font color=#FEAE00>）和独占表锁（</font><font color=#7414AF>lock tables ... write</font><font color=#FEAE00>）发生冲突。</font><br>&emsp;&emsp;表锁和行锁是满足<font color=#FEAE00>读读共享、读写互斥、写写互斥</font>的。<br>&emsp;&emsp;如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。<br>&emsp;&emsp;那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。<br>&emsp;&emsp;所以，<font color=#FEAE00>意向锁的目的是为了快速判断表里是否有记录被加锁</font><font color=#FEAE00>。</font><br>&emsp;&emsp;# AUTO-INC 锁<br>&emsp;&emsp;最后，说说 <font color=#FEAE00>AUTO-INC </font><font color=#FEAE00>锁</font><font color=#FEAE00>。</font><br>&emsp;&emsp;在为某个字段声明 <font color=#4D647F>AUTO_INCREMENT</font> 属性时，之后可以在插入数据时，可以不指定该字段的值，数据库会自动给该字段赋值递增的值，这主要是通过 AUTO-INC 锁实现的。<br>&emsp;&emsp;AUTO-INC 锁是特殊的表锁机制，<font color=#FEAE00>锁</font><font color=#FEAE00>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</font><font color=#FEAE00>。</font><font color=#FEAE00><br>&emsp;&emsp;</font><font color=#FEAE00>在插入数据时，会加一个表级别的</font><font color=#FEAE00> AUTO-INC </font><font color=#FEAE00>锁</font><font color=#FEAE00>，</font>然后为被 <font color=#4D647F>AUTO_INCREMENT</font> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。<br>&emsp;&emsp;那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 <font color=#4D647F>AUTO_INCREMENT</font> 修饰的字段的值是连续递增的。<br>&emsp;&emsp;但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。<br>&emsp;&emsp;因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<font color=#FEAE00>轻量级的锁</font>来实现自增。<br>&emsp;&emsp;一样也是在插入数据的时候，会为被 <font color=#4D647F>AUTO_INCREMENT</font> 修饰的字段加上轻量级锁，<font color=#FEAE00>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</font><font color=#FEAE00>。</font><br>&emsp;&emsp;InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。<br>&emsp;&emsp;	•	当 innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁；<br>&emsp;&emsp;	•	当 innodb_autoinc_lock_mode = 2，就采用轻量级锁；<br>&emsp;&emsp;	•	当 innodb_autoinc_lock_mode = 1，这个是默认值，两种锁混着用，如果能够确定插入记录的数量就采用轻量级锁，不确定时就采用 AUTO-INC 锁。<br>&emsp;&emsp;不过，当 innodb_autoinc_lock_mode = 2 是性能最高的方式，但是会带来一定的问题。因为并发插入的存在，在每次插入时，自增长的值可能不是连续的，<font color=#FEAE00>这在有主从复制的场景中是不安全的</font><font color=#FEAE00>。</font><font color=#5478F6><br>&emsp;&emsp;</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>认识 Redis<br>&emsp;&emsp;- 什么是 Redis <br>&emsp;&emsp;- Redis 和 Memcached 有什么区别? <br>&emsp;&emsp;- 为什么用 Redis 作为 MySQL的缓存? <hr># 什么是 Redis？<br>&emsp;&emsp;我们直接看 Redis 官方是怎么介绍自己的。<br>&emsp;&emsp;Redis 官方的介绍原版是英文的，我翻译成了中文后截图的，所以有些文字读起来会比较拗口，没关系，我会把里面比较重要的特性抽出来讲一下。<br>&emsp;&emsp;Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此<font color=#FEAE00>读写速度非常快</font>，常用于<font color=#FEAE00>缓存，消息队列、分布式锁等场景</font><font color=#FEAE00>。</font><br>&emsp;&emsp;Redis 提供了多种数据类型来支持不同的业务场景，比如 String(字符串)、Hash(哈希)、 List (列表)、Set(集合)、Zset(有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是<font color=#FEAE00>原子性</font>的，因为执行命令由<font color=#FEAE00>单线程负责的</font>，不存在并发竞争的问题。<br>&emsp;&emsp;除此之外，Redis 还支持<font color=#FEAE00>事务</font><font color=#FEAE00> </font><font color=#FEAE00>、持久化、</font><font color=#FEAE00>Lua </font><font color=#FEAE00>脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布</font><font color=#FEAE00>/</font><font color=#FEAE00>订阅模式，内存淘汰机制、过期删除机制</font>等等。<br>&emsp;&emsp;# Redis 和 Memcached 有什么区别？<br>&emsp;&emsp;很多人都说用 Redis 作为缓存，但是 Memcached 也是基于内存的数据库，为什么不选择它作为缓存呢？要解答这个问题，我们就要弄清楚 Redis 和 Memcached 的区别。 Redis 与 Memcached<font color=#FEAE00> </font><font color=#FEAE00>共同点</font>：<br>&emsp;&emsp;	1	都是基于<font color=#FEAE00>内存的数据库</font>，一般都用来当做缓存使用。<br>&emsp;&emsp;	2	都有过期策略。<br>&emsp;&emsp;	3	两者的<font color=#FEAE00>性能都非常高。</font><br>&emsp;&emsp;Redis 与 Memcached <font color=#374EF4>区别</font>：<br>&emsp;&emsp;	•	Redis 支持的数据类型更丰富（String、Hash、List、Set、ZSet），而 Memcached 只支持最简单的 key-value 数据类型；<br>&emsp;&emsp;	•	Redis 支持数据的<font color=#FEAE00>持久化，</font>可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 没有持久化功能，数据全部存在内存之中，Memcached 重启或者挂掉后，数据就没了；<br>&emsp;&emsp;	•	Redis <font color=#FEAE00>原生支持集群模式</font>，Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；<br>&emsp;&emsp;	•	Redis <font color=#FEAE00>支持发布订阅模型、</font><font color=#FEAE00>Lua </font><font color=#FEAE00>脚本、事务等功能</font>，而 Memcached 不支持；<br>&emsp;&emsp;# 为什么用 Redis 作为 MySQL 的<font color=#FEAE00>缓存</font>？<br>&emsp;&emsp;主要是因为 <font color=#FEAE00>Redis </font><font color=#FEAE00>具备「高性能」和「高并发」两种特性</font><font color=#FEAE00>。</font><font color=#FEAE00><br>&emsp;&emsp;</font><font color=#FEAE00>1</font><font color=#FEAE00>、</font><font color=#FEAE00>Redis </font><font color=#FEAE00>具备高性能</font><br>&emsp;&emsp;假如用户第一次访问 MySQL 中的某些数据。这个过程会比较慢，因为是从<font color=#FEAE00>硬盘上读取的</font>。将该用户访问的数据缓存在 Redis 中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了，操作 Redis 缓存就是直接操作内存，所以速度相当快。<br>&emsp;&emsp;￼<br>&emsp;&emsp;如果 MySQL 中的对应数据改变的之后，同步改变 Redis 缓存中相应的数据即可，不过这里会有 <font color=#FEAE00>Redis </font><font color=#FEAE00>和</font><font color=#FEAE00> MySQL </font><font color=#FEAE00>双写一致性的问题，后面我们会提到。</font><br>&emsp;&emsp;<font color=#FEAE00>2</font><font color=#FEAE00>、</font><font color=#FEAE00> Redis </font><font color=#FEAE00>具备高并发</font><br>&emsp;&emsp;单台设备的 Redis 的 <font color=#FEAE00>QPS</font><font color=#FEAE00>（</font><font color=#FEAE00>Query Per Second</font>，每秒钟处理完请求的次数） 是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破 1w。<br>&emsp;&emsp;所以，直接访问 Redis 能够承受的请求是远远大于直接访问 MySQL 的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>跳表和哈希表的区别?<hr><hr>跳表增加和删除如何操作?<hr><hr>跳表的优缺点? 什么时候用<hr><hr>跳表的使用场景?<hr><hr>1310. 子数组异或查询<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>简单的状态压缩<font color=#5DAF99><br>&emsp;&emsp;vector</font><<font color=#3D6DA4>int</font>> <font color=#55552A>xorQueries</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>arr</font>, <font color=#5DAF99>vector</font><<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>>><font color=#3D6DA4>&</font> <font color=#194060>queries</font>) {<br>&emsp;&emsp;<font color=#85A96D>    // </font><font color=#85A96D>存一个数组用前缀和压缩状态</font><br>&emsp;&emsp;<font color=#85A96D>    // </font><font color=#85A96D>前缀和记得从</font><font color=#85A96D> 1 </font><font color=#85A96D>开始</font><font color=#85A96D>,</font><font color=#85A96D>这样第一个就不用特殊处理了</font><br>&emsp;&emsp;    <font color=#3D6DA4>int</font> length = <font color=#194060>arr</font>.<font color=#55552A>size</font>();<br>&emsp;&emsp;    vector<<font color=#3D6DA4>int</font>> <font color=#55552A>f</font>(length + <font color=#435635>1</font>);<font color=#85A96D> // </font><font color=#85A96D>注意一个这个命名是什么</font><font color=#85A96D>?</font><br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>; i < length; i++){<br>&emsp;&emsp;        <font color=#194060>f</font>[i + <font color=#435635>1</font>] = <font color=#194060>f</font>[i] ^ <font color=#194060>arr</font>[i]; <br>&emsp;&emsp;    }<br>&emsp;&emsp;<font color=#85A96D>    // </font><font color=#85A96D>然后每个查询</font><font color=#85A96D> xor </font><font color=#85A96D>一下子</font><br>&emsp;&emsp;    vector<<font color=#3D6DA4>int</font>> res; <br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>auto</font> &v: queries){<br>&emsp;&emsp;        <font color=#194060>res</font>.<font color=#55552A>push_back</font>(<font color=#194060>f</font>[<font color=#194060>v</font>[<font color=#435635>0</font>]] ^ <font color=#194060>f</font>[<font color=#194060>v</font>[<font color=#435635>1</font>] + <font color=#435635>1</font>]);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> res;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>1371. 每个元音包含偶数次的最长子字符串<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>状态压缩的操作 + 前缀和, 这种很少字母的都可以这样子<font color=#3D6DA4><br>&emsp;&emsp;<br>&emsp;&emsp;int</font> <font color=#55552A>findTheLongestSubstring</font>(<font color=#5DAF99>string</font> <font color=#194060>s</font>) {<br>&emsp;&emsp;    string vowel = <font color=#7F4D36>"aeiou"</font>;<br>&emsp;&emsp;<font color=#85A96D>    // vector<int> pos(1 << 5, -1);</font><br>&emsp;&emsp;<font color=#85A96D>    // </font><font color=#85A96D>如果用</font><font color=#85A96D> vector </font><font color=#85A96D>的话可以快一点</font><br>&emsp;&emsp;    unordered_map<<font color=#3D6DA4>int</font>, <font color=#3D6DA4>int</font>> um;<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> length = <font color=#194060>s</font>.<font color=#55552A>size</font>();<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> now = <font color=#435635>0</font>;<br>&emsp;&emsp;    <font color=#194060>um</font>[<font color=#435635>0</font>] = -<font color=#435635>1</font>;<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> res = <font color=#435635>0</font>;<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>; i < length; i++){<br>&emsp;&emsp;        <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> j = <font color=#435635>0</font>; j < <font color=#435635>5</font>; j++){<br>&emsp;&emsp;            <font color=#713D71>if</font>(<font color=#194060>s</font>[i] == <font color=#194060>vowel</font>[j]){ <br>&emsp;&emsp;                now ^= <font color=#435635>1</font> << j;<br>&emsp;&emsp;            }<br>&emsp;&emsp;        }<br>&emsp;&emsp;        <font color=#713D71>if</font>(<font color=#194060>um</font>.<font color=#55552A>count</font>(now)) res = <font color=#55552A>max</font>(res, i - <font color=#194060>um</font>[now]);<br>&emsp;&emsp;        <font color=#713D71>else</font> <font color=#194060>um</font>[now] = i;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> res;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>236. 二叉树的最近公共祖先<br>&emsp;&emsp;使用递归的简便做法? <br>&emsp;&emsp;以及如何保证 这两个点不在里面还是正确的? <br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>如何直接递归的简便做法?<br>&emsp;&emsp;<font color=#5DAF99>TreeNode</font><font color=#3D6DA4>*</font> <font color=#55552A>lowestCommonAncestor</font>(<font color=#5DAF99>TreeNode</font><font color=#3D6DA4>*</font> <font color=#194060>root</font>, <font color=#5DAF99>TreeNode</font><font color=#3D6DA4>*</font> <font color=#194060>p</font>, <font color=#5DAF99>TreeNode</font><font color=#3D6DA4>*</font> <font color=#194060>q</font>) {<br>&emsp;&emsp;<font color=#85A96D>    // </font><font color=#85A96D>如果这个点是左边或者右边</font><font color=#85A96D> </font><font color=#85A96D>或者他是</font><font color=#85A96D> nullptr </font><font color=#85A96D>直接返回就行</font><br>&emsp;&emsp;    <font color=#713D71>if</font>(root == q || root == p || root == <font color=#3D6DA4>nullptr</font>) <font color=#713D71>return</font> root;<br>&emsp;&emsp;    <font color=#3D6DA4>auto</font> left = <font color=#55552A>lowestCommonAncestor</font>(<font color=#194060>root</font>-><font color=#194060>left</font>, p, q);<br>&emsp;&emsp;    <font color=#3D6DA4>auto</font> right = <font color=#55552A>lowestCommonAncestor</font>(<font color=#194060>root</font>-><font color=#194060>right</font>, p, q);<br>&emsp;&emsp;<font color=#85A96D>    // </font><font color=#85A96D>如果两个都非空</font><font color=#85A96D>, </font><font color=#85A96D>直接返回</font><br>&emsp;&emsp;    <font color=#713D71>if</font>(left != <font color=#3D6DA4>NULL</font> && right != <font color=#3D6DA4>NULL</font>) <font color=#713D71>return</font> root;<br>&emsp;&emsp;<font color=#85A96D>    // </font><font color=#85A96D>否则返回有值的那个</font><br>&emsp;&emsp;    <font color=#713D71>return</font> left? left : right;<br>&emsp;&emsp;}<hr><hr>3. 无重复字符的最长子串<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>滑动窗口<br>&emsp;&emsp;如何使用 bitmap, <br>&emsp;&emsp;还有上面应该用到防范式编程<br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#55552A>lengthOfLongestSubstring</font>(<font color=#5DAF99>string</font> <font color=#194060>s</font>) {<br>&emsp;&emsp;    bitset<<font color=#435635>128</font>> a;<font color=#85A96D> // </font><font color=#85A96D>这里可以该进成</font><font color=#85A96D> bitmap </font><font color=#85A96D>来做</font><br>&emsp;&emsp;    <font color=#3D6DA4>int</font> now = <font color=#435635>0</font>;<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> r = <font color=#435635>0</font>, l =<font color=#435635>0</font>; r < <font color=#194060>s</font>.<font color=#55552A>size</font>(); r++){<br>&emsp;&emsp;        <font color=#713D71>while</font>(<font color=#194060>a</font>[<font color=#194060>s</font>[r]]) <font color=#194060>a</font>[<font color=#194060>s</font>[l++]] = <font color=#435635>0</font>;<font color=#85A96D> //  </font><font color=#85A96D>注意取的位置</font><br>&emsp;&emsp;        <font color=#194060>a</font>[<font color=#194060>s</font>[r]] = <font color=#435635>1</font>; <br>&emsp;&emsp;        now = <font color=#55552A>max</font>(now , r - l + <font color=#435635>1</font>);<br>&emsp;&emsp;    } <br>&emsp;&emsp;    <font color=#713D71>return</font> now;<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;<hr><hr>34. 在排序数组中查找元素的第一个和最后一个位置<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;<hr>简单的二分<br>&emsp;&emsp;<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>> <font color=#55552A>searchRange</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>a</font>, <font color=#3D6DA4>int</font> <font color=#194060>target</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> n = <font color=#194060>a</font>.<font color=#55552A>size</font>();<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> l = <font color=#435635>0</font>, r = n - <font color=#435635>1</font>;<br>&emsp;&emsp;    <font color=#713D71>while</font> (l < r) {<br>&emsp;&emsp;        <font color=#3D6DA4>int</font> mi = l + r >> <font color=#435635>1</font>;<br>&emsp;&emsp;        <font color=#713D71>if</font> (<font color=#194060>a</font>[mi] >= target) r = mi;<br>&emsp;&emsp;        <font color=#713D71>else</font> l = mi + <font color=#435635>1</font>;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>if</font> (n == <font color=#435635>0</font> || <font color=#194060>a</font>[l] != target) <font color=#713D71>return</font> { -<font color=#435635>1</font>,-<font color=#435635>1</font> };<font color=#85A96D> // </font><font color=#85A96D>注意这里必须判断返回一下</font><font color=#85A96D>, </font><font color=#85A96D>要不然不够</font><br>&emsp;&emsp;    <font color=#3D6DA4>int</font> res = l;<br>&emsp;&emsp;    r = n - <font color=#435635>1</font>;<font color=#85A96D> // </font><font color=#85A96D>这里完了以后</font><font color=#85A96D>, </font><font color=#85A96D>左边可以不变</font><font color=#85A96D>, </font><font color=#85A96D>少搜索一点点</font><font color=#85A96D> </font><font color=#85A96D>记住</font><font color=#85A96D>...</font><br>&emsp;&emsp;    <font color=#713D71>while</font> (l < r) {<br>&emsp;&emsp;        <font color=#3D6DA4>int</font> mi = l + r + <font color=#435635>1</font> >> <font color=#435635>1</font>;<br>&emsp;&emsp;        <font color=#713D71>if</font> (<font color=#194060>a</font>[mi] <= target) l = mi;<br>&emsp;&emsp;        <font color=#713D71>else</font> r = mi - <font color=#435635>1</font>;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> { res,r };<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>46. 全排列<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>两种方法: <br>&emsp;&emsp;- 迭代<br>&emsp;&emsp;- dfs<br>&emsp;&emsp;todo 做了那个下一个全排列再加吧<br>&emsp;&emsp;<br>&emsp;&emsp;2. dfs<br>&emsp;&emsp;vector<vector<<font color=#3D6DA4>int</font>>> res;<br>&emsp;&emsp;<font color=#85A96D>// state </font><font color=#85A96D>表示第几个</font><font color=#85A96D>  (state >> 1) &1    </font><br>&emsp;&emsp;<font color=#85A96D>                //   state | 1 << i;</font><br>&emsp;&emsp;vector<<font color=#3D6DA4>int</font>> path; <br>&emsp;&emsp;<font color=#3D6DA4>int</font> n;<br>&emsp;&emsp;vector<<font color=#3D6DA4>int</font>> num;<br>&emsp;&emsp;<font color=#3D6DA4>void</font> <font color=#55552A>dfs</font>(<font color=#3D6DA4>int</font> <font color=#194060>cnt</font>,<font color=#3D6DA4>int</font> <font color=#194060>state</font>){<br>&emsp;&emsp;    <font color=#713D71>if</font>(cnt == n) {<font color=#194060>res</font>.<font color=#55552A>push_back</font>(path); <font color=#713D71>return</font>;}<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>;i<n;i++){<br>&emsp;&emsp;        <font color=#713D71>if</font>(((state>>i)&<font color=#435635>1</font>) == <font color=#435635>0</font>)  {<br>&emsp;&emsp;            <font color=#194060>path</font>[cnt] = <font color=#194060>num</font>[i];  <br>&emsp;&emsp;            <font color=#55552A>dfs</font>(cnt+<font color=#435635>1</font>, state | (<font color=#435635>1</font> <<i));<br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;}<br>&emsp;&emsp;<font color=#5DAF99>vector</font><<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>>> <font color=#55552A>permute</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>nums</font>) {<br>&emsp;&emsp;    n = <font color=#194060>nums</font>.<font color=#55552A>size</font>(); <br>&emsp;&emsp;    <font color=#194060>path</font>.<font color=#55552A>resize</font>(n);<br>&emsp;&emsp;    num = nums;<br>&emsp;&emsp;    <font color=#55552A>dfs</font>(<font color=#435635>0</font>,<font color=#435635>0</font>);<br>&emsp;&emsp;    <font color=#713D71>return</font> res;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>560. 和为 K 的子数组<br>&emsp;&emsp;注意有正有负<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>前缀和<font color=#3D6DA4><br>&emsp;&emsp;int</font> <font color=#55552A>subarraySum</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>nums</font>, <font color=#3D6DA4>int</font> <font color=#194060>k</font>) {<br>&emsp;&emsp;<font color=#85A96D>    // </font><font color=#85A96D>前缀和</font><br>&emsp;&emsp;    unordered_map<<font color=#3D6DA4>int</font>,<font color=#3D6DA4>int</font>> um; <br>&emsp;&emsp;    <font color=#194060>um</font>[<font color=#435635>0</font>]++;<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> now = <font color=#435635>0</font>, res = <font color=#435635>0</font>;<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>auto</font> &i:nums){<br>&emsp;&emsp;        now += i;<br>&emsp;&emsp;        <font color=#713D71>if</font>(<font color=#194060>um</font>.<font color=#55552A>count</font>(now - k)){<br>&emsp;&emsp;            res += <font color=#194060>um</font>[now - k];<br>&emsp;&emsp;        }<br>&emsp;&emsp;        <font color=#194060>um</font>[now]++;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> res;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>718. 最长重复子数组 / 最长公共字串<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>简单的 dp 直接进行扫描就好了<font color=#3D6DA4><br>&emsp;&emsp;int</font> <font color=#55552A>findLength</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>nums1</font>, <font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>nums2</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> n = <font color=#194060>nums1</font>.<font color=#55552A>size</font>(), m = <font color=#194060>nums2</font>.<font color=#55552A>size</font>();<br>&emsp;&emsp;    vector<vector<<font color=#3D6DA4>int</font>>> <font color=#55552A>f</font>(n + <font color=#435635>1</font>, <font color=#55552A>vector</font><<font color=#3D6DA4>int</font>>(m + <font color=#435635>1</font>));<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> res = <font color=#435635>0</font>; <br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>; i < n; i++){<br>&emsp;&emsp;        <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> j = <font color=#435635>0</font>; j < m; j++){<br>&emsp;&emsp;            <font color=#713D71>if</font>(<font color=#194060>nums1</font>[i] == <font color=#194060>nums2</font>[j]){<br>&emsp;&emsp;                <font color=#194060>f</font>[i + <font color=#435635>1</font>][j + <font color=#435635>1</font>] = <font color=#194060>f</font>[i][j] + <font color=#435635>1</font>;<br>&emsp;&emsp;                res = <font color=#55552A>max</font>(res, <font color=#194060>f</font>[i + <font color=#435635>1</font>][j + <font color=#435635>1</font>]);<br>&emsp;&emsp;            }<br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> res;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>84. 柱状图中最大的矩形<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>算是一个单调栈的应用吧<br>&emsp;&emsp;每个点 左边看一遍, 右边看一遍, <font color=#3D6DA4><br>&emsp;&emsp;int</font> <font color=#55552A>largestRectangleArea</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>> <font color=#3D6DA4>&</font><font color=#194060>a</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> n = <font color=#194060>a</font>.<font color=#55552A>size</font>();<br>&emsp;&emsp;    vector<<font color=#3D6DA4>int</font>> <font color=#55552A>left</font>(n), <font color=#55552A>right</font>(n);<br>&emsp;&emsp;    stack<<font color=#3D6DA4>int</font>> stk;<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>; i < n; i++){<br>&emsp;&emsp;        <font color=#713D71>while</font> (!<font color=#194060>stk</font>.<font color=#55552A>empty</font>() && <font color=#194060>a</font>[<font color=#194060>stk</font>.<font color=#55552A>top</font>()] >= <font color=#194060>a</font>[i]) <font color=#194060>stk</font>.<font color=#55552A>pop</font>();<br>&emsp;&emsp;        <font color=#194060>left</font>[i] = <font color=#194060>stk</font>.<font color=#55552A>empty</font>() ? -<font color=#435635>1</font> : <font color=#194060>stk</font>.<font color=#55552A>top</font>();<br>&emsp;&emsp;        <font color=#194060>stk</font>.<font color=#55552A>push</font>(i);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    stk = <font color=#55552A>stack</font><<font color=#3D6DA4>int</font>>();<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = n - <font color=#435635>1</font>; i >=<font color=#435635>0</font>; i--) {<br>&emsp;&emsp;        <font color=#713D71>while</font> (!<font color=#194060>stk</font>.<font color=#55552A>empty</font>() && <font color=#194060>a</font>[<font color=#194060>stk</font>.<font color=#55552A>top</font>()] >= <font color=#194060>a</font>[i]) <font color=#194060>stk</font>.<font color=#55552A>pop</font>();<br>&emsp;&emsp;        <font color=#194060>right</font>[i] = <font color=#194060>stk</font>.<font color=#55552A>empty</font>() ? n : <font color=#194060>stk</font>.<font color=#55552A>top</font>();<br>&emsp;&emsp;        <font color=#194060>stk</font>.<font color=#55552A>push</font>(i);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> ans = <font color=#435635>0</font>;<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>; i < n; i++) {<br>&emsp;&emsp;        ans = <font color=#55552A>max</font>(ans, (<font color=#194060>right</font>[i] - <font color=#194060>left</font>[i] - <font color=#435635>1</font>) * <font color=#194060>a</font>[i]);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> ans;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>K 个一组翻转链表<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><font color=#85A96D>// </font><font color=#85A96D>为了防止特别长的代码</font><font color=#85A96D>, </font><font color=#85A96D>可以设计一个子函数来自己调用</font><br>&emsp;&emsp;<font color=#5DAF99>pair</font><<font color=#5DAF99>ListNode</font>*, <font color=#5DAF99>ListNode</font>*> <font color=#55552A>myReverse</font>(<font color=#5DAF99>ListNode</font><font color=#3D6DA4>*</font> <font color=#194060>head</font>, <font color=#5DAF99>ListNode</font><font color=#3D6DA4>*</font> <font color=#194060>tail</font>) {<br>&emsp;&emsp;    ListNode* prev = <font color=#194060>tail</font>-><font color=#194060>next</font>;<font color=#85A96D> // </font><font color=#85A96D>这个是翻转链表的函数</font><br>&emsp;&emsp;    ListNode* p = head;<br>&emsp;&emsp;    <font color=#713D71>while</font> (prev != tail) {<br>&emsp;&emsp;        ListNode* nex = <font color=#194060>p</font>-><font color=#194060>next</font>;<br>&emsp;&emsp;        <font color=#194060>p</font>-><font color=#194060>next</font> = prev;<br>&emsp;&emsp;        prev = p;<br>&emsp;&emsp;        p = nex;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> {tail, head};<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5DAF99>ListNode</font><font color=#3D6DA4>*</font> <font color=#55552A>reverseKGroup</font>(<font color=#5DAF99>ListNode</font><font color=#3D6DA4>*</font> <font color=#194060>head</font>, <font color=#3D6DA4>int</font> <font color=#194060>k</font>) {<br>&emsp;&emsp;    ListNode* dummy = <font color=#713D71>new</font> <font color=#55552A>ListNode</font>(<font color=#435635>0</font>);<br>&emsp;&emsp;    <font color=#194060>dummy</font>-><font color=#194060>next</font> = head;<br>&emsp;&emsp;    ListNode* pre = dummy;<br>&emsp;&emsp;<br>&emsp;&emsp;    <font color=#713D71>while</font> (head) {<br>&emsp;&emsp;        ListNode* tail = pre;<br>&emsp;&emsp;<font color=#85A96D>        // </font><font color=#85A96D>查看剩余部分长度是否大于等于</font><font color=#85A96D> k</font><br>&emsp;&emsp;        <font color=#713D71>for</font> (<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>; i < k; ++i) {<br>&emsp;&emsp;            tail = <font color=#194060>tail</font>-><font color=#194060>next</font>;<br>&emsp;&emsp;            <font color=#713D71>if</font> (!tail) {<br>&emsp;&emsp;                <font color=#713D71>return</font> <font color=#194060>dummy</font>-><font color=#194060>next</font>;<br>&emsp;&emsp;            }<br>&emsp;&emsp;        }<br>&emsp;&emsp;        ListNode* nex = <font color=#194060>tail</font>-><font color=#194060>next</font>;<br>&emsp;&emsp;        <font color=#55552A>tie</font>(head, tail) = <font color=#55552A>myReverse</font>(head, tail);<br>&emsp;&emsp;<font color=#85A96D>        // </font><font color=#85A96D>把子链表重新接回原链表</font><br>&emsp;&emsp;        <font color=#194060>pre</font>-><font color=#194060>next</font> = head;<br>&emsp;&emsp;        <font color=#194060>tail</font>-><font color=#194060>next</font> = nex;<br>&emsp;&emsp;        pre = tail;<br>&emsp;&emsp;        head = <font color=#194060>tail</font>-><font color=#194060>next</font>;<br>&emsp;&emsp;    }<br>&emsp;&emsp;<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#194060>dummy</font>-><font color=#194060>next</font>;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>lfu缓存<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><font color=#85A96D>// </font><font color=#85A96D>可以用到自定义的排序</font><font color=#85A96D> </font><br>&emsp;&emsp;<font color=#85A96D>// bool operator < (const Node& rhs) const{}</font><br>&emsp;&emsp;<font color=#3D6DA4>struct</font> <font color=#5DAF99>Node</font> {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> cnt, time, key, value;<br>&emsp;&emsp;<br>&emsp;&emsp;    <font color=#55552A>Node</font>(<font color=#3D6DA4>int</font> <font color=#194060>_cnt</font>, <font color=#3D6DA4>int</font> <font color=#194060>_time</font>, <font color=#3D6DA4>int</font> <font color=#194060>_key</font>, <font color=#3D6DA4>int</font> <font color=#194060>_value</font>):<font color=#55552A>cnt</font>(_cnt), <font color=#55552A>time</font>(_time), <font color=#55552A>key</font>(_key), <font color=#55552A>value</font>(_value){}<br>&emsp;&emsp;    <br>&emsp;&emsp;    <font color=#3D6DA4>bool</font> <font color=#713D71>operator</font> <font color=#713D71><</font> (<font color=#3D6DA4>const</font> <font color=#5DAF99>Node</font><font color=#3D6DA4>&</font> <font color=#194060>rhs</font>) <font color=#3D6DA4>const</font> {<br>&emsp;&emsp;        <font color=#713D71>return</font> cnt == <font color=#194060>rhs</font>.<font color=#194060>cnt</font> ? time < <font color=#194060>rhs</font>.<font color=#194060>time</font> : cnt < <font color=#194060>rhs</font>.<font color=#194060>cnt</font>;<br>&emsp;&emsp;    }<br>&emsp;&emsp;};<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#3D6DA4>class</font> <font color=#5DAF99>LFUCache</font> {<br>&emsp;&emsp;<font color=#85A96D>    // </font><font color=#85A96D>缓存容量，时间戳</font><br>&emsp;&emsp;    <font color=#3D6DA4>int</font> capacity, time;<br>&emsp;&emsp;    unordered_map<<font color=#3D6DA4>int</font>, Node> key_table;<br>&emsp;&emsp;    set<Node> S;<br>&emsp;&emsp;<font color=#3D6DA4>public:</font><br>&emsp;&emsp;    <font color=#55552A>LFUCache</font>(<font color=#3D6DA4>int</font> <font color=#194060>_capacity</font>): <font color=#55552A>capacity</font>(_capacity), <font color=#55552A>time</font>(<font color=#435635>0</font>) {};<br>&emsp;&emsp;    <br>&emsp;&emsp;    <font color=#3D6DA4>int</font> <font color=#55552A>get</font>(<font color=#3D6DA4>int</font> <font color=#194060>key</font>) {<br>&emsp;&emsp;        <font color=#713D71>if</font> (capacity == <font color=#435635>0</font>) <font color=#713D71>return</font> -<font color=#435635>1</font>;<br>&emsp;&emsp;        <font color=#3D6DA4>auto</font> it = <font color=#194060>key_table</font>.<font color=#55552A>find</font>(key);<br>&emsp;&emsp;<font color=#85A96D>        // </font><font color=#85A96D>如果哈希表中没有键</font><font color=#85A96D> key</font><font color=#85A96D>，返回</font><font color=#85A96D> -1</font><br>&emsp;&emsp;        <font color=#713D71>if</font> (it == <font color=#194060>key_table</font>.<font color=#55552A>end</font>()) <font color=#713D71>return</font> -<font color=#435635>1</font>;<br>&emsp;&emsp;<font color=#85A96D>        // </font><font color=#85A96D>从哈希表中得到旧的缓存</font><br>&emsp;&emsp;        Node cache = <font color=#194060>it </font>-> <font color=#194060>second</font>;<br>&emsp;&emsp;<font color=#85A96D>        // </font><font color=#85A96D>从平衡二叉树中删除旧的缓存</font><br>&emsp;&emsp;        <font color=#194060>S</font>.<font color=#55552A>erase</font>(cache);<br>&emsp;&emsp;<font color=#85A96D>        // </font><font color=#85A96D>将旧缓存更新</font><br>&emsp;&emsp;        <font color=#194060>cache</font>.<font color=#194060>cnt</font> += <font color=#435635>1</font>;<br>&emsp;&emsp;        <font color=#194060>cache</font>.<font color=#194060>time</font> = ++time;<br>&emsp;&emsp;<font color=#85A96D>        // </font><font color=#85A96D>将新缓存重新放入哈希表和平衡二叉树中</font><br>&emsp;&emsp;        <font color=#194060>S</font>.<font color=#55552A>insert</font>(cache);<br>&emsp;&emsp;        <font color=#194060>it </font>-> <font color=#194060>second</font> = cache;<br>&emsp;&emsp;        <font color=#713D71>return</font> <font color=#194060>cache</font>.<font color=#194060>value</font>;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <br>&emsp;&emsp;    <font color=#3D6DA4>void</font> <font color=#55552A>put</font>(<font color=#3D6DA4>int</font> <font color=#194060>key</font>, <font color=#3D6DA4>int</font> <font color=#194060>value</font>) {<br>&emsp;&emsp;        <font color=#713D71>if</font> (capacity == <font color=#435635>0</font>) <font color=#713D71>return</font>;<br>&emsp;&emsp;        <font color=#3D6DA4>auto</font> it = <font color=#194060>key_table</font>.<font color=#55552A>find</font>(key);<br>&emsp;&emsp;        <font color=#713D71>if</font> (it == <font color=#194060>key_table</font>.<font color=#55552A>end</font>()) {<br>&emsp;&emsp;<font color=#85A96D>            // </font><font color=#85A96D>如果到达缓存容量上限</font><br>&emsp;&emsp;            <font color=#713D71>if</font> (<font color=#194060>key_table</font>.<font color=#55552A>size</font>() == capacity) {<br>&emsp;&emsp;<font color=#85A96D>                // </font><font color=#85A96D>从哈希表和平衡二叉树中删除最近最少使用的缓存</font><br>&emsp;&emsp;                <font color=#194060>key_table</font>.<font color=#55552A>erase</font>(<font color=#194060>S</font>.<font color=#55552A>begin</font>()<font color=#194060> </font>-> <font color=#194060>key</font>);<br>&emsp;&emsp;                <font color=#194060>S</font>.<font color=#55552A>erase</font>(<font color=#194060>S</font>.<font color=#55552A>begin</font>());<br>&emsp;&emsp;            }<br>&emsp;&emsp;<font color=#85A96D>            // </font><font color=#85A96D>创建新的缓存</font><br>&emsp;&emsp;            Node cache = <font color=#55552A>Node</font>(<font color=#435635>1</font>, ++time, key, value);<br>&emsp;&emsp;<font color=#85A96D>            // </font><font color=#85A96D>将新缓存放入哈希表和平衡二叉树中</font><br>&emsp;&emsp;            <font color=#194060>key_table</font>.<font color=#55552A>insert</font>(<font color=#55552A>make_pair</font>(key, cache));<br>&emsp;&emsp;            <font color=#194060>S</font>.<font color=#55552A>insert</font>(cache);<br>&emsp;&emsp;        }<br>&emsp;&emsp;        <font color=#713D71>else</font> {<br>&emsp;&emsp;<font color=#85A96D>            // </font><font color=#85A96D>这里和</font><font color=#85A96D> get() </font><font color=#85A96D>函数类似</font><br>&emsp;&emsp;            Node cache = <font color=#194060>it </font>-> <font color=#194060>second</font>;<br>&emsp;&emsp;            <font color=#194060>S</font>.<font color=#55552A>erase</font>(cache);<br>&emsp;&emsp;            <font color=#194060>cache</font>.<font color=#194060>cnt</font> += <font color=#435635>1</font>;<br>&emsp;&emsp;            <font color=#194060>cache</font>.<font color=#194060>time</font> = ++time;<br>&emsp;&emsp;            <font color=#194060>cache</font>.<font color=#194060>value</font> = value;<br>&emsp;&emsp;            <font color=#194060>S</font>.<font color=#55552A>insert</font>(cache);<br>&emsp;&emsp;            <font color=#194060>it </font>-> <font color=#194060>second</font> = cache;<br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;};<br>&emsp;&emsp;<br>&emsp;&emsp;<hr><hr>lru缓存实现？<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>代码非常容易写错，有好多细节<br>&emsp;&emsp;插入的时候：<br>&emsp;&emsp;1.在哈希表中：直接移到最前面，然后返回<br>&emsp;&emsp;2.不在的话，逐出，然后插入进去<br>&emsp;&emsp;多写一写<font color=#3D6DA4><br>&emsp;&emsp;<br>&emsp;&emsp;struct</font> <font color=#5DAF99>Node</font>{<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> key;<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> val;<br>&emsp;&emsp;    Node* next;<br>&emsp;&emsp;    Node* pre;<br>&emsp;&emsp;    <font color=#55552A>Node</font>(<font color=#3D6DA4>int</font> <font color=#194060>k</font>, <font color=#3D6DA4>int</font> <font color=#194060>v</font>) : <font color=#55552A>key</font>(k), <font color=#55552A>val</font>(v), <font color=#55552A>next</font>(<font color=#3D6DA4>nullptr</font>), <font color=#55552A>pre</font>(<font color=#3D6DA4>nullptr</font>) {}<br>&emsp;&emsp;};<br>&emsp;&emsp;<font color=#3D6DA4>int</font> capacity,size;<br>&emsp;&emsp;Node *head,*tail;<br>&emsp;&emsp;unordered_map<<font color=#3D6DA4>int</font>, Node*> mp;<br>&emsp;&emsp;<font color=#55552A>LRUCache</font>(<font color=#3D6DA4>int</font> <font color=#194060>capacity</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>this</font>-><font color=#194060>capacity</font> = capacity;<br>&emsp;&emsp;    <font color=#3D6DA4>this</font>-><font color=#194060>size</font> = <font color=#435635>0</font>;<br>&emsp;&emsp;    <font color=#3D6DA4>this</font>-><font color=#194060>head</font> = <font color=#713D71>new</font> <font color=#55552A>Node</font>(-<font color=#435635>1</font>, -<font color=#435635>1</font>);<br>&emsp;&emsp;    <font color=#3D6DA4>this</font>-><font color=#194060>tail</font> = <font color=#713D71>new</font> <font color=#55552A>Node</font>(-<font color=#435635>1</font>, -<font color=#435635>1</font>);<br>&emsp;&emsp;    <font color=#194060>head</font>-><font color=#194060>next</font> = tail;<br>&emsp;&emsp;    <font color=#194060>tail</font>-><font color=#194060>pre</font> = head;<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#55552A>get</font>(<font color=#3D6DA4>int</font> <font color=#194060>key</font>) {<br>&emsp;&emsp;    <font color=#713D71>if</font>(!<font color=#194060>mp</font>.<font color=#55552A>count</font>(key)) <font color=#713D71>return</font> -<font color=#435635>1</font>;<br>&emsp;&emsp;    <font color=#713D71>else</font> {<br>&emsp;&emsp;        <font color=#55552A>move_to_head</font>(<font color=#194060>mp</font>[key]);<br>&emsp;&emsp;        <font color=#713D71>return</font> <font color=#194060>mp</font>[key]-><font color=#194060>val</font>;<br>&emsp;&emsp;    }<br>&emsp;&emsp;}<br>&emsp;&emsp;<font color=#3D6DA4>void</font> <font color=#55552A>move_to_head</font>(<font color=#5DAF99>Node</font><font color=#3D6DA4>*</font> <font color=#194060>node</font>) {<br>&emsp;&emsp;    <font color=#55552A>deleteNode</font>(node);<br>&emsp;&emsp;    <font color=#55552A>add_nodeAfterHead</font>(node); <br>&emsp;&emsp;}<br>&emsp;&emsp;<font color=#3D6DA4>void</font> <font color=#55552A>add_nodeAfterHead</font>(<font color=#5DAF99>Node</font><font color=#3D6DA4>*</font> <font color=#194060>node</font>){<br>&emsp;&emsp;    <font color=#194060>node</font>-><font color=#194060>next</font> = <font color=#194060>head</font>-><font color=#194060>next</font>;<br>&emsp;&emsp;    <font color=#194060>head</font>-><font color=#194060>next</font> = node;<br>&emsp;&emsp;    <font color=#194060>node</font>-><font color=#194060>pre</font> = head;<br>&emsp;&emsp;    <font color=#194060>node</font>-><font color=#194060>next</font>-><font color=#194060>pre</font> = node; <br>&emsp;&emsp;}<br>&emsp;&emsp;<font color=#3D6DA4>void</font> <font color=#55552A>deleteNode</font>(<font color=#5DAF99>Node</font><font color=#3D6DA4>*</font> <font color=#194060>node</font>){<br>&emsp;&emsp;    <font color=#194060>node</font>-><font color=#194060>pre</font>-><font color=#194060>next</font> = <font color=#194060>node</font>-><font color=#194060>next</font>;<br>&emsp;&emsp;    <font color=#194060>node</font>-><font color=#194060>next</font>-><font color=#194060>pre</font> = <font color=#194060>node</font>-><font color=#194060>pre</font>; <br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#3D6DA4>void</font> <font color=#55552A>put</font>(<font color=#3D6DA4>int</font> <font color=#194060>key</font>, <font color=#3D6DA4>int</font> <font color=#194060>value</font>) {<br>&emsp;&emsp;    <font color=#713D71>if</font>(<font color=#194060>mp</font>.<font color=#55552A>count</font>(key)){<br>&emsp;&emsp;        Node* node = <font color=#194060>mp</font>[key];<br>&emsp;&emsp;        <font color=#194060>node</font>-><font color=#194060>val</font> = value;<br>&emsp;&emsp;        <font color=#55552A>move_to_head</font>(node);<br>&emsp;&emsp;        <font color=#713D71>return</font>;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>if</font>(<font color=#3D6DA4>this</font>-><font color=#194060>size</font> == <font color=#3D6DA4>this</font>-><font color=#194060>capacity</font>){<br>&emsp;&emsp;        <font color=#3D6DA4>auto</font> node = <font color=#194060>tail</font>-><font color=#194060>pre</font>;<br>&emsp;&emsp;        <font color=#55552A>deleteNode</font>(node);<br>&emsp;&emsp;        <font color=#3D6DA4>this</font>-><font color=#194060>size</font>--; <br>&emsp;&emsp;        <font color=#3D6DA4>this</font>-><font color=#194060>mp</font>.<font color=#55552A>erase</font>(<font color=#194060>node</font>-><font color=#194060>key</font>);  <br>&emsp;&emsp;        <font color=#713D71>delete</font> node;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    Node* node = <font color=#713D71>new</font> <font color=#55552A>Node</font>(key, value); <br>&emsp;&emsp;    <font color=#194060>mp</font>[key]=node;<br>&emsp;&emsp;    <font color=#55552A>add_nodeAfterHead</font>(node);<br>&emsp;&emsp;    <font color=#3D6DA4>this</font>-><font color=#194060>size</font> ++;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>todo<br>&emsp;&emsp;等差数列划分<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><hr>todo<br>&emsp;&emsp;设计实现循环双端队列<br>&emsp;&emsp;<br>&emsp;&emsp;什么是deque<hr><hr>todo <br>&emsp;&emsp;最佳买卖股票时机含冷冻期 //todo<br>&emsp;&emsp;<br>&emsp;&emsp;卖出后, 无法在第二天买入股票, 冷冻一天<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>一种常用的方法是将「买入」和「卖出」分开进行考虑：<font color=#FEAE00>「买入」为负收益，而「卖出」为正收益</font>。在初入股市时，你<font color=#FEAE00>只有「买入」的权利，只能获得负收益</font>。而当你「买入」之后，你就<font color=#FEAE00>有了「卖出」的权利，可以获得正收益</font>。显然，我们需要尽可能地降低负收益而提高正收益，因此我们的<font color=#FEAE00>目标总是将收益值最大化</font>。因此，我们可以使用动态规划的方法，维护在股市中每一天结束后可以获得的「<font color=#FEAE00>累计最大收益</font>」，并以此进行状态转移，得到最终的答案。<hr><hr>todo <br>&emsp;&emsp;设计: 秒杀系统?<hr><hr>todo 1125. 最小的必要团队<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>状态压缩<hr><hr>todo 691. 贴纸拼词<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>状态压缩<hr><hr>todo 买卖股票的最佳时机 含手续费 todo<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><hr>todo 参加考试的最大学生数<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>状态压缩<hr><hr>todo 字符串哈希<hr><hr>todo 扰乱字符串 30 以内的<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>todo <br>&emsp;&emsp;https://leetcode.cn/problems/scramble-string/solution/gong-shui-san-xie-yi-ti-san-jie-di-gui-j-hybk/<br>&emsp;&emsp;注意学习一下<hr><hr>todo 最短路<hr><hr>todo 红黑树的写法<hr><hr>todo 自定义排序<hr><hr>todo 解码方法<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>简单的动态规划题目<font color=#3D6DA4><br>&emsp;&emsp;int</font> <font color=#55552A>numDecodings</font>(<font color=#5DAF99>string</font> <font color=#194060>s</font>) {<br>&emsp;&emsp;<font color=#85A96D>    // </font><font color=#85A96D>返回解码方法的总数</font><font color=#85A96D>, </font><font color=#85A96D>这个转移很简单</font><br>&emsp;&emsp;<font color=#85A96D>    // if(a[i] != 0) a[i] = a[]</font><br>&emsp;&emsp;<font color=#85A96D>    // </font><font color=#85A96D>或者</font><font color=#85A96D> </font><font color=#85A96D>前面两个是否可行</font><br>&emsp;&emsp;    <font color=#3D6DA4>int</font> n = <font color=#194060>s</font>.<font color=#55552A>size</font>();<br>&emsp;&emsp;    vector<<font color=#3D6DA4>int</font>> <font color=#55552A>f</font>(n + <font color=#435635>1</font>);<br>&emsp;&emsp;    <font color=#194060>f</font>[<font color=#435635>0</font>] = <font color=#435635>1</font>;<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>; i < n; i++){<br>&emsp;&emsp;        <font color=#713D71>if</font>(<font color=#194060>s</font>[i] != <font color=#7F4D36>'0'</font>) <font color=#194060>f</font>[i + <font color=#435635>1</font>] += <font color=#194060>f</font>[i];<br>&emsp;&emsp;        <font color=#713D71>if</font>(i){<br>&emsp;&emsp;            <font color=#713D71>if</font>(<font color=#194060>s</font>[i - <font color=#435635>1</font>] == <font color=#7F4D36>'1'</font> || (<font color=#194060>s</font>[i - <font color=#435635>1</font>] == <font color=#7F4D36>'2'</font> && <font color=#194060>s</font>[i] <= <font color=#7F4D36>'6'</font>))<br>&emsp;&emsp;                <font color=#194060>f</font>[i + <font color=#435635>1</font>] += <font color=#194060>f</font>[i - <font color=#435635>1</font>];<br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#194060>f</font>[n];<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>todo 设计: 两个文件中重复的数据?<hr><hr>三数之和 O(n2)<br>&emsp;&emsp;1e3<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><font color=#5DAF99>这个题细节还挺多的</font><font color=#5DAF99> </font><font color=#5DAF99>去重啊</font><font color=#5DAF99> </font><font color=#5DAF99>这些东西</font><font color=#5DAF99><br>&emsp;&emsp;vector</font><<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>>> <font color=#55552A>threeSum</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>a</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> n = <font color=#194060>a</font>.<font color=#55552A>size</font>();<br>&emsp;&emsp;<font color=#85A96D>    // </font><font color=#85A96D>如果小于</font><font color=#85A96D> 3 </font><font color=#85A96D>个直接返回</font><br>&emsp;&emsp;    <font color=#713D71>if</font> (n < <font color=#435635>3</font>) <font color=#713D71>return</font> {}; <br>&emsp;&emsp;    <font color=#55552A>sort</font>(<font color=#194060>a</font>.<font color=#55552A>begin</font>(), <font color=#194060>a</font>.<font color=#55552A>end</font>());<br>&emsp;&emsp;    vector<vector<<font color=#3D6DA4>int</font>>> res;<br>&emsp;&emsp;    <font color=#713D71>for</font> (<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>;i < n;i++) {<br>&emsp;&emsp;<font color=#85A96D>        // </font><font color=#85A96D>枚举每一个不相同的数</font><br>&emsp;&emsp;        <font color=#713D71>if</font> (i && <font color=#194060>a</font>[i] == <font color=#194060>a</font>[i - <font color=#435635>1</font>]) <font color=#713D71>continue</font>;<br>&emsp;&emsp;<font color=#85A96D>        // </font><font color=#85A96D>如果枚举到了大于</font><font color=#85A96D> 0 </font><font color=#85A96D>的数</font><font color=#85A96D> </font><font color=#85A96D>直接返回</font><font color=#85A96D>?</font><br>&emsp;&emsp;<font color=#85A96D>        // </font><font color=#85A96D>因为是向后枚举的</font><br>&emsp;&emsp;        <font color=#713D71>if</font> (<font color=#194060>a</font>[i] > <font color=#435635>0</font>) <font color=#713D71>return</font> res;<br>&emsp;&emsp;<font color=#85A96D>        // </font><font color=#85A96D>从他的下一个</font><font color=#85A96D> </font><font color=#85A96D>以及最后一一个开始枚举</font><br>&emsp;&emsp;        <font color=#3D6DA4>int</font> l = i + <font color=#435635>1</font>, r = n - <font color=#435635>1</font>;<br>&emsp;&emsp;        <font color=#713D71>while</font> (l < r && l<n) {<br>&emsp;&emsp;            <font color=#3D6DA4>int</font> val = <font color=#194060>a</font>[i]+<font color=#194060>a</font>[l]+<font color=#194060>a</font>[r];<br>&emsp;&emsp;            <font color=#713D71>if</font>(val><font color=#435635>0</font>) r--;<br>&emsp;&emsp;            <font color=#713D71>else</font> <font color=#713D71>if</font>(val < <font color=#435635>0</font>) l++;<br>&emsp;&emsp;            <font color=#713D71>else</font>{<br>&emsp;&emsp;                <font color=#3D6DA4>int</font> m = <font color=#194060>res</font>.<font color=#55552A>size</font>();<br>&emsp;&emsp;<font color=#85A96D>                // </font><font color=#85A96D>看一下最后一个的数和上一次是否是一样的</font><br>&emsp;&emsp;                <font color=#713D71>if</font>(m && <font color=#194060>res</font>[m - <font color=#435635>1</font>][<font color=#435635>0</font>]==<font color=#194060>a</font>[i] && <font color=#194060>res</font>[m - <font color=#435635>1</font>][<font color=#435635>1</font>]==<font color=#194060>a</font>[l]) {<br>&emsp;&emsp;                    <font color=#435635>0</font>;<br>&emsp;&emsp;                }<font color=#713D71>else</font>{<br>&emsp;&emsp;                    <font color=#194060>res</font>.<font color=#55552A>push_back</font>({<font color=#194060>a</font>[i],<font color=#194060>a</font>[l],<font color=#194060>a</font>[r]});<br>&emsp;&emsp;                }<br>&emsp;&emsp;                l++;<br>&emsp;&emsp;            }<br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> res;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>三角形最小路径和<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>从上往下看三角形<br>&emsp;&emsp;<font color=#3D6DA4><br>&emsp;&emsp;<br>&emsp;&emsp;int</font> <font color=#55552A>minimumTotal</font>(<font color=#5DAF99>vector</font><<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>>><font color=#3D6DA4>&</font> <font color=#194060>triangle</font>) {<br>&emsp;&emsp;<font color=#85A96D>    // </font><font color=#85A96D>应该是从下往上好一点吧</font><br>&emsp;&emsp;    <font color=#3D6DA4>int</font> length = <font color=#194060>triangle</font>.<font color=#55552A>size</font>();<br>&emsp;&emsp;    vector<<font color=#3D6DA4>int</font>> f = <font color=#194060>triangle</font>[length - <font color=#435635>1</font>]; <br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = length - <font color=#435635>2</font>; i >= <font color=#435635>0</font>; i--){<br>&emsp;&emsp;        <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> j = <font color=#435635>0</font>; j <= i; j++){<br>&emsp;&emsp;            <font color=#194060>f</font>[j] = <font color=#55552A>min</font>(<font color=#194060>f</font>[j], <font color=#194060>f</font>[j + <font color=#435635>1</font>]) + <font color=#194060>triangle</font>[i][j];<br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#194060>f</font>[<font color=#435635>0</font>];<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>下降路径最小和<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><font color=#3D6DA4>// </font><font color=#3D6DA4>这个题是可以原地来的</font><font color=#3D6DA4><br>&emsp;&emsp;<br>&emsp;&emsp;int</font> <font color=#55552A>minFallingPathSum</font>(<font color=#5DAF99>vector</font><<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>>><font color=#3D6DA4>&</font> <font color=#194060>matrix</font>) {<br>&emsp;&emsp;<font color=#85A96D>    // </font><font color=#85A96D>可以试着原地来做</font><br>&emsp;&emsp;    <font color=#3D6DA4>int</font> n = <font color=#194060>matrix</font>.<font color=#55552A>size</font>(), m = <font color=#194060>matrix</font>[<font color=#435635>0</font>].<font color=#55552A>size</font>();<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>1</font>; i < n; i++){<br>&emsp;&emsp;        <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> j = <font color=#435635>0</font>; j < m; j++){<br>&emsp;&emsp;            vector<<font color=#3D6DA4>int</font>> &b = <font color=#194060>matrix</font>[i - <font color=#435635>1</font>];<br>&emsp;&emsp;            <font color=#3D6DA4>int</font> a = <font color=#194060>b</font>[j]; <br>&emsp;&emsp;            <font color=#713D71>if</font>(j) a = <font color=#55552A>min</font>(a, <font color=#194060>b</font>[j - <font color=#435635>1</font>]); <br>&emsp;&emsp;            <font color=#713D71>if</font>(j < m - <font color=#435635>1</font>) a = <font color=#55552A>min</font>(a, <font color=#194060>b</font>[j + <font color=#435635>1</font>]);<br>&emsp;&emsp;            <font color=#194060>matrix</font>[i][j] += a;<br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> res = INT_MAX;<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>auto</font> &i:<font color=#194060>matrix</font>[n - <font color=#435635>1</font>]) res = <font color=#55552A>min</font>(res, i);<br>&emsp;&emsp;    <font color=#713D71>return</font> res;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>不同的二叉搜索树<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>简单的 dp<br>&emsp;&emsp;<font color=#3D6DA4><br>&emsp;&emsp;int</font> <font color=#55552A>numTrees</font>(<font color=#3D6DA4>int</font> <font color=#194060>n</font>) {<br>&emsp;&emsp;<font color=#85A96D>    // </font><font color=#85A96D>首先创建一个数组</font><br>&emsp;&emsp;    vector<<font color=#3D6DA4>int</font>> <font color=#55552A>f</font>(n+<font color=#435635>1</font>);<br>&emsp;&emsp;    <font color=#194060>f</font>[<font color=#435635>1</font>] = <font color=#435635>1</font>; <font color=#194060>f</font>[<font color=#435635>0</font>] = <font color=#435635>1</font>;<font color=#85A96D> // </font><font color=#85A96D>然后有一个节点的一种解法</font><font color=#85A96D>, 0</font><font color=#85A96D>个的一种</font><br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>2</font>; i <= n; i++){<font color=#85A96D> // </font><font color=#85A96D>从</font><font color=#85A96D> 2 </font><font color=#85A96D>开始</font><br>&emsp;&emsp;        <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> j = <font color=#435635>0</font>; j < i; j++){ <br>&emsp;&emsp;<font color=#85A96D>            // </font><font color=#85A96D>每个都右边</font><font color=#85A96D> j </font><font color=#85A96D>个</font><font color=#85A96D>, </font><font color=#85A96D>右边</font><font color=#85A96D> i - j - 1</font><font color=#85A96D>个开始遍历</font><br>&emsp;&emsp;            <font color=#194060>f</font>[i]+= <font color=#194060>f</font>[j] * <font color=#194060>f</font>[i-j-<font color=#435635>1</font>]; <br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#194060>f</font>[n];<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>丑数 II<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>两种解法: <br>&emsp;&emsp;最小堆 和 动态规划<br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#55552A>nthUglyNumber</font>(<font color=#3D6DA4>int</font> <font color=#194060>n</font>) {<br>&emsp;&emsp;    vector<<font color=#3D6DA4>bool</font>> f;<br>&emsp;&emsp;    set<<font color=#3D6DA4>long</font> <font color=#3D6DA4>long</font>> ss; <br>&emsp;&emsp;    <font color=#3D6DA4>int</font> have = <font color=#435635>0</font>;<br>&emsp;&emsp;    <font color=#194060>ss</font>.<font color=#55552A>insert</font>(<font color=#435635>1</font>);<br>&emsp;&emsp;    <font color=#713D71>while</font>(--n){<br>&emsp;&emsp;        <font color=#3D6DA4>long</font> <font color=#3D6DA4>long</font> now = *<font color=#194060>ss</font>.<font color=#55552A>begin</font>();<br>&emsp;&emsp;        <font color=#194060>ss</font>.<font color=#55552A>erase</font>(now); <br>&emsp;&emsp;        <font color=#194060>ss</font>.<font color=#55552A>insert</font>(now * <font color=#435635>2</font>);<br>&emsp;&emsp;        <font color=#194060>ss</font>.<font color=#55552A>insert</font>(now * <font color=#435635>3</font>);<br>&emsp;&emsp;        <font color=#194060>ss</font>.<font color=#55552A>insert</font>(now * <font color=#435635>5</font>);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> *<font color=#194060>ss</font>.<font color=#55552A>begin</font>();        <br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#55552A>nthUglyNumber</font>(<font color=#3D6DA4>int</font> <font color=#194060>n</font>) {<br>&emsp;&emsp;    vector<<font color=#3D6DA4>int</font>> <font color=#55552A>dp</font>(n + <font color=#435635>1</font>);<br>&emsp;&emsp;    <font color=#194060>dp</font>[<font color=#435635>1</font>] = <font color=#435635>1</font>;<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> p2 = <font color=#435635>1</font>, p3 = <font color=#435635>1</font>, p5 = <font color=#435635>1</font>;<br>&emsp;&emsp;    <font color=#713D71>for</font> (<font color=#3D6DA4>int</font> i = <font color=#435635>2</font>; i <= n; i++) {<br>&emsp;&emsp;        <font color=#3D6DA4>int</font> num2 = <font color=#194060>dp</font>[p2] * <font color=#435635>2</font>, num3 = <font color=#194060>dp</font>[p3] * <font color=#435635>3</font>, num5 = <font color=#194060>dp</font>[p5] * <font color=#435635>5</font>;<br>&emsp;&emsp;        <font color=#194060>dp</font>[i] = <font color=#55552A>min</font>(<font color=#55552A>min</font>(num2, num3), num5);<br>&emsp;&emsp;        <font color=#713D71>if</font> (<font color=#194060>dp</font>[i] == num2) {<br>&emsp;&emsp;            p2++;<br>&emsp;&emsp;        }<br>&emsp;&emsp;        <font color=#713D71>if</font> (<font color=#194060>dp</font>[i] == num3) {<br>&emsp;&emsp;            p3++;<br>&emsp;&emsp;        }<br>&emsp;&emsp;        <font color=#713D71>if</font> (<font color=#194060>dp</font>[i] == num5) {<br>&emsp;&emsp;            p5++;<br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#194060>dp</font>[n];<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>两数之和<br>&emsp;&emsp;判断和为 target 的两个数, 返回下标是什么<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>unordered_map 或者用 <br>&emsp;&emsp;排序 + 双指针<br>&emsp;&emsp;<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>> <font color=#55552A>twoSum</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>a</font>, <font color=#3D6DA4>int</font> <font color=#194060>t</font>) {<br>&emsp;&emsp;    unordered_map<<font color=#3D6DA4>int</font>,<font color=#3D6DA4>int</font>> um;<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>; i < <font color=#194060>a</font>.<font color=#55552A>size</font>(); i++){<br>&emsp;&emsp;        <font color=#713D71>if</font>(<font color=#194060>um</font>.<font color=#55552A>count</font>(t-<font color=#194060>a</font>[i])) <font color=#713D71>return</font> {i,<font color=#194060>um</font>[t-<font color=#194060>a</font>[i]]};<br>&emsp;&emsp;        <font color=#194060>um</font>[<font color=#194060>a</font>[i]] = i;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> {};<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>乘积为正数的最长子数组长度<br>&emsp;&emsp;1e5<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>注意好的命名非常的重要, 可以学习一下<font color=#3D6DA4><br>&emsp;&emsp;</font><font color=#3D6DA4>int</font> <font color=#55552A>getMaxLen</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>nums</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> length = <font color=#194060>nums</font>.<font color=#55552A>size</font>();<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> positive{<font color=#435635>0</font>}, negative{<font color=#435635>0</font>}, maxLength{<font color=#435635>0</font>};<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>auto</font> i:nums) {<br>&emsp;&emsp;        <font color=#713D71>if</font>(i == <font color=#435635>0</font>) positive = negative = <font color=#435635>0</font>; <br>&emsp;&emsp;        <font color=#713D71>else</font> <font color=#713D71>if</font>(i < <font color=#435635>0</font>){<br>&emsp;&emsp;            <font color=#3D6DA4>int</font> newPositive = negative ? negative + <font color=#435635>1</font> : <font color=#435635>0</font>; <br>&emsp;&emsp;            <font color=#3D6DA4>int</font> newNegative = positive + <font color=#435635>1</font>;<br>&emsp;&emsp;            <font color=#55552A>tie</font>(positive, negative) = {newPositive, newNegative};<br>&emsp;&emsp;        }<font color=#713D71>else</font> <font color=#713D71>if</font>(i > <font color=#435635>0</font>){<br>&emsp;&emsp;            ++positive;<br>&emsp;&emsp;            negative = negative ? negative + <font color=#435635>1</font> : <font color=#435635>0</font>;<br>&emsp;&emsp;        }<br>&emsp;&emsp;        maxLength = <font color=#55552A>max</font>(maxLength, positive);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> maxLength;<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;<hr><hr>乘积最大子数组<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>好像有点难?<font color=#85A96D><br>&emsp;&emsp;// </font><font color=#85A96D>定一个</font><font color=#85A96D>max, </font><font color=#85A96D>定一个</font><font color=#85A96D> min,</font><font color=#85A96D>然后直接开始相乘就可以了</font><br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#55552A>maxProduct</font>(<font color=#5DAF99>vector</font>< <font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>nums</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> n = <font color=#194060>nums</font>.<font color=#55552A>size</font>();<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> maxf,minf;<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> res = maxf = minf = <font color=#194060>nums</font>[<font color=#435635>0</font>];<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>1</font>; i< n;i++){<br>&emsp;&emsp;        <font color=#3D6DA4>int</font> &a = <font color=#194060>nums</font>[i]; <br>&emsp;&emsp;        <font color=#3D6DA4>int</font> mi = minf,ma = maxf;<br>&emsp;&emsp;<font color=#85A96D>        // a, </font><font color=#85A96D>前面最大值</font><font color=#85A96D>*a, </font><font color=#85A96D>前面最小值</font><font color=#85A96D>*a</font><br>&emsp;&emsp;<font color=#85A96D>        // </font><font color=#85A96D>因此如果遇到</font><font color=#85A96D> 0,</font><font color=#85A96D>全部都会变成</font><font color=#85A96D> 0</font><br>&emsp;&emsp;        maxf = <font color=#55552A>max</font>(a, <font color=#55552A>max</font>(ma*a,mi*a)); // 这里是为了防范 a max可能是个 0 吧, 不过这个并行度好高啊<br>&emsp;&emsp;        minf = <font color=#55552A>min</font>(a, <font color=#55552A>min</font>(ma*a,mi*a));<br>&emsp;&emsp;        res = <font color=#55552A>max</font>(maxf, res);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> res;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>买卖股票的最佳时机<br>&emsp;&emsp;只能购买一次的最大利润<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>直接找最小的位置就好<font color=#3D6DA4><br>&emsp;&emsp;int</font> <font color=#55552A>maxProfit</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>prices</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> res = <font color=#435635>0</font>, n = <font color=#194060>prices</font>.<font color=#55552A>size</font>();<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> now = <font color=#194060>prices</font>[<font color=#435635>0</font>];<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>1</font>; i < n; i++){<br>&emsp;&emsp;        <font color=#713D71>if</font>(<font color=#194060>prices</font>[i] < now) now = <font color=#194060>prices</font>[i];<br>&emsp;&emsp;        <font color=#713D71>else</font> res = <font color=#55552A>max</font>(<font color=#194060>prices</font>[i] - now, res);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> res;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>买卖股票的最佳时机 II<br>&emsp;&emsp;这个改成可以买无限次, 然后看你最大收益了 <br>&emsp;&emsp;O(n) <br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><font color=#85A96D>// </font><font color=#85A96D>直接两天如果有差价就加上完事</font><br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#55552A>maxProfit</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>prices</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> res = <font color=#435635>0</font>; <br>&emsp;&emsp;    <font color=#3D6DA4>int</font> length = <font color=#194060>prices</font>.<font color=#55552A>size</font>();<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>1</font>; i < length; i++){<br>&emsp;&emsp;        res += <font color=#55552A>max</font>(<font color=#194060>prices</font>[i] - <font color=#194060>prices</font>[i - <font color=#435635>1</font>], <font color=#435635>0</font>);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> res;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>二分: ⭐️搜索旋转排序数组<br>&emsp;&emsp;边界问题很严重<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>直接两次二分是吧<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#55552A>search</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>nums</font>, <font color=#3D6DA4>int</font> <font color=#194060>target</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> l = <font color=#435635>0</font>, r = <font color=#194060>nums</font>.<font color=#55552A>size</font>() - <font color=#435635>1</font>; <br>&emsp;&emsp;    <font color=#713D71>while</font>(l < r){<br>&emsp;&emsp;        <font color=#3D6DA4>int</font> mi = (r - l) / <font color=#435635>2</font> + l; <br>&emsp;&emsp;        <font color=#713D71>if</font>(<font color=#194060>nums</font>[mi] < <font color=#194060>nums</font>[<font color=#435635>0</font>]) r = mi; <br>&emsp;&emsp;        <font color=#713D71>else</font> l = mi + <font color=#435635>1</font>;<br>&emsp;&emsp;    }<br>&emsp;&emsp;<font color=#85A96D>    // </font><font color=#85A96D>必须底下这样才是对的</font><font color=#85A96D>, </font><font color=#85A96D>已经考虑了边界条件了</font><br>&emsp;&emsp;    <font color=#713D71>if</font>(target < <font color=#194060>nums</font>[<font color=#435635>0</font>]){<br>&emsp;&emsp;        r = <font color=#194060>num</font>.<font color=#55552A>size</font>() - <font color=#435635>1</font>;<br>&emsp;&emsp;    }<font color=#713D71>else</font>{<br>&emsp;&emsp;        l = <font color=#435635>0</font>;<font color=#85A96D>// </font><font color=#85A96D>这里其实</font><font color=#85A96D> a[r] </font><font color=#85A96D>是那个最低点</font><font color=#85A96D>, </font><font color=#85A96D>不过你还是得把他取进来</font><br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>while</font>(l < r){<br>&emsp;&emsp;        <font color=#3D6DA4>int</font> mi = (r - l) / <font color=#435635>2</font> + l;<br>&emsp;&emsp;        <font color=#713D71>if</font>(<font color=#194060>nums</font>[mi] >= target) r = mi; <br>&emsp;&emsp;        <font color=#713D71>else</font> l = mi + <font color=#435635>1</font>;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>if</font>(<font color=#194060>num</font>[l] == target) <font color=#713D71>return</font> l;<br>&emsp;&emsp;    <font color=#713D71>else</font> <font color=#713D71>return</font> -<font color=#435635>1</font>;<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;<hr><hr>二分: 寻找峰值<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>简单的二分<br>&emsp;&emsp;* <font color=#3D6DA4>int</font> l = <font color=#435635>0</font>, r = <font color=#194060>a</font>.<font color=#55552A>size</font>() - <font color=#435635>1</font>;<br>&emsp;&emsp;* <font color=#713D71>while</font> (l < r) {<br>&emsp;&emsp;*     <font color=#3D6DA4>int</font> mi = l + r >> <font color=#435635>1</font>;<br>&emsp;&emsp;* <font color=#85A96D>    // </font><font color=#85A96D>不需要判断</font><font color=#85A96D> mi + 1 < n; </font><font color=#85A96D>因为我们永远取不到</font><font color=#85A96D> n - 1 </font><font color=#85A96D>上去</font><font color=#85A96D>.</font><br>&emsp;&emsp;*     <font color=#713D71>if</font> (<font color=#194060>a</font>[mi] > <font color=#194060>a</font>[mi + <font color=#435635>1</font>]) r = mi;<br>&emsp;&emsp;* <font color=#85A96D>    // </font><font color=#85A96D>右边满足的这个性质</font><font color=#85A96D>, </font><br>&emsp;&emsp;*     <font color=#713D71>else</font> l = mi + <font color=#435635>1</font>;<br>&emsp;&emsp;* }<br>&emsp;&emsp;* <font color=#713D71>return</font> l;<br>&emsp;&emsp;<hr><hr>二分:x的平方根 其他方法?<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>- A: 注意全部用 long long, 然后用的是左边满足那部分, 因为是最大值. 对吧.<br>&emsp;&emsp;- 可以有其他的数学方法或者牛顿迭代法https://leetcode-cn.com/problems/sqrtx/solution/x-de-ping-fang-gen-by-leetcode-solution/<br>&emsp;&emsp;- <br>&emsp;&emsp;简单的二分<font color=#85A96D><br>&emsp;&emsp;// </font><font color=#85A96D>为什么现在这种题都不能一下子做出来了呀</font><br>&emsp;&emsp;<font color=#3D6DA4>long</font> <font color=#3D6DA4>long</font> l = <font color=#435635>0</font>, r = x; <br>&emsp;&emsp;<font color=#713D71>while</font>(l < r){<br>&emsp;&emsp;    <font color=#3D6DA4>long</font> <font color=#3D6DA4>long</font> mi = (r - l) / <font color=#435635>2</font> + l + <font color=#435635>1</font>;<font color=#85A96D> //</font><font color=#85A96D>注意这里必须</font><font color=#85A96D> + 1</font><br>&emsp;&emsp;    <font color=#713D71>if</font>(mi * mi <= x) l = mi;<br>&emsp;&emsp;    <font color=#713D71>else</font> r = mi - <font color=#435635>1</font>;<font color=#85A96D> //</font><font color=#85A96D>注意地下如果是</font><font color=#85A96D> -1 </font><font color=#85A96D>一定要</font><font color=#85A96D> +1</font><br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>二叉树中的最大路径和<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><font color=#85A96D>// </font><font color=#85A96D>很类似原来做过的那种树上的</font><font color=#85A96D> dp </font><font color=#85A96D>题目吧</font><br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#55552A>maxPathSum</font>(<font color=#5DAF99>TreeNode</font> <font color=#3D6DA4>*</font><font color=#194060>root</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> res = INT_MIN;<br>&emsp;&emsp;    function<<font color=#3D6DA4>int</font>(TreeNode *)> dfs;<br>&emsp;&emsp;    dfs = [&](<font color=#5DAF99>TreeNode</font> <font color=#3D6DA4>*</font><font color=#194060>node</font>) {<br>&emsp;&emsp;        <font color=#713D71>if</font> (!node) <font color=#713D71>return</font> <font color=#435635>0</font>;<br>&emsp;&emsp;        <font color=#3D6DA4>int</font> l = <font color=#55552A>max</font>(<font color=#55552A>dfs</font>(<font color=#194060>node</font>-><font color=#194060>left</font>), <font color=#435635>0</font>);<br>&emsp;&emsp;        <font color=#3D6DA4>int</font> r = <font color=#55552A>max</font>(<font color=#55552A>dfs</font>(<font color=#194060>node</font>-><font color=#194060>right</font>), <font color=#435635>0</font>);<br>&emsp;&emsp;<br>&emsp;&emsp;        res = <font color=#55552A>max</font>(res, l + r + <font color=#194060>node</font>-><font color=#194060>val</font>);<br>&emsp;&emsp;        <font color=#713D71>return</font> <font color=#194060>node</font>-><font color=#194060>val</font> + <font color=#55552A>max</font>(l, r);<br>&emsp;&emsp;    };<br>&emsp;&emsp;    <font color=#55552A>dfs</font>(root);<br>&emsp;&emsp;    <font color=#713D71>return</font> res;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>二叉树的中序遍历, 递归 + 迭代<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>> <font color=#55552A>inorderTraversal</font>(<font color=#5DAF99>TreeNode</font><font color=#3D6DA4>*</font> <font color=#194060>root</font>) {<br>&emsp;&emsp;    vector<<font color=#3D6DA4>int</font>> res;<br>&emsp;&emsp;    stack<TreeNode*> stk;<br>&emsp;&emsp;<font color=#85A96D>    // </font><font color=#85A96D>如果其中还有点或者</font><font color=#85A96D> root </font><font color=#85A96D>飞空</font><br>&emsp;&emsp;    <font color=#713D71>while</font>(root!=<font color=#3D6DA4>NULL</font> || !<font color=#194060>stk</font>.<font color=#55552A>empty</font>()){<br>&emsp;&emsp;<font color=#85A96D>        // push root </font><font color=#85A96D>进去</font><font color=#85A96D>, </font><font color=#85A96D>然后</font><font color=#85A96D> root </font><font color=#85A96D>往左走</font><br>&emsp;&emsp;        <font color=#713D71>while</font>(root!=<font color=#3D6DA4>NULL</font>){<br>&emsp;&emsp;            <font color=#194060>stk</font>.<font color=#55552A>push</font>(root);root=<font color=#194060>root</font>-><font color=#194060>left</font>;<br>&emsp;&emsp;        }<br>&emsp;&emsp;<font color=#85A96D>        // </font><font color=#85A96D>然后</font><font color=#85A96D> pop </font><font color=#85A96D>出来这个点</font><font color=#85A96D>, </font><font color=#85A96D>然后赋值成有右边那个</font><br>&emsp;&emsp;        root = <font color=#194060>stk</font>.<font color=#55552A>top</font>();<font color=#194060>stk</font>.<font color=#55552A>pop</font>();<br>&emsp;&emsp;        <font color=#713D71>if</font>(root==<font color=#3D6DA4>NULL</font>) <font color=#713D71>continue</font>;<br>&emsp;&emsp;        <font color=#194060>res</font>.<font color=#55552A>push_back</font>(<font color=#194060>root</font>-><font color=#194060>val</font>);<br>&emsp;&emsp;        root = <font color=#194060>root</font>-><font color=#194060>right</font>;<br>&emsp;&emsp;<font color=#85A96D>        //</font><font color=#85A96D>这样才能保证最新访问的那个</font><font color=#85A96D>.....</font><br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> res;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>二叉树的前序遍历<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>> <font color=#55552A>preorderTraversal</font>(<font color=#5DAF99>TreeNode</font><font color=#3D6DA4>*</font> <font color=#194060>root</font>) {<br>&emsp;&emsp;    vector<<font color=#3D6DA4>int</font>> res;<br>&emsp;&emsp;    stack<TreeNode*> stk;<br>&emsp;&emsp;    <font color=#194060>stk</font>.<font color=#55552A>push</font>(root);<br>&emsp;&emsp;    <font color=#713D71>while</font> (!<font color=#194060>stk</font>.<font color=#55552A>empty</font>()) {<br>&emsp;&emsp;<font color=#85A96D>        // 1. </font><font color=#85A96D>访问</font><font color=#85A96D> 2. push </font><font color=#85A96D>左边和右边</font><br>&emsp;&emsp;        <font color=#3D6DA4>auto</font> s = <font color=#194060>stk</font>.<font color=#55552A>top</font>(); <font color=#194060>stk</font>.<font color=#55552A>pop</font>();<br>&emsp;&emsp;        <font color=#713D71>if</font> (s == <font color=#3D6DA4>NULL</font>)<font color=#713D71>continue</font>;<br>&emsp;&emsp;        <font color=#194060>res</font>.<font color=#55552A>push_back</font>(<font color=#194060>s</font>-><font color=#194060>val</font>);<br>&emsp;&emsp;        <font color=#194060>stk</font>.<font color=#55552A>push</font>(<font color=#194060>s</font>-><font color=#194060>right</font>);<br>&emsp;&emsp;        <font color=#194060>stk</font>.<font color=#55552A>push</font>(<font color=#194060>s</font>-><font color=#194060>left</font>);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> res;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>二叉树的层序遍历<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;<hr><font color=#5DAF99>vector</font><<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>>> <font color=#55552A>levelOrder</font>(<font color=#5DAF99>TreeNode</font><font color=#3D6DA4>*</font> <font color=#194060>root</font>) {<br>&emsp;&emsp;    vector<vector<<font color=#3D6DA4>int</font>>> res; <br>&emsp;&emsp;    <font color=#713D71>if</font>(!root) <font color=#713D71>return</font> res;<br>&emsp;&emsp;    queue<TreeNode*> q;<br>&emsp;&emsp;    <font color=#194060>q</font>.<font color=#55552A>push</font>(root); <br>&emsp;&emsp;    <font color=#713D71>while</font>(!<font color=#194060>q</font>.<font color=#55552A>empty</font>()){<br>&emsp;&emsp;        <font color=#3D6DA4>int</font> len = <font color=#194060>q</font>.<font color=#55552A>size</font>(); <br>&emsp;&emsp;        vector<<font color=#3D6DA4>int</font>> tmp;<br>&emsp;&emsp;        <font color=#713D71>while</font>(len--){<br>&emsp;&emsp;            <font color=#3D6DA4>auto</font> node = <font color=#194060>q</font>.<font color=#55552A>front</font>(); <font color=#194060>q</font>.<font color=#55552A>pop</font>(); <br>&emsp;&emsp;            <font color=#194060>tmp</font>.<font color=#55552A>push_back</font>(<font color=#194060>node</font>-><font color=#194060>val</font>);<br>&emsp;&emsp;            <font color=#713D71>if</font>(<font color=#194060>node</font>-><font color=#194060>left</font>) <font color=#194060>q</font>.<font color=#55552A>push</font>(<font color=#194060>node</font>-><font color=#194060>left</font>); <br>&emsp;&emsp;            <font color=#713D71>if</font>(<font color=#194060>node</font>-><font color=#194060>right</font>) <font color=#194060>q</font>.<font color=#55552A>push</font>(<font color=#194060>node</font>-><font color=#194060>right</font>);<br>&emsp;&emsp;        }<br>&emsp;&emsp;        <font color=#194060>res</font>.<font color=#55552A>push_back</font>(tmp);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> res;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>二叉树的最大深度<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;<hr>简单的层序遍历?<br>&emsp;&emsp;或者 dfs<br>&emsp;&emsp;不过可以用递归直接解决<br>&emsp;&emsp;两行代码<br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#55552A>maxDepth</font>(<font color=#5DAF99>TreeNode</font><font color=#3D6DA4>*</font> <font color=#194060>root</font>) {<br>&emsp;&emsp;    <font color=#713D71>if</font> (root == <font color=#3D6DA4>NULL</font>) <font color=#713D71>return</font> <font color=#435635>0</font>;<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#55552A>max</font>(<font color=#55552A>maxDepth</font>(<font color=#194060>root</font>-><font color=#194060>left</font>), <font color=#55552A>maxDepth</font>(<font color=#194060>root</font>-><font color=#194060>right</font>)) + <font color=#435635>1</font>;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>二叉树的锯齿形层序遍历<br>&emsp;&emsp;锯齿形层序遍历, 和那个 Z形遍历差不多<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>这是一个用上 emplace_back 的标准写法, 其实只要是奇数的那些反向就可以了<font color=#5DAF99><br>&emsp;&emsp;vector</font><<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>>> <font color=#55552A>zigzagLevelOrder</font>(<font color=#5DAF99>TreeNode</font><font color=#3D6DA4>*</font> <font color=#194060>root</font>) {<br>&emsp;&emsp;    vector<vector<<font color=#3D6DA4>int</font>>> ans;<br>&emsp;&emsp;    <font color=#713D71>if</font> (!root) {<br>&emsp;&emsp;        <font color=#713D71>return</font> ans;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    queue<TreeNode*> nodeQueue;<br>&emsp;&emsp;    <font color=#194060>nodeQueue</font>.<font color=#55552A>push</font>(root);<br>&emsp;&emsp;    <font color=#3D6DA4>bool</font> isOrderLeft = <font color=#3D6DA4>true</font>;<br>&emsp;&emsp;    <font color=#713D71>while</font> (!<font color=#194060>nodeQueue</font>.<font color=#55552A>empty</font>()) {<br>&emsp;&emsp;        deque<<font color=#3D6DA4>int</font>> levelList;<br>&emsp;&emsp;        <font color=#3D6DA4>int</font> size = <font color=#194060>nodeQueue</font>.<font color=#55552A>size</font>();<br>&emsp;&emsp;        <font color=#713D71>for</font> (<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>; i < size; ++i) {<br>&emsp;&emsp;            <font color=#3D6DA4>auto</font> node = <font color=#194060>nodeQueue</font>.<font color=#55552A>front</font>();<br>&emsp;&emsp;            <font color=#194060>nodeQueue</font>.<font color=#55552A>pop</font>();<br>&emsp;&emsp;            <font color=#713D71>if</font> (isOrderLeft) {<br>&emsp;&emsp;                <font color=#194060>levelList</font>.<font color=#55552A>push_back</font>(<font color=#194060>node</font>-><font color=#194060>val</font>);<br>&emsp;&emsp;            } <font color=#713D71>else</font> {<br>&emsp;&emsp;                <font color=#194060>levelList</font>.<font color=#55552A>push_front</font>(<font color=#194060>node</font>-><font color=#194060>val</font>);<br>&emsp;&emsp;            }<br>&emsp;&emsp;            <font color=#713D71>if</font> (<font color=#194060>node</font>-><font color=#194060>left</font>) {<br>&emsp;&emsp;                <font color=#194060>nodeQueue</font>.<font color=#55552A>push</font>(<font color=#194060>node</font>-><font color=#194060>left</font>);<br>&emsp;&emsp;            }<br>&emsp;&emsp;            <font color=#713D71>if</font> (<font color=#194060>node</font>-><font color=#194060>right</font>) {<br>&emsp;&emsp;                <font color=#194060>nodeQueue</font>.<font color=#55552A>push</font>(<font color=#194060>node</font>-><font color=#194060>right</font>);<br>&emsp;&emsp;            }<br>&emsp;&emsp;        }<br>&emsp;&emsp;        <font color=#194060>ans</font>.<font color=#55552A>emplace_back</font>(vector<<font color=#3D6DA4>int</font>>{<font color=#194060>levelList</font>.<font color=#55552A>begin</font>(), <font color=#194060>levelList</font>.<font color=#55552A>end</font>()});<br>&emsp;&emsp;        isOrderLeft = !isOrderLeft;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> ans;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>分发糖果<br>&emsp;&emsp;O(N)<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>动态规划, 只需要来回两遍就行<font color=#3D6DA4><br>&emsp;&emsp;int</font> <font color=#55552A>candy</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>ratings</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> length = <font color=#194060>ratings</font>.<font color=#55552A>size</font>(); <br>&emsp;&emsp;    vector<<font color=#3D6DA4>int</font>> <font color=#55552A>left</font>(length), <font color=#55552A>right</font>(length);<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>1</font>; i < length; i++){<br>&emsp;&emsp;        <font color=#713D71>if</font>(<font color=#194060>ratings</font>[i] > <font color=#194060>ratings</font>[i - <font color=#435635>1</font>]) <font color=#194060>left</font>[i] = <font color=#194060>left</font>[i - <font color=#435635>1</font>] + <font color=#435635>1</font>;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> res = length;<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = length - <font color=#435635>2</font>; i >= <font color=#435635>0</font>; i--){<br>&emsp;&emsp;        <font color=#713D71>if</font>(<font color=#194060>ratings</font>[i] > <font color=#194060>ratings</font>[i + <font color=#435635>1</font>]) <font color=#194060>right</font>[i] = <font color=#194060>right</font>[i + <font color=#435635>1</font>] + <font color=#435635>1</font>;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>; i < length; i++){<br>&emsp;&emsp;        res += <font color=#55552A>max</font>(<font color=#194060>left</font>[i], <font color=#194060>right</font>[i]);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> res;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>删除并获得点数<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>和打家劫舍感觉一模一样的 ...<font color=#3D6DA4><br>&emsp;&emsp;int</font> <font color=#55552A>deleteAndEarn</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>nums</font>) {<br>&emsp;&emsp;    vector<<font color=#3D6DA4>int</font>> <font color=#55552A>f</font>(<font color=#435635>1e4</font> + <font color=#435635>1</font>);<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>auto</font>& i :nums){<br>&emsp;&emsp;        <font color=#194060>f</font>[i]++;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> first = <font color=#435635>0</font>, second = <font color=#194060>f</font>[<font color=#435635>1</font>];<br>&emsp;&emsp;    <br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>2</font>; i < <font color=#435635>1e4</font> + <font color=#435635>1</font>; i++){<br>&emsp;&emsp;        <font color=#3D6DA4>int</font> tmp = second; <br>&emsp;&emsp;        <font color=#713D71>if</font>(<font color=#194060>f</font>[i]) second = <font color=#55552A>max</font>(first + <font color=#194060>f</font>[i] * i, second);<br>&emsp;&emsp;        first = tmp;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> second;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>前缀和<br>&emsp;&emsp;Q:长度为n的数列, 输入m个询问: 左l到右r的<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;<hr><font color=#85A96D>    // </font><font color=#85A96D>求出来前缀和</font><br>&emsp;&emsp;    <font color=#713D71>for</font> (<font color=#3D6DA4>int</font> i = <font color=#435635>1</font>; i <= n; i ++ ){<br>&emsp;&emsp;        <font color=#194060>s</font>[i] = <font color=#194060>s</font>[i - <font color=#435635>1</font>] + <font color=#194060>a</font>[i - <font color=#435635>1</font>];<br>&emsp;&emsp;    }<br>&emsp;&emsp;<font color=#85A96D>    // </font><font color=#85A96D>计算前缀和大小</font><br>&emsp;&emsp;    <font color=#194060>s</font>[r + <font color=#435635>1</font>] - <font color=#194060>s</font>[l];<br>&emsp;&emsp;<hr><hr>单词拆分<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><hr>单调栈<br>&emsp;&emsp;可以用来输出每个数左边第一个比它小的数或者大的数<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>可<font color=#5DAF99><br>&emsp;&emsp;vector</font><<font color=#3D6DA4>int</font>> <font color=#55552A>slove</font>(<font color=#3D6DA4>int</font> <font color=#3D6DA4>*</font><font color=#194060>a</font>, <font color=#3D6DA4>int</font> <font color=#194060>n</font>){ <br>&emsp;&emsp;    stack<<font color=#3D6DA4>int</font>> s; <br>&emsp;&emsp;    vector<<font color=#3D6DA4>int</font>> res;<br>&emsp;&emsp;    <font color=#713D71>for</font> (<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>; i < n; i ++ ){<br>&emsp;&emsp;        <font color=#713D71>while</font>(!<font color=#194060>s</font>.<font color=#55552A>empty</font>() && <font color=#194060>s</font>.<font color=#55552A>top</font>() >= <font color=#194060>a</font>[i]) <font color=#194060>s</font>.<font color=#55552A>pop</font>();<br>&emsp;&emsp;        <font color=#194060>res</font>.<font color=#55552A>push_back</font>(<font color=#194060>s</font>.<font color=#55552A>empty</font>() ? -<font color=#435635>1</font>: <font color=#194060>s</font>.<font color=#55552A>top</font>()); <br>&emsp;&emsp;        <font color=#194060>s</font>.<font color=#55552A>push</font>(<font color=#194060>a</font>[i]);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> res;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>反转链表<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>创建一个新的链表出来<br>&emsp;&emsp;也没有少创建一个吧, 还是需要备份一下的<font color=#5DAF99><br>&emsp;&emsp;ListNode</font><font color=#3D6DA4>*</font> <font color=#55552A>reverseList</font>(<font color=#5DAF99>ListNode</font><font color=#3D6DA4>*</font> <font color=#194060>head</font>) {<br>&emsp;&emsp;    ListNode* newhead = <font color=#3D6DA4>nullptr</font>;<font color=#85A96D> // </font><font color=#85A96D>这样子不用</font><font color=#85A96D> dummy </font><font color=#85A96D>可以少创建一个节点出来</font><font color=#85A96D>, </font><font color=#85A96D>不用</font><font color=#85A96D> new </font><font color=#85A96D>了</font><font color=#85A96D>,</font><font color=#85A96D>反正里面的少不掉</font><font color=#85A96D>.</font><br>&emsp;&emsp;    <font color=#713D71>while</font>(head){<br>&emsp;&emsp;        ListNode* node = <font color=#194060>head</font>-><font color=#194060>next</font>; <br>&emsp;&emsp;        <font color=#194060>head</font>-><font color=#194060>next</font> = newhead; <br>&emsp;&emsp;        newhead = head;<br>&emsp;&emsp;        head = node;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> newhead;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>合并 K 个升序链表<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>用自定义排序的 pq <br>&emsp;&emsp;利用类似归并排序的写法: <br>&emsp;&emsp;<font color=#5DAF99>ListNode</font><font color=#3D6DA4>*</font> <font color=#55552A>mergeTwoLists</font>(<font color=#5DAF99>ListNode</font> <font color=#3D6DA4>*</font><font color=#194060>a</font>, <font color=#5DAF99>ListNode</font> <font color=#3D6DA4>*</font><font color=#194060>b</font>) {<br>&emsp;&emsp;    <font color=#713D71>if</font> ((!a) || (!b)) <font color=#713D71>return</font> a ? a : b;<br>&emsp;&emsp;    ListNode head, *tail = &head, *aPtr = a, *bPtr = b;<br>&emsp;&emsp;    <font color=#713D71>while</font> (aPtr && bPtr) {<br>&emsp;&emsp;        <font color=#713D71>if</font> (<font color=#194060>aPtr</font>-><font color=#194060>val</font> < <font color=#194060>bPtr</font>-><font color=#194060>val</font>) {<br>&emsp;&emsp;            <font color=#194060>tail</font>-><font color=#194060>next</font> = aPtr; aPtr = <font color=#194060>aPtr</font>-><font color=#194060>next</font>;<br>&emsp;&emsp;        } <font color=#713D71>else</font> {<br>&emsp;&emsp;            <font color=#194060>tail</font>-><font color=#194060>next</font> = bPtr; bPtr = <font color=#194060>bPtr</font>-><font color=#194060>next</font>;<br>&emsp;&emsp;        }<br>&emsp;&emsp;        tail = <font color=#194060>tail</font>-><font color=#194060>next</font>;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#194060>tail</font>-><font color=#194060>next</font> = (aPtr ? aPtr : bPtr);<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#194060>head</font>.<font color=#194060>next</font>;<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5DAF99>ListNode</font><font color=#3D6DA4>*</font> <font color=#55552A>merge</font>(<font color=#5DAF99>vector</font> <<font color=#5DAF99>ListNode</font>*> <font color=#3D6DA4>&</font><font color=#194060>lists</font>, <font color=#3D6DA4>int</font> <font color=#194060>l</font>, <font color=#3D6DA4>int</font> <font color=#194060>r</font>) {<br>&emsp;&emsp;    <font color=#713D71>if</font> (l == r) <font color=#713D71>return</font> <font color=#194060>lists</font>[l];<br>&emsp;&emsp;    <font color=#713D71>if</font> (l > r) <font color=#713D71>return</font> <font color=#3D6DA4>nullptr</font>;<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> mid = (l + r) >> <font color=#435635>1</font>;<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#55552A>mergeTwoLists</font>(<font color=#55552A>merge</font>(lists, l, mid), <font color=#55552A>merge</font>(lists, mid + <font color=#435635>1</font>, r));<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5DAF99>ListNode</font><font color=#3D6DA4>*</font> <font color=#55552A>mergeKLists</font>(<font color=#5DAF99>vector</font><<font color=#5DAF99>ListNode</font>*><font color=#3D6DA4>&</font> <font color=#194060>lists</font>) {<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#55552A>merge</font>(lists, <font color=#435635>0</font>, <font color=#194060>lists</font>.<font color=#55552A>size</font>() - <font color=#435635>1</font>);<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;---<br>&emsp;&emsp;<font color=#3D6DA4>class</font> <font color=#5DAF99>bj</font> {<br>&emsp;&emsp;<font color=#3D6DA4>public:</font><br>&emsp;&emsp;    <font color=#3D6DA4>bool</font> <font color=#713D71>operator()</font>(<font color=#5DAF99>ListNode</font><font color=#3D6DA4>*</font> <font color=#194060>a</font>, <font color=#5DAF99>ListNode</font><font color=#3D6DA4>*</font> <font color=#194060>b</font>) {<br>&emsp;&emsp;        <font color=#713D71>return</font> <font color=#194060>a</font>-><font color=#194060>val</font> > <font color=#194060>b</font>-><font color=#194060>val</font>;<br>&emsp;&emsp;    }<br>&emsp;&emsp;};<br>&emsp;&emsp;<font color=#85A96D>// </font><font color=#85A96D>直接用自定义排序的</font><font color=#85A96D> pq;</font><br>&emsp;&emsp;<font color=#5DAF99>ListNode</font><font color=#3D6DA4>*</font> <font color=#55552A>mergeKLists</font>(<font color=#5DAF99>vector</font><<font color=#5DAF99>ListNode</font>*><font color=#3D6DA4>&</font> <font color=#194060>lists</font>) {<br>&emsp;&emsp;    <font color=#713D71>if</font> (<font color=#194060>lists</font>.<font color=#55552A>size</font>() == <font color=#435635>0</font>) <font color=#713D71>return</font> <font color=#3D6DA4>nullptr</font>;<br>&emsp;&emsp;    ListNode* dummy = <font color=#713D71>new</font> <font color=#55552A>ListNode</font>(-<font color=#435635>1</font>);<br>&emsp;&emsp;    ListNode* ans = dummy;<br>&emsp;&emsp;    priority_queue<ListNode*, vector<ListNode*>, bj> pq;<br>&emsp;&emsp;    <font color=#713D71>for</font> (<font color=#3D6DA4>auto</font>& x : lists) {<br>&emsp;&emsp;        <font color=#713D71>if</font> (x) <font color=#194060>pq</font>.<font color=#55552A>push</font>(x);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>while</font> (!<font color=#194060>pq</font>.<font color=#55552A>empty</font>()) {<br>&emsp;&emsp;<font color=#85A96D>        // cout << ans->val;</font><br>&emsp;&emsp;        ans = <font color=#194060>ans</font>-><font color=#194060>next</font> = <font color=#194060>pq</font>.<font color=#55552A>top</font>();<br>&emsp;&emsp;        <font color=#3D6DA4>auto</font> x = <font color=#194060>pq</font>.<font color=#55552A>top</font>();<br>&emsp;&emsp;        <font color=#194060>pq</font>.<font color=#55552A>pop</font>();<br>&emsp;&emsp;        <font color=#713D71>if</font> (<font color=#194060>x</font>-><font color=#194060>next</font>)<font color=#194060>pq</font>.<font color=#55552A>push</font>(<font color=#194060>x</font>-><font color=#194060>next</font>);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#194060>dummy</font>-><font color=#194060>next</font>;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>合并两个有序链表<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>用一个 dummy, 然后直接赋值就行了<font color=#5DAF99><br>&emsp;&emsp;ListNode</font><font color=#3D6DA4>*</font> <font color=#55552A>mergeTwoLists</font>(<font color=#5DAF99>ListNode</font><font color=#3D6DA4>*</font> <font color=#194060>list1</font>, <font color=#5DAF99>ListNode</font><font color=#3D6DA4>*</font> <font color=#194060>list2</font>) {<br>&emsp;&emsp;    ListNode *dummy = <font color=#713D71>new</font> <font color=#55552A>ListNode</font>(-<font color=#435635>1</font>); <br>&emsp;&emsp;    ListNode *p = dummy;<br>&emsp;&emsp;    <font color=#713D71>while</font>(list1 && list2){<br>&emsp;&emsp;        <font color=#713D71>if</font>(<font color=#194060>list1</font>-><font color=#194060>val</font><<font color=#194060>list2</font>-><font color=#194060>val</font>) <font color=#194060>p</font>-><font color=#194060>next</font> = list1, list1 = <font color=#194060>list1</font>-><font color=#194060>next</font>;<br>&emsp;&emsp;        <font color=#713D71>else</font> <font color=#194060>p</font>-><font color=#194060>next</font> = list2, list2 = <font color=#194060>list2</font>-><font color=#194060>next</font>;<br>&emsp;&emsp;        p = <font color=#194060>p</font>-><font color=#194060>next</font>; <br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>if</font>(list1) <font color=#194060>p</font>-><font color=#194060>next</font> = list1; <br>&emsp;&emsp;    <font color=#713D71>else</font> <font color=#194060>p</font>-><font color=#194060>next</font> = list2;<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#194060>dummy</font>-><font color=#194060>next</font>;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>大数加法<br>&emsp;&emsp;字符串相加<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><font color=#5DAF99>string</font> <font color=#55552A>addStrings</font>(<font color=#5DAF99>string</font> <font color=#194060>num1</font>, <font color=#5DAF99>string</font> <font color=#194060>num2</font>) {<br>&emsp;&emsp;    <font color=#55552A>reverse</font>(<font color=#194060>num1</font>.<font color=#55552A>begin</font>(), <font color=#194060>num1</font>.<font color=#55552A>end</font>());        <br>&emsp;&emsp;    <font color=#55552A>reverse</font>(<font color=#194060>num2</font>.<font color=#55552A>begin</font>(), <font color=#194060>num2</font>.<font color=#55552A>end</font>());        <br>&emsp;&emsp;    <font color=#713D71>if</font>(<font color=#194060>num1</font>.<font color=#55552A>size</font>()<<font color=#194060>num2</font>.<font color=#55552A>size</font>())<font color=#55552A>swap</font>(num1,num2);<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> tmp = <font color=#435635>0</font>;<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> n = <font color=#194060>num1</font>.<font color=#55552A>size</font>(), m = <font color=#194060>num2</font>.<font color=#55552A>size</font>();<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>; i< m || tmp;i++){<br>&emsp;&emsp;        <font color=#713D71>if</font>(i==n) num1+=<font color=#7F4D36>'0'</font>;<br>&emsp;&emsp;        <font color=#194060>num1</font>[i] += tmp;<br>&emsp;&emsp;        <font color=#713D71>if</font>(i<m) <font color=#194060>num1</font>[i] += <font color=#194060>num2</font>[i] -<font color=#7F4D36>'0'</font>;<br>&emsp;&emsp;        tmp = <font color=#435635>0</font>;<br>&emsp;&emsp;        <font color=#713D71>if</font>(<font color=#194060>num1</font>[i]><font color=#7F4D36>'9'</font>){<br>&emsp;&emsp;            <font color=#194060>num1</font>[i]-=<font color=#435635>10</font>;<br>&emsp;&emsp;            tmp = <font color=#435635>1</font>;<br>&emsp;&emsp;        }<br>&emsp;&emsp;            <br>&emsp;&emsp;    } <br>&emsp;&emsp;    <font color=#55552A>reverse</font>(<font color=#194060>num1</font>.<font color=#55552A>begin</font>(), <font color=#194060>num1</font>.<font color=#55552A>end</font>());        <br>&emsp;&emsp;    <font color=#713D71>return</font> num1;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>字符串转换整数<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>很像是一个状态机, 然后来回进行判断吧<font color=#3D6DA4><br>&emsp;&emsp;int</font> <font color=#55552A>myAtoi</font>(<font color=#5DAF99>string</font> <font color=#194060>s</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>bool</font> start = <font color=#3D6DA4>false</font>;<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> reverse = <font color=#435635>1</font>;<br>&emsp;&emsp;    <font color=#3D6DA4>long</font> <font color=#3D6DA4>long</font> r = <font color=#435635>0</font>;<br>&emsp;&emsp;    <font color=#713D71>for</font> (<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>;i < <font color=#194060>s</font>.<font color=#55552A>size</font>();i++) {<br>&emsp;&emsp;        <font color=#713D71>if</font> (<font color=#194060>s</font>[i] == <font color=#7F4D36>' '</font>&&!start)<font color=#713D71>continue</font>;<br>&emsp;&emsp;        <font color=#713D71>if</font> (<font color=#194060>s</font>[i] >= <font color=#7F4D36>'0'</font> && <font color=#194060>s</font>[i] <= <font color=#7F4D36>'9'</font>) {<br>&emsp;&emsp;            r = r * <font color=#435635>10</font> + (<font color=#194060>s</font>[i] - <font color=#7F4D36>'0'</font>) * reverse;<br>&emsp;&emsp;            <font color=#713D71>if</font> (r > INT_MAX)<font color=#713D71>return</font> INT_MAX;<br>&emsp;&emsp;            <font color=#713D71>else</font> <font color=#713D71>if</font> (r < INT_MIN)<font color=#713D71>return</font> INT_MIN;<br>&emsp;&emsp;            start = <font color=#3D6DA4>true</font>;<br>&emsp;&emsp;        }<br>&emsp;&emsp;        <font color=#713D71>else</font> <font color=#713D71>if</font> (<font color=#194060>s</font>[i] == <font color=#7F4D36>'-'</font> && !start) {<br>&emsp;&emsp;            reverse = -<font color=#435635>1</font>, start = <font color=#3D6DA4>true</font>;<br>&emsp;&emsp;        }<br>&emsp;&emsp;        <font color=#713D71>else</font> <font color=#713D71>if</font> (<font color=#194060>s</font>[i] == <font color=#7F4D36>'+'</font> && !start) {<br>&emsp;&emsp;            reverse = <font color=#435635>1</font>, start = <font color=#3D6DA4>true</font>;<br>&emsp;&emsp;        }<br>&emsp;&emsp;        <font color=#713D71>else</font> {<br>&emsp;&emsp;            <font color=#713D71>break</font>;<br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> r;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>岛屿周长?<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>1. dfs 发现如果是 1 就看周边的. <br>&emsp;&emsp;2. 循环直接判断, 周边是不是可以算作周长<hr><hr><font color=#FEAE00>岛屿数量</font><br>&emsp;&emsp;面试有什么<font color=#FEAE00>需要注意</font>的?<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>##  面试时候注意问下面试官<font color=#FEAE00>能否修改原数组</font><font color=#FEAE00>, </font><font color=#FEAE00>不行的话</font><font color=#FEAE00>, </font><font color=#FEAE00>创建个</font><font color=#FEAE00> flag </font><font color=#FEAE00>数组</font><font color=#FEAE00> </font><br>&emsp;&emsp;1. <font color=#FEAE00>标准</font><font color=#FEAE00> dfs </font><font color=#FEAE00>解法</font><font color=#FEAE00><br>&emsp;&emsp;</font>2. <font color=#FEAE00>并查集</font><font color=#FEAE00>, </font><font color=#FEAE00>直接解</font><font color=#FEAE00><br>&emsp;&emsp;</font>3. <font color=#FEAE00>bfs </font><font color=#FEAE00>解法</font><br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;1. dfs:: <br>&emsp;&emsp;<font color=#3D6DA4>int</font>[<font color=#435635>4</font>][<font color=#435635>2</font>] dir = {{<font color=#435635>0</font>, <font color=#435635>1</font>}, {<font color=#435635>0</font>, -<font color=#435635>1</font>}, {<font color=#435635>1</font>, <font color=#435635>0</font>}, {-<font color=#435635>1</font>, <font color=#435635>0</font>}};<font color=#85A96D> // </font><font color=#85A96D>这样子方便遍历</font><br>&emsp;&emsp;function<<font color=#3D6DA4>void</font>(<font color=#3D6DA4>int</font>,<font color=#3D6DA4>int</font>,<font color=#3D6DA4>bool</font>)> dfs = [&](<font color=#3D6DA4>int</font> <font color=#194060>i</font>, <font color=#3D6DA4>int</font> <font color=#194060>j</font>, <font color=#3D6DA4>bool</font> <font color=#194060>count</font>){<br>&emsp;&emsp;    <font color=#713D71>if</font>(<font color=#194060>grid</font>[i][j] == <font color=#7F4D36>'1'</font>){<br>&emsp;&emsp;        <font color=#713D71>if</font>(count) res ++;<br>&emsp;&emsp;        <font color=#194060>grid</font>[i][j] = <font color=#435635>0</font>;<br>&emsp;&emsp;        <font color=#713D71>for</font>(<font color=#3D6DA4>auto</font> d:dir){<br>&emsp;&emsp;            <font color=#3D6DA4>int</font> x = i + <font color=#194060>d</font>[<font color=#435635>0</font>], y = j + <font color=#194060>d</font>[<font color=#435635>1</font>];<font color=#85A96D> // </font><font color=#85A96D>相加操作</font><br>&emsp;&emsp;            <font color=#713D71>if</font>(x >= <font color=#435635>0</font> && x < n && y >= <font color=#435635>0</font> && y < m){<br>&emsp;&emsp;                <font color=#55552A>dfs</font>(x, y, <font color=#3D6DA4>false</font>);<br>&emsp;&emsp;            }<br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;};<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;2. 并查集::<br>&emsp;&emsp;注意这个合并操作 背会<br>&emsp;&emsp;<font color=#3D6DA4>auto</font> find = [&](<font color=#3D6DA4>int</font> <font color=#194060>x</font>){<br>&emsp;&emsp;    <font color=#713D71>if</font>(<font color=#194060>p</font>[x] != x)<br>&emsp;&emsp;        <font color=#713D71>return</font> <font color=#194060>p</font>[x] = <font color=#55552A>find</font>(<font color=#194060>p</font>[x]);<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#194060>p</font>[x];            <br>&emsp;&emsp;};<br>&emsp;&emsp;<hr><hr>岛屿的最大面积<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>dfs / bfs / 并查集<br>&emsp;&emsp;<br>&emsp;&emsp;可以使用栈来实现 dfs <br>&emsp;&emsp;<br>&emsp;&emsp;还是改一下吧 这样复杂度有点高<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#55552A>maxAreaOfIsland</font>(<font color=#5DAF99>vector</font><<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>>><font color=#3D6DA4>&</font> <font color=#194060>grid</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> n = <font color=#194060>grid</font>.<font color=#55552A>size</font>(), m = <font color=#194060>grid</font>[<font color=#435635>0</font>].<font color=#55552A>size</font>();<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> ans = <font color=#435635>0</font>;<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> <font color=#194060>dir</font>[<font color=#435635>4</font>][<font color=#435635>2</font>] = {{<font color=#435635>0</font>,<font color=#435635>1</font>}, {<font color=#435635>0</font>,-<font color=#435635>1</font>}, {-<font color=#435635>1</font>,<font color=#435635>0</font>}, {<font color=#435635>1</font>,<font color=#435635>0</font>}};<br>&emsp;&emsp;    <font color=#713D71>for</font> (<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>; i != n; ++i) {<br>&emsp;&emsp;        <font color=#713D71>for</font> (<font color=#3D6DA4>int</font> j = <font color=#435635>0</font>; j != m; ++j) {<font color=#85A96D> //</font><font color=#85A96D>遍历一遍</font><br>&emsp;&emsp;            <font color=#713D71>if</font>(!<font color=#194060>grid</font>[i][j]) <font color=#713D71>continue</font>;<br>&emsp;&emsp;            <font color=#3D6DA4>int</font> cur = <font color=#435635>1</font>;<br>&emsp;&emsp;            stack<pair<<font color=#3D6DA4>int</font>,<font color=#3D6DA4>int</font>>> ss;<br>&emsp;&emsp;            <font color=#194060>ss</font>.<font color=#55552A>push</font>({i,j});<br>&emsp;&emsp;            <font color=#194060>grid</font>[i][j] = <font color=#435635>0</font>;<br>&emsp;&emsp;            <font color=#713D71>while</font> (!<font color=#194060>ss</font>.<font color=#55552A>empty</font>()) {<br>&emsp;&emsp;                <font color=#3D6DA4>int</font> cur_i = <font color=#194060>ss</font>.<font color=#55552A>top</font>().<font color=#194060>first</font>, cur_j = <font color=#194060>ss</font>.<font color=#55552A>top</font>().<font color=#194060>second</font>;<br>&emsp;&emsp;                <font color=#194060>ss</font>.<font color=#55552A>pop</font>();<br>&emsp;&emsp;                <font color=#713D71>for</font>(<font color=#3D6DA4>auto</font> d:dir){<br>&emsp;&emsp;                    <font color=#3D6DA4>int</font> next_i = cur_i + <font color=#194060>d</font>[<font color=#435635>0</font>], next_j = cur_j + <font color=#194060>d</font>[<font color=#435635>1</font>];<br>&emsp;&emsp;                    <font color=#713D71>if</font>(next_i >=<font color=#435635>0</font> && next_i<n && next_j>=<font color=#435635>0</font> && next_j<m && <font color=#194060>grid</font>[next_i][next_j]){ <br>&emsp;&emsp;                        <font color=#194060>ss</font>.<font color=#55552A>push</font>({next_i, next_j});<br>&emsp;&emsp;                        <font color=#194060>grid</font>[next_i][next_j] = <font color=#435635>0</font>;<br>&emsp;&emsp;                        cur++;<br>&emsp;&emsp;                    }<br>&emsp;&emsp;                }<br>&emsp;&emsp;            }<br>&emsp;&emsp;            ans = <font color=#55552A>max</font>(ans, cur);<br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> ans;<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;<hr><hr>恰有 K 根木棍可以看到的排列数目<br>&emsp;&emsp;￼<br>&emsp;&emsp;todo 没看懂<hr>￼<br>&emsp;&emsp;懂了 考虑最短的那根是否能被看到<br>&emsp;&emsp;￼<br>&emsp;&emsp;这是个斯特林数？<hr><hr>手写归并排序<hr><font color=#3D6DA4>需要改进</font><font color=#3D6DA4> </font><font color=#3D6DA4>有更高效的算法</font><font color=#3D6DA4><br>&emsp;&emsp;</font><font color=#3D6DA4>还有试着都写成</font><font color=#3D6DA4> template</font><font color=#3D6DA4>形式的</font><font color=#3D6DA4><br>&emsp;&emsp;void</font> <font color=#55552A>msort</font>(<font color=#3D6DA4>int</font> <font color=#3D6DA4>*</font><font color=#194060>a</font>, <font color=#3D6DA4>int</font> <font color=#194060>l</font>, <font color=#3D6DA4>int</font> <font color=#194060>r</font>) {<font color=#85A96D> // </font><font color=#85A96D>还是</font><font color=#85A96D> l </font><font color=#85A96D>和</font><font color=#85A96D> r - 1;</font><br>&emsp;&emsp;    <font color=#713D71>if</font> (l >= r) <font color=#713D71>return</font>;<font color=#85A96D> // </font><font color=#85A96D>递归基</font><font color=#85A96D>  </font><font color=#85A96D>一个数</font><br>&emsp;&emsp;    <font color=#3D6DA4>int</font> mid = l + (r - l) / <font color=#435635>2</font>;<font color=#85A96D> // </font><font color=#85A96D>二分</font><font color=#85A96D>.</font><br>&emsp;&emsp;    <font color=#55552A>msort</font>(a, l, mid), <font color=#55552A>msort</font>(a, mid + <font color=#435635>1</font>, r);<font color=#85A96D> // </font><font color=#85A96D>递归两边</font><font color=#85A96D>.</font><br>&emsp;&emsp;    <font color=#3D6DA4>int</font> k = <font color=#435635>0</font>, i = l, j = mid + <font color=#435635>1</font>;<font color=#85A96D> // </font><font color=#85A96D>命名新的变量</font><font color=#85A96D> k </font><font color=#85A96D>代表</font><font color=#85A96D>tmp </font><font color=#85A96D>里面的序数</font><br>&emsp;&emsp;    <font color=#713D71>while</font> (i < = mid && j < = r)<font color=#85A96D>  // </font><font color=#85A96D>当两边都没到底时候</font><font color=#85A96D> (</font><font color=#85A96D>小于等于</font><font color=#85A96D>)★</font><br>&emsp;&emsp;        <font color=#713D71>if</font> (<font color=#194060>a</font>[i] < = <font color=#194060>a</font>[j]) <font color=#194060>tmp</font>[k++] = <font color=#194060>a</font>[i++];<font color=#85A96D> // </font><font color=#85A96D>往后</font><br>&emsp;&emsp;        <font color=#713D71>else</font> <font color=#194060>tmp</font>[k++] = <font color=#194060>a</font>[j++];<br>&emsp;&emsp;    <font color=#713D71>while</font> (i < = mid) <font color=#194060>tmp</font>[k++] = <font color=#194060>a</font>[i++];<font color=#85A96D> //</font><font color=#85A96D>这种放后面写清晰点</font><font color=#85A96D>.</font><br>&emsp;&emsp;    <font color=#713D71>while</font> (j < = r) <font color=#194060>tmp</font>[k++] = <font color=#194060>a</font>[j++];<br>&emsp;&emsp;    <font color=#713D71>for</font> (i = l, j = <font color=#435635>0</font>;i < = r;i++, j++) <font color=#194060>a</font>[i] = <font color=#194060>tmp</font>[j];<font color=#85A96D> // </font><font color=#85A96D>数组进行腾挪</font><font color=#85A96D>.</font><br>&emsp;&emsp;<font color=#85A96D>           // </font><font color=#85A96D>可能有</font><font color=#85A96D>vector</font><font color=#85A96D>有更高效的操作</font><font color=#85A96D>?</font><br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>手写快速排序<hr>快速排序, 记得记一下<br>&emsp;&emsp;下午好好理解一下<font color=#3D6DA4><br>&emsp;&emsp;void</font> <font color=#55552A>qSort</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>> <font color=#3D6DA4>&</font><font color=#194060>q</font>, <font color=#3D6DA4>int</font> <font color=#194060>l</font>, <font color=#3D6DA4>int</font> <font color=#194060>r</font>){<br>&emsp;&emsp;    <font color=#713D71>if</font>(l >= r) <font color=#713D71>return</font>;<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> now = <font color=#194060>q</font>[l]; <br>&emsp;&emsp;<font color=#85A96D>    // </font><font color=#85A96D>注意这里</font><font color=#85A96D> x </font><font color=#85A96D>的取值必须是这样的</font><br>&emsp;&emsp;    <font color=#3D6DA4>int</font> x = <font color=#194060>q</font>[(r - l) / <font color=#435635>2</font> + l], i = l - <font color=#435635>1</font>, j = r + <font color=#435635>1</font>;<br>&emsp;&emsp;    <font color=#713D71>while</font>(i < j){<br>&emsp;&emsp;        <font color=#713D71>while</font>(<font color=#194060>q</font>[++i] < x);<font color=#85A96D> // </font><font color=#85A96D>找到第一个小于</font><font color=#85A96D> x </font><font color=#85A96D>的数</font><br>&emsp;&emsp;        <font color=#713D71>while</font>(<font color=#194060>q</font>[--j] > x);<font color=#85A96D> // </font><font color=#85A96D>找到第一个大于</font><font color=#85A96D> x </font><font color=#85A96D>的数</font><br>&emsp;&emsp;        <font color=#713D71>if</font>(i < j) <font color=#55552A>swap</font>(<font color=#194060>q</font>[i], <font color=#194060>q</font>[j]);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#55552A>qSort</font>(q, l, j); <br>&emsp;&emsp;    <font color=#55552A>qSort</font>(q, j + <font color=#435635>1</font>, r);<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>打家劫舍<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>另一种解法从偷不偷考虑，当前点只能偷倒数第二个 所以直接来<br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#55552A>rob</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>nums</font>) {    <br>&emsp;&emsp;    <font color=#713D71>if</font>(<font color=#194060>nums</font>.<font color=#55552A>size</font>()==<font color=#435635>1</font>)<font color=#713D71>return</font> <font color=#194060>nums</font>[<font color=#435635>0</font>];<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> n = <font color=#194060>nums</font>.<font color=#55552A>size</font>();<br>&emsp;&emsp;    vector<<font color=#3D6DA4>int</font>> <font color=#55552A>dp</font>(n);<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> first = <font color=#194060>nums</font>[<font color=#435635>0</font>], sec = <font color=#55552A>max</font>(<font color=#194060>nums</font>[<font color=#435635>1</font>], <font color=#194060>nums</font>[<font color=#435635>0</font>]);<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>2</font>;i<n;i++){<br>&emsp;&emsp;        <font color=#3D6DA4>int</font> nowsec = <font color=#55552A>max</font>(sec, first + <font color=#194060>nums</font>[i]);<br>&emsp;&emsp;        first = sec; <br>&emsp;&emsp;        sec = nowsec;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> sec;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>打家劫舍 II<br>&emsp;&emsp;所有的房子都在一个环中, 同时你不能抢劫相邻的两个房子, 问最大能抢到的钱数<br>&emsp;&emsp;1 - 100 <br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>如果用 O(2*n) 的话, 可以做两次<br>&emsp;&emsp;一次把最前面一个去掉, 一次把最后面一个去掉<br>&emsp;&emsp;注意 robRange 里面这个边界条件的处理<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#55552A>robRange</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>nums</font>, <font color=#3D6DA4>int</font> <font color=#194060>start</font>, <font color=#3D6DA4>int</font> <font color=#194060>end</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> first = <font color=#194060>nums</font>[start], second = <font color=#55552A>max</font>(<font color=#194060>nums</font>[start], <font color=#194060>nums</font>[start + <font color=#435635>1</font>]);<br>&emsp;&emsp;    <font color=#713D71>for</font> (<font color=#3D6DA4>int</font> i = start + <font color=#435635>2</font>; i <= end; i++) {<br>&emsp;&emsp;        <font color=#3D6DA4>int</font> temp = second;<br>&emsp;&emsp;<font color=#85A96D>        // </font><font color=#85A96D>这样计算当前的</font><font color=#85A96D> max </font><font color=#85A96D>可以省去很多麻烦对吧</font><font color=#85A96D>, </font><font color=#85A96D>也是对的</font><br>&emsp;&emsp;        second = <font color=#55552A>max</font>(first + <font color=#194060>nums</font>[i], second);<br>&emsp;&emsp;        first = temp;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> second;<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#55552A>rob</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>nums</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> length = <font color=#194060>nums</font>.<font color=#55552A>size</font>();<br>&emsp;&emsp;    <font color=#713D71>if</font> (length == <font color=#435635>1</font>) {<br>&emsp;&emsp;        <font color=#713D71>return</font> <font color=#194060>nums</font>[<font color=#435635>0</font>];<br>&emsp;&emsp;    } <font color=#713D71>else</font> <font color=#713D71>if</font> (length == <font color=#435635>2</font>) {<br>&emsp;&emsp;        <font color=#713D71>return</font> <font color=#55552A>max</font>(<font color=#194060>nums</font>[<font color=#435635>0</font>], <font color=#194060>nums</font>[<font color=#435635>1</font>]);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#55552A>max</font>(<font color=#55552A>robRange</font>(nums, <font color=#435635>0</font>, length - <font color=#435635>2</font>), <font color=#55552A>robRange</font>(nums, <font color=#435635>1</font>, length - <font color=#435635>1</font>));<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;<hr><hr>接雨水<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>•	动态规划:<br>&emsp;&emsp;	◦	左边接一次, 右边接一次, 然后两个join起来.<br>&emsp;&emsp;•	单调栈<br>&emsp;&emsp;	◦	由于每次都这样接, 整体单调可以算出来<br>&emsp;&emsp;•	双指针<br>&emsp;&emsp;	◦	?? 如何计算当前的最高? 还有...<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;只会最简单的 dp 方法,从左边扫一遍, 从右边扫一遍<font color=#3D6DA4><br>&emsp;&emsp;int</font> <font color=#55552A>trap</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>height</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> n = <font color=#194060>height</font>.<font color=#55552A>size</font>();<br>&emsp;&emsp;    vector<<font color=#3D6DA4>int</font>> <font color=#55552A>left</font>(n), <font color=#55552A>right</font>(n); <br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>; i < n; i++){<br>&emsp;&emsp;        <font color=#194060>left</font>[i] = <font color=#194060>height</font>[i]; <br>&emsp;&emsp;        <font color=#713D71>if</font>(i > <font color=#435635>0</font>) <font color=#194060>left</font>[i] = <font color=#55552A>max</font>(<font color=#194060>left</font>[i-<font color=#435635>1</font>], <font color=#194060>left</font>[i]); <br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = n - <font color=#435635>1</font>; i >= <font color=#435635>0</font>; i--){<br>&emsp;&emsp;        <font color=#194060>right</font>[i] = <font color=#194060>height</font>[i]; <br>&emsp;&emsp;        <font color=#713D71>if</font>(i < n - <font color=#435635>1</font>) <font color=#194060>right</font>[i] = <font color=#55552A>max</font>(<font color=#194060>right</font>[i + <font color=#435635>1</font>], <font color=#194060>right</font>[i]);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> res = <font color=#435635>0</font>;<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>; i < n; i++){<br>&emsp;&emsp;        res += <font color=#55552A>min</font>(<font color=#194060>left</font>[i], <font color=#194060>right</font>[i]) - <font color=#194060>height</font>[i];<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> res;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>数组中第k个最大<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>- 方法一：基于快速排序的选择方法<br>&emsp;&emsp;- 方法二: 堆中的东西<br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#55552A>quickSelect</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>a</font>, <font color=#3D6DA4>int</font> <font color=#194060>l</font>, <font color=#3D6DA4>int</font> <font color=#194060>r</font>, <font color=#3D6DA4>int</font> <font color=#194060>index</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> q = <font color=#55552A>randomPartition</font>(a, l, r);<br>&emsp;&emsp;    <font color=#713D71>if</font> (q == index) {<br>&emsp;&emsp;        <font color=#713D71>return</font> <font color=#194060>a</font>[q];<br>&emsp;&emsp;    } <font color=#713D71>else</font> {<br>&emsp;&emsp;        <font color=#713D71>return</font> q < index ? <font color=#55552A>quickSelect</font>(a, q + <font color=#435635>1</font>, r, index) : <font color=#55552A>quickSelect</font>(a, l, q - <font color=#435635>1</font>, index);<br>&emsp;&emsp;    }<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#3D6DA4>inline</font> <font color=#3D6DA4>int</font> <font color=#55552A>randomPartition</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>a</font>, <font color=#3D6DA4>int</font> <font color=#194060>l</font>, <font color=#3D6DA4>int</font> <font color=#194060>r</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> i = <font color=#55552A>rand</font>() % (r - l + <font color=#435635>1</font>) + l;<br>&emsp;&emsp;    <font color=#55552A>swap</font>(<font color=#194060>a</font>[i], <font color=#194060>a</font>[r]);<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#55552A>partition</font>(a, l, r);<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#3D6DA4>inline</font> <font color=#3D6DA4>int</font> <font color=#55552A>partition</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>a</font>, <font color=#3D6DA4>int</font> <font color=#194060>l</font>, <font color=#3D6DA4>int</font> <font color=#194060>r</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> x = <font color=#194060>a</font>[r], i = l - <font color=#435635>1</font>;<br>&emsp;&emsp;    <font color=#713D71>for</font> (<font color=#3D6DA4>int</font> j = l; j < r; ++j) {<br>&emsp;&emsp;        <font color=#713D71>if</font> (<font color=#194060>a</font>[j] <= x) {<br>&emsp;&emsp;            <font color=#55552A>swap</font>(<font color=#194060>a</font>[++i], <font color=#194060>a</font>[j]);<br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#55552A>swap</font>(<font color=#194060>a</font>[i + <font color=#435635>1</font>], <font color=#194060>a</font>[r]);<br>&emsp;&emsp;    <font color=#713D71>return</font> i + <font color=#435635>1</font>;<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#55552A>findKthLargest</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>nums</font>, <font color=#3D6DA4>int</font> <font color=#194060>k</font>) {<br>&emsp;&emsp;    <font color=#55552A>srand</font>(<font color=#55552A>time</font>(<font color=#435635>0</font>));<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#55552A>quickSelect</font>(nums, <font color=#435635>0</font>, <font color=#194060>nums</font>.<font color=#55552A>size</font>() - <font color=#435635>1</font>, <font color=#194060>nums</font>.<font color=#55552A>size</font>() - k);<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr><font color=#666666>斐波那契数列</font><font color=#666666> </font><font color=#666666>线性</font><font color=#666666> dp<br>&emsp;&emsp;</font>￼<br>&emsp;&emsp;<hr>这样多算一个可能爆掉<br>&emsp;&emsp;因此可以进来直接 n--<br>&emsp;&emsp;然后最后的时候是 return b<font color=#3D6DA4><br>&emsp;&emsp;int</font> <font color=#55552A>slove</font>(<font color=#3D6DA4>int</font> <font color=#194060>n</font>){<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> a = <font color=#435635>0</font>, b = <font color=#435635>1</font>,c;<font color=#85A96D> // </font><font color=#85A96D>这样子直接设置</font><br>&emsp;&emsp;    <font color=#713D71>while</font>(n--){<font color=#85A96D> // </font><font color=#85A96D>直接从</font><font color=#85A96D> n </font><font color=#85A96D>开始</font><br>&emsp;&emsp;        c = a + b;<font color=#85A96D> // </font><font color=#85A96D>每次交换一下</font><br>&emsp;&emsp;        a = b; <br>&emsp;&emsp;        b = c;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> a;<font color=#85A96D> // </font><font color=#85A96D>最后直接返回就行</font><br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>最佳观光组合<br>&emsp;&emsp;两个之间的 j - i<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>简单的 dp <font color=#3D6DA4><br>&emsp;&emsp;int</font> <font color=#55552A>maxScoreSightseeingPair</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>a</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> n = <font color=#194060>a</font>.<font color=#55552A>size</font>();<br>&emsp;&emsp;    vector<<font color=#3D6DA4>int</font>> <font color=#55552A>f</font>(<font color=#55552A>sz</font>(a));<br>&emsp;&emsp;    <font color=#194060>f</font>[<font color=#435635>0</font>] = <font color=#194060>a</font>[<font color=#435635>0</font>];<br>&emsp;&emsp;    <font color=#55552A>rep</font>(i, <font color=#435635>1</font>, n) {<br>&emsp;&emsp;<font color=#85A96D>        // </font><font color=#85A96D>从前到后</font><font color=#85A96D>, </font><font color=#85A96D>每个点的值</font><font color=#85A96D>, </font><font color=#85A96D>是这个点的值加上前一个点能达到的</font><font color=#85A96D> -1 </font><br>&emsp;&emsp;        <font color=#194060>f</font>[i] = <font color=#55552A>max</font>(<font color=#194060>a</font>[i], <font color=#194060>f</font>[i - <font color=#435635>1</font>] - <font color=#435635>1</font>);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> res = INT_MIN;<br>&emsp;&emsp;    <font color=#55552A>rep</font>(i, <font color=#435635>1</font>, n) {<br>&emsp;&emsp;<font color=#85A96D>        // </font><font color=#85A96D>然后遍历每个点</font><font color=#85A96D>, </font><font color=#85A96D>和之前的加起来就完事了</font><br>&emsp;&emsp;        res = <font color=#55552A>max</font>(res, <font color=#194060>a</font>[i] + <font color=#194060>f</font>[i - <font color=#435635>1</font>] - <font color=#435635>1</font>);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> res;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>最大子数组和<br>&emsp;&emsp;最大子序和<br>&emsp;&emsp;1 e5<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>小陷阱<font color=#3D6DA4><br>&emsp;&emsp;int</font> <font color=#55552A>maxSubArray</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>nums</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> res = INT_MIN;<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> now = <font color=#435635>0</font>;<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>auto</font> i:nums){<br>&emsp;&emsp;        now = <font color=#55552A>max</font>(i, now + i); <br>&emsp;&emsp;<font color=#85A96D>        // </font><font color=#85A96D>注意如果写成</font><font color=#85A96D> now = max(now + i, 0); </font><font color=#85A96D>的话会出错的</font><br>&emsp;&emsp;<font color=#85A96D>        // </font><font color=#85A96D>这样会算不上一个子数组</font><br>&emsp;&emsp;        res = <font color=#55552A>max</font>(res, now);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> res;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>最大矩形<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>类似单调栈, 不过好像采用了不同的写法?<font color=#3D6DA4><br>&emsp;&emsp;int</font> <font color=#55552A>maximalRectangle</font>(<font color=#5DAF99>vector</font><<font color=#5DAF99>vector</font><<font color=#3D6DA4>char</font>>> <font color=#3D6DA4>&</font><font color=#194060>a</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> n = <font color=#194060>a</font>.<font color=#55552A>size</font>(), m = <font color=#194060>a</font>[<font color=#435635>0</font>].<font color=#55552A>size</font>();<br>&emsp;&emsp;    vector<vector<<font color=#3D6DA4>int</font>>> <font color=#55552A>f</font>(n, <font color=#55552A>vector</font><<font color=#3D6DA4>int</font>>(m));<br>&emsp;&emsp;    <font color=#55552A>rep</font>(j, <font color=#435635>0</font>, m) {<br>&emsp;&emsp;        <font color=#55552A>rep</font>(i, <font color=#435635>0</font>, n) {<br>&emsp;&emsp;            <font color=#713D71>if</font> (<font color=#194060>a</font>[i][j] == <font color=#7F4D36>'1'</font>) {<br>&emsp;&emsp;                <font color=#194060>f</font>[i][j] = <font color=#435635>1</font>;<br>&emsp;&emsp;                <font color=#713D71>if</font> (i - <font color=#435635>1</font> >= <font color=#435635>0</font> && <font color=#194060>f</font>[i - <font color=#435635>1</font>][j]) {<br>&emsp;&emsp;                    <font color=#194060>f</font>[i][j] += <font color=#194060>f</font>[i - <font color=#435635>1</font>][j];<br>&emsp;&emsp;                }<br>&emsp;&emsp;            }<br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#55552A>dea2</font>(f, n, m);<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> res = <font color=#435635>0</font>;<br>&emsp;&emsp;    <font color=#55552A>rep</font>(i, <font color=#435635>0</font>, n) {<br>&emsp;&emsp;        vector<<font color=#3D6DA4>int</font>> &a = <font color=#194060>f</font>[i], <font color=#55552A>l</font>(m), <font color=#55552A>r</font>(m);<br>&emsp;&emsp;        <font color=#55552A>dea</font>(a, m);<br>&emsp;&emsp;        stack<<font color=#3D6DA4>int</font>> stk;<br>&emsp;&emsp;        <font color=#55552A>rep</font>(j, <font color=#435635>0</font>, m) {<br>&emsp;&emsp;            <font color=#713D71>while</font> (!<font color=#194060>stk</font>.<font color=#55552A>empty</font>() && <font color=#194060>a</font>[<font color=#194060>stk</font>.<font color=#55552A>top</font>()] >= <font color=#194060>a</font>[j]) {<br>&emsp;&emsp;                <font color=#194060>r</font>[<font color=#194060>stk</font>.<font color=#55552A>top</font>()] = j;<font color=#85A96D> // </font><font color=#85A96D>刚好大一格</font><br>&emsp;&emsp;                <font color=#194060>stk</font>.<font color=#55552A>pop</font>();<br>&emsp;&emsp;            }<br>&emsp;&emsp;            <font color=#194060>l</font>[j] = <font color=#194060>stk</font>.<font color=#55552A>empty</font>() ? -<font color=#435635>1</font> : <font color=#194060>stk</font>.<font color=#55552A>top</font>();<font color=#85A96D> // </font><font color=#85A96D>刚好小一格</font><br>&emsp;&emsp;            <font color=#194060>stk</font>.<font color=#55552A>push</font>(j);<br>&emsp;&emsp;        }<br>&emsp;&emsp;        <font color=#713D71>while</font> (!<font color=#194060>stk</font>.<font color=#55552A>empty</font>()) {<br>&emsp;&emsp;            <font color=#194060>r</font>[<font color=#194060>stk</font>.<font color=#55552A>top</font>()] = m;<br>&emsp;&emsp;            <font color=#194060>stk</font>.<font color=#55552A>pop</font>();<br>&emsp;&emsp;        }<br>&emsp;&emsp;        <font color=#55552A>print</font>(<font color=#7F4D36>"l & r"</font>);<br>&emsp;&emsp;        <font color=#55552A>dea</font>(l, m);<br>&emsp;&emsp;        <font color=#55552A>dea</font>(r, m);<br>&emsp;&emsp;        <font color=#55552A>rep</font>(j, <font color=#435635>0</font>, m) {<br>&emsp;&emsp;            <font color=#3D6DA4>int</font> val = (<font color=#194060>r</font>[j] - <font color=#194060>l</font>[j] - <font color=#435635>1</font>) * <font color=#194060>a</font>[j];<br>&emsp;&emsp;            res = <font color=#55552A>max</font>(res, (<font color=#194060>r</font>[j] - <font color=#194060>l</font>[j] - <font color=#435635>1</font>) * <font color=#194060>a</font>[j]);<br>&emsp;&emsp;            <font color=#55552A>print</font>(i, j, val);<br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> res;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>最小花费爬楼梯<br>&emsp;&emsp;2 - 1e3<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>我记得前面有个 tie 的那个赋值方法?<font color=#85A96D><br>&emsp;&emsp;// </font><font color=#85A96D>直接用滚动数组做</font><br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#55552A>minCostClimbingStairs</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>cost</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font>  n = <font color=#194060>cost</font>.<font color=#55552A>size</font>();<br>&emsp;&emsp;<font color=#85A96D>    // </font><font color=#85A96D>两个数</font><font color=#85A96D>, </font><font color=#85A96D>一个是从前一个</font><font color=#85A96D>, </font><font color=#85A96D>一个是从前两个</font><br>&emsp;&emsp;    <font color=#3D6DA4>int</font> a = <font color=#194060>cost</font>[<font color=#435635>0</font>], b=<font color=#194060>cost</font>[<font color=#435635>1</font>];<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>2</font>;i<n;i++){<br>&emsp;&emsp;        <font color=#3D6DA4>int</font> c = <font color=#55552A>min</font>(a, b)+<font color=#194060>cost</font>[i];<br>&emsp;&emsp;        a = b, b = c;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#55552A>min</font>(a, b);<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>最长公共子序列<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>* 很简单的 dp<br>&emsp;&emsp;* 注意写的时候, 把我住范围<br>&emsp;&emsp;改一下回去 i=0 好一点<font color=#3D6DA4><br>&emsp;&emsp;int</font> n = <font color=#194060>text1</font>.<font color=#55552A>size</font>(), m = <font color=#194060>text2</font>.<font color=#55552A>size</font>(); <br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#194060>dp</font>[n + <font color=#435635>1</font>][m + <font color=#435635>1</font>];<font color=#85A96D> // </font><font color=#85A96D>最简单的转移方法</font><br>&emsp;&emsp;<font color=#55552A>memset</font>(dp, <font color=#435635>0</font>, <font color=#3D6DA4>sizeof</font>(dp)); <br>&emsp;&emsp;<font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>1</font>; i <= n; i++){<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> j = <font color=#435635>1</font>; j <= m; j++){<br>&emsp;&emsp;        <font color=#713D71>if</font>(<font color=#194060>text1</font>[i - <font color=#435635>1</font>] == <font color=#194060>text2</font>[j - <font color=#435635>1</font>]){<font color=#85A96D> // </font><font color=#85A96D>千万注意</font><font color=#85A96D>, </font><font color=#85A96D>这里要</font><font color=#85A96D> -1</font><br>&emsp;&emsp;            <font color=#194060>dp</font>[i][j] = <font color=#194060>dp</font>[i - <font color=#435635>1</font>][j - <font color=#435635>1</font>] + <font color=#435635>1</font>;<br>&emsp;&emsp;        }<font color=#713D71>else</font>{<br>&emsp;&emsp;            <font color=#194060>dp</font>[i][j] = <font color=#55552A>max</font>(<font color=#194060>dp</font>[i - <font color=#435635>1</font>][j], <font color=#194060>dp</font>[i][j - <font color=#435635>1</font>]); <br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>最长回文字串: <br>&emsp;&emsp;返回字符串中的最长回文字串是什么<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>三种方法: <br>&emsp;&emsp;中心扩展法 dp 和 马拉车法<br>&emsp;&emsp;<font color=#5DAF99>pair</font><<font color=#3D6DA4>int</font>, <font color=#3D6DA4>int</font>> <font color=#55552A>expandAroundCenter</font>(<font color=#5DAF99>string</font> <font color=#194060>s</font>, <font color=#3D6DA4>int</font> <font color=#194060>left</font>, <font color=#3D6DA4>int</font> <font color=#194060>right</font>){<br>&emsp;&emsp;    <font color=#713D71>while</font>(left >= <font color=#435635>0</font> && right < <font color=#55552A>sz</font>(s) && <font color=#194060>s</font>[left] == <font color=#194060>s</font>[right]) {<br>&emsp;&emsp;        --left;<br>&emsp;&emsp;        ++right;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> {left+<font color=#435635>1</font>, right-<font color=#435635>1</font>};<font color=#85A96D> // </font><font color=#85A96D>因为最后需要还原一下</font><font color=#85A96D>.</font><br>&emsp;&emsp;}<br>&emsp;&emsp;<font color=#5DAF99>string</font> <font color=#55552A>longestPalindrome</font>(<font color=#5DAF99>string</font> <font color=#194060>s</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> start = <font color=#435635>0</font>, end = <font color=#435635>0</font>;<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i =<font color=#435635>0</font>; i< <font color=#194060>s</font>.<font color=#55552A>size</font>(); i++){<br>&emsp;&emsp;        <font color=#3D6DA4>auto</font> [left1,right1] = <font color=#55552A>expandAroundCenter</font>(s, i, i);<br>&emsp;&emsp;        <font color=#713D71>if</font>(right1 - left1 > end - start){<br>&emsp;&emsp;            start = left1; end = right1;<font color=#85A96D> // </font><font color=#85A96D>比较完了谁扩增的是对的</font><font color=#85A96D>.</font><br>&emsp;&emsp;        }<br>&emsp;&emsp;        <font color=#3D6DA4>auto</font> [left2,right2] = <font color=#55552A>expandAroundCenter</font>(s, i, i+<font color=#435635>1</font>);<br>&emsp;&emsp;        <font color=#713D71>if</font>(right2 - left2 > end - start){<br>&emsp;&emsp;            start = left2, end = right2;<br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#194060>s</font>.<font color=#55552A>substr</font>(start, end - start + <font color=#435635>1</font>);<font color=#85A96D> // </font><font color=#85A96D>返回最后的结果</font><br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;马拉车法<br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#55552A>expand</font>(<font color=#3D6DA4>const</font> <font color=#5DAF99>string</font> <font color=#3D6DA4>&</font><font color=#194060>s</font>, <font color=#3D6DA4>int</font> <font color=#194060>left</font>, <font color=#3D6DA4>int</font> <font color=#194060>right</font>) {<br>&emsp;&emsp;    <font color=#713D71>while</font> (left >= <font color=#435635>0</font> && right <= <font color=#194060>s</font>.<font color=#55552A>size</font>() && <font color=#194060>s</font>[left] == <font color=#194060>s</font>[right]) {<br>&emsp;&emsp;        --left, ++right;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> (right - left - <font color=#435635>2</font>) / <font color=#435635>2</font>;<br>&emsp;&emsp;}<br>&emsp;&emsp;<font color=#5DAF99>string</font> <font color=#55552A>longestPalindrome</font>(<font color=#5DAF99>string</font> <font color=#194060>s</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> start = <font color=#435635>0</font>, end = -<font color=#435635>1</font>;<br>&emsp;&emsp;    string t = <font color=#7F4D36>"#"</font>;<br>&emsp;&emsp;    <font color=#713D71>for</font> (<font color=#3D6DA4>char</font> c : s) {<br>&emsp;&emsp;        t += c;<br>&emsp;&emsp;        t += <font color=#7F4D36>"#"</font>;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    t += <font color=#7F4D36>"#"</font>;<br>&emsp;&emsp;    s = t;<br>&emsp;&emsp;    vector<<font color=#3D6DA4>int</font>> arm_len;<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> right = -<font color=#435635>1</font>, j = -<font color=#435635>1</font>, cur_arm_len;<br>&emsp;&emsp;    <font color=#713D71>for</font> (<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>; i < <font color=#55552A>sz</font>(s); i++) {<br>&emsp;&emsp;        <font color=#713D71>if</font> (right >= i) {<br>&emsp;&emsp;            <font color=#3D6DA4>int</font> i_sym = j * <font color=#435635>2</font> - i;<font color=#85A96D> // </font><font color=#85A96D>对称点</font><font color=#85A96D>.</font><br>&emsp;&emsp;            <font color=#3D6DA4>int</font> min_arm_len = <font color=#55552A>min</font>(<font color=#194060>arm_len</font>[i_sym], right - i);<br>&emsp;&emsp;            cur_arm_len = <font color=#55552A>expand</font>(s, i - min_arm_len, i + min_arm_len);<br>&emsp;&emsp;        } <font color=#713D71>else</font> {<br>&emsp;&emsp;            cur_arm_len = <font color=#55552A>expand</font>(s, i, i);<br>&emsp;&emsp;        }<br>&emsp;&emsp;        <font color=#194060>arm_len</font>.<font color=#55552A>push_back</font>(cur_arm_len);<br>&emsp;&emsp;        <font color=#713D71>if</font> (i + cur_arm_len > right) j = i, right = i + cur_arm_len;<br>&emsp;&emsp;        <font color=#713D71>if</font> (cur_arm_len * <font color=#435635>2</font> + <font color=#435635>1</font> > end - start) {<br>&emsp;&emsp;            start = i - cur_arm_len;<br>&emsp;&emsp;            end = i + cur_arm_len;<br>&emsp;&emsp;        }<br>&emsp;&emsp;        <font color=#55552A>print</font>(start,end);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    string ans;<br>&emsp;&emsp;    <font color=#713D71>for</font> (<font color=#3D6DA4>int</font> i = start; i <= end; i++) {<br>&emsp;&emsp;        <font color=#713D71>if</font> (<font color=#194060>s</font>[i] != <font color=#7F4D36>'#'</font>) ans += <font color=#194060>s</font>[i];<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> ans;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>有效的括号<br>&emsp;&emsp;判断是否配对, 不过有三种括号这里<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>简单的括号配对, 不过需要一个 unordered_map 才行<font color=#3D6DA4><br>&emsp;&emsp;bool</font> <font color=#55552A>isValid</font>(<font color=#5DAF99>string</font> <font color=#194060>s</font>) {<br>&emsp;&emsp;    unordered_map<<font color=#3D6DA4>char</font>, <font color=#3D6DA4>char</font>> pairs = {<br>&emsp;&emsp;        {<font color=#7F4D36>')'</font>,<font color=#7F4D36>'('</font>}, {<font color=#7F4D36>'</font><font color=#7F4D36>]</font><font color=#7F4D36>'</font>,<font color=#7F4D36>'</font><font color=#7F4D36>[</font><font color=#7F4D36>'</font>},{<font color=#7F4D36>'}'</font>,<font color=#7F4D36>'{'</font>}<br>&emsp;&emsp;    };<br>&emsp;&emsp;    stack<<font color=#3D6DA4>char</font>> left;<br>&emsp;&emsp;    <font color=#713D71>for</font> (<font color=#3D6DA4>char</font> c : s) {<br>&emsp;&emsp;        <font color=#713D71>if</font> (<font color=#194060>pairs</font>.<font color=#55552A>count</font>(c) && !<font color=#194060>left</font>.<font color=#55552A>empty</font>() && <font color=#194060>left</font>.<font color=#55552A>top</font>() == <font color=#194060>pairs</font>[c]) {<br>&emsp;&emsp;            <font color=#194060>left</font>.<font color=#55552A>pop</font>();<br>&emsp;&emsp;        }<br>&emsp;&emsp;        <font color=#713D71>else</font> <font color=#194060>left</font>.<font color=#55552A>push</font>(c);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#194060>left</font>.<font color=#55552A>empty</font>();<br>&emsp;&emsp;};<br>&emsp;&emsp;<hr><hr>杨辉三角<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><font color=#5DAF99>vector</font><<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>>> <font color=#55552A>generate</font>(<font color=#3D6DA4>int</font> <font color=#194060>numRows</font>) {<br>&emsp;&emsp;    vector<vector<<font color=#3D6DA4>int</font>>> <font color=#55552A>ret</font>(numRows);<br>&emsp;&emsp;    <font color=#713D71>for</font> (<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>; i < numRows; ++i) {<br>&emsp;&emsp;        <font color=#194060>ret</font>[i].<font color=#55552A>resize</font>(i + <font color=#435635>1</font>);<br>&emsp;&emsp;        <font color=#194060>ret</font>[i][<font color=#435635>0</font>] = <font color=#194060>ret</font>[i][i] = <font color=#435635>1</font>;<br>&emsp;&emsp;        <font color=#713D71>for</font> (<font color=#3D6DA4>int</font> j = <font color=#435635>1</font>; j < i; ++j) {<br>&emsp;&emsp;<font color=#85A96D>            // </font><font color=#85A96D>每一层做一下判断</font><br>&emsp;&emsp;            <font color=#194060>ret</font>[i][j] = <font color=#194060>ret</font>[i - <font color=#435635>1</font>][j] + <font color=#194060>ret</font>[i - <font color=#435635>1</font>][j - <font color=#435635>1</font>];<br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> ret;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>模拟栈<br>&emsp;&emsp;实现 push(x), pop(), top(), empty() <hr><font color=#3D6DA4>int</font> <font color=#194060>stk</font>[N5], tt;<font color=#85A96D> // </font><font color=#85A96D>这样子好用</font><font color=#85A96D>, </font><font color=#85A96D>所有的都是从</font><font color=#85A96D> 0 </font><font color=#85A96D>开始的</font><font color=#85A96D>;</font><br>&emsp;&emsp;<font color=#3D6DA4>void</font> <font color=#55552A>push</font>(<font color=#3D6DA4>int</font> <font color=#194060>x</font>) {<br>&emsp;&emsp;    <font color=#194060>stk</font>[tt++] = x;<br>&emsp;&emsp;}<br>&emsp;&emsp;<font color=#3D6DA4>void</font> <font color=#55552A>pop</font>() {<br>&emsp;&emsp;    --tt;<br>&emsp;&emsp;}<br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#55552A>query</font>() {<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#194060>stk</font>[tt];<br>&emsp;&emsp;}<br>&emsp;&emsp;<font color=#3D6DA4>bool</font> <font color=#55552A>empty</font>() {<br>&emsp;&emsp;    <font color=#713D71>return</font> tt == <font color=#435635>0</font>;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>模拟队列<br>&emsp;&emsp;<br>&emsp;&emsp;push() <br>&emsp;&emsp;pop()<br>&emsp;&emsp;front()<br>&emsp;&emsp;empty() <hr><font color=#3D6DA4>int</font> <font color=#194060>q</font>[N5], tt, hh;<br>&emsp;&emsp;<font color=#3D6DA4>void</font> <font color=#55552A>push</font>(<font color=#3D6DA4>int</font> <font color=#194060>x</font>) {<br>&emsp;&emsp;    <font color=#194060>q</font>[tt++] = x;<br>&emsp;&emsp;}<br>&emsp;&emsp;<font color=#3D6DA4>void</font> <font color=#55552A>pop</font>() {<br>&emsp;&emsp;    ++hh;<br>&emsp;&emsp;}<br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#55552A>query</font>() {<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#194060>q</font>[hh];<br>&emsp;&emsp;}<br>&emsp;&emsp;<font color=#3D6DA4>bool</font> <font color=#55552A>empty</font>() {<br>&emsp;&emsp;    <font color=#713D71>return</font> hh >= tt;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>滑动窗口最大最小值<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><font color=#5DAF99><br>&emsp;&emsp;vector</font><<font color=#3D6DA4>int</font>> <font color=#55552A>maxSlidingWindow</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>> <font color=#3D6DA4>&</font><font color=#194060>a</font>, <font color=#3D6DA4>int</font> <font color=#194060>k</font>) {<br>&emsp;&emsp;    vector<<font color=#3D6DA4>int</font>> res;<br>&emsp;&emsp;    deque<<font color=#3D6DA4>int</font>> q;<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> n = <font color=#194060>a</font>.<font color=#55552A>size</font>();<br>&emsp;&emsp;    <font color=#55552A>rep</font>(i, <font color=#435635>0</font>, n) {<br>&emsp;&emsp;<font color=#85A96D>        // </font><font color=#85A96D>对于每一个数</font><font color=#85A96D>, </font><font color=#85A96D>如果超出范围弹出</font><br>&emsp;&emsp;        <font color=#713D71>if</font> (!<font color=#194060>q</font>.<font color=#55552A>empty</font>() && (i - <font color=#194060>q</font>.<font color=#55552A>front</font>() >= k)) <font color=#194060>q</font>.<font color=#55552A>pop_front</font>();<br>&emsp;&emsp;<font color=#85A96D>        // </font><font color=#85A96D>如果队列尾端小于当前的数</font><font color=#85A96D>, </font><font color=#85A96D>弹出</font><br>&emsp;&emsp;        <font color=#713D71>while</font> (!<font color=#194060>q</font>.<font color=#55552A>empty</font>() && <font color=#194060>a</font>[<font color=#194060>q</font>.<font color=#55552A>back</font>()] <= <font color=#194060>a</font>[i]) {<br>&emsp;&emsp;            <font color=#194060>q</font>.<font color=#55552A>pop_back</font>();<br>&emsp;&emsp;        }<br>&emsp;&emsp;<font color=#85A96D>        // </font><font color=#85A96D>尾端推入</font><br>&emsp;&emsp;        <font color=#194060>q</font>.<font color=#55552A>push_back</font>(i);<br>&emsp;&emsp;        <font color=#713D71>if</font> (i >= k - <font color=#435635>1</font>) {<br>&emsp;&emsp;<font color=#85A96D>            // </font><font color=#85A96D>返回的应该是最前端的那个数</font><br>&emsp;&emsp;            <font color=#194060>res</font>.<font color=#55552A>push_back</font>(<font color=#194060>a</font>[<font color=#194060>q</font>.<font color=#55552A>front</font>()]);<br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> res;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>爬楼梯<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>斐波那契数列吧<font color=#3D6DA4><br>&emsp;&emsp;int</font> <font color=#55552A>climbStairs</font>(<font color=#3D6DA4>int</font> <font color=#194060>n</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> a = <font color=#435635>0</font>, b = <font color=#435635>1</font>; <br>&emsp;&emsp;    <font color=#713D71>while</font>(n--){<br>&emsp;&emsp;        <font color=#3D6DA4>int</font> c = a + b; <br>&emsp;&emsp;        a = b; <br>&emsp;&emsp;        b = c;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> b;<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#194060>dp</font>[i] = <font color=#194060>Math</font>.<font color=#55552A>min</font>(<font color=#194060>dp</font>[i - <font color=#435635>2</font>] + <font color=#194060>cost</font>[i - <font color=#435635>2</font>], <font color=#194060>dp</font>[i - <font color=#435635>1</font>] + <font color=#194060>cost</font>[i - <font color=#435635>1</font>])<br>&emsp;&emsp;<hr><hr>环形子数组的最大和<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>可以理解 但最后一行？<br>&emsp;&emsp;因为ma如果小于0的话 最后会得到0 是个错误的答案<br>&emsp;&emsp;Q: 可以是最大或者最小那个. <br>&emsp;&emsp;￼<br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#55552A>maxSubarraySumCircular</font>(<font color=#5DAF99>vector</font>< <font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>a</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> curmax = <font color=#435635>0</font>, ma = <font color=#194060>a</font>[<font color=#435635>0</font>], curmin = <font color=#435635>0</font>, mi = <font color=#194060>a</font>[<font color=#435635>0</font>], total = <font color=#435635>0</font>;<br>&emsp;&emsp;    <font color=#713D71>for</font> (<font color=#3D6DA4>auto</font> i : a) {<br>&emsp;&emsp;        curmax = <font color=#55552A>max</font>(i, curmax + i);<br>&emsp;&emsp;        ma = <font color=#55552A>max</font>(ma, curmax);<br>&emsp;&emsp;        curmin = <font color=#55552A>min</font>(i, curmin + i);<br>&emsp;&emsp;        mi = <font color=#55552A>min</font>(mi, curmin);<br>&emsp;&emsp;        total += i;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> ma > <font color=#435635>0</font> ? <font color=#55552A>max</font>(ma, total - mi) : ma;<br>&emsp;&emsp;}<br>&emsp;&emsp;多理解一下这个代码<hr><hr>环形链表<br>&emsp;&emsp;判断一个链表是否是环形的<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><font color=#3D6DA4>fast && fast.next<br>&emsp;&emsp;bool</font> <font color=#55552A>hasCycle</font>(<font color=#5DAF99>ListNode</font> <font color=#3D6DA4>*</font><font color=#194060>head</font>) {<br>&emsp;&emsp;    ListNode *slow = head, *fast = head; <br>&emsp;&emsp;    <font color=#713D71>while</font>(fast && <font color=#194060>fast</font>-><font color=#194060>next</font>){<font color=#85A96D> // </font><font color=#85A96D>环形，</font><font color=#85A96D> </font><font color=#85A96D>快的可能走到最后去</font><br>&emsp;&emsp;        slow = <font color=#194060>slow</font>-><font color=#194060>next</font>;<br>&emsp;&emsp;        fast = <font color=#194060>fast</font>-><font color=#194060>next</font>-><font color=#194060>next</font>;<font color=#85A96D> // </font><font color=#85A96D>对了，上面判断过了</font><br>&emsp;&emsp;        <font color=#713D71>if</font>(slow == fast) <font color=#713D71>return</font> <font color=#3D6DA4>true</font>;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#3D6DA4>false</font>;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>环形链表 II<br>&emsp;&emsp;返回链表开始成环的第一个节点<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>前端 a, 环 b, 遇到位置 c<br>&emsp;&emsp;有  a + c = a + b + c = 2 ( a + c) <br>&emsp;&emsp;b = a + c  <br>&emsp;&emsp;a = b - c <br>&emsp;&emsp;因此 快的回去, 慢慢走 最终就会相遇了<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5DAF99>ListNode</font> <font color=#3D6DA4>*</font><font color=#55552A>detectCycle</font>(<font color=#5DAF99>ListNode</font> <font color=#3D6DA4>*</font><font color=#194060>head</font>) {<br>&emsp;&emsp;    ListNode *fast = head, *slow = head;<br>&emsp;&emsp;    <font color=#713D71>while</font>(fast && <font color=#194060>fast </font>-><font color=#194060>next</font>){<br>&emsp;&emsp;        fast = <font color=#194060>fast</font>-><font color=#194060>next</font>-><font color=#194060>next</font>; <br>&emsp;&emsp;        slow = <font color=#194060>slow</font>-><font color=#194060>next</font>; <br>&emsp;&emsp;        <font color=#713D71>if</font>(fast == slow){<br>&emsp;&emsp;            fast = head; <br>&emsp;&emsp;            <font color=#713D71>while</font>(fast != slow){<br>&emsp;&emsp;                fast = <font color=#194060>fast</font>-><font color=#194060>next</font>; <br>&emsp;&emsp;                slow = <font color=#194060>slow</font>-><font color=#194060>next</font>;<br>&emsp;&emsp;            }<br>&emsp;&emsp;            <font color=#713D71>return</font> fast;<br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#3D6DA4>nullptr</font>;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>用栈实现队列<br>&emsp;&emsp;push pop peek empty<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><font color=#85A96D>// push </font><font color=#85A96D>到左边去</font><br>&emsp;&emsp;<font color=#85A96D>// </font><font color=#85A96D>然后</font><font color=#85A96D> pop </font><font color=#85A96D>的时候</font><font color=#85A96D>,</font><font color=#85A96D>如果右边有的话</font><font color=#85A96D>, </font><font color=#85A96D>就直接</font><font color=#85A96D> pop ,</font><br>&emsp;&emsp;<font color=#85A96D>// </font><font color=#85A96D>否则把左边的全部放过去</font><br>&emsp;&emsp;stack<<font color=#3D6DA4>int</font>> left, right;<br>&emsp;&emsp;<font color=#55552A>MyQueue</font>() {}<br>&emsp;&emsp;<font color=#3D6DA4>void</font> <font color=#55552A>push</font>(<font color=#3D6DA4>int</font> <font color=#194060>x</font>) {<br>&emsp;&emsp;    <font color=#194060>left</font>.<font color=#55552A>push</font>(x);<br>&emsp;&emsp;}<br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#55552A>pop</font>() {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> x = <font color=#55552A>peek</font>();<font color=#194060>right</font>.<font color=#55552A>pop</font>();<br>&emsp;&emsp;    <font color=#713D71>return</font> x;<br>&emsp;&emsp;}<br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#55552A>peek</font>() {<br>&emsp;&emsp;    <font color=#713D71>if</font> (<font color=#194060>right</font>.<font color=#55552A>empty</font>()) {<br>&emsp;&emsp;        <font color=#713D71>while</font> (!<font color=#194060>left</font>.<font color=#55552A>empty</font>()) {<br>&emsp;&emsp;            <font color=#194060>right</font>.<font color=#55552A>push</font>(<font color=#194060>left</font>.<font color=#55552A>top</font>());<br>&emsp;&emsp;            <font color=#194060>left</font>.<font color=#55552A>pop</font>();<br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#194060>right</font>.<font color=#55552A>top</font>();<br>&emsp;&emsp;}<br>&emsp;&emsp;<font color=#3D6DA4>bool</font> <font color=#55552A>empty</font>() {<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#194060>left</font>.<font color=#55552A>empty</font>() && <font color=#194060>right</font>.<font color=#55552A>empty</font>();<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>相交链表 : <br>&emsp;&emsp;判断两个链表是否是相交的<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><font color=#5DAF99>ListNode</font> <font color=#3D6DA4>*</font><font color=#55552A>getIntersectionNode</font>(<font color=#5DAF99>ListNode</font> <font color=#3D6DA4>*</font><font color=#194060>headA</font>, <font color=#5DAF99>ListNode</font> <font color=#3D6DA4>*</font><font color=#194060>headB</font>) {<br>&emsp;&emsp;    <font color=#713D71>if</font> (headA == <font color=#3D6DA4>nullptr</font> || headB == <font color=#3D6DA4>nullptr</font>) {<br>&emsp;&emsp;        <font color=#713D71>return</font> <font color=#3D6DA4>nullptr</font>;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    ListNode *pA = headA, *pB = headB;<br>&emsp;&emsp;<font color=#85A96D>    // </font><font color=#85A96D>不会死循环</font><font color=#85A96D>, </font><font color=#85A96D>因为最后一定是个</font><font color=#85A96D> nullptr</font><br>&emsp;&emsp;    <font color=#713D71>while</font> (pA != pB) {<br>&emsp;&emsp;        pA = pA ? <font color=#194060>pA</font>-><font color=#194060>next</font> : headB;<br>&emsp;&emsp;        pB = pB ? <font color=#194060>pB</font>-><font color=#194060>next</font> : headA;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> pA;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>矩阵区域和<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><hr>第 n 个泰波那契数<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>滚动数组的边界问题?<font color=#3D6DA4><br>&emsp;&emsp;int</font> <font color=#55552A>tribonacci</font>(<font color=#3D6DA4>int</font> <font color=#194060>n</font>) {<br>&emsp;&emsp;    vector<<font color=#3D6DA4>int</font>> <font color=#55552A>a</font>(n+<font color=#435635>10</font>);<br>&emsp;&emsp;    <font color=#194060>a</font>[<font color=#435635>0</font>] = <font color=#435635>0</font>, <font color=#194060>a</font>[<font color=#435635>1</font>] = <font color=#435635>1</font>, <font color=#194060>a</font>[<font color=#435635>2</font>] = <font color=#435635>1</font>; <br>&emsp;&emsp;    <font color=#55552A>rep</font>(i,<font color=#435635>3</font>,n + <font color=#435635>1</font>)  {<br>&emsp;&emsp;        <font color=#194060>a</font>[i] = <font color=#194060>a</font>[i-<font color=#435635>3</font>] + <font color=#194060>a</font>[i-<font color=#435635>2</font>] + <font color=#194060>a</font>[i-<font color=#435635>1</font>];<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#194060>a</font>[n];<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>编辑距离<br>&emsp;&emsp;<br>&emsp;&emsp;可以 插入/删除/替换 的情况下<br>&emsp;&emsp;最少的变成相同的次数<br>&emsp;&emsp;<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><font color=#3D6DA4>int</font> <font color=#55552A>minDistance</font>(<font color=#5DAF99>string</font> <font color=#194060>word1</font>, <font color=#5DAF99>string</font> <font color=#194060>word2</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> n = <font color=#194060>word1</font>.<font color=#55552A>size</font>(), m = <font color=#194060>word2</font>.<font color=#55552A>size</font>();<br>&emsp;&emsp;    vector<vector<<font color=#3D6DA4>int</font>>> <font color=#55552A>dp</font>(n + <font color=#435635>1</font>, <font color=#55552A>vector</font><<font color=#3D6DA4>int</font>>(m + <font color=#435635>1</font>)); <br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>; i <= n; i++) <font color=#194060>dp</font>[i][<font color=#435635>0</font>] = i; <br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> j = <font color=#435635>0</font>; j <= m; j++) <font color=#194060>dp</font>[<font color=#435635>0</font>][j] = j;<br>&emsp;&emsp;    <br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>; i < n; i++){<br>&emsp;&emsp;        <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> j = <font color=#435635>0</font>; j < m; j++){<br>&emsp;&emsp;            <font color=#194060>dp</font>[i + <font color=#435635>1</font>][j + <font color=#435635>1</font>] = <font color=#55552A>min</font>(<font color=#194060>dp</font>[i + <font color=#435635>1</font>][j], <font color=#194060>dp</font>[i][j + <font color=#435635>1</font>]) + <font color=#435635>1</font>;<br>&emsp;&emsp;            <font color=#194060>dp</font>[i + <font color=#435635>1</font>][j + <font color=#435635>1</font>] = <font color=#55552A>min</font>(<font color=#194060>dp</font>[i + <font color=#435635>1</font>][j + <font color=#435635>1</font>], <br>&emsp;&emsp;                    <font color=#194060>dp</font>[i][j] + !(<font color=#194060>word1</font>[i] == <font color=#194060>word2</font>[j]));<br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#194060>dp</font>[n][m];<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>翻转二叉树<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>迭代的话 只需要一个栈就好 然后反复的交换<br>&emsp;&emsp;<br>&emsp;&emsp;递归实现， 非常的简单<font color=#5DAF99><br>&emsp;&emsp;TreeNode</font><font color=#3D6DA4>*</font> <font color=#55552A>invertTree</font>(<font color=#5DAF99>TreeNode</font><font color=#3D6DA4>*</font> <font color=#194060>root</font>) {<br>&emsp;&emsp;    <font color=#713D71>if</font>(root == <font color=#3D6DA4>nullptr</font>) <font color=#713D71>return</font> <font color=#3D6DA4>nullptr</font>;<br>&emsp;&emsp;    <font color=#55552A>swap</font>(<font color=#194060>root</font>-><font color=#194060>left</font>, <font color=#194060>root</font>-><font color=#194060>right</font>); <br>&emsp;&emsp;    <font color=#55552A>invertTree</font>(<font color=#194060>root</font>-><font color=#194060>left</font>); <br>&emsp;&emsp;    <font color=#55552A>invertTree</font>(<font color=#194060>root</font>-><font color=#194060>right</font>);<br>&emsp;&emsp;    <font color=#713D71>return</font> root;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>螺旋矩阵: <br>&emsp;&emsp;按照螺旋顺序, 遍历矩阵中的所有元素<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>> <font color=#55552A>spiralOrder</font>(<font color=#5DAF99>vector</font><<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>>><font color=#3D6DA4>&</font> <font color=#194060>matrix</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>constexpr</font> <font color=#3D6DA4>int</font> NO = INT_MIN;<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> n = <font color=#194060>matrix</font>.<font color=#55552A>size</font>(), m=<font color=#194060>matrix</font>[<font color=#435635>0</font>].<font color=#55552A>size</font>();<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> i = <font color=#435635>0</font>, j = -<font color=#435635>1</font>;<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> <font color=#194060>pos</font>[<font color=#435635>4</font>][<font color=#435635>2</font>] = {{<font color=#435635>0</font>,<font color=#435635>1</font>},{<font color=#435635>1</font>,<font color=#435635>0</font>},{<font color=#435635>0</font>,-<font color=#435635>1</font>},{-<font color=#435635>1</font>,<font color=#435635>0</font>}};<br>&emsp;&emsp;    vector<<font color=#3D6DA4>int</font>> res;<br>&emsp;&emsp;    <br>&emsp;&emsp;    <font color=#3D6DA4>int</font> now = <font color=#435635>0</font>;<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> cnt = <font color=#435635>0</font>;<br>&emsp;&emsp;    <font color=#713D71>while</font>(cnt<m*n){<br>&emsp;&emsp;        <font color=#3D6DA4>int</font> a = <font color=#194060>pos</font>[now%<font color=#435635>4</font>][<font color=#435635>0</font>] + i, b = <font color=#194060>pos</font>[now%<font color=#435635>4</font>][<font color=#435635>1</font>] + j;<br>&emsp;&emsp;        <font color=#713D71>if</font>(a<<font color=#435635>0</font> || a>=n || b<<font color=#435635>0</font> || b>=m || <font color=#194060>matrix</font>[a][b] == NO){<br>&emsp;&emsp;            now++; <font color=#713D71>continue</font>;<br>&emsp;&emsp;        }<br>&emsp;&emsp;        <font color=#194060>res</font>.<font color=#55552A>push_back</font>(<font color=#194060>matrix</font>[a][b]);<br>&emsp;&emsp;<font color=#85A96D>        // </font><font color=#85A96D>注意这里底下的更新</font><font color=#85A96D>, </font><font color=#85A96D>如果这个矩阵是不可变的</font><font color=#85A96D>, </font><font color=#85A96D>整个都要重新写</font><br>&emsp;&emsp;        <font color=#194060>matrix</font>[i=a][j=b] = NO;<br>&emsp;&emsp;        cnt++;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> res;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>跳跃游戏<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><font color=#3D6DA4>直接用最大跳跃长度来做就行</font><font color=#3D6DA4> </font><font color=#3D6DA4>简单的</font><font color=#3D6DA4> dp<br>&emsp;&emsp;bool</font> <font color=#55552A>canJump</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>nums</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> length = <font color=#194060>nums</font>.<font color=#55552A>size</font>(); <br>&emsp;&emsp;    <font color=#3D6DA4>int</font> maxJump = <font color=#435635>0</font>; <br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>; i < length; i++){<br>&emsp;&emsp;        <font color=#713D71>if</font>(maxJump < i) <font color=#713D71>return</font> <font color=#3D6DA4>false</font>;<br>&emsp;&emsp;        maxJump = <font color=#55552A>max</font>(maxJump, i + <font color=#194060>nums</font>[i]);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#3D6DA4>true</font>;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>跳跃游戏 II<br>&emsp;&emsp;最小跳跃次数到最后一个 1e4<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>注意题目里面的假设, 永远可以到达最后的位置<font color=#3D6DA4><br>&emsp;&emsp;<br>&emsp;&emsp;int</font> <font color=#55552A>jump</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>nums</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> maxPos = <font color=#435635>0</font>, n = <font color=#194060>nums</font>.<font color=#55552A>size</font>(), end = <font color=#435635>0</font>, step = <font color=#435635>0</font>;<br>&emsp;&emsp;    <font color=#713D71>for</font> (<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>; i < n - <font color=#435635>1</font>; ++i) {<br>&emsp;&emsp;        maxPos = <font color=#55552A>max</font>(maxPos, i + <font color=#194060>nums</font>[i]);<font color=#85A96D> // maxPos </font><font color=#85A96D>维护当前能到的最远的位置</font><br>&emsp;&emsp;        <font color=#713D71>if</font> (i == end) {<font color=#85A96D> // </font><font color=#85A96D>如果到了这一跳期限内的最远的话</font><br>&emsp;&emsp;            end = maxPos;<font color=#85A96D> // end </font><font color=#85A96D>变成下一跳可以到的最远的地方</font><br>&emsp;&emsp;            ++step;<br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> step;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>跳跃游戏 III<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>直接用栈来判断是否能到吧 就可以<font color=#3D6DA4><br>&emsp;&emsp;<br>&emsp;&emsp;bool</font> <font color=#55552A>canReach</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>arr</font>, <font color=#3D6DA4>int</font> <font color=#194060>start</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> length = <font color=#194060>arr</font>.<font color=#55552A>size</font>(); <br>&emsp;&emsp;    vector<<font color=#3D6DA4>bool</font>> <font color=#55552A>stat</font>(length);<br>&emsp;&emsp;    stack<<font color=#3D6DA4>int</font>> s;<br>&emsp;&emsp;    <font color=#194060>s</font>.<font color=#55552A>push</font>(start); <br>&emsp;&emsp;    <font color=#713D71>while</font>(!<font color=#194060>s</font>.<font color=#55552A>empty</font>()){<br>&emsp;&emsp;        <font color=#3D6DA4>int</font> now = <font color=#194060>s</font>.<font color=#55552A>top</font>(); <font color=#194060>s</font>.<font color=#55552A>pop</font>();<br>&emsp;&emsp;        <font color=#713D71>if</font>(<font color=#194060>stat</font>[now]) <font color=#713D71>continue</font>;<br>&emsp;&emsp;        <font color=#194060>stat</font>[now] = <font color=#3D6DA4>true</font>;<br>&emsp;&emsp;        <font color=#713D71>if</font>(<font color=#194060>arr</font>[now] == <font color=#435635>0</font>)<font color=#713D71>return</font> <font color=#3D6DA4>true</font>;<br>&emsp;&emsp;        <font color=#3D6DA4>int</font> left = now - <font color=#194060>arr</font>[now], right = now + <font color=#194060>arr</font>[now];<br>&emsp;&emsp;        <font color=#713D71>if</font>(left >= <font color=#435635>0</font> && !<font color=#194060>stat</font>[left]) <font color=#194060>s</font>.<font color=#55552A>push</font>(left); <br>&emsp;&emsp;        <font color=#713D71>if</font>(right < length && !<font color=#194060>stat</font>[right]) <font color=#194060>s</font>.<font color=#55552A>push</font>(right);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#3D6DA4>false</font>;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>跳跃游戏 IV<br>&emsp;&emsp;<br>&emsp;&emsp;对于每一步来说, 可以往左跳一下, 可以往右跳一下<br>&emsp;&emsp;可以跳到 = 当前数的位置上去<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>只有 bfs 搜索出来应该就行吧<br>&emsp;&emsp;类似于层序遍历? 给他搞成一颗树<br>&emsp;&emsp;<br>&emsp;&emsp;直接搜索, 应该是可以提前返回的吧<br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#55552A>minJumps</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>> <font color=#3D6DA4>&</font><font color=#194060>arr</font>) {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> n = <font color=#194060>arr</font>.<font color=#55552A>size</font>();<br>&emsp;&emsp;    vector<<font color=#3D6DA4>int</font>> <font color=#55552A>st</font>(n);<br>&emsp;&emsp;    unordered_map<<font color=#3D6DA4>int</font>, vector<<font color=#3D6DA4>int</font>>> um;<br>&emsp;&emsp;    <font color=#55552A>rep</font>(i, <font color=#435635>0</font>, n) {<br>&emsp;&emsp;        <font color=#194060>um</font>[<font color=#194060>arr</font>[i]].<font color=#55552A>push_back</font>(i);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    queue<<font color=#3D6DA4>int</font>> q;<br>&emsp;&emsp;    <font color=#194060>q</font>.<font color=#55552A>push</font>(<font color=#435635>0</font>);<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> cnt = <font color=#435635>0</font>;<br>&emsp;&emsp;    <font color=#713D71>while</font> (!<font color=#194060>q</font>.<font color=#55552A>empty</font>()) {<br>&emsp;&emsp;        <font color=#3D6DA4>int</font> size = <font color=#55552A>sz</font>(q);<br>&emsp;&emsp;        cnt++;<br>&emsp;&emsp;        <font color=#713D71>while</font> (size--) {<br>&emsp;&emsp;            <font color=#3D6DA4>int</font> now = <font color=#194060>q</font>.<font color=#55552A>front</font>();<br>&emsp;&emsp;            <font color=#194060>q</font>.<font color=#55552A>pop</font>();<br>&emsp;&emsp;            <font color=#713D71>if</font> (<font color=#194060>st</font>[now]) <font color=#713D71>continue</font>;<br>&emsp;&emsp;            <font color=#3D6DA4>int</font> val = <font color=#194060>arr</font>[now];<br>&emsp;&emsp;            <font color=#194060>st</font>[now] = cnt;<br>&emsp;&emsp;            <font color=#713D71>for</font> (<font color=#3D6DA4>auto</font> &i : <font color=#194060>um</font>[val]) {<br>&emsp;&emsp;                <font color=#194060>q</font>.<font color=#55552A>push</font>(i);<br>&emsp;&emsp;            }<br>&emsp;&emsp;            <font color=#194060>um</font>[val].<font color=#55552A>clear</font>();<br>&emsp;&emsp;            <font color=#713D71>if</font> (now >= <font color=#435635>1</font> && !<font color=#194060>st</font>[now - <font color=#435635>1</font>]) <font color=#194060>q</font>.<font color=#55552A>push</font>(now - <font color=#435635>1</font>);<br>&emsp;&emsp;            <font color=#713D71>if</font> (now < n - <font color=#435635>1</font> && !<font color=#194060>st</font>[now + <font color=#435635>1</font>]) <font color=#194060>q</font>.<font color=#55552A>push</font>(now + <font color=#435635>1</font>);<br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#194060>st</font>[n - <font color=#435635>1</font>] - <font color=#435635>1</font>;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>重建二叉树<br>&emsp;&emsp;前序中序遍历还原二叉树<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>首先创建一个哈希表,用来快速查找<br>&emsp;&emsp;然后创建一个 build 函数. <br>&emsp;&emsp;<br>&emsp;&emsp;这个还挺好做的, 不过注意地下的代码顺序<font color=#5DAF99><br>&emsp;&emsp;TreeNode</font><font color=#3D6DA4>*</font> <font color=#55552A>buildTree</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>preorder</font>, <font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>inorder</font>) {<br>&emsp;&emsp;    unordered_map<<font color=#3D6DA4>int</font>,<font color=#3D6DA4>int</font>> um;<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> n = <font color=#194060>preorder</font>.<font color=#55552A>size</font>() - <font color=#435635>1</font>;<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>0</font>; i <= n; i++){<br>&emsp;&emsp;        <font color=#194060>um</font>[<font color=#194060>inorder</font>[i]] = i; <br>&emsp;&emsp;    }<br>&emsp;&emsp;    function<TreeNode*(<font color=#3D6DA4>int</font>,<font color=#3D6DA4>int</font>,<font color=#3D6DA4>int</font>,<font color=#3D6DA4>int</font>)> build = [&](<font color=#3D6DA4>int</font> <font color=#194060>pl</font>, <font color=#3D6DA4>int</font> <font color=#194060>pr</font>, <font color=#3D6DA4>int</font> <font color=#194060>il</font>, <font color=#3D6DA4>int</font> <font color=#194060>ir</font>){<br>&emsp;&emsp;        <font color=#713D71>if</font>(pl > pr) <font color=#713D71>return</font> (TreeNode*)<font color=#3D6DA4>nullptr</font>;<br>&emsp;&emsp;<font color=#85A96D>        // int node = preorder</font><font color=#85A96D>[</font><font color=#85A96D>pl</font><font color=#85A96D>]</font><font color=#85A96D>; </font><br>&emsp;&emsp;        <font color=#3D6DA4>int</font> pos = <font color=#194060>um</font>[<font color=#194060>preorder</font>[pl]];<br>&emsp;&emsp;        TreeNode* node = <font color=#713D71>new</font> <font color=#55552A>TreeNode</font>(<font color=#194060>preorder</font>[pl]);<br>&emsp;&emsp;        <font color=#194060>node</font>-><font color=#194060>left</font> = <font color=#55552A>build</font>(pl + <font color=#435635>1</font>,pos - il + pl, il, pos - <font color=#435635>1</font>);<br>&emsp;&emsp;        <font color=#194060>node</font>-><font color=#194060>right</font> = <font color=#55552A>build</font>(pos - il + pl + <font color=#435635>1</font> , pr, pos + <font color=#435635>1</font>, ir);            <br>&emsp;&emsp;        <font color=#713D71>return</font> node;<br>&emsp;&emsp;    };<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#55552A>build</font>(<font color=#435635>0</font>, n, <font color=#435635>0</font>, n); <br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>重建二叉树, 两种方法.<br>&emsp;&emsp;<br>&emsp;&emsp;//todo acwing 的方法<hr><font color=#3D6DA4>/* </font><font color=#3D6DA4>用链表表示数的结构</font><font color=#3D6DA4> */<br>&emsp;&emsp;struct</font> <font color=#5DAF99>TreeNode</font> {<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> val; <br>&emsp;&emsp;    TreeNode *left, *right;<br>&emsp;&emsp;    <font color=#55552A>TreeNode</font>(<font color=#3D6DA4>int</font> <font color=#194060>x</font> = <font color=#435635>0</font>):<font color=#55552A>val</font>(x), <font color=#55552A>left</font>(<font color=#3D6DA4>nullptr</font>), <font color=#55552A>right</font>(<font color=#3D6DA4>nullptr</font>) {}<br>&emsp;&emsp;};<br>&emsp;&emsp;<br>&emsp;&emsp;auto node = new TreeNode();<br>&emsp;&emsp;---<br>&emsp;&emsp;/* 用数组来表示树 */<br>&emsp;&emsp;<font color=#85A96D>// </font><font color=#85A96D>定义数据结构</font><br>&emsp;&emsp;<font color=#3D6DA4>int</font> <font color=#194060>h</font>[N], <font color=#194060>e</font>[N], <font color=#194060>ne</font>[N * <font color=#435635>2</font>], idx;<font color=#85A96D> //</font><font color=#85A96D>定义数据结构</font><br>&emsp;&emsp;<font color=#85A96D>// </font><font color=#85A96D>建立树</font><br>&emsp;&emsp;<font color=#3D6DA4>void</font> <font color=#55552A>add</font>(<font color=#3D6DA4>int</font> <font color=#194060>a</font>, <font color=#3D6DA4>int</font> <font color=#194060>b</font>){<br>&emsp;&emsp;    <font color=#194060>e</font>[++idx] = b, <font color=#194060>ne</font>[idx] = <font color=#194060>h</font>[a], <font color=#194060>h</font>[a] = idx;<br>&emsp;&emsp;}<br>&emsp;&emsp;<font color=#3D6DA4>int</font> a, b;<br>&emsp;&emsp;<font color=#55552A>add</font>(<font color=#5DAF99>a</font>,<font color=#5DAF99>b</font>), <font color=#55552A>add</font>(b, a)<font color=#85A96D> // </font><font color=#85A96D>建立图</font><br>&emsp;&emsp;<font color=#85A96D>// </font><font color=#85A96D>遍历树</font><br>&emsp;&emsp;<font color=#713D71>for</font>(<font color=#3D6DA4>int</font> <font color=#194060>i</font> = <font color=#194060>h</font>[u]; i; i = <font color=#194060>ne</font>[i]){<br>&emsp;&emsp;    <font color=#3D6DA4>int</font> j = <font color=#194060>e</font>[i]; <br>&emsp;&emsp;<font color=#85A96D>    // .... </font><font color=#85A96D>等等</font><br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>链表: 取尾部第K个结点?<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>注意：面试的时候需要注意，是否存在的问题是吧，就是底下的while(k--)需要多判断一下<br>&emsp;&emsp;<br>&emsp;&emsp;没有防范式编程 可能出错<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5DAF99>ListNode</font><font color=#3D6DA4>*</font> <font color=#55552A>getKthFromEnd</font>(<font color=#5DAF99>ListNode</font><font color=#3D6DA4>*</font> <font color=#194060>head</font>, <font color=#3D6DA4>int</font> <font color=#194060>k</font>) {<br>&emsp;&emsp;    ListNode *slow = head, *fast = head;<br>&emsp;&emsp;    <font color=#713D71>while</font>(k--){<font color=#85A96D> // </font><font color=#85A96D>首先快的先走</font><br>&emsp;&emsp;        fast = <font color=#194060>fast</font>-><font color=#194060>next</font>;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>while</font>(fast){<font color=#85A96D> // </font><font color=#85A96D>然后直接返回</font><font color=#85A96D> slow </font><font color=#85A96D>的就行</font><br>&emsp;&emsp;        fast = <font color=#194060>fast</font>-><font color=#194060>next</font>;<br>&emsp;&emsp;        slow = <font color=#194060>slow</font>-><font color=#194060>next</font>;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> slow;<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>零钱兑换<br>&emsp;&emsp;￼<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>简单的背包问题<br>&emsp;&emsp;<font color=#3D6DA4><br>&emsp;&emsp;int</font> <font color=#55552A>coinChange</font>(<font color=#5DAF99>vector</font><<font color=#3D6DA4>int</font>><font color=#3D6DA4>&</font> <font color=#194060>coins</font>, <font color=#3D6DA4>int</font> <font color=#194060>amount</font>) {<br>&emsp;&emsp;    vector<<font color=#3D6DA4>int</font>> <font color=#55552A>dp</font>(amount + <font color=#435635>1</font>, amount + <font color=#435635>1</font>);<br>&emsp;&emsp;    <font color=#194060>dp</font>[<font color=#435635>0</font>] = <font color=#435635>0</font>;<br>&emsp;&emsp;    <font color=#713D71>for</font>(<font color=#3D6DA4>int</font> i = <font color=#435635>1</font>;i <= amount;i++){<br>&emsp;&emsp;        <font color=#713D71>for</font>(<font color=#3D6DA4>auto</font>& coin:coins){<br>&emsp;&emsp;            <font color=#713D71>if</font>(i >= coin){<br>&emsp;&emsp;                <font color=#194060>dp</font>[i] = <font color=#55552A>min</font>(<font color=#194060>dp</font>[i],<font color=#194060>dp</font>[i - coin] + <font color=#435635>1</font>);<br>&emsp;&emsp;            }<br>&emsp;&emsp;        }<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#713D71>return</font> <font color=#194060>dp</font>[amount] == amount + <font color=#435635>1</font>? -<font color=#435635>1</font> : <font color=#194060>dp</font>[amount];<br>&emsp;&emsp;}<br>&emsp;&emsp;<hr><hr>1.38、如何用代码判断大小端存储？<hr>强制类型转换 / union 联合体<br>&emsp;&emsp;###<br>&emsp;&emsp;<br>&emsp;&emsp;大端存储：高字节存储在低地址中<br>&emsp;&emsp;小端存储：低字节存储在低地址中<hr><hr>1.47、静态变量什么时候初始化<hr>1. <font color=#1DB100>初始化只有一次</font>，但是可以<font color=#1DB100>多次赋值</font>，在主程序之前，编译器<font color=#1DB100>已经为其分配好了内存</font>。<br>&emsp;&emsp;2. 静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，但在C和C++中静态局部变量的初始化节点又有点不太一样。在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收。<br>&emsp;&emsp;3. 而在C++中，<font color=#1DB100>初始化时在执行相关代码时才会进行初始化</font>，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以C++标准定<font color=#1DB100>为全局或静态对象是有首次用到时才会进行构造</font>，并通过<font color=#1DB100>atexit()</font><font color=#1DB100>来管理</font>。在程序结束，按照<font color=#1DB100>构造顺序反方向进行逐个析构</font>。所以在C++中是可以使用变量对静态局部变量进行初始化的。<hr><hr>1.67、写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？<br>&emsp;&emsp;<br>&emsp;&emsp;todo 更多知识<br>&emsp;&emsp;如何调试 常用命令<br>&emsp;&emsp;以及 如何看是否开启<hr>使用gdb调试coredump<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;<font color=#1DB100>gdb </font><font color=#1DB100>[</font><font color=#1DB100>可执行文件名]</font><font color=#1DB100> </font><font color=#1DB100>[</font><font color=#1DB100>core</font><font color=#1DB100>文件名]</font><br>&emsp;&emsp;```<hr><hr>1.69、C++中将临时变量作为返回值时的处理过程<br>&emsp;&emsp;<br>&emsp;&emsp;todo 如果是个对象呢<hr>首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了<br>&emsp;&emsp;<br>&emsp;&emsp;C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，<font color=#1DB100>返回值保持在</font><font color=#1DB100>eax</font><font color=#1DB100>寄存器中</font>，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit<br>&emsp;&emsp;<br>&emsp;&emsp;由此可见，函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系<br>&emsp;&emsp;<br>&emsp;&emsp;如果我们需要返回值，一般使用赋值语句就可以了。<hr><hr>1.73、全局变量和局部变量有什么区别？<hr>生命周期(全局/栈) 使用方式 分配空间(全局/堆栈空间)<br>&emsp;&emsp;---<br>&emsp;&emsp;生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；<br>&emsp;&emsp;<br>&emsp;&emsp;使用方式不同：通过声明后全局变量在程序的各个部分都可以用到；局部变量分配在堆栈区，只能在局部使用。<br>&emsp;&emsp;<br>&emsp;&emsp;操作系统和编译器通过内存分配的位置可以区分两者，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。<hr><hr>1.75、 怎样判断两个浮点数是否相等？<hr>对两个浮点数判断大小和是否相等不能直接用==来判断，会出错！明明相等的两个数比较反而是不相等！对于两个浮点数比较只能通过相减并与预先设定的精度比较，记得要取绝对值！浮点数与0的比较也应该注意。与浮点数的表示方式有关。<hr><hr>13、宏定义和函数有何区别？<hr>- 宏在预处理阶段完成替换，之后被替换的文本参与编译，相当于直接插入了代码，<font color=#1DB100>运行时不存在函数调用，执行起来更快</font>；函数调用在运行时需要跳转到具体调用函数。<br>&emsp;&emsp;- 宏定义属于在结构中插入代码，没有返回值；<font color=#1DB100>函数调用具有返回值</font>。<br>&emsp;&emsp;- 宏定义参数<font color=#1DB100>没有类型，不进行类型检查</font>；函数参数<font color=#1DB100>具有类型，需要检查类型</font>。<br>&emsp;&emsp;- 宏定义不要在最后加分号。<hr><hr>14、宏定义和typedef区别？<hr>- 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。<br>&emsp;&emsp;- 宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。<br>&emsp;&emsp;- 宏不检查类型；typedef会检查数据类型。<br>&emsp;&emsp;- 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。<br>&emsp;&emsp;- 注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。<br>&emsp;&emsp;//todo<br>&emsp;&emsp;最后这个什么意思<hr><hr>15、变量声明和定义区别？<hr>- <font color=#1DB100>声明</font>仅仅是把变量的声明的<font color=#1DB100>位置及类型提供给编译器</font>，并不分配内存空间；定义要在<font color=#1DB100>定义的地方为其分配存储</font>空间。<br>&emsp;&emsp;- 相同变量可以在<font color=#1DB100>多处声明（外部变量</font><font color=#1DB100>extern</font>），但只能在一处定义。<hr><hr>1、 在main执行之前和之后执行的代码可能是什么？<hr>main函数执行之前，主要就是初始化系统相关资源：<br>&emsp;&emsp;<br>&emsp;&emsp;- <font color=#FEAE00>设置栈指针</font><font color=#FEAE00><br>&emsp;&emsp;</font>- <font color=#FEAE00>初始化静态</font><font color=#FEAE00>`static`</font><font color=#FEAE00>变量和</font><font color=#FEAE00>`global`</font><font color=#FEAE00>全局变量，即</font><font color=#FEAE00>`.data`</font><font color=#FEAE00>段的内容</font><br>&emsp;&emsp;- 将未初始化部分的全局变量赋初值：short int long 等 .bss段的内容<br>&emsp;&emsp;- 全局对象初始化，在`main`之前调用构造函数，这是可能会执行前的一些代码<br>&emsp;&emsp;- 将main函数的参数`argc`，`argv`等传递给`main`函数，然后才真正运行`main`函数<br>&emsp;&emsp;- `__attribute__((constructor))`<br>&emsp;&emsp;<br>&emsp;&emsp;main函数执行之后：<br>&emsp;&emsp;<br>&emsp;&emsp;- 全局对象的析构函数会在main函数之后执行；<br>&emsp;&emsp;- 可以用 `atexit` 注册一个函数，它会在main 之后执行;<br>&emsp;&emsp;- `__attribute__((destructor))`<hr><hr>2.16.2、（补充题）一个指针占多少字节？<hr>在16题中有提到sizeof（str）的值为8，是在64位的编译环境下的，指针的占用大小为8字节；<br>&emsp;&emsp;<br>&emsp;&emsp;而在32位环境下，指针占用大小为4字节。<br>&emsp;&emsp;<br>&emsp;&emsp;一个指针占内存的大小跟编译环境有关，而与机器的位数无关。<hr><hr>2.16、strlen和sizeof区别？<hr>- sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。<br>&emsp;&emsp;- sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。<br>&emsp;&emsp;- 因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。<hr><hr>2.22、C++中struct和class的区别？<br>&emsp;&emsp;那c和c++呢<br>&emsp;&emsp;<br>&emsp;&emsp;todo 头<hr>相同点<br>&emsp;&emsp;<br>&emsp;&emsp;- 两者都拥有成员函数、公有和私有部分<br>&emsp;&emsp;- 任何可以使用class完成的工作，同样可以使用struct完成<br>&emsp;&emsp;<br>&emsp;&emsp;不同点<br>&emsp;&emsp;<br>&emsp;&emsp;- 两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的<br>&emsp;&emsp;- <font color=#FEAE00>class</font><font color=#FEAE00>默认是</font><font color=#FEAE00>private</font><font color=#FEAE00>继承，</font><font color=#FEAE00> </font><font color=#FEAE00>而</font><font color=#FEAE00>struct</font><font color=#FEAE00>默认是</font><font color=#FEAE00>public</font><font color=#FEAE00>继承</font><br>&emsp;&emsp;<br>&emsp;&emsp;引申：C++和C的struct区别<br>&emsp;&emsp;<br>&emsp;&emsp;- C语言中：struct是用户自定义数据类型（UDT）；C++中struct是抽象数据类型（ADT），支持成员函数的定义，（C++中的struct能继承，能实现多态）<br>&emsp;&emsp;- C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数<br>&emsp;&emsp;- C++中，struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了与C兼容）<br>&emsp;&emsp;- struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名（除：typedef struct class{};）;C++中结构体标记（结构体名）可以直接作为结构体类型名使用，此外结构体struct在C++中被当作类的一种特例<hr><hr>2.26、数组名和指针（这里为指向数组首元素的指针）区别？<hr>数组名不能自增自减, 但是可以通过sizeof获取到大小<br>&emsp;&emsp;都可通过偏移量访问元素<br>&emsp;&emsp;##<br>&emsp;&emsp;- 二者均可通过增减偏移量来访问数组中的元素。<br>&emsp;&emsp;- 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。<br>&emsp;&emsp;- 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。<hr><hr>2.31、野指针和悬空指针<hr>野(没有初始化) 悬空(已经释放掉了)<br>&emsp;&emsp;解决办法: 野(及时初始化/ 置为空) 悬空(free后立即置空)<br>&emsp;&emsp;智能指针<br>&emsp;&emsp;##<br>&emsp;&emsp;都是是指向无效内存区域(这里的无效指的是"不安全不可控")的指针，访问行为将会导致未定义行为。<br>&emsp;&emsp;<br>&emsp;&emsp;- 野指针<br>&emsp;&emsp;  野指针，指的是没有被初始化过的指针<br>&emsp;&emsp;  ```cpp<br>&emsp;&emsp;  int* p;     // 未初始化<br>&emsp;&emsp;  std::cout<< *p << stdendl; // 未初始化就被使用<br>&emsp;&emsp;  ```<br>&emsp;&emsp;  指针初始化时都是赋值为 `nullptr`，这样在使用时编译器就会直接报错，产生非法内存访问。<br>&emsp;&emsp;<br>&emsp;&emsp;- 悬空指针<br>&emsp;&emsp;  悬空指针，指针最初指向的内存已经被释放了的一种指针。<br>&emsp;&emsp;<br>&emsp;&emsp;  ```cpp<br>&emsp;&emsp;    int * p = nullptr;<br>&emsp;&emsp;    int* p2 = new int;<br>&emsp;&emsp;    p = p2;<br>&emsp;&emsp;    delete p2;<br>&emsp;&emsp;  }<br>&emsp;&emsp;      <br>&emsp;&emsp;  ```<br>&emsp;&emsp;<br>&emsp;&emsp;此时 p和p2就是悬空指针，指向的内存已经被释放。继续使用这两个指针，行为不可预料。需要设置为`p=p2=nullptr`。此时再使用，编译器会直接保错。 避免野指针比较简单，但悬空指针比较麻烦。c++引入了智能指针，C++智能指针的本质就是避免悬空指针的产生。<br>&emsp;&emsp;<br>&emsp;&emsp;产生原因及解决办法：<br>&emsp;&emsp;<br>&emsp;&emsp;野指针：指针变量未及时初始化 => 定义指针变量及时初始化，要么置空。<br>&emsp;&emsp;<br>&emsp;&emsp;悬空指针：指针free或delete之后没有及时置空 => 释放操作后立即置空。<hr><hr>2.50、从汇编层去解释一下引用<hr>没有加优化的时候, 引用时通过指针来实现的<br>&emsp;&emsp;---<font color=#AA5925><br>&emsp;&emsp;9</font><font color=#519696>:</font>      <font color=#5E3563>int</font> x <font color=#519696>=</font> <font color=#AA5925>1</font>;<br>&emsp;&emsp;<font color=#AA5925>00401048</font>  mov     dword ptr [ebp<font color=#519696>-</font><font color=#AA5925>4</font>],<font color=#AA5925>1</font><br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#AA5925>10</font><font color=#519696>:</font>     <font color=#5E3563>int</font> <font color=#519696>&</font>b <font color=#519696>=</font> x;<br>&emsp;&emsp;<font color=#AA5925>0040104F</font>   lea     eax,[ebp<font color=#519696>-</font><font color=#AA5925>4</font>]<br>&emsp;&emsp;<font color=#AA5925>00401052</font>  mov     dword ptr [ebp<font color=#519696>-</font><font color=#AA5925>8</font>],eax<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#FEAE00>x</font><font color=#FEAE00>的地址为</font><font color=#FEAE00>ebp-4</font>，<font color=#FEAE00>b</font><font color=#FEAE00>的地址为</font><font color=#FEAE00>ebp-8</font>，因为栈内的变量内存是从高往低进行分配的，所以<font color=#FEAE00>b</font><font color=#FEAE00>的地址比</font><font color=#FEAE00>x</font><font color=#FEAE00>的低。</font><br>&emsp;&emsp;<br>&emsp;&emsp;lea eax,[ebp-4] 这条语句将x的地址ebp-4放入eax寄存器<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#FEAE00>mov dword ptr </font><font color=#FEAE00>[</font><font color=#FEAE00>ebp-8</font><font color=#FEAE00>]</font><font color=#FEAE00>,eax </font><font color=#FEAE00>这条语句将</font><font color=#FEAE00>eax</font><font color=#FEAE00>的值放入</font><font color=#FEAE00>b</font><font color=#FEAE00>的地址</font><br>&emsp;&emsp;<br>&emsp;&emsp;ebp-8中上面两条汇编的作用即：将x的地址存入变量b中，这不和将某个变量的地址存入指针变量是一样的吗？<font color=#FEAE00>所以从汇编层次来看，的确引用是通过指针来实现的。</font><hr><hr>21、C++与Java的区别<hr>语言特性<br>&emsp;&emsp;<br>&emsp;&emsp;- Java语言给开发人员提供了更为简洁的语法；完全面向对象，由于JVM可以安装到任何的操作系统上，所以说它的可移植性强<br>&emsp;&emsp;- Java语言中没有指针的概念，引入了真正的数组。不同于C++中利用指针实现的“伪数组”，Java引入了真正的数组，同时将容易造成麻烦的指针从语言中去掉，这将有利于防止在C++程序中常见的因为数组操作越界等指针操作而对系统数据进行非法读写带来的不安全问题<br>&emsp;&emsp;- C++也可以在其他系统运行，但是需要不同的编码（这一点不如Java，只编写一次代码，到处运行），例如对一个数字，在windows下是大端存储，在unix中则为小端存储。Java程序一般都是生成字节码，在JVM里面运行得到结果<br>&emsp;&emsp;- Java用接口(Interface)技术取代C++程序中的抽象类。接口与抽象类有同样的功能，但是省却了在实现和维护上的复杂性<br>&emsp;&emsp;<br>&emsp;&emsp;垃圾回收<br>&emsp;&emsp;<br>&emsp;&emsp;- C++用析构函数回收垃圾，写C和C++程序时一定要注意内存的申请和释放<br>&emsp;&emsp;- Java语言不使用指针，内存的分配和回收都是自动进行的，程序员无须考虑内存碎片的问题<br>&emsp;&emsp;<br>&emsp;&emsp;应用场景<br>&emsp;&emsp;<br>&emsp;&emsp;- Java在桌面程序上不如C++实用，C++可以直接编译成exe文件，指针是c++的优势，可以直接对内存的操作，但同时具有危险性 。（操作内存的确是一项非常危险的事情，一旦指针指向的位置发生错误，或者误删除了内存中某个地址单元存放的重要数据，后果是可想而知的）<br>&emsp;&emsp;- Java在Web 应用上具有C++ 无可比拟的优势，具有丰富多样的框架<br>&emsp;&emsp;- 对于底层程序的编程以及控制方面的编程，C++很灵活，因为有句柄的存在<hr><hr>2、结构体内存对齐问题？<hr>按照size最大的成员对其, 每个成员对齐到他整数倍的地址上<br>&emsp;&emsp;alignas(cachesize)<br>&emsp;&emsp;##<br>&emsp;&emsp;- 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。<br>&emsp;&emsp;- 未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）<br>&emsp;&emsp;<br>&emsp;&emsp;c++11以后引入两个关键字 [alignas 与 [alignof  其中`alignof`可以计算出类型的对齐方式，`alignas`可以指定结构体的对齐方式。<br>&emsp;&emsp;<br>&emsp;&emsp;但是`alignas`在某些情况下是不能使用的，具体见下面的例子:<br>&emsp;&emsp;<br>&emsp;&emsp;若`alignas`小于自然对齐的最小单位，则被忽略。<br>&emsp;&emsp;<br>&emsp;&emsp;`struct alignas(2) Info2 {` ...<br>&emsp;&emsp;<br>&emsp;&emsp;`alignof(a)` 输出内存对其的大小<hr><hr>3.45、形参与实参的区别？<hr>1. 形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。<br>&emsp;&emsp;2. 实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量。<br>&emsp;&emsp;3. 实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。<br>&emsp;&emsp;4. 函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。<br>&emsp;&emsp;5. 当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。<hr><hr>3.46、<font color=#FEAE00>值传递、指针传递、引用传递</font>的区别和效率<hr>1. 值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象 或是大的结构体对象，将耗费一定的时间和空间。（传值）<br>&emsp;&emsp;2. 指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）<br>&emsp;&emsp;3. 引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）<br>&emsp;&emsp;4. 效率上讲，<font color=#FEAE00>指针传递和引用传递比值传递效率高</font>。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。<hr><hr>3.4、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？<hr>- 需要<font color=#FEAE00>返回函数内局部变量的内存的时候用指针</font>。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的<br>&emsp;&emsp;- 对<font color=#FEAE00>栈空间大小比较敏感（比如递归）的时候使用引用</font>。使用引用传递不需要创建临时变量，开销要更小<br>&emsp;&emsp;- 类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式<hr><hr>32、C和C++的类型安全<hr>什么是类型安全？<br>&emsp;&emsp;<br>&emsp;&emsp;类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。“类型安全”常被用来形容编程语言，其根据在于该门编程语言是否提供保障类型安全的机制；有的时候也用“类型安全”形容某个程序，判别的标准在于该程序是否隐含类型错误。<br>&emsp;&emsp;<br>&emsp;&emsp;类型安全的编程语言与类型安全的程序之间，没有必然联系。好的程序员可以使用类型不那么安全的语言写出类型相当安全的程序，相反的，差一点儿的程序员可能使用类型相当安全的语言写出类型不太安全的程序。绝对类型安全的编程语言暂时还没有。<br>&emsp;&emsp;<br>&emsp;&emsp;（1）C的类型安全<br>&emsp;&emsp;<br>&emsp;&emsp;C只在局部上下文中表现出类型安全，比如试图从一种结构体的指针转换成另一种结构体的指针时，编译器将会报告错误，除非使用显式类型转换。然而，C中相当多的操作是不安全的。以下是两个十分常见的例子：<br>&emsp;&emsp;<br>&emsp;&emsp;- printf格式输出<br>&emsp;&emsp;<br>&emsp;&emsp;上述代码中，使用%d控制整型数字的输出，没有问题，但是改成%f时，明显输出错误，再改成%s时，运行直接报segmentation fault错误<br>&emsp;&emsp;<br>&emsp;&emsp;- malloc函数的返回值<br>&emsp;&emsp;<br>&emsp;&emsp;malloc是C中进行内存分配的函数，它的返回类型是void*即空类型指针，常常有这样的用法char* pStr=(char*)malloc(100*sizeof(char))，这里明显做了显式的类型转换。<br>&emsp;&emsp;<br>&emsp;&emsp;类型匹配尚且没有问题，但是一旦出现int* pInt=(int*)malloc(100*sizeof(char))就很可能带来一些问题，而这样的转换C并不会提示错误。<br>&emsp;&emsp;<br>&emsp;&emsp;（2）C++的类型安全<br>&emsp;&emsp;<br>&emsp;&emsp;如果C++使用得当，它将远比C更有类型安全性。相比于C语言，C++提供了一些新的机制保障类型安全：<br>&emsp;&emsp;<br>&emsp;&emsp;- 操作符new返回的指针类型严格与对象匹配，而不是void*<br>&emsp;&emsp;<br>&emsp;&emsp;- C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；<br>&emsp;&emsp;<br>&emsp;&emsp;- 引入const关键字代替#define constants，它是有类型、有作用域的，而#define constants只是简单的文本替换<br>&emsp;&emsp;<br>&emsp;&emsp;- 一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全<br>&emsp;&emsp;<br>&emsp;&emsp;- C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。<br>&emsp;&emsp;<br>&emsp;&emsp;  例1：使用void*进行类型转换<br>&emsp;&emsp;<br>&emsp;&emsp; 例2：不同类型指针之间转换<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;#include<iostream><br>&emsp;&emsp;using namespace std;<br>&emsp;&emsp; <br>&emsp;&emsp;class Parent{};<br>&emsp;&emsp;class Child1 : public Parent<br>&emsp;&emsp;{<br>&emsp;&emsp;public:<br>&emsp;&emsp;	int i;<br>&emsp;&emsp;	Child1(int e):i(e){}<br>&emsp;&emsp;};<br>&emsp;&emsp;class Child2 : public Parent<br>&emsp;&emsp;{<br>&emsp;&emsp;public:<br>&emsp;&emsp;	double d;<br>&emsp;&emsp;	Child2(double e):d(e){}<br>&emsp;&emsp;};<br>&emsp;&emsp;int main()<br>&emsp;&emsp;{<br>&emsp;&emsp;	Child1 c1(5);<br>&emsp;&emsp;	Child2 c2(4.1);<br>&emsp;&emsp;	Parent* pp;<br>&emsp;&emsp;	Child1* pc1;<br>&emsp;&emsp; 	<br>&emsp;&emsp;	pp=&c1; <br>&emsp;&emsp;	pc1=(Child1*)pp;  // 类型向下转换 强制转换，由于类型仍然为Child1*，不造成错误<br>&emsp;&emsp;	cout<<pc1->i<<endl; //输出：5<br>&emsp;&emsp; <br>&emsp;&emsp;	pp=&c2;<br>&emsp;&emsp;	pc1=(Child1*)pp;  //强制转换，且类型发生变化，将造成错误<br>&emsp;&emsp;	cout<<pc1->i<<endl;// 输出：1717986918<br>&emsp;&emsp;	return 0;<br>&emsp;&emsp;}<br>&emsp;&emsp; <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;上面两个例子之所以引起类型不安全的问题，是因为程序员使用不得当。第一个例子用到了空类型指针`void*`，第二个例子则是在两个类型指针之间进行强制转换。因此，想保证程序的类型安全性，应尽量避免使用空类型指针`void*`，尽量不对两种类型指针做强制转换。<hr><hr>36、内联函数和宏定义的区别<hr>- 在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。<br>&emsp;&emsp;- 内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载。<br>&emsp;&emsp;- 宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义<br>&emsp;&emsp;- 内联函数有类型检测、语法判断等功能，而宏没有<br>&emsp;&emsp;<br>&emsp;&emsp;内联函数适用场景:<br>&emsp;&emsp;<br>&emsp;&emsp;- 使用宏定义的地方都可以使用 inline 函数。<br>&emsp;&emsp;- 作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率。<hr><hr>3、指针和引用的区别<hr>- 是否可变：指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名<br>&emsp;&emsp;- 级别数量：指针可以有多级，引用只有一级<br>&emsp;&emsp;- 是否可为空：指针可以为空，引用不能为NULL且在定义时必须初始化<br>&emsp;&emsp;- 后面变：指针在初始化后可以改变指向，而引用在初始化之后不可再改变<br>&emsp;&emsp;- sizeof大小：sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小<br>&emsp;&emsp;- 传参区别：当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。<br>&emsp;&emsp;- 引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间（，具体情况还要具体分析）。<br>&emsp;&emsp;- 引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。<br>&emsp;&emsp;- 引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。<br>&emsp;&emsp;- 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。<br>&emsp;&emsp;todo 可能需要新的总结<hr><hr>4.23、define宏定义和const的区别<hr>阶段 编译/执行 安全性。内存占用。检查类型。<br>&emsp;&emsp;##<br>&emsp;&emsp;编译阶段<br>&emsp;&emsp;<br>&emsp;&emsp;- define是在编译的预处理阶段起作用，而const是在编译、运行的时候起作用<br>&emsp;&emsp;<br>&emsp;&emsp;安全性<br>&emsp;&emsp;<br>&emsp;&emsp;- define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错<br>&emsp;&emsp;- const常量有数据类型，编译器可以对其进行类型安全检查<br>&emsp;&emsp;<br>&emsp;&emsp;内存占用<br>&emsp;&emsp;<br>&emsp;&emsp;- define只是将宏名称进行替换，在内存中会产生多分相同的备份。const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表<br>&emsp;&emsp;- 宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。<br>&emsp;&emsp;- 宏不检查类型；const会检查数据类型。<br>&emsp;&emsp;- 宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。<hr><hr>4.24、C++中const和static的作用<hr><br>&emsp;&emsp;const 初始化 形参 等<br>&emsp;&emsp;##<br>&emsp;&emsp;const<br>&emsp;&emsp;<br>&emsp;&emsp;- 不考虑类的情况<br>&emsp;&emsp;  - const常量在定义时必须初始化，之后无法更改<br>&emsp;&emsp;  - const形参可以接收const和非const类型的实参，例如// i 可以是 int 型或者 const int 型void fun(const int& i){ //...}<br>&emsp;&emsp;- 考虑类的情况<br>&emsp;&emsp;  - const成员变量：不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数；不同类对其const数据成员的值可以不同，所以不能在类中声明时初始化<br>&emsp;&emsp;  - const成员函数：const对象不可以调用非const成员函数；非const对象都可以调用；不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值<br>&emsp;&emsp;<br>&emsp;&emsp;补充一点const相关：const修饰变量是也与static有一样的隐藏作用。只能在该文件中使用，其他文件不可以引用声明使用。 因此在头文件中声明const变量是没问题的，因为即使被多个文件包含，链接性都是内部的，不会出现符号冲突。<hr><hr>4.25、C++的顶层const和底层const<hr>概念区分<br>&emsp;&emsp;<br>&emsp;&emsp;- 顶层const：指的是const修饰的变量本身是一个常量，无法修改，指的是指针，就是 * 号的右边<br>&emsp;&emsp;- 底层const：指的是const修饰的变量所指向的对象是一个常量，指的是所指变量，就是 * 号的左边<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;int a = 10;int* const b1 = &a;        //顶层const，b1本身是一个常量<br>&emsp;&emsp;const int* b2 = &a;       //底层const，b2本身可变，所指的对象是常量<br>&emsp;&emsp;const int b3 = 20; 		   //顶层const，b3是常量不可变<br>&emsp;&emsp;const int* const b4 = &a;  //前一个const为底层，后一个为顶层，b4不可变<br>&emsp;&emsp;const int& b5 = a;		   //用于声明引用变量，都是底层const<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;区分作用<br>&emsp;&emsp;<br>&emsp;&emsp;- 执行对象拷贝时有限制，常量的底层const不能赋值给非常量的底层const<br>&emsp;&emsp;<br>&emsp;&emsp;- 使用命名的强制类型转换函数const_cast时，只能改变运算对象的底层const<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;const int a;int const a;const int *a;int *const a;<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;- int const a和const int a均表示定义常量类型a。<br>&emsp;&emsp;- const int *a，其中a为指向int型变量的指针，const在 * 左侧，表示a指向不可变常量。(看成const (*a)，对引用加const)<br>&emsp;&emsp;- int *const a，依旧是指针类型，表示a为指向整型数据的常指针。(看成const(a)，对指针const)<hr><hr>4.27、final和override关键字<hr>override<br>&emsp;&emsp;<br>&emsp;&emsp;当在父类中使用了虚函数时候，你可能需要在某个子类中对这个虚函数进行重写，以下方法都可以<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;class A<br>&emsp;&emsp;{<br>&emsp;&emsp;    virtual void foo();<br>&emsp;&emsp;}<br>&emsp;&emsp;class B : public A<br>&emsp;&emsp;{<br>&emsp;&emsp;    void foo(); //OK<br>&emsp;&emsp;    virtual void foo(); // OK<br>&emsp;&emsp;    void foo() override; //OK<br>&emsp;&emsp;}<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;如果不使用override，当你手一抖，将foo()写成了f00()会怎么样呢？结果是编译器并不会报错，因为它并不知道你的目的是重写虚函数，而是把它当成了新的函数。如果这个虚函数很重要的话，那就会对整个程序不利。所以，override的作用就出来了，它指定了子类的这个虚函数是重写的父类的，如果你名字不小心打错了的话，编译器是不会编译通过的：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;class A<br>&emsp;&emsp;{<br>&emsp;&emsp;    virtual void foo();<br>&emsp;&emsp;};<br>&emsp;&emsp;class B : public A<br>&emsp;&emsp;{<br>&emsp;&emsp;    virtual void f00(); //OK，这个函数是B新增的，不是继承的<br>&emsp;&emsp;    virtual void f0o() override; //Error, 加了override之后，这个函数一定是继承自A的，A找不到就报错<br>&emsp;&emsp;};<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;final<br>&emsp;&emsp;<br>&emsp;&emsp;当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。例子如下：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;class Base<br>&emsp;&emsp;{<br>&emsp;&emsp;    virtual void foo();<br>&emsp;&emsp;};<br>&emsp;&emsp; <br>&emsp;&emsp;class A : public Base<br>&emsp;&emsp;{<br>&emsp;&emsp;    void foo() final; // foo 被override并且是最后一个override，在其子类中不可以重写<br>&emsp;&emsp;};<br>&emsp;&emsp;<br>&emsp;&emsp;class B final : A // 指明B是不可以被继承的<br>&emsp;&emsp;{<br>&emsp;&emsp;    void foo() override; // Error: 在A中已经被final了<br>&emsp;&emsp;};<br>&emsp;&emsp; <br>&emsp;&emsp;class C : B // Error: B is final<br>&emsp;&emsp;{<br>&emsp;&emsp;};<br>&emsp;&emsp;```<hr><hr>4.30、extern"C"的用法<hr>为了能够正确的在C++代码中调用C语言的代码：在程序中加上extern "C"后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++；<br>&emsp;&emsp;<br>&emsp;&emsp;哪些情况下使用extern "C"：<br>&emsp;&emsp;<br>&emsp;&emsp;（1）C++代码中调用C语言代码；<br>&emsp;&emsp;<br>&emsp;&emsp;（2）在C++中的头文件中使用；<br>&emsp;&emsp;<br>&emsp;&emsp;（3）在多个人协同开发时，可能有人擅长C语言，而有人擅长C++；<br>&emsp;&emsp;<br>&emsp;&emsp;举个例子，C++中调用C代码：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;#ifndef __MY_HANDLE_H__<br>&emsp;&emsp;#define __MY_HANDLE_H__<br>&emsp;&emsp;<br>&emsp;&emsp;extern "C"{<br>&emsp;&emsp;    typedef unsigned int result_t;<br>&emsp;&emsp;    typedef void* my_handle_t;<br>&emsp;&emsp;    <br>&emsp;&emsp;    my_handle_t create_handle(const char* name);<br>&emsp;&emsp;    result_t operate_on_handle(my_handle_t handle);<br>&emsp;&emsp;    void close_handle(my_handle_t handle);<br>&emsp;&emsp;}<br>&emsp;&emsp; <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;综上，总结出使用方法，在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern "C"声明，在.c文件中包含了extern "C"时会出现编译语法错误。所以使用extern "C"全部都放在于cpp程序相关文件或其头文件中。<br>&emsp;&emsp;<br>&emsp;&emsp;总结出如下形式：<br>&emsp;&emsp;<br>&emsp;&emsp;（1）C++调用C函数<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;//xx.h<br>&emsp;&emsp;extern int add(...)<br>&emsp;&emsp;<br>&emsp;&emsp;//xx.c<br>&emsp;&emsp;int add(){<br>&emsp;&emsp;    <br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;//xx.cpp<br>&emsp;&emsp;extern "C" {<br>&emsp;&emsp;    #include "xx.h"<br>&emsp;&emsp;}<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;（2）C调用C++函数<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;//xx.h<br>&emsp;&emsp;extern "C"{<br>&emsp;&emsp;    int add();<br>&emsp;&emsp;}<br>&emsp;&emsp;//xx.cpp<br>&emsp;&emsp;int add(){    <br>&emsp;&emsp;}<br>&emsp;&emsp;//xx.c<br>&emsp;&emsp;extern int add();<br>&emsp;&emsp;```<hr><hr>4.39、volatile、mutable和explicit关键字的用法<hr>(1)volatile<br>&emsp;&emsp;<br>&emsp;&emsp;volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。<br>&emsp;&emsp;<br>&emsp;&emsp;当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。<br>&emsp;&emsp;<br>&emsp;&emsp;volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。<br>&emsp;&emsp;<br>&emsp;&emsp;volatile 指针<br>&emsp;&emsp;<br>&emsp;&emsp;volatile 指针和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念<br>&emsp;&emsp;<br>&emsp;&emsp;修饰由指针指向的对象、数据是 const 或 volatile 的：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;const char* cpch;volatile char* vpch;<br>&emsp;&emsp; <br>&emsp;&emsp;        @阿秀: 代码已成功复制到剪贴板<br>&emsp;&emsp;    <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;1<br>&emsp;&emsp;<br>&emsp;&emsp;指针自身的值——一个代表地址的整数变量，是 const 或 volatile 的：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;char* const pchc;char* volatile pchv;<br>&emsp;&emsp; <br>&emsp;&emsp;        @阿秀: 代码已成功复制到剪贴板<br>&emsp;&emsp;    <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;1<br>&emsp;&emsp;<br>&emsp;&emsp;注意：<br>&emsp;&emsp;<br>&emsp;&emsp;- 可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。<br>&emsp;&emsp;- 除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。<br>&emsp;&emsp;- C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从类传递到它的成员。<br>&emsp;&emsp;<br>&emsp;&emsp;多线程下的volatile<br>&emsp;&emsp;<br>&emsp;&emsp;有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。<br>&emsp;&emsp;<br>&emsp;&emsp;（2）mutable<br>&emsp;&emsp;<br>&emsp;&emsp;mutable的中文意思是“可变的，易变的”，跟constant（既C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置。<br>&emsp;&emsp;<br>&emsp;&emsp;样例<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;class person<br>&emsp;&emsp;{<br>&emsp;&emsp;int m_A;<br>&emsp;&emsp;mutable int m_B;//特殊变量 在常函数里值也可以被修改<br>&emsp;&emsp;public:<br>&emsp;&emsp;     void add() const//在函数里不可修改this指针指向的值 常量指针<br>&emsp;&emsp;     {<br>&emsp;&emsp;        m_A=10;//错误  不可修改值，this已经被修饰为常量指针<br>&emsp;&emsp;        m_B=20;//正确<br>&emsp;&emsp;     }<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;class person<br>&emsp;&emsp;{<br>&emsp;&emsp;int m_A;<br>&emsp;&emsp;mutable int m_B;//特殊变量 在常函数里值也可以被修改<br>&emsp;&emsp;}<br>&emsp;&emsp;int main()<br>&emsp;&emsp;{<br>&emsp;&emsp;const person p;//修饰常对象 不可修改类成员的值<br>&emsp;&emsp;p.m_A=10;//错误，被修饰了指针常量<br>&emsp;&emsp;p.m_B=200;//正确，特殊变量，修饰了mutable<br>&emsp;&emsp;}<br>&emsp;&emsp;    <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;（3）explicit<br>&emsp;&emsp;<br>&emsp;&emsp;explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换，注意以下几点：<br>&emsp;&emsp;<br>&emsp;&emsp;- explicit 关键字只能用于类内部的构造函数声明上<br>&emsp;&emsp;- explicit 关键字作用于单个参数的构造函数<br>&emsp;&emsp;- 被explicit修饰的构造函数的类，不能发生相应的隐式类型转换<hr><hr>4.43、<font color=#FEAE00>static</font><font color=#FEAE00>的用法</font>和作用？<hr><font color=#FEAE00>全局变量</font><font color=#FEAE00> / </font><font color=#FEAE00>函数的隐藏</font><font color=#1DB100>(</font><font color=#1DB100>文件</font><font color=#FEAE00>内</font><font color=#FEAE00>,</font><font color=#1DB100> </font><font color=#1DB100>类</font><font color=#FEAE00>内</font><font color=#FEAE00>, </font><font color=#1DB100>函数</font><font color=#FEAE00>内</font><font color=#FEAE00>)</font><br>&emsp;&emsp;##<br>&emsp;&emsp;static 作用可以当做是全局变量 / 函数 的隐藏, 不过有很多个级别: <br>&emsp;&emsp;<br>&emsp;&emsp;1. 文件内隐藏: 多个文件, 加了就只有文件内的可见性<br>&emsp;&emsp;2. 类内隐藏: 类内声明的, 其实可以看做和全局变量特征一样, 存储在静态区的, 不过可以控制可见范围是类内可见的.<br>&emsp;&emsp;3. 默认初始化为0, 这个所有的全局变量都具有的特征<br>&emsp;&emsp;4. 函数体内的 static, 其实就是隐藏在了函数的作用范围之中<br>&emsp;&emsp;5. 注意的话, 类内修饰的变量需要在类外初始化<br>&emsp;&emsp;6. static 属于类, 不属于对象, 是没有 this 指针的<br>&emsp;&emsp;7. 不能被virtual修饰, 不属于任何对象或者实例, <br>&emsp;&emsp;<hr><hr>4.44、指针和const的用法<br>&emsp;&emsp;<br>&emsp;&emsp;todo 代码随想录有详细<hr>1. 当const修饰指针时，由于const的位置不同，它的修饰对象会有所不同。<br>&emsp;&emsp;2. int *const p2中const修饰p2的值,所以理解为p2的值不可以改变，即p2只能指向固定的一个变量地址，但可以通过*p2读写这个变量的值。顶层指针表示指针本身是一个常量<br>&emsp;&emsp;3. int const *p1或者const int *p1两种情况中const修饰*p1，所以理解为*p1的值不可以改变，即不可以给*p1赋值改变p1指向变量的值，但可以通过给p赋值不同的地址改变这个指针指向。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#FEAE00>底层指针表示指针所指向的变量是一个常量。</font><hr><hr>4.48、const关键字的作用有哪些?<br>&emsp;&emsp;<br>&emsp;&emsp;todo 太长<hr>1. 阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；<br>&emsp;&emsp;2. 对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；<br>&emsp;&emsp;3. 在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；<br>&emsp;&emsp;4. 对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量，类的常对象只能访问类的常成员函数；<br>&emsp;&emsp;5. 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。<br>&emsp;&emsp;6. const成员函数可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；<br>&emsp;&emsp;7. 非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；<br>&emsp;&emsp;8. 一个没有明确声明为const的成员函数被看作是将要修改对象中数据成员的函数，而且编译器不允许它为一个const对象所调用。因此const对象只能调用const成员函数。<br>&emsp;&emsp;9. const类型变量可以通过类型转换符const_cast将const类型转换为非const类型；<br>&emsp;&emsp;10. const类型变量必须定义的时候进行初始化，因此也导致如果类的成员变量有const类型的变量，那么该变量必须在类的初始化列表中进行初始化；<br>&emsp;&emsp;11. 对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参。则这个时候无论加不加const对实参不会产生任何影响。但是在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。因为在编译阶段编译器对调用函数的选择是根据实参进行的，所以，只有引用传递和指针传递可以用是否加const来重载。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。<hr><hr>5.66、C++函数调用的压栈过程<br>&emsp;&emsp;<br>&emsp;&emsp;todo 错了<hr><hr>5.6、你觉得<font color=#FEAE00>堆快一点还是栈</font>快一点？<hr>栈快一点, 专门的寄存器, ebp esp, 入栈出栈很简单<br>&emsp;&emsp;堆: c++ 函数库提供, 需要算法分配和回收, 存在间接访存<br>&emsp;&emsp;---<br>&emsp;&emsp;毫无疑问是<font color=#1DB100>栈快一点</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;因为操作系统会在底层对栈提供支持，会分配<font color=#1DB100>专门的寄存器存放栈的地址</font>，栈的<font color=#FEAE00>入栈出栈操作</font>也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。<br>&emsp;&emsp;<br>&emsp;&emsp;而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要<font color=#1DB100>一定的算法寻找合适大小的内存</font>。并且获取堆的内容需要<font color=#1DB100>两次访问</font>，第一次<font color=#1DB100>访问指针</font>，第二次<font color=#1DB100>根据指针保存的地址访问内存</font>，因此堆比较慢。<hr><hr>5、堆和栈的区别<hr>- 申请方式不同。<br>&emsp;&emsp;  - 栈由系统自动分配。<br>&emsp;&emsp;  - 堆是自己申请和释放的。<br>&emsp;&emsp;- 管理方式 不同<br>&emsp;&emsp;  - 栈资源由编译器自动管理，无需手工控制<br>&emsp;&emsp;  - 堆中资源由程序员控制（容易产生memory leak）<br>&emsp;&emsp;- 申请大小限制不同。<br>&emsp;&emsp;  - 栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改。<br>&emsp;&emsp;  - 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。<br>&emsp;&emsp;- 申请效率不同。<br>&emsp;&emsp;  - 栈由系统分配，速度快，不会有碎片。<br>&emsp;&emsp;  - 堆由程序员分配，速度慢，且会有碎片。<br>&emsp;&emsp;<br>&emsp;&emsp;栈空间默认是4M, 堆区一般是 1G - 4G<hr><hr>6.29、初始化和赋值的区别<hr>- <font color=#FEAE00>对于简单类型来说，初始化和赋值没什么区别</font><br>&emsp;&emsp;- 对于类和复杂数据类型来说，这两者的区别就大了，举例如下：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;class A{<br>&emsp;&emsp;public:<br>&emsp;&emsp;    int num1;<br>&emsp;&emsp;    int num2;<br>&emsp;&emsp;public:<br>&emsp;&emsp;    A(int a=0, int b=0):num1(a),num2(b){};<br>&emsp;&emsp;    A(const A& a){};<br>&emsp;&emsp;    //重载 = 号操作符函数<br>&emsp;&emsp;    A& operator=(const A& a){<br>&emsp;&emsp;        num1 = a.num1 + 1;<br>&emsp;&emsp;        num2 = a.num2 + 1;<br>&emsp;&emsp;        return *this;<br>&emsp;&emsp;    };<br>&emsp;&emsp;};<br>&emsp;&emsp;int main(){<br>&emsp;&emsp;    A a(1,1);<br>&emsp;&emsp;    A a1 = a; //拷贝初始化操作，调用拷贝构造函数<br>&emsp;&emsp;    A b;<br>&emsp;&emsp;    b = a;//赋值操作，对象a中，num1 = 1，num2 = 1；对象b中，num1 = 2，num2 = 2<br>&emsp;&emsp;    return 0;<br>&emsp;&emsp;}<br>&emsp;&emsp;```<hr><hr>6.34、C++有哪几种的构造函数<hr>C++中的构造函数可以分为4类：<br>&emsp;&emsp;<br>&emsp;&emsp;- 默认构造函数<br>&emsp;&emsp;- 初始化构造函数（有参数）<br>&emsp;&emsp;- 拷贝构造函数<br>&emsp;&emsp;- 移动构造函数（move和右值引用）<br>&emsp;&emsp;- 委托构造函数<br>&emsp;&emsp;- 转换构造函数<br>&emsp;&emsp;<br>&emsp;&emsp;举个例子：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;#include <iostream><br>&emsp;&emsp;using namespace std;<br>&emsp;&emsp;<br>&emsp;&emsp;class Student{<br>&emsp;&emsp;public:<br>&emsp;&emsp;    Student(){//默认构造函数，没有参数<br>&emsp;&emsp;        this->age = 20;<br>&emsp;&emsp;        this->num = 1000;<br>&emsp;&emsp;    };  <br>&emsp;&emsp;    Student(int a, int n):age(a), num(n){}; //初始化构造函数，有参数和参数列表<br>&emsp;&emsp;    Student(const Student& s){//拷贝构造函数，这里与编译器生成的一致<br>&emsp;&emsp;        this->age = s.age;<br>&emsp;&emsp;        this->num = s.num;<br>&emsp;&emsp;    }; <br>&emsp;&emsp;    Student(int r){   //转换构造函数,形参是其他类型变量，且只有一个形参<br>&emsp;&emsp;        this->age = r;<br>&emsp;&emsp;		this->num = 1002;<br>&emsp;&emsp;    };<br>&emsp;&emsp;    ~Student(){}<br>&emsp;&emsp;public:<br>&emsp;&emsp;    int age;<br>&emsp;&emsp;    int num;<br>&emsp;&emsp;};<br>&emsp;&emsp;<br>&emsp;&emsp;int main(){<br>&emsp;&emsp;    Student s1;<br>&emsp;&emsp;    Student s2(18,1001);<br>&emsp;&emsp;    int a = 10;<br>&emsp;&emsp;    Student s3(a);<br>&emsp;&emsp;    Student s4(s3);<br>&emsp;&emsp;    <br>&emsp;&emsp;    printf("s1 age:%d, num:%d\n", s1.age, s1.num);<br>&emsp;&emsp;    printf("s2 age:%d, num:%d\n", s2.age, s2.num);<br>&emsp;&emsp;    printf("s3 age:%d, num:%d\n", s3.age, s3.num);<br>&emsp;&emsp;    printf("s2 age:%d, num:%d\n", s4.age, s4.num);<br>&emsp;&emsp;    return 0;<br>&emsp;&emsp;}<br>&emsp;&emsp;//运行结果<br>&emsp;&emsp;//s1 age:20, num:1000<br>&emsp;&emsp;//s2 age:18, num:1001<br>&emsp;&emsp;//s3 age:10, num:1002<br>&emsp;&emsp;//s2 age:10, num:1002<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;- 默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作<br>&emsp;&emsp;- 复制构造函数用于复制本类的对象<br>&emsp;&emsp;- 转换构造函数用于将其他类型的变量，隐式转换为本类对象<hr><hr>6.40、什么情况下会调用拷贝构造函数<hr>- 用类的一个实例化对象去初始化另一个对象的时候<br>&emsp;&emsp;- 函数的参数是类的对象时（非引用传递）<br>&emsp;&emsp;- 函数的返回值是函数体内局部对象的类的对象时 ,此时虽然发生（Named return Value优化）NRV优化，但是由于返回方式是值传递，所以会在返回值的地方调用拷贝构造函数<br>&emsp;&emsp;<br>&emsp;&emsp;另：第三种情况在Linux g++ 下则不会发生拷贝构造函数，不仅如此即使返回局部对象的引用，依然不会发生拷贝构造函数<br>&emsp;&emsp;<br>&emsp;&emsp;总结就是：即使发生NRV优化的情况下，Linux+ g++的环境是不管值返回方式还是引用方式返回的方式都不会发生拷贝构造函数，而Windows + VS2019在值返回的情况下发生拷贝构造函数，引用返回方式则不发生拷贝构造函数。<br>&emsp;&emsp;<br>&emsp;&emsp;在c++编译器发生NRV优化，如果是引用返回的形式则不会调用拷贝构造函数，如果是值传递的方式依然会发生拷贝构造函数。<br>&emsp;&emsp;<br>&emsp;&emsp;在VS2019下进行下述实验：<br>&emsp;&emsp;<br>&emsp;&emsp;举个例子：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;class A<br>&emsp;&emsp;{<br>&emsp;&emsp;public:<br>&emsp;&emsp;	A() {};<br>&emsp;&emsp;	A(const A& a)<br>&emsp;&emsp;	{<br>&emsp;&emsp;		cout << "copy constructor is called" << endl;<br>&emsp;&emsp;	};<br>&emsp;&emsp;	~A() {};<br>&emsp;&emsp;};<br>&emsp;&emsp;<br>&emsp;&emsp;void useClassA(A a) {}<br>&emsp;&emsp;<br>&emsp;&emsp;A getClassA()//此时会发生拷贝构造函数的调用，虽然发生NRV优化，但是依然调用拷贝构造函数<br>&emsp;&emsp;{<br>&emsp;&emsp;	A a;<br>&emsp;&emsp;	return a;<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;//A& getClassA2()//  VS2019下，此时编辑器会进行（Named return Value优化）NRV优化,不调用拷贝构造函数 ，如果是引用传递的方式返回当前函数体内生成的对象时，并不发生拷贝构造函数的调用<br>&emsp;&emsp;//{<br>&emsp;&emsp;//	A a;<br>&emsp;&emsp;//	return a;<br>&emsp;&emsp;//}<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;int main()<br>&emsp;&emsp;{<br>&emsp;&emsp;	A a1,a3,a4;<br>&emsp;&emsp;	A a2 = a1;  //调用拷贝构造函数,对应情况1<br>&emsp;&emsp;	useClassA(a1);//调用拷贝构造函数，对应情况2<br>&emsp;&emsp;	a3 = getClassA();//发生NRV优化，但是值返回，依然会有拷贝构造函数的调用 情况3<br>&emsp;&emsp;	a4 = getClassA2(a1);//发生NRV优化，且引用返回自身，不会调用<br>&emsp;&emsp;    return 0;<br>&emsp;&emsp;}<br>&emsp;&emsp;    <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;情况1比较好理解<br>&emsp;&emsp;<br>&emsp;&emsp;情况2的实现过程是，调用函数时先根据传入的实参产生临时对象，再用拷贝构造去初始化这个临时对象，在函数中与形参对应，函数调用结束后析构临时对象<br>&emsp;&emsp;<br>&emsp;&emsp;情况3在执行return时，理论的执行过程是：产生临时对象，调用拷贝构造函数把返回对象拷贝给临时对象，函数执行完先析构局部变量，再析构临时对象， 依然会调用拷贝构造函数<hr><hr>6.58、类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？<hr>1. 赋值初始化，通过在函数体内进行赋值初始化；列表初始化，在冒号后使用初始化列表进行初始化。<br>&emsp;&emsp;<br>&emsp;&emsp;这两种方式的主要区别在于：<br>&emsp;&emsp;<br>&emsp;&emsp;对于在函数体中初始化,是在所有的数据成员被分配内存空间后才进行的。<br>&emsp;&emsp;<br>&emsp;&emsp;列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式),那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行。<br>&emsp;&emsp;<br>&emsp;&emsp;2. 一个派生类构造函数的执行顺序如下：<br>&emsp;&emsp;<br>&emsp;&emsp;① 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。<br>&emsp;&emsp;<br>&emsp;&emsp;② 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。<br>&emsp;&emsp;<br>&emsp;&emsp;③ 类类型的成员对象的构造函数（按照初始化顺序）<br>&emsp;&emsp;<br>&emsp;&emsp;④ 派生类自己的构造函数。<br>&emsp;&emsp;<br>&emsp;&emsp;3. 方法一是在构造函数当中做赋值的操作，而方法二是做纯粹的初始化操作。我们都知道，C++的赋值操作是会产生临时对象的。临时对象的出现会降低程序的效率。<hr><hr>6.59、有哪些情况必须用到成员列表初始化？作用是什么？<br>&emsp;&emsp;<br>&emsp;&emsp;todo 这是什么<hr>1. 必须使用成员初始化的<font color=#1DB100>四种</font>情况<br>&emsp;&emsp;① 当初始化一个<font color=#1DB100>引用成员</font>时；<br>&emsp;&emsp;② 当初始化一个<font color=#1DB100>常量成员</font>时；<br>&emsp;&emsp;③ 当调用一个基类的<font color=#1DB100>构造函数</font>，而它拥有一组参数时；<br>&emsp;&emsp;④ 当调用一个成员类的构造函数，而它拥有一组参数时；<br>&emsp;&emsp;1. 成员初始化列表做了什么<br>&emsp;&emsp;* ① 编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；<br>&emsp;&emsp;* ② list中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的；<hr><hr>6.68、说说移动构造函数<br>&emsp;&emsp;<br>&emsp;&emsp;todo 太长<hr>1. 我们用对象a初始化对象b，后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；<br>&emsp;&emsp;2. 拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。<br>&emsp;&emsp;<br>&emsp;&emsp;所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针（比如a->value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a->value指向的空间；<br>&emsp;&emsp;<br>&emsp;&emsp;1. 移动构造函数的参数和拷贝构造函数不同，<font color=#FEAE00>拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用</font>。意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，只用用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值。<hr><hr>66.1、以例子进行讲解<br>&emsp;&emsp;<br>&emsp;&emsp;todo连着<hr>从代码入手，解释这个过程：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;#include <iostream><br>&emsp;&emsp;using namespace std;<br>&emsp;&emsp;<br>&emsp;&emsp;int f(int n) <br>&emsp;&emsp;{<br>&emsp;&emsp;	cout << n << endl;<br>&emsp;&emsp;	return n;<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;void func(int param1, int param2)<br>&emsp;&emsp;{<br>&emsp;&emsp;	int var1 = param1;<br>&emsp;&emsp;	int var2 = param2;<br>&emsp;&emsp;	printf("var1=%d,var2=%d", f(var1), f(var2));//如果将printf换为cout进行输出，输出结果则刚好相反<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;int main(int argc, char* argv[])<br>&emsp;&emsp;{<br>&emsp;&emsp;	func(1, 2);<br>&emsp;&emsp;	return 0;<br>&emsp;&emsp;}<br>&emsp;&emsp;//输出结果<br>&emsp;&emsp;//2<br>&emsp;&emsp;//1<br>&emsp;&emsp;//var1=1,var2=2<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;当函数从入口函数main函数开始执行时，编译器会将我们操作系统的运行状态，main函数的返回地址、main的参数、mian函数中的变量、进行依次压栈；<br>&emsp;&emsp;<br>&emsp;&emsp;当main函数开始调用func()函数时，编译器此时会将main函数的运行状态进行压栈，再将func()函数的返回地址、func()函数的参数从右到左、func()定义变量依次压栈；<br>&emsp;&emsp;<br>&emsp;&emsp;当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再将的返回地址、f()函数的参数从右到左、f()定义变量依次压栈<br>&emsp;&emsp;<br>&emsp;&emsp;从代码的输出结果可以看出，函数f(var1)、f(var2)依次入栈，而后先执行f(var2)，再执行f(var1)，最后打印整个字符串，将栈中的变量依次弹出，最后主函数返回。<hr><hr>66.2、文字化表述<br>&emsp;&emsp;<br>&emsp;&emsp;todo<hr>函数的调用过程：<br>&emsp;&emsp;<br>&emsp;&emsp;1）从栈空间分配存储空间<br>&emsp;&emsp;<br>&emsp;&emsp;2）从实参的存储空间复制值到形参栈空间<br>&emsp;&emsp;<br>&emsp;&emsp;3）进行运算<br>&emsp;&emsp;<br>&emsp;&emsp;形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。<br>&emsp;&emsp;<br>&emsp;&emsp;数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。<br>&emsp;&emsp;<br>&emsp;&emsp;当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址/指针传递。<hr><hr>7.33 C++中的重载、重写（覆盖）和隐藏的区别<hr>（1）重载（overload）<br>&emsp;&emsp;<br>&emsp;&emsp;重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关。举个例子：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;class A{<br>&emsp;&emsp;    ...<br>&emsp;&emsp;    virtual int fun();<br>&emsp;&emsp;    void fun(int);<br>&emsp;&emsp;    void fun(double, double);<br>&emsp;&emsp;    static int fun(char);<br>&emsp;&emsp;    ...<br>&emsp;&emsp;}<br>&emsp;&emsp;    <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;（2）重写（覆盖）（override）<br>&emsp;&emsp;<br>&emsp;&emsp;重写指的是在派生类中覆盖基类中的同名函数，重写就是重写函数体，要求基类函数必须是虚函数且：<br>&emsp;&emsp;<br>&emsp;&emsp;- 与基类的虚函数有相同的参数个数<br>&emsp;&emsp;- 与基类的虚函数有相同的参数类型<br>&emsp;&emsp;- 与基类的虚函数有相同的返回值类型<br>&emsp;&emsp;<br>&emsp;&emsp;举个例子：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;//父类<br>&emsp;&emsp;class A{<br>&emsp;&emsp;public:<br>&emsp;&emsp;    virtual int fun(int a){}<br>&emsp;&emsp;}<br>&emsp;&emsp;//子类<br>&emsp;&emsp;class B : public A{<br>&emsp;&emsp;public:<br>&emsp;&emsp;    //重写,一般加override可以确保是重写父类的函数<br>&emsp;&emsp;    virtual int fun(int a) override{}<br>&emsp;&emsp;}<br>&emsp;&emsp;    <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;重载与重写的区别：<br>&emsp;&emsp;<br>&emsp;&emsp;- 重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系<br>&emsp;&emsp;- 重写要求参数列表相同，重载则要求参数列表不同，返回值不要求<br>&emsp;&emsp;- 重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体<br>&emsp;&emsp;<br>&emsp;&emsp;（3）隐藏（hide）<br>&emsp;&emsp;<br>&emsp;&emsp;隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：<br>&emsp;&emsp;<br>&emsp;&emsp;- 两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数是否是虚函数。举个例子：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;//父类<br>&emsp;&emsp;class A{<br>&emsp;&emsp;public:<br>&emsp;&emsp;    void fun(int a){<br>&emsp;&emsp;		cout << "A中的fun函数" << endl;<br>&emsp;&emsp;	}<br>&emsp;&emsp;};<br>&emsp;&emsp;//子类<br>&emsp;&emsp;class B : public A{<br>&emsp;&emsp;public:<br>&emsp;&emsp;    //隐藏父类的fun函数<br>&emsp;&emsp;    void fun(int a){<br>&emsp;&emsp;		cout << "B中的fun函数" << endl;<br>&emsp;&emsp;	}<br>&emsp;&emsp;};<br>&emsp;&emsp;int main(){<br>&emsp;&emsp;    B b;<br>&emsp;&emsp;    b.fun(2); //调用的是B中的fun函数<br>&emsp;&emsp;    b.A::fun(2); //调用A中fun函数<br>&emsp;&emsp;    return 0;<br>&emsp;&emsp;}<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;- 两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。举个例子：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;//父类<br>&emsp;&emsp;class A{<br>&emsp;&emsp;public:<br>&emsp;&emsp;    virtual void fun(int a){<br>&emsp;&emsp;		cout << "A中的fun函数" << endl;<br>&emsp;&emsp;	}<br>&emsp;&emsp;};<br>&emsp;&emsp;//子类<br>&emsp;&emsp;class B : public A{<br>&emsp;&emsp;public:<br>&emsp;&emsp;    //隐藏父类的fun函数<br>&emsp;&emsp;   virtual void fun(char* a){<br>&emsp;&emsp;	   cout << "A中的fun函数" << endl;<br>&emsp;&emsp;   }<br>&emsp;&emsp;};<br>&emsp;&emsp;int main(){<br>&emsp;&emsp;    B b;<br>&emsp;&emsp;    b.fun(2); //报错，调用的是B中的fun函数，参数类型不对<br>&emsp;&emsp;    b.A::fun(2); //调用A中fun函数<br>&emsp;&emsp;    return 0;<br>&emsp;&emsp;}<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;补充：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;// 父类<br>&emsp;&emsp;class A {<br>&emsp;&emsp;public:<br>&emsp;&emsp;    virtual void fun(int a) { // 虚函数<br>&emsp;&emsp;        cout << "This is A fun " << a << endl;<br>&emsp;&emsp;    }  <br>&emsp;&emsp;    void add(int a, int b) {<br>&emsp;&emsp;        cout << "This is A add " << a + b << endl;<br>&emsp;&emsp;    }<br>&emsp;&emsp;};<br>&emsp;&emsp;<br>&emsp;&emsp;// 子类<br>&emsp;&emsp;class B: public A {<br>&emsp;&emsp;public:<br>&emsp;&emsp;    void fun(int a) override {  // 覆盖<br>&emsp;&emsp;        cout << "this is B fun " << a << endl;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    void add(int a) {   // 隐藏<br>&emsp;&emsp;        cout << "This is B add " << a + a << endl;<br>&emsp;&emsp;    }<br>&emsp;&emsp;};<br>&emsp;&emsp;<br>&emsp;&emsp;int main() {<br>&emsp;&emsp;    // 基类指针指向派生类对象时，基类指针可以直接调用到派生类的覆盖函数，也可以通过 :: 调用到基类被覆盖<br>&emsp;&emsp;    // 的虚函数；而基类指针只能调用基类的被隐藏函数，无法识别派生类中的隐藏函数。<br>&emsp;&emsp;<br>&emsp;&emsp;    A *p = new B();<br>&emsp;&emsp;    p->fun(1);      // 调用子类 fun 覆盖函数<br>&emsp;&emsp;    p->A::fun(1);   // 调用父类 fun<br>&emsp;&emsp;    p->add(1, 2);<br>&emsp;&emsp;    // p->add(1);      // 错误，识别的是 A 类中的 add 函数，参数不匹配<br>&emsp;&emsp;    // p->B::add(1);   // 错误，无法识别子类 add 函数<br>&emsp;&emsp;    return 0;<br>&emsp;&emsp;}<br>&emsp;&emsp;```<hr><hr>7.35、浅拷贝和深拷贝的区别<hr>浅拷贝<br>&emsp;&emsp;<br>&emsp;&emsp;浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。<br>&emsp;&emsp;<br>&emsp;&emsp;深拷贝<br>&emsp;&emsp;<br>&emsp;&emsp;深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;#include <iostream>  <br>&emsp;&emsp;#include <string.h><br>&emsp;&emsp;using namespace std;<br>&emsp;&emsp; <br>&emsp;&emsp;class Student<br>&emsp;&emsp;{<br>&emsp;&emsp;private:<br>&emsp;&emsp;	int num;<br>&emsp;&emsp;	char *name;<br>&emsp;&emsp;public:<br>&emsp;&emsp;	Student(){<br>&emsp;&emsp;        name = new char(20);<br>&emsp;&emsp;		cout << "Student" << endl;<br>&emsp;&emsp;    };<br>&emsp;&emsp;	~Student(){<br>&emsp;&emsp;        cout << "~Student " << &name << endl;<br>&emsp;&emsp;        delete name;<br>&emsp;&emsp;        name = NULL;<br>&emsp;&emsp;    };<br>&emsp;&emsp;	Student(const Student &s){//拷贝构造函数<br>&emsp;&emsp;        //浅拷贝，当对象的name和传入对象的name指向相同的地址<br>&emsp;&emsp;        name = s.name;<br>&emsp;&emsp;        //深拷贝<br>&emsp;&emsp;        //name = new char(20);<br>&emsp;&emsp;        //memcpy(name, s.name, strlen(s.name));<br>&emsp;&emsp;        cout << "copy Student" << endl;<br>&emsp;&emsp;    };<br>&emsp;&emsp;};<br>&emsp;&emsp; <br>&emsp;&emsp;int main()<br>&emsp;&emsp;{<br>&emsp;&emsp;	{// 花括号让s1和s2变成局部对象，方便测试<br>&emsp;&emsp;		Student s1;<br>&emsp;&emsp;		Student s2(s1);// 复制对象<br>&emsp;&emsp;	}<br>&emsp;&emsp;	system("pause");<br>&emsp;&emsp;	return 0;<br>&emsp;&emsp;}<br>&emsp;&emsp;//浅拷贝执行结果：<br>&emsp;&emsp;//Student<br>&emsp;&emsp;//copy Student<br>&emsp;&emsp;//~Student 0x7fffed0c3ec0<br>&emsp;&emsp;//~Student 0x7fffed0c3ed0<br>&emsp;&emsp;//* Error in `/tmp/815453382/a.out': double free or corruption (fasttop): 0x0000000001c82c20 *<br>&emsp;&emsp;<br>&emsp;&emsp;//深拷贝执行结果：<br>&emsp;&emsp;//Student<br>&emsp;&emsp;//copy Student<br>&emsp;&emsp;//~Student 0x7fffebca9fb0<br>&emsp;&emsp;//~Student 0x7fffebca9fc0<br>&emsp;&emsp;    <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;从执行结果可以看出，浅拷贝在对象的拷贝创建时存在风险，即被拷贝的对象析构释放资源之后，拷贝对象析构时会再次释放一个已经释放的资源，深拷贝的结果是两个对象之间没有任何关系，各自成员地址不同。<hr><hr>7.37、public，protected和private访问和继承权限/public/protected/private的区别？<hr>//todo 还有图没加上来<br>&emsp;&emsp;<br>&emsp;&emsp;- public的变量和函数在类的内部外部都可以访问。<br>&emsp;&emsp;- protected的变量和函数只能在类的内部和其派生类中访问。<br>&emsp;&emsp;- private修饰的元素只能在类内访问。<br>&emsp;&emsp;<br>&emsp;&emsp;（一）访问权限<br>&emsp;&emsp;<br>&emsp;&emsp;派生类可以继承基类中除了构造/析构、赋值运算符重载函数之外的成员，但是这些成员的访问属性在派生过程中也是可以调整的，三种派生方式的访问权限如下表所示：注意外部访问并不是真正的外部访问，而是在通过派生类的对象对基类成员的访问。<br>&emsp;&emsp;<br>&emsp;&emsp;派生类对基类成员的访问形象有如下两种：<br>&emsp;&emsp;<br>&emsp;&emsp;- 内部访问：由派生类中新增的成员函数对从基类继承来的成员的访问<br>&emsp;&emsp;- 外部访问：在派生类外部，通过派生类的对象对从基类继承来的成员的访问<br>&emsp;&emsp;<br>&emsp;&emsp;（二）继承权限<br>&emsp;&emsp;<br>&emsp;&emsp;public继承<br>&emsp;&emsp;<br>&emsp;&emsp;公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，都保持原有的状态，而基类的私有成员任然是私有的，不能被这个派生类的子类所访问<br>&emsp;&emsp;<br>&emsp;&emsp;protected继承<br>&emsp;&emsp;<br>&emsp;&emsp;保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元函数访问，基类的私有成员仍然是私有的，访问规则如下表<br>&emsp;&emsp;<br>&emsp;&emsp;private继承<br>&emsp;&emsp;<br>&emsp;&emsp;私有继承的特点是基类的所有公有成员和保护成员都成为派生类的私有成员，并不被它的派生类的子类所访问，基类的成员只能由自己派生类访问，无法再往下继承，访问规则如下表<hr><hr>7.49、什么是类的继承？<br>&emsp;&emsp;<br>&emsp;&emsp;todo 太多<hr>- 类与类之间的关系<br>&emsp;&emsp;<br>&emsp;&emsp;has-A包含关系，用以描述一个类由多个部件类构成，实现has-A关系用类的成员属性表示，即一个类的成员属性是另一个已经定义好的类；<br>&emsp;&emsp;<br>&emsp;&emsp;use-A，一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现；<br>&emsp;&emsp;<br>&emsp;&emsp;is-A，继承关系，关系具有传递性；<br>&emsp;&emsp;<br>&emsp;&emsp;- 继承的相关概念<br>&emsp;&emsp;<br>&emsp;&emsp;所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，被称为子类或者派生类，被继承的类称为父类或者基类；<br>&emsp;&emsp;<br>&emsp;&emsp;- 继承的特点<br>&emsp;&emsp;<br>&emsp;&emsp;子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法，子类对象可以当做父类对象使用；<br>&emsp;&emsp;<br>&emsp;&emsp;- 继承中的访问控制<br>&emsp;&emsp;<br>&emsp;&emsp;public、protected、private<br>&emsp;&emsp;<br>&emsp;&emsp;- 继承中的构造和析构函数<br>&emsp;&emsp;<br>&emsp;&emsp;- 继承中的兼容性原则<hr><hr>7.51、深拷贝与浅拷可以描述一下吗？<hr>浅复制 ：只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”，换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。<br>&emsp;&emsp;<br>&emsp;&emsp;深复制 ：在计算机中开辟了一块新的内存地址用于存放复制的对象。<br>&emsp;&emsp;<br>&emsp;&emsp;在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。<hr><hr>7.62、对象复用的了解，零拷贝的了解<br>&emsp;&emsp;<br>&emsp;&emsp;todo 这个复用是啥<hr>对象复用<br>&emsp;&emsp;<br>&emsp;&emsp;对象复用其本质是一种<font color=#1DB100>设计模式</font>：Flyweight享元模式。<br>&emsp;&emsp;<br>&emsp;&emsp;通过将<font color=#1DB100>对象存储到“对象池</font>”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。<br>&emsp;&emsp;<br>&emsp;&emsp;零拷贝<br>&emsp;&emsp;零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。<br>&emsp;&emsp;<br>&emsp;&emsp;零拷贝技术可以减少数据拷贝和共享总线操作的次数。<br>&emsp;&emsp;<br>&emsp;&emsp;在C++中，vector的一个成员函数<font color=#1DB100>emplace_back</font>()很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：使用push_back()函数需要调用<font color=#1DB100>拷贝构造函数和转移构造函数</font>，而使用emplace_back()插入的元素<font color=#1DB100>原地构造</font>，不需要触发拷贝构造和转移构造，效率更高。举个例子：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;#include <vector><br>&emsp;&emsp;#include <string><br>&emsp;&emsp;#include <iostream><br>&emsp;&emsp;using namespace std;<br>&emsp;&emsp;<br>&emsp;&emsp;struct Person<br>&emsp;&emsp;{<br>&emsp;&emsp;    string name;<br>&emsp;&emsp;    int age;<br>&emsp;&emsp;    //初始构造函数<br>&emsp;&emsp;    Person(string p_name, int p_age): name(std::move(p_name)), age(p_age)<br>&emsp;&emsp;    {<br>&emsp;&emsp;         cout << "I have been constructed" <<endl;<br>&emsp;&emsp;    }<br>&emsp;&emsp;     //拷贝构造函数<br>&emsp;&emsp;     Person(const Person& other): name(std::move(other.name)), age(other.age)<br>&emsp;&emsp;    {<br>&emsp;&emsp;         cout << "I have been copy constructed" <<endl;<br>&emsp;&emsp;    }<br>&emsp;&emsp;     //转移构造函数<br>&emsp;&emsp;     Person(Person&& other): name(std::move(other.name)), age(other.age)<br>&emsp;&emsp;    {<br>&emsp;&emsp;         cout << "I have been moved"<<endl;<br>&emsp;&emsp;    }<br>&emsp;&emsp;};<br>&emsp;&emsp;<br>&emsp;&emsp;int main()<br>&emsp;&emsp;{<br>&emsp;&emsp;    vector<Person> e;<br>&emsp;&emsp;    cout << "emplace_back:" <<endl;<br>&emsp;&emsp;    e.emplace_back("Jane", 23); //不用构造类对象<br>&emsp;&emsp;<br>&emsp;&emsp;    vector<Person> p;<br>&emsp;&emsp;    cout << "push_back:"<<endl;<br>&emsp;&emsp;    p.push_back(Person("Mike",36));<br>&emsp;&emsp;    return 0;<br>&emsp;&emsp;}<br>&emsp;&emsp;//输出结果：<br>&emsp;&emsp;//emplace_back:<br>&emsp;&emsp;//I have been constructed<br>&emsp;&emsp;//push_back:<br>&emsp;&emsp;//I have been constructed<br>&emsp;&emsp;//I am being moved.<br>&emsp;&emsp; <br>&emsp;&emsp;```<hr><hr>7.63、介绍面向对象的三大特性，并且举例说明<br>&emsp;&emsp;<br>&emsp;&emsp;todo 多态补充一下<hr>三大特性：继承、封装和多态<br>&emsp;&emsp;<br>&emsp;&emsp;（1）继承<br>&emsp;&emsp;<br>&emsp;&emsp;让某种类型对象获得另一个类型对象的属性和方法。<br>&emsp;&emsp;<br>&emsp;&emsp;它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展<br>&emsp;&emsp;<br>&emsp;&emsp;常见的继承有<font color=#1DB100>三种</font>方式：<br>&emsp;&emsp;<br>&emsp;&emsp;1. <font color=#1DB100>实现</font>继承：指使用基类的属性和方法而无需额外编码的能力<br>&emsp;&emsp;2. <font color=#1DB100>接口</font>继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力<br>&emsp;&emsp;3. <font color=#1DB100>可视</font>继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力（C++里好像不怎么用）<br>&emsp;&emsp;<br>&emsp;&emsp;例如，将人定义为一个<font color=#1DB100>抽象类</font>，拥有姓名、性别、年龄等公共属性，吃饭、睡觉、走路等公共方法，在定义一个具体的人时，就可以继承这个抽象类，既保留了<font color=#1DB100>公共属性和方法</font>，也可以在此基础上扩展跳舞、唱歌等特有方法<br>&emsp;&emsp;<br>&emsp;&emsp;（2）封装<br>&emsp;&emsp;<br>&emsp;&emsp;数据和代码捆绑在一起，避免外界干扰和不确定性访问。<br>&emsp;&emsp;<br>&emsp;&emsp;封装，也就是把客观事物<font color=#1DB100>封装成抽象</font>的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用<font color=#1DB100>private</font>修饰。<br>&emsp;&emsp;<br>&emsp;&emsp;（3）多态<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#1DB100>同一事物</font>表现出<font color=#1DB100>不同事物的能力</font>，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（<font color=#1DB100>重载</font>实现<font color=#1DB100>编译时</font>多态，<font color=#1DB100>虚函数实现运行时</font>多态）。<br>&emsp;&emsp;<br>&emsp;&emsp;多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单一句话：允许将子类类型的指针赋值给父类类型的指针<br>&emsp;&emsp;<br>&emsp;&emsp;实现多态有二种方式：<font color=#1DB100>覆盖（</font><font color=#1DB100>override</font><font color=#1DB100>）</font>，<font color=#1DB100>重载（</font><font color=#1DB100>overload</font><font color=#1DB100>）</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;覆盖：是指子类重新定义父类的虚函数的做法。<br>&emsp;&emsp;<br>&emsp;&emsp;重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。例如：基类是一个抽象对象——人，那教师、运动员也是人，而使用这个抽象对象既可以表示教师、也可以表示运动员。<hr><hr>7.71、静态类型和动态类型，静态绑定和动态绑定的介绍<br>&emsp;&emsp;<br>&emsp;&emsp;todo 好长<hr>- 静态类型：对象在声明时采用的类型，在编译期既已确定；<br>&emsp;&emsp;- 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；<br>&emsp;&emsp;- 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；<br>&emsp;&emsp;- 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；<br>&emsp;&emsp;<br>&emsp;&emsp;从上面的定义也可以看出，非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态性）。 举个例子：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;#include <iostream><br>&emsp;&emsp;using namespace std;<br>&emsp;&emsp;<br>&emsp;&emsp;class A<br>&emsp;&emsp;{<br>&emsp;&emsp;public:<br>&emsp;&emsp;	/*virtual*/ void func() { stdcout << "Afunc()\n"; }<br>&emsp;&emsp;};<br>&emsp;&emsp;class B : public A<br>&emsp;&emsp;{<br>&emsp;&emsp;public:<br>&emsp;&emsp;	void func() { stdcout << "Bfunc()\n"; }<br>&emsp;&emsp;};<br>&emsp;&emsp;class C : public A<br>&emsp;&emsp;{<br>&emsp;&emsp;public:<br>&emsp;&emsp;	void func() { stdcout << "Cfunc()\n"; }<br>&emsp;&emsp;};<br>&emsp;&emsp;int main()<br>&emsp;&emsp;{<br>&emsp;&emsp;	C* pc = new C(); //pc的静态类型是它声明的类型C*，动态类型也是C*；<br>&emsp;&emsp;	B* pb = new B(); //pb的静态类型和动态类型也都是B*；<br>&emsp;&emsp;	A* pa = pc;      //pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*；<br>&emsp;&emsp;	pa = pb;         //pa的动态类型可以更改，现在它的动态类型是B*，但其静态类型仍是声明时候的A*；<br>&emsp;&emsp;	C *pnull = NULL; //pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；<br>&emsp;&emsp;    <br>&emsp;&emsp;    pa->func();      //Afunc() pa的静态类型永远都是A*，不管其指向的是哪个子类，都是直接调用Afunc()；<br>&emsp;&emsp;	pc->func();      //Cfunc() pc的动、静态类型都是C*，因此调用Cfunc()；<br>&emsp;&emsp;	pnull->func();   //C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定了，和指针空不空没关系；<br>&emsp;&emsp;	return 0;<br>&emsp;&emsp;}<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;如果将A类中的virtual注释去掉，则运行结果是：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;pa->func();      //B::func() 因为有了virtual虚函数特性，pa的动态类型指向B*，因此先在B中查找，找到后直接调用；<br>&emsp;&emsp;pc->func();      //C::func() pc的动、静态类型都是C*，因此也是先在C中查找；<br>&emsp;&emsp;pnull->func();   //空指针异常，因为是func是virtual函数，因此对func的调用只能等到运行期才能确定，然后才发现pnull是空指针；<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;在上面的例子中，<br>&emsp;&emsp;<br>&emsp;&emsp;- 如果基类A中的func不是virtual函数，那么不论pa、pb、pc指向哪个子类对象，对func的调用都是在定义pa、pb、pc时的静态类型决定，早已在编译期确定了。<br>&emsp;&emsp;- 同样的空指针也能够直接调用no-virtual函数而不报错（这也说明一定要做空指针检查啊！），因此静态绑定不能实现多态；<br>&emsp;&emsp;- 如果func是虚函数，那所有的调用都要等到运行时根据其指向对象的类型才能确定，比起静态绑定自然是要有性能损失的，但是却能实现多态特性；<br>&emsp;&emsp;<br>&emsp;&emsp;本文代码里都是针对指针的情况来分析的，但是对于引用的情况同样适用。<br>&emsp;&emsp;<br>&emsp;&emsp;至此总结一下静态绑定和动态绑定的区别：<br>&emsp;&emsp;<br>&emsp;&emsp;- 静态绑定发生在编译期，动态绑定发生在运行期；<br>&emsp;&emsp;- 对象的动态类型可以更改，但是静态类型无法更改；<br>&emsp;&emsp;- 要想实现动态，必须使用动态绑定；<br>&emsp;&emsp;- 在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；<br>&emsp;&emsp;<br>&emsp;&emsp;建议：<br>&emsp;&emsp;<br>&emsp;&emsp;绝对不要重新定义继承而来的非虚(non-virtual)函数（《Effective C++ 第三版》条款36），因为这样导致函数调用由对象声明时的静态类型确定了，而和对象本身脱离了关系，没有多态，也这将给程序留下不可预知的隐患和莫名其妙的BUG；另外，在动态绑定也即在virtual函数中，要注意默认参数的使用。当缺省参数和virtual函数一起使用的时候一定要谨慎，不然出了问题怕是很难排查。 看下面的代码：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;#include <iostream><br>&emsp;&emsp;using namespace std;<br>&emsp;&emsp;<br>&emsp;&emsp;class E<br>&emsp;&emsp;{<br>&emsp;&emsp;public:<br>&emsp;&emsp;	virtual void func(int i = 0)<br>&emsp;&emsp;	{<br>&emsp;&emsp;		stdcout << "Efunc()\t" << i << "\n";<br>&emsp;&emsp;	}<br>&emsp;&emsp;};<br>&emsp;&emsp;class F : public E<br>&emsp;&emsp;{<br>&emsp;&emsp;public:<br>&emsp;&emsp;	virtual void func(int i = 1)<br>&emsp;&emsp;	{<br>&emsp;&emsp;		stdcout << "Ffunc()\t" << i << "\n";<br>&emsp;&emsp;	}<br>&emsp;&emsp;};<br>&emsp;&emsp;<br>&emsp;&emsp;void test2()<br>&emsp;&emsp;{<br>&emsp;&emsp;	F* pf = new F();<br>&emsp;&emsp;	E* pe = pf;<br>&emsp;&emsp;	pf->func(); //F::func() 1  正常，就该如此；<br>&emsp;&emsp;	pe->func(); //F::func() 0  哇哦，这是什么情况，调用了子类的函数，却使用了基类中参数的默认值！<br>&emsp;&emsp;}<br>&emsp;&emsp;int main()<br>&emsp;&emsp;{<br>&emsp;&emsp;	test2();<br>&emsp;&emsp;	return 0;<br>&emsp;&emsp;}<br>&emsp;&emsp;```<hr><hr>7.79、如果想将某个类用作基类，为什么该类必须<font color=#1DB100>定义</font>而非<font color=#1DB100>声明</font>？<hr>派生类中包含并且可以使用它从基类继承而来的<font color=#1DB100>成员</font>，为了使用这些成员，派生类必须知道他们是什么。<br>&emsp;&emsp;<br>&emsp;&emsp;所以必须定义而非声明。<hr><hr>8.1 [阿秀9]、new和delete是如何实现的？<hr>- new的实现过程是：首先调用名为<font color=#1DB100>operator new</font>的标准库函数，分配<font color=#1DB100>足够大的原始为类型化的内存</font>，以保存指定类型的一个对象；接下来运行该类型的一个<font color=#1DB100>构造函数</font>，用指定<font color=#1DB100>初始化构造对象</font>；最后返回指向新分配并构造后的的对象的指针<br>&emsp;&emsp;- delete的实现过程：对指针指向的对象运行适当的<font color=#1DB100>析构函数</font>；然后通过调用名为<font color=#1DB100>operator delete</font>的标准库函数释放该对象所用内存<hr><hr>8.2、malloc和new的区别？ [阿秀10]<hr>- malloc和free是标准库函数，<font color=#1DB100>支持覆盖</font>；new和delete是运算符，<font color=#1DB100>不重载</font>。<br>&emsp;&emsp;- malloc<font color=#1DB100>仅仅分配内存空间</font>，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间<font color=#1DB100>存储类的对象存在风险</font>；new和delete除了分配回收功能外，还会调用<font color=#1DB100>构造函数和析构函数</font>。<br>&emsp;&emsp;- malloc和free返回的是<font color=#1DB100>void</font><font color=#1DB100>类型指针</font>（必须进行类型转换），new和delete返回的是<font color=#1DB100>具体类型指针</font>。<hr><hr>8.3 、既然有了malloc/free，C++中为什么还需要new/delete呢？直接用malloc/free不好吗？ [阿秀11]<hr>- malloc/free和new/delete都是用来申请内存和回收内存的。<br>&emsp;&emsp;- 在<font color=#1DB100>对非基本数据类型的对象使用的时候</font>，对象创建的时候还需要<font color=#1DB100>执行构造函数</font>，销毁的时候要执行析构函数。而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc/free，所以new/delete是<font color=#1DB100>必不可少的</font>。<hr><hr>8.4 、被<font color=#1DB100>free</font>回收的内存是立即返还给操作系统吗？ [阿秀12]<hr>不是的，被free回收的内存会首先<font color=#1DB100>被</font><font color=#1DB100>ptmalloc</font><font color=#1DB100>使用双链表保存起来</font>，当用户下一次申请内存的时候，会尝试<font color=#1DB100>从这些内存中寻找合适的返回</font>。这样就<font color=#1DB100>避免了频繁的系统调用</font>，占用过多的系统资源。同时ptmalloc也会尝试<font color=#1DB100>对小块内存进行合并</font>，避免过多的<font color=#1DB100>内存碎片</font>。<hr><hr>8.55、malloc申请的存储空间能用delete释放吗?<hr>不能，malloc /free主要为了兼容C，new和delete 完全可以取代malloc /free的。<br>&emsp;&emsp;<br>&emsp;&emsp;malloc /free的操作对象都是必须明确大小的，而且不能用在动态类上。<br>&emsp;&emsp;<br>&emsp;&emsp;new 和delete会自动进行类型检查和大小，malloc/free不能执行构造函数与析构函数，所以动态对象它是不行的。<br>&emsp;&emsp;<br>&emsp;&emsp;当然从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常。<hr><hr>8.9、new和delete的实现原理， delete是如何知道释放内存的大小的？ - 阿秀 54<hr>1、 new简单类型直接调用operator new分配内存；<br>&emsp;&emsp;<br>&emsp;&emsp;而对于复杂结构，先调用operator new分配内存，然后在分配的内存上调用构造函数；<br>&emsp;&emsp;<br>&emsp;&emsp;对于简单类型，new[]计算好大小后调用operator new；<br>&emsp;&emsp;<br>&emsp;&emsp;对于复杂数据结构，new[]先调用operator new[]分配内存，然后在p的前四个字节写入数组大小n，然后调用n次构造函数，针对复杂类型，new[]会额外存储数组大小；<br>&emsp;&emsp;<br>&emsp;&emsp;① new表达式调用一个名为operator new(operator new[])函数，分配一块足够大的、原始的、未命名的内存空间；<br>&emsp;&emsp;<br>&emsp;&emsp;② 编译器运行相应的构造函数以构造这些对象，并为其传入初始值；<br>&emsp;&emsp;<br>&emsp;&emsp;③ 对象被分配了空间并构造完成，返回一个指向该对象的指针。<br>&emsp;&emsp;<br>&emsp;&emsp;2、 delete简单数据类型默认只是调用free函数；复杂数据类型先调用析构函数再调用operator delete；针对简单类型，delete和delete[]等同。假设指针p指向new[]分配的内存。因为要4字节存储数组大小，实际分配的内存地址为[p-4]，系统记录的也是这个地址。delete[]实际释放的就是p-4指向的内存。而delete会直接释放p指向的内存，这个内存根本没有被系统记录，所以会崩溃。<br>&emsp;&emsp;<br>&emsp;&emsp;3、 需要在 new [] 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，就知道了需要调用析构函数多少次了。<hr><hr>8、delete p、delete [] p、allocator都有什么作用？ 阿秀 53<hr>1、 动态数组管理new一个数组时，[]中必须是一个整数，但是不一定是常量整数，普通数组必须是一个常量整数；<br>&emsp;&emsp;<br>&emsp;&emsp;2、 new动态数组返回的并不是数组类型，而是一个元素类型的指针；<br>&emsp;&emsp;<br>&emsp;&emsp;3、 delete[]时，数组中的元素按<font color=#1DB100>逆序</font>的顺序进行销毁；<br>&emsp;&emsp;<br>&emsp;&emsp;4、 new在内存分配上面有一些局限性，new的机制是将内存分配和对象构造组合在一起，同样的，delete也是将对象析构和内存释放组合在一起的。allocator将这两部分分开进行，allocator申请一部分内存，不进行初始化对象，只有当需要的时候才进行初始化操作。<hr><hr>8、malloc、realloc、calloc的区别 阿秀53<hr>calloc(n, sizeof(...)) 分配空间, 初始化为 0<br>&emsp;&emsp;realloc(*p, size) 分配额外的空间, 扩充容量? 能否执行成功?<br>&emsp;&emsp;---<br>&emsp;&emsp;malloc<br>&emsp;&emsp;<font color=#5E3563>void</font><font color=#519696>*</font> <font color=#AA5925>malloc</font>(<font color=#5E3563>unsigned</font> <font color=#5E3563>int</font> num_size);<br>&emsp;&emsp;<font color=#5E3563>int</font> <font color=#519696>*</font>p <font color=#519696>=</font> <font color=#AA5925>malloc</font>(<font color=#AA5925>20</font><font color=#519696>*</font><font color=#5E3563>sizeof</font>(<font color=#5E3563>int</font>));申请<font color=#AA5925>20</font>个<font color=#5E3563>int</font>类型的空间；<br>&emsp;&emsp;<br>&emsp;&emsp;calloc函数<br>&emsp;&emsp;<font color=#5E3563>void</font><font color=#519696>*</font> <font color=#AA5925>calloc</font>(size_t n,size_t size);<br>&emsp;&emsp;<font color=#5E3563>int</font> <font color=#519696>*</font>p <font color=#519696>=</font> <font color=#AA5925>calloc</font>(<font color=#AA5925>20</font>, <font color=#5E3563>sizeof</font>(<font color=#5E3563>int</font>));<br>&emsp;&emsp;省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的<br>&emsp;&emsp;<br>&emsp;&emsp;realloc函数<br>&emsp;&emsp;<font color=#5E3563>void</font> <font color=#AA5925>realloc</font>(<font color=#5E3563>void</font> <font color=#519696>*</font>p, size_t new_size);<br>&emsp;&emsp;给动态分配的空间分配额外的空间，用于扩充容量。<br>&emsp;&emsp;<hr><hr>8、new / delete 与 malloc / free的异同<hr>相同点<br>&emsp;&emsp;<br>&emsp;&emsp;- 都可用于内存的动态申请和释放<br>&emsp;&emsp;<br>&emsp;&emsp;不同点<br>&emsp;&emsp;<br>&emsp;&emsp;- 前者是C++运算符，后者是C/C++语言标准库函数<br>&emsp;&emsp;- new自动计算要分配的空间大小，malloc需要手工计算<br>&emsp;&emsp;- new是类型安全的，malloc不是。例如：<br>&emsp;&emsp;<br>&emsp;&emsp;int *p = new float[2]; //编译错误<br>&emsp;&emsp;int *p = (int*)malloc(2 * sizeof(double));//编译无错误<br>&emsp;&emsp;<br>&emsp;&emsp;- new调用名为operator new的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存。后者均没有相关调用<br>&emsp;&emsp;- 后者需要库文件支持，前者不用<br>&emsp;&emsp;- new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象<hr><hr>8、new和malloc的区别<hr>1、 new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持；<br>&emsp;&emsp;<br>&emsp;&emsp;2、 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。<br>&emsp;&emsp;<br>&emsp;&emsp;3、 new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。<br>&emsp;&emsp;<br>&emsp;&emsp;4、 new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。<br>&emsp;&emsp;<br>&emsp;&emsp;5、 new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。<hr><hr>9.60、C++中新增了<font color=#FEAE00>string</font>，它与C语言中的 char *有什么区别吗？它是如何实现的？<hr>动态扩容, 没有非法访问, O(1) 访问长度和容量, <br>&emsp;&emsp;---<br>&emsp;&emsp;string继承自basic_string,其实是对char*进行了封装，封装的string包含了<font color=#1DB100>char*</font><font color=#1DB100>数组，容量，长度</font>等等属性。<br>&emsp;&emsp;<br>&emsp;&emsp;string可以进行<font color=#1DB100>动态扩展</font>，在每次扩展的时候另外申请一块原空间大小<font color=#1DB100>两倍的空间</font>（2^n），然后将原字符串拷贝过去，并加上新增的内容。<hr><hr>C++ 11 新特性<hr><hr>C++ lambda函数怎么用? 怎么实现?<hr><hr>c++ 中 vector 是怎么实现的<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;todo <hr><hr>c++ 如何实现一个接口? <br>&emsp;&emsp;<br>&emsp;&emsp;todo <hr>抽象类 + 纯虚函数<hr><hr>g++中-L,-I,-l的作用，有什么区别。-l指定链接库的时候，如何a库依赖b库，是否a库必须放在b库前面<hr><hr>gdb的指令<br>&emsp;&emsp;<br>&emsp;&emsp;todo<hr><hr>list的实现? vector和list的区别?<hr><hr>move怎么用？<hr><hr>sharedptr 和 uniqueptr 智能指针<hr><hr>td 1.61、什么是内存泄露，如何检测与避免<hr>内存泄露<br>&emsp;&emsp;<br>&emsp;&emsp;一般我们常说的内存泄漏是指<font color=#1DB100>堆内存的泄漏</font>。堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。应用程序般使用malloc,、realloc、 new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了<br>&emsp;&emsp;<br>&emsp;&emsp;避免内存泄露的几种方式<br>&emsp;&emsp;<br>&emsp;&emsp;- <font color=#1DB100>计数法：使用</font><font color=#1DB100>new</font><font color=#1DB100>或者</font><font color=#1DB100>malloc</font><font color=#1DB100>时，让该数</font><font color=#1DB100>+1</font>，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露<br>&emsp;&emsp;- 一定要将<font color=#1DB100>基类的析构函数声明为</font><font color=#1DB100>虚函数</font><br>&emsp;&emsp;- 对象数组的释放一定要用delete []<br>&emsp;&emsp;- 有new就有delete，有malloc就有free，保证它们一定成对出现<br>&emsp;&emsp;<br>&emsp;&emsp;检测工具<br>&emsp;&emsp;<br>&emsp;&emsp;- Linux下可以使用<font color=#1DB100>Valgrind</font><font color=#1DB100>工具</font><br>&emsp;&emsp;- Windows下可以使用CRT库<hr><hr>td 3.77、C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？<hr>1) 指针参数传递本质上是值传递，它所传递的是一个地址值。<br>&emsp;&emsp;<br>&emsp;&emsp;值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。<br>&emsp;&emsp;<br>&emsp;&emsp;值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。<br>&emsp;&emsp;<br>&emsp;&emsp;2) 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。<br>&emsp;&emsp;<br>&emsp;&emsp;被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。<br>&emsp;&emsp;<br>&emsp;&emsp;因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。<br>&emsp;&emsp;<br>&emsp;&emsp;3) 引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。<br>&emsp;&emsp;<br>&emsp;&emsp;而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。<br>&emsp;&emsp;<br>&emsp;&emsp;4) 从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。<br>&emsp;&emsp;<br>&emsp;&emsp;指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。<br>&emsp;&emsp;<br>&emsp;&emsp;符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。<hr><hr>td 8、malloc与free的实现原理？ 阿秀 56<hr>1、 在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk、mmap、，munmap这些系统调用实现的;<br>&emsp;&emsp;<br>&emsp;&emsp;2、 brk是将数据段(.data)的最高地址指针_edata往高地址推,mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系；<br>&emsp;&emsp;<br>&emsp;&emsp;3、 malloc小于128k的内存，使用brk分配内存，将_edata往高地址推；malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配；brk分配的内存需要等到高地址内存释放以后才能释放，而mmap分配的内存可以单独释放。当最高地址空间的空闲内存超过128K（可由M_TRIM_THRESHOLD选项调节）时，执行内存紧缩操作（trim）。在上一个步骤free的时候，发现最高地址空闲内存超过128K，于是内存紧缩。<br>&emsp;&emsp;<br>&emsp;&emsp;4、 malloc是从堆里面申请内存，也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。<hr><hr>td protected是什么<hr><hr>td1.42、C++的异常处理的方法<hr>在程序执行过程中，由于程序员的疏忽或是系统资源紧张等因素都有<font color=#1DB100>可能导致异常</font>，任何程序都无法保证绝对的稳定，常见的异常有：<br>&emsp;&emsp;<br>&emsp;&emsp;- 数组下标越界<br>&emsp;&emsp;- 除法计算时除数为0<br>&emsp;&emsp;- 动态分配空间时空间不足<br>&emsp;&emsp;- ...<br>&emsp;&emsp;<br>&emsp;&emsp;如果不及时对这些异常进行处理，程序多数情况下都会崩溃。<br>&emsp;&emsp;<br>&emsp;&emsp;（1）<font color=#1DB100>try</font><font color=#1DB100>、</font><font color=#1DB100>throw</font><font color=#1DB100>和</font><font color=#1DB100>catch</font>关键字<br>&emsp;&emsp;<br>&emsp;&emsp;C++中的异常处理机制主要使用try、throw和catch三个关键字，其在程序中的用法如下：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;#include <iostream><br>&emsp;&emsp;using namespace std;<br>&emsp;&emsp;int main()<br>&emsp;&emsp;{<br>&emsp;&emsp;    double m = 1, n = 0;<br>&emsp;&emsp;    <font color=#1DB100>try {</font><br>&emsp;&emsp;        cout << "before dividing." << endl;<br>&emsp;&emsp;        if (n == 0)<br>&emsp;&emsp;            <font color=#1DB100>throw - 1;  </font>//抛出int型异常<br>&emsp;&emsp;        else if (m == 0)<br>&emsp;&emsp;            throw - 1.0;  //拋出 double 型异常<br>&emsp;&emsp;        else<br>&emsp;&emsp;            cout << m / n << endl;<br>&emsp;&emsp;        cout << "after dividing." << endl;<br>&emsp;&emsp;    }<br>&emsp;&emsp;   <font color=#1DB100> catch (double d) {</font><br>&emsp;&emsp;        cout << "catch (double)" << d << endl;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    <font color=#1DB100>catch (...) {</font><br>&emsp;&emsp;        cout << "catch (...)" << endl;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    cout << "finished" << endl;<br>&emsp;&emsp;    return 0;<br>&emsp;&emsp;}<br>&emsp;&emsp;//运行结果<br>&emsp;&emsp;//before dividing.<br>&emsp;&emsp;//catch (...)<br>&emsp;&emsp;//finished<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#929292>代码中，对两个数进行除法计算，其中除数为</font><font color=#929292>0</font><font color=#929292>。可以看到以上三个关键字，程序的执行流程是先执行</font><font color=#929292>try</font><font color=#929292>包裹的语句块，如果执行过程中没有异常发生，则不会进入任何</font><font color=#929292>catch</font><font color=#929292>包裹的语句块，如果发生异常，则使用</font><font color=#929292>throw</font><font color=#929292>进行异常抛出，再由</font><font color=#929292>catch</font><font color=#929292>进行捕获，</font><font color=#929292>throw</font><font color=#929292>可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常</font><font color=#929292>class</font>。<font color=#1DB100>catch</font><font color=#1DB100>根据</font><font color=#1DB100>throw</font><font color=#1DB100>抛出的数据类型进行精确捕获（不会出现类型转换）</font>，如果匹配不到就直接报错，可以使用catch(...)的方式捕获任何异常（不推荐）。当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。<br>&emsp;&emsp;<br>&emsp;&emsp;（2）函数的<font color=#1DB100>异常声明列表</font><br>&emsp;&emsp;<br>&emsp;&emsp;有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，写法如下：<br>&emsp;&emsp;<br>&emsp;&emsp;```text<br>&emsp;&emsp;<font color=#1DB100>int fun() throw(int,double,A,B,C){...};</font><br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;这种写法表名函数可能会抛出int,double型或者A、B、C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常<br>&emsp;&emsp;<br>&emsp;&emsp;（3）C++标准异常类 exception<br>&emsp;&emsp;<br>&emsp;&emsp;C++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的，如下图所示<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212342667.png)<br>&emsp;&emsp;<br>&emsp;&emsp;- bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常，例如：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;#include <iostream><br>&emsp;&emsp;#include <typeinfo><br>&emsp;&emsp;using namespace std;<br>&emsp;&emsp;<br>&emsp;&emsp;class A{<br>&emsp;&emsp;public:<br>&emsp;&emsp;  virtual ~A();<br>&emsp;&emsp;};<br>&emsp;&emsp; <br>&emsp;&emsp;using namespace std;<br>&emsp;&emsp;int main() {<br>&emsp;&emsp;	A* a = NULL;<br>&emsp;&emsp;	try {<br>&emsp;&emsp;  		cout << typeid(*a).name() << endl; // Error condition<br>&emsp;&emsp;  	}<br>&emsp;&emsp;	catch (bad_typeid){<br>&emsp;&emsp;  		cout << "Object is NULL" << endl;<br>&emsp;&emsp;  	}<br>&emsp;&emsp;    return 0;<br>&emsp;&emsp;}<br>&emsp;&emsp;//运行结果：bject is NULL<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;- bad_cast：在用 dynamic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常<br>&emsp;&emsp;- bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常<br>&emsp;&emsp;- out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常<hr><hr>td1.76、<font color=#1DB100>方法调用</font>的原理（栈，汇编）<hr>1. 机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后恢复，以及本地存储。而为单个过程分配的那部分栈称为<font color=#1DB100>帧栈</font>；帧栈可以认为是程序栈的一段，它有两个端点，一个标识起始地址，一个标识着结束地址，两个指针结束地址指针esp，开始地址指针ebp;<br>&emsp;&emsp;2. 由一系列栈帧构成，这些栈帧对应一个过程，而且每一个栈指针+4的位置存储函数返回地址；每一个栈帧都建立在调用者的下方，当被调用者执行完毕时，这一段栈帧会被释放。由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存。如果将栈指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放了。<br>&emsp;&emsp;3. 过程实现<br>&emsp;&emsp;<br>&emsp;&emsp;① 备份原来的帧指针，调整当前的栈帧指针到栈指针位置；<br>&emsp;&emsp;<br>&emsp;&emsp;② 建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存；<br>&emsp;&emsp;<br>&emsp;&emsp;③ 使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。<br>&emsp;&emsp;<br>&emsp;&emsp;④ 恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了<br>&emsp;&emsp;<br>&emsp;&emsp;⑤ 恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了。<br>&emsp;&emsp;<br>&emsp;&emsp;⑥ 释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针，因此会采用类似下面的汇编代码处理。<br>&emsp;&emsp;<br>&emsp;&emsp;⑦ 恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域又回到了原始的位置。<br>&emsp;&emsp;<br>&emsp;&emsp;⑧ 弹出返回地址，跳出当前过程，继续执行调用者的代码。<br>&emsp;&emsp;<br>&emsp;&emsp;1. 过程调用和返回指令<br>&emsp;&emsp;<br>&emsp;&emsp;① call指令<br>&emsp;&emsp;<br>&emsp;&emsp;② leave指令<br>&emsp;&emsp;<br>&emsp;&emsp;③ ret指令<hr><hr>td2.18、a和&a有什么区别？<hr>假设数组int a[10]; int (*p)[10] = &a;其中：<br>&emsp;&emsp;<br>&emsp;&emsp;- a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。<br>&emsp;&emsp;- &a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。<br>&emsp;&emsp;- 若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。<hr><hr>td2.70、如何获得结构成员相对于结构开头的字节偏移量<hr>使用<stddef.h>头文件中的，offsetof宏。<br>&emsp;&emsp;<br>&emsp;&emsp;举个例子：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;#include <iostream><br>&emsp;&emsp;#include <stddef.h><br>&emsp;&emsp;using namespace std;<br>&emsp;&emsp;<br>&emsp;&emsp;struct  S<br>&emsp;&emsp;{<br>&emsp;&emsp;	int x;<br>&emsp;&emsp;	char y;<br>&emsp;&emsp;	int z;<br>&emsp;&emsp;	double a;<br>&emsp;&emsp;};<br>&emsp;&emsp;int main()<br>&emsp;&emsp;{<br>&emsp;&emsp;	cout << offsetof(S, x) << endl; // 0<br>&emsp;&emsp;	cout << offsetof(S, y) << endl; // 4<br>&emsp;&emsp;	cout << offsetof(S, z) << endl; // 8<br>&emsp;&emsp;	cout << offsetof(S, a) << endl; // 12<br>&emsp;&emsp;	return 0;<br>&emsp;&emsp;}<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;在Visual Studio 2019 + Win10 下的输出情况如下<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;cout << offsetof(S, x) << endl; // 0<br>&emsp;&emsp;cout << offsetof(S, y) << endl; // 4<br>&emsp;&emsp;cout << offsetof(S, z) << endl; // 8<br>&emsp;&emsp;cout << offsetof(S, a) << endl; // 16 这里是 16的位置，因为 double是8字节，需要找一个8的倍数对齐，<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;当然了，如果加上 #pragma pack(4) 指定4字节对齐方式就可以了。<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;#pragma pack(4)<br>&emsp;&emsp;struct  S<br>&emsp;&emsp;{<br>&emsp;&emsp;	int x;<br>&emsp;&emsp;	char y;<br>&emsp;&emsp;	int z;<br>&emsp;&emsp;	double a;<br>&emsp;&emsp;};<br>&emsp;&emsp;void test02()<br>&emsp;&emsp;{<br>&emsp;&emsp;cout << offsetof(S, x) << endl; // 0<br>&emsp;&emsp;cout << offsetof(S, y) << endl; // 4<br>&emsp;&emsp;cout << offsetof(S, z) << endl; // 8<br>&emsp;&emsp;cout << offsetof(S, a) << endl; // 12<br>&emsp;&emsp;｝<br>&emsp;&emsp;```<hr><hr>td2.72、引用是否能实现动态绑定，为什么可以实现？<hr>可以。<br>&emsp;&emsp;<br>&emsp;&emsp;引用在创建的时候必须初始化，在访问虚函数时，编译器会根据其所绑定的对象类型决定要调用哪个函数。注意只能调用虚函数。<br>&emsp;&emsp;<br>&emsp;&emsp;举个例子：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;#include <iostream><br>&emsp;&emsp;using namespace std;<br>&emsp;&emsp;<br>&emsp;&emsp;class Base <br>&emsp;&emsp;{<br>&emsp;&emsp;public:<br>&emsp;&emsp;	virtual void  fun()<br>&emsp;&emsp;	{<br>&emsp;&emsp;		cout << "base :: fun()" << endl;<br>&emsp;&emsp;	}<br>&emsp;&emsp;};<br>&emsp;&emsp;<br>&emsp;&emsp;class Son : public Base<br>&emsp;&emsp;{<br>&emsp;&emsp;public:<br>&emsp;&emsp;	virtual void  fun()<br>&emsp;&emsp;	{<br>&emsp;&emsp;		cout << "son :: fun()" << endl;<br>&emsp;&emsp;	}<br>&emsp;&emsp;	void func()<br>&emsp;&emsp;	{<br>&emsp;&emsp;		cout << "son :: not virtual function" <<endl;<br>&emsp;&emsp;	}<br>&emsp;&emsp;};<br>&emsp;&emsp;<br>&emsp;&emsp;int main()<br>&emsp;&emsp;{<br>&emsp;&emsp;	Son s;<br>&emsp;&emsp;	Base& b = s; // 基类类型引用绑定已经存在的Son对象，引用必须初始化<br>&emsp;&emsp;	s.fun(); //son::fun()<br>&emsp;&emsp;	b.fun(); //son :: fun()<br>&emsp;&emsp;	return 0;<br>&emsp;&emsp;}<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;需要说明的是虚函数才具有动态绑定，上面代码中，Son类中还有一个非虚函数func()，这在b对象中是无法调用的，如果使用基类指针来指向子类也是一样的。<hr><hr>td3.74、指针加减计算要注意什么？<hr>指针加减本质是对其所指地址的移动，移动的步长跟指针的类型是有关系的，因此在涉及到指针加减运算需要十分小心，加多或者减多都会导致指针指向一块未知的内存地址，如果再进行操作就会很危险。<br>&emsp;&emsp;<br>&emsp;&emsp;举个例子：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;#include <iostream><br>&emsp;&emsp;using namespace std;<br>&emsp;&emsp;<br>&emsp;&emsp;int main()<br>&emsp;&emsp;{<br>&emsp;&emsp;	int *a, *b, c;<br>&emsp;&emsp;	a = (int*)0x500;<br>&emsp;&emsp;	b = (int*)0x520;<br>&emsp;&emsp;	c = b - a;<br>&emsp;&emsp;	printf("%d\n", c); // 8<br>&emsp;&emsp;	a += 0x020;<br>&emsp;&emsp;	c = b - a;<br>&emsp;&emsp;	printf("%d\n", c); // -24<br>&emsp;&emsp;	return 0;<br>&emsp;&emsp;}<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;首先变量a和b都是以16进制的形式初始化，将它们转成10进制分别是1280（5*16^2=1280）和1312（5*16^2+2*16=1312)， 那么它们的差值为32，也就是说a和b所指向的地址之间间隔32个位，但是考虑到是int类型占4位，所以c的值为32/4=8<br>&emsp;&emsp;<br>&emsp;&emsp;a自增16进制0x20之后，其实际地址变为1280 + 2*16*4 = 1408，（因为一个int占4位，所以要乘4），这样它们的差值就变成了1312 - 1280 = -96，所以c的值就变成了-96/4 = -24<br>&emsp;&emsp;<br>&emsp;&emsp;遇到指针的计算，需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转成10进制计算，计算结果除以类型长度取得结果<hr><hr>td3.7、区别以下指针类型？ <br>&emsp;&emsp;int <font color=#1DB100>*p</font>[10]<br>&emsp;&emsp;<br>&emsp;&emsp;int (*p)[10]<br>&emsp;&emsp;<br>&emsp;&emsp;int *p(int)<br>&emsp;&emsp;<br>&emsp;&emsp;int <font color=#1DB100>(*p)</font>(int)<hr>- int *p[10]表示指针<font color=#1DB100>数组</font>，强调数组概念，是一个数组变量，<font color=#1DB100>数组大小为</font><font color=#1DB100>10</font>，数组内<font color=#1DB100>每个元素都是指向</font><font color=#1DB100>int</font><font color=#1DB100>类型的指针变量</font>。<br>&emsp;&emsp;- int (*p)[10]表示<font color=#1DB100>数组指针</font>，强调是<font color=#1DB100>指针</font>，<font color=#1DB100>只有一个变量</font>，是指针类型，不过<font color=#1DB100>指向的是一个</font><font color=#1DB100>int</font><font color=#1DB100>类型的数组</font>，这个数组大小是10。<br>&emsp;&emsp;- int *p(int)是<font color=#1DB100>函数声明</font>，函数名是p，参数是int类型的，返回值是int *类型的。<br>&emsp;&emsp;- int (*p)(int)是<font color=#1DB100>函数指针</font>，强调是指针，该<font color=#1DB100>指针指向的函数具有</font><font color=#1DB100>int</font><font color=#1DB100>类型参数</font>，并且返回值是int类型的。<hr><hr>td4.65、C++的四种强制转换reinterpret_cast/const_cast/static_cast /dynamic_cast<hr>reinterpret_cast<br>&emsp;&emsp;<br>&emsp;&emsp;reinterpret_cast<type-id> (expression)<br>&emsp;&emsp;<br>&emsp;&emsp;type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以用于类型之间进行<font color=#1DB100>强制转换</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;const_cast<br>&emsp;&emsp;<br>&emsp;&emsp;const_cast<type_id> (expression)<br>&emsp;&emsp;<br>&emsp;&emsp;该运算符用来<font color=#1DB100>修改类型的</font><font color=#1DB100>const</font>或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。用法如下：<br>&emsp;&emsp;<br>&emsp;&emsp;- 常量指针被转化成非常量的指针，并且仍然指向原来的对象<br>&emsp;&emsp;- 常量引用被转换成非常量的引用，并且仍然指向原来的对象<br>&emsp;&emsp;- const_cast一般用于修改底指针。如const char *p形式<br>&emsp;&emsp;<br>&emsp;&emsp;static_cast<br>&emsp;&emsp;<br>&emsp;&emsp;static_cast < type-id > (expression)<br>&emsp;&emsp;<br>&emsp;&emsp;该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：<br>&emsp;&emsp;<br>&emsp;&emsp;- 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换<br>&emsp;&emsp;  - 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的<br>&emsp;&emsp;  - 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的<br>&emsp;&emsp;- 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。<br>&emsp;&emsp;- 把空指针转换成目标类型的空指针<br>&emsp;&emsp;- 把任何类型的表达式转换成void类型<br>&emsp;&emsp;<br>&emsp;&emsp;注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。<br>&emsp;&emsp;<br>&emsp;&emsp;dynamic_cast<br>&emsp;&emsp;<br>&emsp;&emsp;有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全<br>&emsp;&emsp;<br>&emsp;&emsp;dynamic_cast <type-id> (expression)<br>&emsp;&emsp;<br>&emsp;&emsp;该运算符把expression转换成type-id类型的对象。type-id 必须是类的指针、类的引用或者void*<br>&emsp;&emsp;<br>&emsp;&emsp;如果 type-id 是类指针类型，那么expression也必须是一个指针，如果 type-id 是一个引用，那么 expression 也必须是一个引用<br>&emsp;&emsp;<br>&emsp;&emsp;dynamic_cast运算符可以在执行期决定真正的类型，也就是说expression必须是多态类型。如果下行转换是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果 如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）<br>&emsp;&emsp;<br>&emsp;&emsp;dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换<br>&emsp;&emsp;<br>&emsp;&emsp;在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的<br>&emsp;&emsp;<br>&emsp;&emsp;在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全<br>&emsp;&emsp;<br>&emsp;&emsp;举个例子：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;#include <bits/stdc++.h><br>&emsp;&emsp;using namespace std;<br>&emsp;&emsp;<br>&emsp;&emsp;class Base<br>&emsp;&emsp;{<br>&emsp;&emsp;public:<br>&emsp;&emsp;	Base() :b(1) {}<br>&emsp;&emsp;	virtual void fun() {};<br>&emsp;&emsp;	int b;<br>&emsp;&emsp;};<br>&emsp;&emsp;<br>&emsp;&emsp;class Son : public Base<br>&emsp;&emsp;{<br>&emsp;&emsp;public:<br>&emsp;&emsp;	Son() :d(2) {}<br>&emsp;&emsp;	int d;<br>&emsp;&emsp;};<br>&emsp;&emsp;<br>&emsp;&emsp;int main()<br>&emsp;&emsp;{<br>&emsp;&emsp;	int n = 97;<br>&emsp;&emsp;<br>&emsp;&emsp;	//reinterpret_cast<br>&emsp;&emsp;	int *p = &n;<br>&emsp;&emsp;	//以下两者效果相同<br>&emsp;&emsp;	char *c = reinterpret_cast<char*> (p); <br>&emsp;&emsp;	char *c2 =  (char*)(p);<br>&emsp;&emsp;	cout << "reinterpret_cast输出："<< *c2 << endl;<br>&emsp;&emsp;	//const_cast<br>&emsp;&emsp;	const int *p2 = &n;<br>&emsp;&emsp;	int *p3 = const_cast<int*>(p2);<br>&emsp;&emsp;	*p3 = 100;<br>&emsp;&emsp;	cout << "const_cast输出：" << *p3 << endl;<br>&emsp;&emsp;	<br>&emsp;&emsp;	Base* b1 = new Son;<br>&emsp;&emsp;	Base* b2 = new Base;<br>&emsp;&emsp;<br>&emsp;&emsp;	//static_cast<br>&emsp;&emsp;	Son* s1 = static_cast<Son*>(b1); //同类型转换<br>&emsp;&emsp;	Son* s2 = static_cast<Son*>(b2); //下行转换，不安全<br>&emsp;&emsp;	cout << "static_cast输出："<< endl;<br>&emsp;&emsp;	cout << s1->d << endl;<br>&emsp;&emsp;	cout << s2->d << endl; //下行转换，原先父对象没有d成员，输出垃圾值<br>&emsp;&emsp;<br>&emsp;&emsp;	//dynamic_cast<br>&emsp;&emsp;	Son* s3 = dynamic_cast<Son*>(b1); //同类型转换<br>&emsp;&emsp;	Son* s4 = dynamic_cast<Son*>(b2); //下行转换，安全<br>&emsp;&emsp;	cout << "dynamic_cast输出：" << endl;<br>&emsp;&emsp;	cout << s3->d << endl;<br>&emsp;&emsp;	if(s4 == nullptr)<br>&emsp;&emsp;		cout << "s4指针为nullptr" << endl;<br>&emsp;&emsp;	else<br>&emsp;&emsp;		cout << s4->d << endl;<br>&emsp;&emsp;	<br>&emsp;&emsp;	<br>&emsp;&emsp;	return 0;<br>&emsp;&emsp;}<br>&emsp;&emsp;//输出结果<br>&emsp;&emsp;//reinterpret_cast输出：a<br>&emsp;&emsp;//const_cast输出：100<br>&emsp;&emsp;//static_cast输出：<br>&emsp;&emsp;//2<br>&emsp;&emsp;//-33686019<br>&emsp;&emsp;//dynamic_cast输出：<br>&emsp;&emsp;//2<br>&emsp;&emsp;//s4指针为nullptr<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;从输出结果可以看出，在进行下行转换时，dynamic_cast安全的，如果下行转换不安全的话其会返回空指针，这样在进行操作的时候可以预先判断。而使用static_cast下行转换存在不安全的情况也可以转换成功，但是直接使用转换后的对象进行操作容易造成错误。<hr><hr>td6.28、拷贝初始化和直接初始化<hr>- 当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。举例如下<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;string str1("I am a string");//语句1 直接初始化<br>&emsp;&emsp;string str2(str1);//语句2 直接初始化，str1是已经存在的对象，直接调用拷贝构造函数对str2进行初始化<br>&emsp;&emsp;string str3 = "I am a string";//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3<br>&emsp;&emsp;string str4 = str1;//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;- 为了提高效率，允许编译器跳过创建临时对象这一步，直接调用构造函数构造要创建的对象，这样就完全等价于直接初始化了<br>&emsp;&emsp;<br>&emsp;&emsp;  （语句1和语句3等价），但是需要辨别两种情况。<br>&emsp;&emsp;<br>&emsp;&emsp;  - 当拷贝构造函数为private时：语句3和语句4在编译时会报错<br>&emsp;&emsp;  - 使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错<hr><hr>td6.64、成员初始化列表的概念，为什么用它会快一些？<hr>成员初始化列表的概念<br>&emsp;&emsp;<br>&emsp;&emsp;在类的构造函数中，不在函数体内对成员变量赋值，而是在构造函数的花括号前面使用冒号和初始化列表赋值<br>&emsp;&emsp;<br>&emsp;&emsp;效率<br>&emsp;&emsp;<br>&emsp;&emsp;用初始化列表会快一些的原因是，对于类型，它少了一次调用构造函数的过程，而在函数体中赋值则会多一次调用。而对于内置数据类型则没有差别。举个例子：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;#include <iostream><br>&emsp;&emsp;using namespace std;<br>&emsp;&emsp;class A<br>&emsp;&emsp;{<br>&emsp;&emsp;public:<br>&emsp;&emsp;    A()<br>&emsp;&emsp;    {<br>&emsp;&emsp;        cout << "默认构造函数A()" << endl;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    A(int a)<br>&emsp;&emsp;    {<br>&emsp;&emsp;        value = a;<br>&emsp;&emsp;        cout << "A(int "<<value<<")" << endl;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    A(const A& a)<br>&emsp;&emsp;    {<br>&emsp;&emsp;        value = a.value;<br>&emsp;&emsp;        cout << "拷贝构造函数A(A& a):  "<<value << endl;<br>&emsp;&emsp;    }<br>&emsp;&emsp;    int value;<br>&emsp;&emsp;};<br>&emsp;&emsp;<br>&emsp;&emsp;class B<br>&emsp;&emsp;{<br>&emsp;&emsp;public:<br>&emsp;&emsp;    B() : a(1)<br>&emsp;&emsp;    {<br>&emsp;&emsp;        b = A(2);<br>&emsp;&emsp;    }<br>&emsp;&emsp;    A a;<br>&emsp;&emsp;    A b;<br>&emsp;&emsp;};<br>&emsp;&emsp;int main()<br>&emsp;&emsp;{<br>&emsp;&emsp;    B b;<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;//输出结果：<br>&emsp;&emsp;//A(int 1)<br>&emsp;&emsp;//默认构造函数A()<br>&emsp;&emsp;//A(int 2)<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;从代码运行结果可以看出，在构造函数体内部初始化的对象b多了一次构造函数的调用过程，而对象a则没有。由于对象成员变量的初始化动作发生在进入构造函数之前，对于内置类型没什么影响，但如果有些成员是类，那么在进入构造函数之前，会先调用一次默认构造函数，进入构造函数后所做的事其实是一次赋值操作(对象已存在)，所以如果是在构造函数体内进行赋值的话，等于是一次默认构造加一次赋值，而初始化列表只做一次赋值操作。<hr><hr>td7.78、类如何实现只能静态分配和只能动态分配<hr>1. 前者是把new、delete运算符重载为private属性。后者是把构造、析构函数设为protected属性，再用子类来动态创建<br>&emsp;&emsp;2. 建立类的对象有两种方式：<br>&emsp;&emsp;<br>&emsp;&emsp;① 静态建立，静态建立一个类对象，就是由编译器为对象在栈空间中分配内存；<br>&emsp;&emsp;<br>&emsp;&emsp;② 动态建立，A *p = new A();动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象；<br>&emsp;&emsp;<br>&emsp;&emsp;3. 只有使用new运算符，对象才会被建立在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上，可以将new运算符设为私有。<hr><hr>td7.80、 继承机制中<font color=#1DB100>对象</font>之间如何<font color=#1DB100>转换</font>？指针和引用之间如何转换？<hr>- <font color=#1DB100>向上类型转换</font><br>&emsp;&emsp;<br>&emsp;&emsp;将派生类指针或引用<font color=#1DB100>转换为基类的指针或引用</font>被称为向上类型转换，向上类型转换会<font color=#1DB100>自动进行</font>，而且向上类型转换是安全的。<br>&emsp;&emsp;<br>&emsp;&emsp;- <font color=#1DB100>向下类型转换</font><br>&emsp;&emsp;<br>&emsp;&emsp;将基类指针或引用<font color=#1DB100>转换为派生类指针</font>或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时<font color=#1DB100>必须加动态类型识别技术</font>。<font color=#1DB100>RTTI</font><font color=#1DB100>技术，用</font><font color=#1DB100>dynamic_cast</font>进行向下类型转换。<hr><hr>td9、C++中有几种类型的new - 阿秀41<hr>在C++中，new有三种典型的使用方法：plain new，nothrow new和placement new<br>&emsp;&emsp;<br>&emsp;&emsp;（1）<font color=#1DB100>plain new</font><br>&emsp;&emsp;<br>&emsp;&emsp;言下之意就是普通的new，就是我们常用的new，在C++中定义如下：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;void* operator new(stdsize_t) throw(stdbad_alloc);<br>&emsp;&emsp;void operator delete(void *) throw();<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;因此plain new在<font color=#1DB100>空间分配失败的情况下</font>，抛出异常<font color=#1DB100>std::bad_alloc</font>而不是返回NULL，因此通过判断返回值是否为NULL是徒劳的，举个例子：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;int main()<br>&emsp;&emsp;{<br>&emsp;&emsp;	try<br>&emsp;&emsp;	{<br>&emsp;&emsp;		char *p = new char[10e11];<br>&emsp;&emsp;		delete p;<br>&emsp;&emsp;	}<br>&emsp;&emsp;	<font color=#1DB100>catch (const std::bad_alloc &ex)</font><br>&emsp;&emsp;	{<br>&emsp;&emsp;		cout << ex.what() << endl;<br>&emsp;&emsp;	}<br>&emsp;&emsp;	return 0;<br>&emsp;&emsp;}<br>&emsp;&emsp;//执行结果：bad allocation<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;（2）<font color=#1DB100>nothrow new</font><br>&emsp;&emsp;<br>&emsp;&emsp;nothrow new在空间分配失败的情况下是不抛出异常，而<font color=#1DB100>是返回</font><font color=#1DB100>NULL</font>，定义如下：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;void * operator new(stdsize_t,const stdnothrow_t&) throw();<br>&emsp;&emsp;void operator delete(void*) throw();<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;举个例子：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;#include <iostream><br>&emsp;&emsp;#include <string><br>&emsp;&emsp;using namespace std;<br>&emsp;&emsp;<br>&emsp;&emsp;int main()<br>&emsp;&emsp;{<br>&emsp;&emsp;	<font color=#1DB100>char *p = new(nothrow) char</font><font color=#1DB100>[</font><font color=#1DB100>10e11</font><font color=#1DB100>]</font><font color=#1DB100>;</font><br>&emsp;&emsp;	if (<font color=#1DB100>p == NULL) </font><br>&emsp;&emsp;	{<br>&emsp;&emsp;		cout << "alloc failed" << endl;<br>&emsp;&emsp;	}<br>&emsp;&emsp;	delete p;<br>&emsp;&emsp;	return 0;<br>&emsp;&emsp;}<br>&emsp;&emsp;//运行结果：alloc failed<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;（3）<font color=#1DB100>placement new</font><br>&emsp;&emsp;<br>&emsp;&emsp;这种new允许在一块已经分配成功的内存上<font color=#1DB100>重新构造对象或对象数组</font>。placement new不用担心内存分配失败，因为它根本不分配内存，<font color=#1DB100>它做的唯一一件事情就是调用对象的构造函数</font>。定义如下：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;void* operator new(size_t,void*);<br>&emsp;&emsp;void operator delete(void*,void*);<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;使用placement new需要注意两点：<br>&emsp;&emsp;<br>&emsp;&emsp;- palcement new的主要用途就是<font color=#1DB100>反复使用一块较大的动态分配</font>的内存来构造不同类型的对象或者他们的数组<br>&emsp;&emsp;- placement new构造起来的对象数组，要<font color=#1DB100>显式的调用他们的析构函数来销毁</font>（析构函数并不释放对象的内存），千万不要使用delete，这是因为placement new构造起来的<font color=#1DB100>对象或数组大小并不一定等于原来分配的内存大小</font>，使用<font color=#1DB100>delete</font><font color=#1DB100>会造成内存泄漏</font>或者之后释放内存时出现运行时错误。<br>&emsp;&emsp;<br>&emsp;&emsp;举个例子：<br>&emsp;&emsp;<br>&emsp;&emsp;```cpp<br>&emsp;&emsp;#include <iostream><br>&emsp;&emsp;#include <string><br>&emsp;&emsp;using namespace std;<br>&emsp;&emsp;class ADT{<br>&emsp;&emsp;	int i;<br>&emsp;&emsp;	int j;<br>&emsp;&emsp;public:<br>&emsp;&emsp;	ADT(){<br>&emsp;&emsp;		i = 10;<br>&emsp;&emsp;		j = 100;<br>&emsp;&emsp;		cout << "ADT construct i=" << i << "j="<<j <<endl;<br>&emsp;&emsp;	}<br>&emsp;&emsp;	~ADT(){<br>&emsp;&emsp;		cout << "ADT destruct" << endl;<br>&emsp;&emsp;	}<br>&emsp;&emsp;};<br>&emsp;&emsp;int main()<br>&emsp;&emsp;{<br>&emsp;&emsp;	char *p = new(nothrow) char[sizeof ADT + 1];<br>&emsp;&emsp;	if (p == NULL) {<br>&emsp;&emsp;		cout << "alloc failed" << endl;<br>&emsp;&emsp;	}<br>&emsp;&emsp;	<font color=#1DB100>ADT *q = new(p) ADT; </font> //placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可<br>&emsp;&emsp;	//delete q;//错误!不能在此处调用delete q;<br>&emsp;&emsp;	<font color=#1DB100>q->ADT::~ADT();/</font>/显示调用析构函数<br>&emsp;&emsp;	<font color=#1DB100>delete</font><font color=#1DB100>[]</font><font color=#1DB100> p; // ? </font><font color=#1DB100>是应该这样写</font>么?<br>&emsp;&emsp;	return 0;<br>&emsp;&emsp;}<br>&emsp;&emsp;//输出结果：<br>&emsp;&emsp;//ADT construct i=10j=100<br>&emsp;&emsp;//ADT destruct<br>&emsp;&emsp; <br>&emsp;&emsp;```<hr><hr>td后面反一下2.17、<font color=#FEAE00>常量指针</font>和<font color=#FEAE00>指针常量</font>区别？<hr>- <font color=#FEAE00>指针常量</font><font color=#FEAE00> </font><font color=#FEAE00>指针</font><font color=#FEAE00>to</font><font color=#FEAE00>常量</font><br>&emsp;&emsp;- 是一个指针，读成常量的指针，指向一个只读变量，也就是后面所指明的int const 和 const int，都是一个常量，可以写作int const *p或const int *p。<br>&emsp;&emsp;- <font color=#FEAE00>常量指针</font><font color=#FEAE00> </font><font color=#FEAE00>常量</font><font color=#FEAE00> to </font><font color=#FEAE00>指针</font><br>&emsp;&emsp;- 是一个不能给改变指向的指针。指针是个常量，必须初始化，一旦初始化完成，它的值（也就是存放在指针中的地址）就不能在改变了，即不能中途改变指向，如int *const p。<hr><hr>todo c++中那个数组, 有的时候用 ++ 会跳到下一个相同大小的数组? 那个是啥? <br>&emsp;&emsp;<hr>好像是类似 *p[10] 这种东西? <br>&emsp;&emsp;或者直接把括号已经扩上了<hr><hr>treemap的实现原理? <br>&emsp;&emsp;<br>&emsp;&emsp;todo 这是啥?<hr><hr>volatile 和 sychronized 的区别<hr><hr>一个类创建多个对象有几个虚函数表<hr><hr>函数重载底层原理<hr><hr>单例模式?<hr><hr>各个类型的占用大小 64位机子<br>&emsp;&emsp;double <br>&emsp;&emsp;float<br>&emsp;&emsp;short<br>&emsp;&emsp;long <br>&emsp;&emsp;long long <hr>占用大小记得 float == int == long = 4<br>&emsp;&emsp;double == long long = 8<br>&emsp;&emsp;64位上 long 是 8 其他不变 <br>&emsp;&emsp;<br>&emsp;&emsp;char（1），int（4），float（4），double（8），long（8）<hr><hr>左值和右值引用<hr><hr>常成员函数的是声明方式<br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr>常成员函数: void print() const<br>&emsp;&emsp;<br>&emsp;&emsp;const void print(const int num) const <br>&emsp;&emsp;第一个const修饰返回类型 第二个const修饰参数 第三个const修饰调用对象<br>&emsp;&emsp;<br>&emsp;&emsp;没有 void const 这种表述方式<hr><hr>析构函数可以是虚函数么?<hr><hr>知道JeMalloc, tcMalloc, ptMalloc么? <hr><hr>红黑树的实现<br>&emsp;&emsp;<br>&emsp;&emsp;todo<hr><hr>纯虚函数的作用是什么?<hr><hr>虚函数 <br>&emsp;&emsp;todo <hr>虚函数的调用关系，this->vptr->ctable->virtual function<hr><hr>虚函数是如何实现的?<hr><hr>设计模式三大类<hr><hr>设计模式都有哪些?<hr><hr>说一下C++的多态?<hr><hr>说一说工厂模式?<hr><hr>￼<br>&emsp;&emsp;<hr>\065表示一个char 大小的数字<br>&emsp;&emsp;占用一个字符 ... <br>&emsp;&emsp;中间插入结束符可以: <br>&emsp;&emsp;\000  或者 \x00<hr><hr>￼<br>&emsp;&emsp;<hr>*p 应该是个 char* 的类型了是吧<hr><hr>￼<br>&emsp;&emsp;<hr>实际上是没有变过的.. <br>&emsp;&emsp;￼<br>&emsp;&emsp;<hr><hr> 进程::进程、线程和协程的区别和联系<hr>1、进程是资源调度的基本单位，运行一个可执行程序会创建一个或多个进程，进程就是运行起来的可执行程序<br>&emsp;&emsp;<br>&emsp;&emsp;2、线程是程序执行的基本单位，是轻量级的进程。每个进程中都有唯一的主线程，且只能有一个，主线程和进程是相互依存的关系，主线程结束进程也会结束。多提一句：协程是用户态的轻量级线程，线程内部调度的基本单位<br>&emsp;&emsp;<br>&emsp;&emsp;| 进程  | 线程  | 协程  |  |<br>&emsp;&emsp;| -------- | ------------------------------------------------------------ | -------------------------------------------------- | ------------------------------------------------------------ |<br>&emsp;&emsp;| 定义  | 资源分配和拥有的基本单位  | 程序执行的基本单位  | 用户态的轻量级线程，线程内部调度的基本单位  |<br>&emsp;&emsp;| 切换情况 | 进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置 | 保存和设置程序计数器、少量寄存器和栈的内容  | 先将寄存器上下文和栈保存，等切换回来的时候再进行恢复  |<br>&emsp;&emsp;| 切换者  | 操作系统  | 操作系统  | 用户  |<br>&emsp;&emsp;| 切换过程 | 用户态->内核态->用户态  | 用户态->内核态->用户态  | 用户态(没有陷入内核)  |<br>&emsp;&emsp;|调用栈|内核栈| 内核栈 | 用户栈|<br>&emsp;&emsp;| 拥有资源 | CPU资源、内存资源、文件资源和句柄等  | 程序计数器、寄存器、栈和状态字  | 拥有自己的寄存器上下文和栈  |<br>&emsp;&emsp;| 并发性  | 不同进程之间切换实现并发，各自占有CPU实现并行  | 一个进程内部的多个线程并发执行  | 同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理 |<br>&emsp;&emsp;| 系统开销 | 切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大 | 切换时只需保存和设置少量寄存器内容，因此开销很小  | 直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快 |<br>&emsp;&emsp;| 通信方面 | 进程间通信需要借助操作系统  | 线程间可以直接读写进程数据段(如全局变量)来进行通信 | 共享内存、消息队列  |<hr><hr>0.2.目录<br>&emsp;&emsp;堆栈--分布--交换--虚拟--gc<hr><hr>0.3目录<br>&emsp;&emsp;并发<br>&emsp;&emsp;调度<br>&emsp;&emsp;进程<br>&emsp;&emsp;死锁<br>&emsp;&emsp;通信<hr><hr>2.1 CPU 是如何执行程序的?<hr>2.1 CPU 是如何执行程序的？<br>&emsp;&emsp;代码写了那么多，你知道 <font color=#4D647F>a = 1 + 2</font> 这条代码是怎么被 CPU 执行的吗？<br>&emsp;&emsp;软件用了那么多，你知道软件的 32 位和 64 位之间的区别吗？再来 32 位的操作系统可以运行在 64 位的电脑上吗？64 位的操作系统可以运行在 32 位的电脑上吗？如果不行，原因是什么？<br>&emsp;&emsp;CPU 看了那么多，我们都知道 CPU 通常分为 32 位和 64 位，你知道 64 位相比 32 位 CPU 的优势在哪吗？64 位 CPU 的计算性能一定比 32 位 CPU 高很多吗？<br>&emsp;&emsp;不知道也不用慌张，接下来就循序渐进的、一层一层的攻破这些问题。<br>&emsp;&emsp;￼<hr><hr>2.2 总结<hr>各种存储器之间的关系，可以用我们在图书馆学习这个场景来理解。<br>&emsp;&emsp;CPU 可以比喻成我们的大脑，我们当前正在思考和处理的知识的过程，就好比 CPU 中的<font color=#374EF4>寄存器</font>处理数据的过程，速度极快，但是容量很小。而 CPU 中的 <font color=#374EF4>L1-L3 Cache</font> 好比我们大脑中的短期记忆和长期记忆，需要小小花费点时间来调取数据并处理。<br>&emsp;&emsp;我们面前的桌子就相当于<font color=#374EF4>内存</font>，能放下更多的书（数据），但是找起来和看起来就要花费一些时间，相比 CPU Cache 慢不少。而图书馆的书架相当于<font color=#374EF4>硬盘</font>，能放下比内存更多的数据，但找起来就更费时间了，可以说是最慢的存储器设备了。<br>&emsp;&emsp;从 寄存器、CPU Cache，到内存、硬盘，这样一层层下来的存储器，访问速度越来越慢，存储容量越来越大，价格也越来越便宜，而且每个存储器只和相邻的一层存储器设备打交道，于是这样就形成了存储器的层次结构。<br>&emsp;&emsp;再来回答，开头的问题：那机械硬盘、固态硬盘、内存这三个存储器，到底和 <font color=#4D647F>CPU L1 Cache</font> 相比速度差多少倍呢？<br>&emsp;&emsp;CPU L1 Cache 随机访问延时是 1 纳秒，内存则是 100 纳秒，所以 <font color=#374EF4>CPU L1 Cache </font><font color=#374EF4>比内存快</font><font color=#374EF4> </font><font color=#4D647F>100</font><font color=#374EF4> </font><font color=#374EF4>倍左右</font>。<br>&emsp;&emsp;SSD 随机访问延时是 150 微秒，所以 <font color=#374EF4>CPU L1 Cache </font><font color=#374EF4>比</font><font color=#374EF4> SSD </font><font color=#374EF4>快</font><font color=#374EF4> </font><font color=#4D647F>150000</font><font color=#374EF4> </font><font color=#374EF4>倍左右</font>。<br>&emsp;&emsp;最慢的机械硬盘随机访问延时已经高达 10 毫秒，我们来看看机械硬盘到底有多「龟速」：<br>&emsp;&emsp;<font color=#374EF4>	•	</font><font color=#374EF4>SSD </font><font color=#374EF4>比机械硬盘快</font><font color=#374EF4> 70 </font><font color=#374EF4>倍左右；</font><br>&emsp;&emsp;<font color=#374EF4>	•	</font><font color=#374EF4>内存比机械硬盘快</font><font color=#374EF4> 100000 </font><font color=#374EF4>倍左右；</font><br>&emsp;&emsp;<font color=#374EF4>	•	</font><font color=#374EF4>CPU L1 Cache </font><font color=#374EF4>比机械硬盘快</font><font color=#374EF4> 10000000 </font><font color=#374EF4>倍左右；</font><br>&emsp;&emsp;我们把上述的时间比例差异放大后，就能非常直观感受到它们的性能差异了。如果 CPU 访问 L1 Cache 的缓存时间是 1 秒，那访问内存则需要大约 2 分钟，随机访问 SSD 里的数据则需要 1.7 天，访问机械硬盘那更久，长达近 4 个月。<br>&emsp;&emsp;可以发现，不同的存储器之间性能差距很大，构造存储器分级很有意义，分级的目的是要构造<font color=#374EF4>缓存</font>体系。<hr><hr>2.2 磁盘比内存慢几万倍？<hr>大家如果想自己组装电脑的话，肯定需要购买一个 CPU，但是存储器方面的设备，分类比较多，那我们肯定不能只买一种存储器，比如你除了要买内存，还要买硬盘，而针对硬盘我们还可以选择是固态硬盘还是机械硬盘。<br>&emsp;&emsp;相信大家都知道内存和硬盘都属于计算机的存储设备，断电后内存的数据是会丢失的，而硬盘则不会，因为硬盘是持久化存储设备，同时也是一个 I/O 设备。<br>&emsp;&emsp;但其实 CPU 内部也有存储数据的组件，这个应该比较少人注意到，比如<font color=#374EF4>寄存器、</font><font color=#374EF4>CPU L1/L2/L3 Cache</font> 也都是属于存储设备，只不过它们能存储的数据非常小，但是它们因为靠近 CPU 核心，所以访问速度都非常快，快过硬盘好几个数量级别。<br>&emsp;&emsp;问题来了，<font color=#374EF4>那机械硬盘、固态硬盘、内存这三个存储器，到底和</font><font color=#374EF4> CPU L1 Cache </font><font color=#374EF4>相比速度差多少倍呢？</font><br>&emsp;&emsp;在回答这个问题之前，我们先来看看「<font color=#374EF4>存储器的层次结构</font>」，好让我们对存储器设备有一个整体的认识。<br>&emsp;&emsp;￼<hr><hr>2.3 如何写出让 CPU 跑得更快的代码？<hr>代码都是由 CPU 跑起来的，我们代码写的好与坏就决定了 CPU 的执行效率，特别是在编写计算密集型的程序，更要注重 CPU 的执行效率，否则将会大大影响系统性能。<br>&emsp;&emsp;CPU 内部嵌入了 CPU Cache（高速缓存），它的存储容量很小，但是离 CPU 核心很近，所以缓存的读写速度是极快的，那么如果 CPU 运算时，直接从 CPU Cache 读取数据，而不是从内存的话，运算速度就会很快。<br>&emsp;&emsp;但是，大多数人不知道 CPU Cache 的运行机制，以至于不知道如何才能够写出能够配合 CPU Cache 工作机制的代码，一旦你掌握了它，你写代码的时候，就有新的优化思路了。<br>&emsp;&emsp;那么，接下来我们就来看看，CPU Cache 到底是什么样的，是如何工作的呢，又该如何写出让 CPU 执行更快的代码呢？<br>&emsp;&emsp;￼<hr><hr>2.4 CPU Cache 的数据写入<hr>随着时间的推移，CPU 和内存的访问性能相差越来越大，于是就在 CPU 内部嵌入了 CPU Cache（高速缓存），CPU Cache 离 CPU 核心相当近，因此它的访问速度是很快的，于是它充当了 CPU 与内存之间的缓存角色。<br>&emsp;&emsp;CPU Cache 通常分为三级缓存：L1 Cache、L2 Cache、L3 Cache，级别越低的离 CPU 核心越近，访问速度也快，但是存储容量相对就会越小。其中，在多核心的 CPU 里，每个核心都有各自的 L1/L2 Cache，而 L3 Cache 是所有核心共享使用的。<br>&emsp;&emsp;￼<br>&emsp;&emsp;我们先简单了解下 CPU Cache 的结构，CPU Cache 是由很多个 Cache Line 组成的，CPU Line 是 CPU 从内存读取数据的基本单位，而 CPU Line 是由各种标志（Tag）+ 数据块（Data Block）组成，你可以在下图清晰的看到：<br>&emsp;&emsp;￼<br>&emsp;&emsp;我们当然期望 CPU 读取数据的时候，都是尽可能地从 CPU Cache 中读取，而不是每一次都要从内存中获取数据。所以，身为程序员，我们要尽可能写出缓存命中率高的代码，这样就有效提高程序的性能，具体的做法，你可以参考我上一篇文章<font color=#5478F6>「如何写出让</font><font color=#5478F6> CPU </font><font color=#5478F6>跑得更快的代码？」</font><font color=#5478F6><br>&emsp;&emsp;</font><font color=#5478F6>(opens new window)</font><font color=#5478F6><br>&emsp;&emsp;</font>事实上，数据不光是只有读操作，还有写操作，那么如果数据写入 Cache 之后，内存与 Cache 相对应的数据将会不同，这种情况下 Cache 和内存数据都不一致了，于是我们肯定是要把 Cache 中的数据同步到内存里的。<br>&emsp;&emsp;问题来了，那在什么时机才把 Cache 中的数据写回到内存呢？为了应对这个问题，下面介绍两种针对写入数据的方法：<br>&emsp;&emsp;	•	写直达（<font color=#7414AF>Write Through</font>）<br>&emsp;&emsp;	•	写回（<font color=#7414AF>Write Back</font>）<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font>写直达<br>&emsp;&emsp;保持内存与 Cache 一致性最简单的方式是，<font color=#374EF4>把数据同时写入内存和</font><font color=#374EF4> Cache </font><font color=#374EF4>中</font>，这种方法称为<font color=#374EF4>写直达（</font><font color=#7414AF>Write Through</font><font color=#374EF4>）</font>。<br>&emsp;&emsp;￼<br>&emsp;&emsp;在这个方法里，写入前会先判断数据是否已经在 CPU Cache 里面了：<br>&emsp;&emsp;	•	如果数据已经在 Cache 里面，先将数据更新到 Cache 里面，再写入到内存里面；<br>&emsp;&emsp;	•	如果数据没有在 Cache 里面，就直接把数据更新到内存里面。<br>&emsp;&emsp;写直达法很直观，也很简单，但是问题明显，无论数据在不在 Cache 里面，每次写操作都会写回到内存，这样写操作将会花费大量的时间，无疑性能会受到很大的影响。<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font>写回<br>&emsp;&emsp;既然写直达由于每次写操作都会把数据写回到内存，而导致影响性能，于是为了要减少数据写回内存的频率，就出现了<font color=#374EF4>写回（</font><font color=#7414AF>Write Back</font><font color=#374EF4>）的方法</font>。<br>&emsp;&emsp;在写回机制中，<font color=#374EF4>当发生写操作时，新的数据仅仅被写入</font><font color=#374EF4> Cache Block </font><font color=#374EF4>里，只有当修改过的</font><font color=#374EF4> Cache Block</font><font color=#374EF4>「被替换」时才需要写到内存中</font>，减少了数据写回内存的频率，这样便可以提高系统的性能。<br>&emsp;&emsp;￼<br>&emsp;&emsp;那具体如何做到的呢？下面来详细说一下：<br>&emsp;&emsp;	•	如果当发生写操作时，数据已经在 CPU Cache 里的话，则把数据更新到 CPU Cache 里，同时标记 CPU Cache 里的这个 Cache Block 为脏（Dirty）的，这个脏的标记代表这个时候，我们 CPU Cache 里面的这个 Cache Block 的数据和内存是不一致的，这种情况是不用把数据写到内存里的；<br>&emsp;&emsp;	•	如果当发生写操作时，数据所对应的 Cache Block 里存放的是「别的内存地址的数据」的话，就要检查这个 Cache Block 里的数据有没有被标记为脏的：<br>&emsp;&emsp;	◦	如果是脏的话，我们就要把这个 Cache Block 里的数据写回到内存，然后再把当前要写入的数据，先从内存读入到 Cache Block 里（注意，这一步不是没用的，具体为什么要这一步，可以看这个「<font color=#5478F6>回答</font><font color=#555555> </font><font color=#5478F6>(opens new window)</font><font color=#5478F6><br>&emsp;&emsp;</font>」），然后再把当前要写入的数据写入到 Cache Block，最后也把它标记为脏的；<br>&emsp;&emsp;	◦	如果 Cache Block 里面的数据没有被标记为脏，则就直接将数据写入到这个 Cache Block 里，然后再把这个 Cache Block 标记为脏的就好了。<br>&emsp;&emsp;可以发现写回这个方法，在把数据写入到 Cache 的时候，只有在缓存不命中，同时数据对应的 Cache 中的 Cache Block 为脏标记的情况下，才会将数据写到内存中，而在缓存命中的情况下，则在写入后 Cache 后，只需把该数据对应的 Cache Block 标记为脏即可，而不用写到内存里。<br>&emsp;&emsp;这样的好处是，如果我们大量的操作都能够命中缓存，那么大部分时间里 CPU 都不需要读写内存，自然性能相比写直达会高很多。<br>&emsp;&emsp;为什么缓存没命中时，还要定位 cache block？这是因为此时是要判断数据即将写入到 cache block 里的位置，是否被「其他数据」占用了此位置，如果这个「其他数据」是脏数据，那么就要帮忙把它写回到内存。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>2.4 CPU 缓存一致性<hr>直接上，不多 BB 了。<br>&emsp;&emsp;￼<hr><hr>2.4 MESI 协议 原子实现<hr>就是四个状态: M修改 E独占 S 共享 I 失效<br>&emsp;&emsp;如果是已修改, 就要写会到内存<br>&emsp;&emsp;进来都是独占的, 然后如果读取相同,变为共享, 然后这时候修改先广播 -> 已修改, 其他的失效<br>&emsp;&emsp;MESI 协议其实是 <font color=#FEAE00>4 </font><font color=#FEAE00>个状态单词的开头字母缩写</font>，分别是：<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>Modified</font>，已修改<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>Exclusive</font>，独占<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>Shared</font>，共享<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>Invalidated</font>，已失效<br>&emsp;&emsp;这四个<font color=#FEAE00>状态来标记</font><font color=#FEAE00> Cache Line </font><font color=#FEAE00>四个不同的状态</font>。<br>&emsp;&emsp;「<font color=#FEAE00>已修改</font>」状态就是我们前面提到的<font color=#FEAE00>脏标记</font>，代表该 Cache Block 上的数据已经被更新过，但是还没有写到内存里。而「<font color=#FEAE00>已失效</font>」状态，表示的是这个 Cache Block <font color=#FEAE00>里的数据已经失效了</font>，不可以读取该状态的数据。<br>&emsp;&emsp;「<font color=#FEAE00>独占」和「共享</font>」状态都代表 Cache Block 里的数据是<font color=#FEAE00>干净的</font>，也就是说，这个时候 Cache Block 里的数据和内存里面的数据是一致性的。<br>&emsp;&emsp;「独占」和「共享」的差别在于，<font color=#FEAE00>独占状态的时候，数据只存储在一个</font><font color=#FEAE00> CPU </font><font color=#FEAE00>核心的</font><font color=#FEAE00> Cache </font><font color=#FEAE00>里</font>，而其他 CPU 核心的 Cache 没有该数据。这个时候，如果要向独占的 Cache 写数据，就可以直接<font color=#FEAE00>自由地写入</font>，而不需要通知其他 CPU 核心，因为只有你这有这个数据，就不存在缓存一致性的问题了，于是就可以随便操作该数据。<br>&emsp;&emsp;另外，在「<font color=#FEAE00>独占」状态下的数据</font>，如果有其他核心从内存读取了相同的数据到各自的 Cache ，那么这个时候，<font color=#FEAE00>独占状态下的数据就会变成共享状态。</font><br>&emsp;&emsp;那么，「<font color=#FEAE00>共享</font>」状态代表着相同的数据在多个 CPU 核心的 Cache 里都有，所以当我们要<font color=#FEAE00>更新</font><font color=#FEAE00> Cache </font><font color=#FEAE00>里面的数据的时候，不能直接修改，而是要先向所有的其他</font><font color=#FEAE00> CPU </font><font color=#FEAE00>核心广播一个请求</font>，要求先把其他核心的 Cache 中对应的 <font color=#FEAE00>Cache Line </font><font color=#FEAE00>标记为「无效」状态</font>，然后再更新当前 Cache 里面的数据。<br>&emsp;&emsp;我们举个具体的例子来看看这四个状态的转换：<br>&emsp;&emsp;	1	当 <font color=#FEAE00>A </font><font color=#FEAE00>号</font><font color=#FEAE00> CPU </font>核心从内存<font color=#FEAE00>读取变量</font><font color=#FEAE00> i </font>的值，数据被缓存在 A 号 CPU 核心自己的 Cache 里面，此时其他 CPU 核心的 Cache 没有缓存该数据，于是标记 Cache Line 状态为「<font color=#FEAE00>独占</font>」，此时其 Cache 中的数据与内存是一致的；<br>&emsp;&emsp;	2	然后 <font color=#1DB100>B </font><font color=#1DB100>号</font><font color=#1DB100> CPU </font><font color=#1DB100>核心</font>也从内存<font color=#FEAE00>读取了变量</font><font color=#FEAE00> i </font><font color=#FEAE00>的值</font>，此时会发送消息给其他 CPU 核心，由于 A 号 CPU 核心已经缓存了该数据，所以会把数据返回给 B 号 CPU 核心。在这个时候， A 和 B 核心缓存了相同的数据，Cache Line 的状态就会变成「<font color=#FEAE00>共享</font>」，并且其 Cache 中的数据与内存也是一致的；<br>&emsp;&emsp;	3	当 <font color=#1DB100>A </font><font color=#1DB100>号</font><font color=#1DB100> CPU </font><font color=#1DB100>核心</font>要<font color=#FEAE00>修改</font><font color=#FEAE00> Cache </font><font color=#FEAE00>中</font><font color=#FEAE00> i </font><font color=#FEAE00>变量</font>的值，发现数据对应的 Cache Line 的状态是共享状态，则要向所有的其他 CPU 核心<font color=#FEAE00>广播一个请求</font>，要求先把其他核心的 Cache 中对应的 Cache Line <font color=#FEAE00>标记为「无效</font>」状态，然后 A 号 CPU 核心才更新 Cache 里面的数据，同时标记 <font color=#FEAE00>Cache Line </font><font color=#FEAE00>为「已修改」状态</font>，此时 Cache 中的数据就与内存不一致了。<br>&emsp;&emsp;	4	如果 A 号 CPU 核心「继续」修改 Cache 中 i 变量的值，由于此时的 Cache Line 是「已修改」状态，因此不需要给其他 CPU 核心发送消息，<font color=#FEAE00>直接更新数据即可。</font><br>&emsp;&emsp;	5	如果 A 号 CPU 核心的 Cache 里的 i 变量对应的 Cache Line 要被「<font color=#1DB100>替换</font>」，发现 Cache Line 状态是「<font color=#FEAE00>已修改」</font>状态，就会在<font color=#FEAE00>替换前先把数据同步到内存。</font><br>&emsp;&emsp;所以，可以发现当 Cache Line 状态是「已修改」或者「独占」状态时，<font color=#FEAE00>修改更新其数据不需要发送广播给其他</font><font color=#FEAE00> CPU </font><font color=#FEAE00>核心</font>，这在一定程度上<font color=#FEAE00>减少了总线带宽压力。</font><br>&emsp;&emsp;事实上，整个 MESI 的状态可以用一个有限状态机来表示它的状态流转。还有一点，对于不同状态触发的事件操作，可能是来自本地 CPU 核心发出的广播事件，也可以是来自其他 CPU 核心通过总线发出的广播事件。下图即是 MESI 协议的状态图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;MESI 协议的四种状态之间的流转过程，我汇总成了下面的表格，你可以更详细的看到每个状态转换的原因：<br>&emsp;&emsp;￼<hr><hr>2.4 总线嗅探<hr>写传播的原则就是当某个 CPU 核心更新了 Cache 中的数据，要把该事件广播通知到其他核心。最常见实现的方式是<font color=#374EF4>总线嗅探（</font><font color=#7414AF>Bus Snooping</font><font color=#374EF4>）</font>。<br>&emsp;&emsp;我还是以前面的 i 变量例子来说明总线嗅探的工作机制，当 A 号 CPU 核心修改了 L1 Cache 中 i 变量的值，通过总线把这个事件广播通知给其他所有的核心，然后每个 CPU 核心都会监听总线上的广播事件，并检查是否有相同的数据在自己的 L1 Cache 里面，如果 B 号 CPU 核心的 L1 Cache 中有该数据，那么也需要把该数据更新到自己的 L1 Cache。<br>&emsp;&emsp;可以发现，总线嗅探方法很简单， CPU 需要每时每刻监听总线上的一切活动，但是不管别的核心的 Cache 是否缓存相同的数据，都需要发出一个广播事件，这无疑会加重总线的负载。<br>&emsp;&emsp;另外，总线嗅探只是保证了某个 CPU 核心的 Cache 更新数据这个事件能被其他 CPU 核心知道，但是并不能保证事务串行化。<br>&emsp;&emsp;于是，有一个协议基于总线嗅探机制实现了事务串行化，也用状态机机制降低了总线带宽压力，这个协议就是 MESI 协议，这个协议就做到了 CPU 缓存一致性。<hr><hr>2.4 总结<hr>CPU 在读写数据的时候，都是在 CPU Cache 读写数据的，原因是 Cache 离 CPU 很近，读写性能相比内存高出很多。对于 Cache 里没有缓存 CPU 所需要读取的数据的这种情况，CPU 则会从内存读取数据，并将数据缓存到 Cache 里面，最后 CPU 再从 Cache 读取数据。<br>&emsp;&emsp;而对于数据的写入，CPU 都会先写入到 Cache 里面，然后再在找个合适的时机写入到内存，那就有「写直达」和「写回」这两种策略来保证 Cache 与内存的数据一致性：<br>&emsp;&emsp;	•	写直达，只要有数据写入，都会直接把数据写入到内存里面，这种方式简单直观，但是性能就会受限于内存的访问速度；<br>&emsp;&emsp;	•	写回，对于已经缓存在 Cache 的数据的写入，只需要更新其数据就可以，不用写入到内存，只有在需要把缓存里面的脏数据交换出去的时候，才把数据同步到内存里，这种方式在缓存命中率高的情况，性能会更好；<br>&emsp;&emsp;当今 CPU 都是多核的，每个核心都有各自独立的 L1/L2 Cache，只有 L3 Cache 是多个核心之间共享的。所以，我们要确保多核缓存是一致性的，否则会出现错误的结果。<br>&emsp;&emsp;要想实现缓存一致性，关键是要满足 2 点：<br>&emsp;&emsp;	•	第一点是写传播，也就是当某个 CPU 核心发生写入操作时，需要把该事件广播通知给其他核心；<br>&emsp;&emsp;	•	第二点是事物的串行化，这个很重要，只有保证了这个，才能保障我们的数据是真正一致的，我们的程序在各个不同的核心上运行的结果也是一致的；<br>&emsp;&emsp;基于总线嗅探机制的 MESI 协议，就满足上面了这两点，因此它是保障缓存一致性的协议。<br>&emsp;&emsp;MESI 协议，是已修改、独占、共享、已失效这四个状态的英文缩写的组合。整个 MSI 状态的变更，则是根据来自本地 CPU 核心的请求，或者来自其他 CPU 核心通过总线传输过来的请求，从而构成一个流动的状态机。另外，对于在「已修改」或者「独占」状态的 Cache Line，修改更新其数据不需要发送广播给其他 CPU 核心。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>2.4 缓存一致性问题<hr>现在 CPU 都是多核的，由于 L1/L2 Cache 是多个核心各自独有的，那么会带来多核心的<font color=#374EF4>缓存一致性（</font><font color=#7414AF>Cache Coherence</font><font color=#374EF4>）</font> 的问题，如果不能保证缓存一致性的问题，就可能造成结果错误。<br>&emsp;&emsp;那缓存一致性的问题具体是怎么发生的呢？我们以一个含有两个核心的 CPU 作为例子看一看。<br>&emsp;&emsp;假设 A 号核心和 B 号核心同时运行两个线程，都操作共同的变量 i（初始值为 0 ）。<br>&emsp;&emsp;￼<br>&emsp;&emsp;这时如果 A 号核心执行了 <font color=#4D647F>i++</font> 语句的时候，为了考虑性能，使用了我们前面所说的写回策略，先把值为 <font color=#4D647F>1</font> 的执行结果写入到 L1/L2 Cache 中，然后把 L1/L2 Cache 中对应的 Block 标记为脏的，这个时候数据其实没有被同步到内存中的，因为写回策略，只有在 A 号核心中的这个 Cache Block 要被替换的时候，数据才会写入到内存里。<br>&emsp;&emsp;如果这时旁边的 B 号核心尝试从内存读取 i 变量的值，则读到的将会是错误的值，因为刚才 A 号核心更新 i 值还没写入到内存中，内存中的值还依然是 0。<font color=#374EF4>这个就是所谓的缓存一致性问题，</font><font color=#374EF4>A </font><font color=#374EF4>号核心和</font><font color=#374EF4> B </font><font color=#374EF4>号核心的缓存，在这个时候是不一致，从而会导致执行结果的错误。</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;那么，要解决这一问题，就需要一种机制，来同步两个不同核心里面的缓存数据。要实现的这个机制的话，要保证做到下面这 2 点：<br>&emsp;&emsp;	•	第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为<font color=#374EF4>写传播（</font><font color=#7414AF>Write Propagation</font><font color=#374EF4>）</font>；<br>&emsp;&emsp;	•	第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为<font color=#374EF4>事务的串行化（</font><font color=#7414AF>Transaction Serialization</font><font color=#374EF4>）</font>。<br>&emsp;&emsp;第一点写传播很容易就理解，当某个核心在 Cache 更新了数据，就需要同步到其他核心的 Cache 里。而对于第二点事务的串行化，我们举个例子来理解它。<br>&emsp;&emsp;假设我们有一个含有 4 个核心的 CPU，这 4 个核心都操作共同的变量 i（初始值为 0 ）。A 号核心先把 i 值变为 100，而此时同一时间，B 号核心先把 i 值变为 200，这里两个修改，都会「传播」到 C 和 D 号核心。<br>&emsp;&emsp;￼<br>&emsp;&emsp;那么问题就来了，C 号核心先收到了 A 号核心更新数据的事件，再收到 B 号核心更新数据的事件，因此 C 号核心看到的变量 i 是先变成 100，后变成 200。<br>&emsp;&emsp;而如果 D 号核心收到的事件是反过来的，则 D 号核心看到的是变量 i 先变成 200，再变成 100，虽然是做到了写传播，但是各个 Cache 里面的数据还是不一致的。<br>&emsp;&emsp;所以，我们要保证 C 号核心和 D 号核心都能看到<font color=#374EF4>相同顺序的数据变化</font>，比如变量 i 都是先变成 100，再变成 200，这样的过程就是事务的串行化。<br>&emsp;&emsp;要实现事务串行化，要做到 2 点：<br>&emsp;&emsp;	•	CPU 核心对于 Cache 中数据的操作，需要同步给其他 CPU 核心；<br>&emsp;&emsp;	•	要引入「锁」的概念，如果两个 CPU 核心里有相同数据的 Cache，那么对于这个 Cache 数据的更新，只有拿到了「锁」，才能进行对应的数据更新。<br>&emsp;&emsp;那接下来我们看看，写传播和事务串行化具体是用什么技术实现的。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>2.5 CPU 如何读写数据的？<hr>先来认识 CPU 的架构，只有理解了 CPU 的 架构，才能更好地理解 CPU 是如何读写数据的，对于现代 CPU 的架构图如下：<br>&emsp;&emsp;￼<br>&emsp;&emsp;可以看到，一个 CPU 里通常会有多个 CPU 核心，比如上图中的 1 号和 2 号 CPU 核心，并且每个 CPU 核心都有自己的 L1 Cache 和 L2 Cache，而 L1 Cache 通常分为 dCache（数据缓存） 和 iCache（指令缓存），L3 Cache 则是多个核心共享的，这就是 CPU 典型的缓存层次。<br>&emsp;&emsp;上面提到的都是 CPU 内部的 Cache，放眼外部的话，还会有内存和硬盘，这些存储设备共同构成了金字塔存储层次。如下图所示：<br>&emsp;&emsp;￼<br>&emsp;&emsp;从上图也可以看到，从上往下，存储设备的容量会越大，而访问速度会越慢。至于每个存储设备的访问延时，你可以看下图的表格：<br>&emsp;&emsp;￼<br>&emsp;&emsp;你可以看到， CPU 访问 L1 Cache 速度比访问内存快 100 倍，这就是为什么 CPU 里会有 L1~L3 Cache 的原因，目的就是把 Cache 作为 CPU 与内存之间的缓存层，以减少对内存的访问频率。<br>&emsp;&emsp;CPU 从内存中读取数据到 Cache 的时候，并不是一个字节一个字节读取，而是一块一块的方式来读取数据的，这一块一块的数据被称为 CPU Line（缓存行），所以 <font color=#374EF4>CPU Line </font><font color=#374EF4>是</font><font color=#374EF4> CPU </font><font color=#374EF4>从内存读取数据到</font><font color=#374EF4> Cache </font><font color=#374EF4>的单位</font>。<br>&emsp;&emsp;至于 CPU Line 大小，在 Linux 系统可以用下面的方式查看到，你可以看我服务器的 L1 Cache Line 大小是 64 字节，也就意味着 <font color=#374EF4>L1 Cache </font><font color=#374EF4>一次载入数据的大小是</font><font color=#374EF4> 64 </font><font color=#374EF4>字节</font>。<br>&emsp;&emsp;￼<br>&emsp;&emsp;那么对数组的加载， CPU 就会加载数组里面连续的多个数据到 Cache 里，因此我们应该按照物理内存地址分布的顺序去访问元素，这样访问数组元素的时候，Cache 命中率就会很高，于是就能减少从内存读取数据的频率， 从而可提高程序的性能。<br>&emsp;&emsp;但是，在我们不使用数组，而是使用单独的变量的时候，则会有 Cache 伪共享的问题，Cache 伪共享问题上是一个性能杀手，我们应该要规避它。<br>&emsp;&emsp;接下来，就来看看 Cache 伪共享是什么？又如何避免这个问题？<br>&emsp;&emsp;现在假设有一个双核心的 CPU，这两个 CPU 核心并行运行着两个不同的线程，它们同时从内存中读取两个不同的数据，分别是类型为 <font color=#4D647F>long</font> 的变量 A 和 B，这个两个数据的地址在物理内存上是<font color=#374EF4>连续</font>的，如果 Cahce Line 的大小是 64 字节，并且变量 A 在 Cahce Line 的开头位置，那么这两个数据是位于<font color=#374EF4>同一个</font><font color=#374EF4> Cache Line </font><font color=#374EF4>中</font>，又因为 CPU Line 是 CPU 从内存读取数据到 Cache 的单位，所以这两个数据会被同时读入到了两个 CPU 核心中各自 Cache 中。<br>&emsp;&emsp;￼<br>&emsp;&emsp;我们来思考一个问题，如果这两个不同核心的线程分别修改不同的数据，比如 1 号 CPU 核心的线程只修改了 变量 A，或 2 号 CPU 核心的线程的线程只修改了变量 B，会发生什么呢？<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>2.5 CPU 如何选择线程的？<hr>了解完 CPU 读取数据的过程后，我们再来看看 CPU 是根据什么来选择当前要执行的线程。<br>&emsp;&emsp;在 Linux 内核中，进程和线程都是用 <font color=#4D647F>task_struct</font> 结构体表示的，区别在于线程的 task_struct 结构体里部分资源是共享了进程已创建的资源，比如内存地址空间、代码段、文件描述符等，所以 Linux 中的线程也被称为轻量级进程，因为线程的 task_struct 相比进程的 task_struct 承载的 资源比较少，因此以「轻」得名。<br>&emsp;&emsp;一般来说，没有创建线程的进程，是只有单个执行流，它被称为是主线程。如果想让进程处理更多的事情，可以创建多个线程分别去处理，但不管怎么样，它们对应到内核里都是 <font color=#4D647F>task_struct</font>。<br>&emsp;&emsp;￼<br>&emsp;&emsp;所以，Linux 内核里的调度器，调度的对象就是 <font color=#4D647F>task_struct</font>，接下来我们就把这个数据结构统称为<font color=#374EF4>任务</font>。<br>&emsp;&emsp;在 Linux 系统中，根据任务的优先级以及响应要求，主要分为两种，其中优先级的数值越小，优先级越高：<br>&emsp;&emsp;	•	实时任务，对系统的响应时间要求很高，也就是要尽可能快的执行实时任务，优先级在 <font color=#4D647F>0~99</font> 范围内的就算实时任务；<br>&emsp;&emsp;	•	普通任务，响应时间没有很高的要求，优先级在 <font color=#4D647F>100~139</font> 范围内都是普通任务级别；<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font>调度类<br>&emsp;&emsp;由于任务有优先级之分，Linux 系统为了保障高优先级的任务能够尽可能早的被执行，于是分为了这几种调度类，如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;Deadline 和 Realtime 这两个调度类，都是应用于实时任务的，这两个调度类的调度策略合起来共有这三种，它们的作用如下：<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>SCHED_DEADLINE</font>：是按照 deadline 进行调度的，距离当前时间点最近的 deadline 的任务会被优先调度；<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>SCHED_FIFO</font>：对于相同优先级的任务，按先来先服务的原则，但是优先级更高的任务，可以抢占低优先级的任务，也就是优先级高的可以「插队」；<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>SCHED_RR</font>：对于相同优先级的任务，轮流着运行，每个任务都有一定的时间片，当用完时间片的任务会被放到队列尾部，以保证相同优先级任务的公平性，但是高优先级的任务依然可以抢占低优先级的任务；<br>&emsp;&emsp;而 Fair 调度类是应用于普通任务，都是由 CFS 调度器管理的，分为两种调度策略：<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>SCHED_NORMAL</font>：普通任务使用的调度策略；<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>SCHED_BATCH</font>：后台任务的调度策略，不和终端进行交互，因此在不影响其他需要交互的任务，可以适当降低它的优先级。<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font>完全公平调度<br>&emsp;&emsp;我们平日里遇到的基本都是普通任务，对于普通任务来说，公平性最重要，在 Linux 里面，实现了一个基于 CFS 的调度算法，也就是<font color=#374EF4>完全公平调度（</font><font color=#7414AF>Completely Fair Scheduling</font><font color=#374EF4>）</font>。<br>&emsp;&emsp;这个算法的理念是想让分配给每个任务的 CPU 时间是一样，于是它为每个任务安排一个虚拟运行时间 vruntime，如果一个任务在运行，其运行的越久，该任务的 vruntime 自然就会越大，而没有被运行的任务，vruntime 是不会变化的。<br>&emsp;&emsp;那么，<font color=#374EF4>在</font><font color=#374EF4> CFS </font><font color=#374EF4>算法调度的时候，会优先选择</font><font color=#374EF4> vruntime </font><font color=#374EF4>少的任务</font>，以保证每个任务的公平性。<br>&emsp;&emsp;这就好比，让你把一桶的奶茶平均分到 10 杯奶茶杯里，你看着哪杯奶茶少，就多倒一些；哪个多了，就先不倒，这样经过多轮操作，虽然不能保证每杯奶茶完全一样多，但至少是公平的。<br>&emsp;&emsp;当然，上面提到的例子没有考虑到优先级的问题，虽然是普通任务，但是普通任务之间还是有优先级区分的，所以在计算虚拟运行时间 vruntime 还要考虑普通任务的<font color=#374EF4>权重值</font>，注意权重值并不是优先级的值，内核中会有一个 nice 级别与权重值的转换表，nice 级别越低的权重值就越大，至于 nice 值是什么，我们后面会提到。 于是就有了以下这个公式：<br>&emsp;&emsp;￼<br>&emsp;&emsp;你可以不用管 NICE_0_LOAD 是什么，你就认为它是一个常量，那么在「同样的实际运行时间」里，高权重任务的 vruntime 比低权重任务的 vruntime <font color=#374EF4>少</font>，你可能会奇怪为什么是少的？你还记得 CFS 调度吗，它是会优先选择 vruntime 少的任务进行调度，所以高权重的任务就会被优先调度了，于是高权重的获得的实际运行时间自然就多了。<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font>CPU 运行队列<br>&emsp;&emsp;一个系统通常都会运行着很多任务，多任务的数量基本都是远超 CPU 核心数量，因此这时候就需要<font color=#374EF4>排队</font>。<br>&emsp;&emsp;事实上，每个 CPU 都有自己的<font color=#374EF4>运行队列（</font><font color=#7414AF>Run Queue, rq</font><font color=#374EF4>）</font>，用于描述在此 CPU 上所运行的所有进程，其队列包含三个运行队列，Deadline 运行队列 dl_rq、实时任务运行队列 rt_rq 和 CFS 运行队列 csf_rq，其中 csf_rq 是用红黑树来描述的，按 vruntime 大小来排序的，最左侧的叶子节点，就是下次会被调度的任务。<br>&emsp;&emsp;￼<br>&emsp;&emsp;这几种调度类是有优先级的，优先级如下：Deadline > Realtime > Fair，这意味着 Linux 选择下一个任务执行的时候，会按照此优先级顺序进行选择，也就是说先从 <font color=#4D647F>dl_rq</font> 里选择任务，然后从 <font color=#4D647F>rt_rq</font> 里选择任务，最后从 <font color=#4D647F>csf_rq</font> 里选择任务。因此，<font color=#374EF4>实时任务总是会比普通任务优先被执行</font>。<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font>调整优先级<br>&emsp;&emsp;如果我们启动任务的时候，没有特意去指定优先级的话，默认情况下都是普通任务，普通任务的调度类是 Fair，由 CFS 调度器来进行管理。CFS 调度器的目的是实现任务运行的公平性，也就是保障每个任务的运行的时间是差不多的。<br>&emsp;&emsp;如果你想让某个普通任务有更多的执行时间，可以调整任务的 <font color=#4D647F>nice</font> 值，从而让优先级高一些的任务执行更多时间。nice 的值能设置的范围是 <font color=#4D647F>-20</font><font color=#4D647F>～</font><font color=#4D647F>19</font>， 值越低，表明优先级越高，因此 -20 是最高优先级，19 则是最低优先级，默认优先级是 0。<br>&emsp;&emsp;是不是觉得 nice 值的范围很诡异？事实上，nice 值并不是表示优先级，而是表示优先级的修正数值，它与优先级（priority）的关系是这样的：priority(new) = priority(old) + nice。内核中，priority 的范围是 0~139，值越低，优先级越高，其中前面的 0~99 范围是提供给实时任务使用的，而 nice 值是映射到 100~139，这个范围是提供给普通任务用的，因此 nice 值调整的是普通任务的优先级。<br>&emsp;&emsp;￼<br>&emsp;&emsp;在前面我们提到了，权重值与 nice 值的关系的，nice 值越低，权重值就越大，计算出来的 vruntime 就会越少，由于 CFS 算法调度的时候，就会优先选择 vruntime 少的任务进行执行，所以 nice 值越低，任务的优先级就越高。<br>&emsp;&emsp;我们可以在启动任务的时候，可以指定 nice 的值，比如将 mysqld 以 -3 优先级：<br>&emsp;&emsp;￼<br>&emsp;&emsp;如果想修改已经运行中的任务的优先级，则可以使用 <font color=#4D647F>renice</font> 来调整 nice 值：<br>&emsp;&emsp;￼<br>&emsp;&emsp;nice 调整的是普通任务的优先级，所以不管怎么缩小 nice 值，任务永远都是普通任务，如果某些任务要求实时性比较高，那么你可以考虑改变任务的优先级以及调度策略，使得它变成实时任务，比如：<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>2.5 CPU 是如何执行任务的？<hr>你清楚下面这几个问题吗？<br>&emsp;&emsp;	•	有了内存，为什么还需要 CPU Cache？<br>&emsp;&emsp;	•	CPU 是怎么读写数据的？<br>&emsp;&emsp;	•	如何让 CPU 能读取数据更快一些？<br>&emsp;&emsp;	•	CPU 伪共享是如何发生的？又该如何避免？<br>&emsp;&emsp;	•	CPU 是如何调度任务的？如果你的任务对响应要求很高，你希望它总是能被先调度，这该怎么办？<br>&emsp;&emsp;	•	...<br>&emsp;&emsp;这篇，我们就来回答这些问题。<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>2.5 分析伪共享问题<hr>现在我们结合保证多核缓存一致的 MESI 协议，来说明这一整个的过程，如果你还不知道 MESI 协议，你可以看我这篇文章「<font color=#5478F6>10 </font><font color=#5478F6>张图打开</font><font color=#5478F6> CPU </font><font color=#5478F6>缓存一致性的大门</font><font color=#5478F6><br>&emsp;&emsp;</font><font color=#5478F6>(opens new window)</font><font color=#5478F6><br>&emsp;&emsp;</font>」。<br>&emsp;&emsp;①. 最开始变量 A 和 B 都还不在 Cache 里面，假设 1 号核心绑定了线程 A，2 号核心绑定了线程 B，线程 A 只会读写变量 A，线程 B 只会读写变量 B。<br>&emsp;&emsp;￼<br>&emsp;&emsp;②. 1 号核心读取变量 A，由于 CPU 从内存读取数据到 Cache 的单位是 Cache Line，也正好变量 A 和 变量 B 的数据归属于同一个 Cache Line，所以 A 和 B 的数据都会被加载到 Cache，并将此 Cache Line 标记为「独占」状态。<br>&emsp;&emsp;￼<br>&emsp;&emsp;③. 接着，2 号核心开始从内存里读取变量 B，同样的也是读取 Cache Line 大小的数据到 Cache 中，此 Cache Line 中的数据也包含了变量 A 和 变量 B，此时 1 号和 2 号核心的 Cache Line 状态变为「共享」状态。<br>&emsp;&emsp;￼<br>&emsp;&emsp;④. 1 号核心需要修改变量 A，发现此 Cache Line 的状态是「共享」状态，所以先需要通过总线发送消息给 2 号核心，通知 2 号核心把 Cache 中对应的 Cache Line 标记为「已失效」状态，然后 1 号核心对应的 Cache Line 状态变成「已修改」状态，并且修改变量 A。<br>&emsp;&emsp;￼<br>&emsp;&emsp;⑤. 之后，2 号核心需要修改变量 B，此时 2 号核心的 Cache 中对应的 Cache Line 是已失效状态，另外由于 1 号核心的 Cache 也有此相同的数据，且状态为「已修改」状态，所以要先把 1 号核心的 Cache 对应的 Cache Line 写回到内存，然后 2 号核心再从内存读取 Cache Line 大小的数据到 Cache 中，最后把变量 B 修改到 2 号核心的 Cache 中，并将状态标记为「已修改」状态。<br>&emsp;&emsp;￼<br>&emsp;&emsp;所以，可以发现如果 1 号和 2 号 CPU 核心这样持续交替的分别修改变量 A 和 B，就会重复 ④ 和 ⑤ 这两个步骤，Cache 并没有起到缓存的效果，虽然变量 A 和 B 之间其实并没有任何的关系，但是因为同时归属于一个 Cache Line ，这个 Cache Line 中的任意数据被修改后，都会相互影响，从而出现 ④ 和 ⑤ 这两个步骤。<br>&emsp;&emsp;因此，这种因为多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象称为<font color=#374EF4>伪共享（</font><font color=#7414AF>False Sharing</font><font color=#374EF4>）</font>。<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>2.5 总结<hr>理解 CPU 是如何读写数据的前提，是要理解 CPU 的架构，CPU 内部的多个 Cache + 外部的内存和磁盘都就构成了金字塔的存储器结构，在这个金字塔中，越往下，存储器的容量就越大，但访问速度就会小。<br>&emsp;&emsp;CPU 读写数据的时候，并不是按一个一个字节为单位来进行读写，而是以 CPU Line 大小为单位，CPU Line 大小一般是 64 个字节，也就意味着 CPU 读写数据的时候，每一次都是以 64 字节大小为一块进行操作。<br>&emsp;&emsp;因此，如果我们操作的数据是数组，那么访问数组元素的时候，按内存分布的地址顺序进行访问，这样能充分利用到 Cache，程序的性能得到提升。但如果操作的数据不是数组，而是普通的变量，并在多核 CPU 的情况下，我们还需要避免 Cache Line 伪共享的问题。<br>&emsp;&emsp;所谓的 Cache Line 伪共享问题就是，多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象。那么对于多个线程共享的热点数据，即经常会修改的数据，应该避免这些数据刚好在同一个 Cache Line 中，避免的方式一般有 Cache Line 大小字节对齐，以及字节填充等方法。<br>&emsp;&emsp;系统中需要运行的多线程数一般都会大于 CPU 核心，这样就会导致线程排队等待 CPU，这可能会产生一定的延时，如果我们的任务对延时容忍度很低，则可以通过一些人为手段干预 Linux 的默认调度策略和优先级。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>2.5 避免伪共享的方法<hr>因此，对于多个线程共享的热点数据，即经常会修改的数据，应该避免这些数据刚好在同一个 Cache Line 中，否则就会出现为伪共享的问题。<br>&emsp;&emsp;接下来，看看在实际项目中是用什么方式来避免伪共享的问题的。<br>&emsp;&emsp;在 Linux 内核中存在 <font color=#4D647F>__cacheline_aligned_in_smp</font> 宏定义，是用于解决伪共享的问题。<br>&emsp;&emsp;￼<br>&emsp;&emsp;从上面的宏定义，我们可以看到：<br>&emsp;&emsp;	•	如果在多核（MP）系统里，该宏定义是 <font color=#4D647F>__cacheline_aligned</font>，也就是 Cache Line 的大小；<br>&emsp;&emsp;	•	而如果在单核系统里，该宏定义是空的；<br>&emsp;&emsp;因此，针对在同一个 Cache Line 中的共享的数据，如果在多核之间竞争比较严重，为了防止伪共享现象的发生，可以采用上面的宏定义使得变量在 Cache Line 里是对齐的。<br>&emsp;&emsp;举个例子，有下面这个结构体：<br>&emsp;&emsp;￼<br>&emsp;&emsp;结构体里的两个成员变量 a 和 b 在物理内存地址上是连续的，于是它们可能会位于同一个 Cache Line 中，如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;所以，为了防止前面提到的 Cache 伪共享问题，我们可以使用上面介绍的宏定义，将 b 的地址设置为 Cache Line 对齐地址，如下：<br>&emsp;&emsp;￼<br>&emsp;&emsp;这样 a 和 b 变量就不会在同一个 Cache Line 中了，如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;所以，避免 Cache 伪共享实际上是用空间换时间的思想，浪费一部分 Cache 空间，从而换来性能的提升。<br>&emsp;&emsp;我们再来看一个应用层面的规避方案，有一个 Java 并发框架 Disruptor 使用「字节填充 + 继承」的方式，来避免伪共享的问题。<br>&emsp;&emsp;Disruptor 中有一个 RingBuffer 类会经常被多个线程使用，代码如下：<br>&emsp;&emsp;￼<br>&emsp;&emsp;你可能会觉得 RingBufferPad 类里 7 个 long 类型的名字很奇怪，但事实上，它们虽然看起来毫无作用，但却对性能的提升起到了至关重要的作用。<br>&emsp;&emsp;我们都知道，CPU Cache 从内存读取数据的单位是 CPU Line，一般 64 位 CPU 的 CPU Line 的大小是 64 个字节，一个 long 类型的数据是 8 个字节，所以 CPU 一下会加载 8 个 long 类型的数据。<br>&emsp;&emsp;根据 JVM 对象继承关系中父类成员和子类成员，内存地址是连续排列布局的，因此 RingBufferPad 中的 7 个 long 类型数据作为 Cache Line <font color=#374EF4>前置填充</font>，而 RingBuffer 中的 7 个 long 类型数据则作为 Cache Line <font color=#374EF4>后置填充</font>，这 14 个 long 变量没有任何实际用途，更不会对它们进行读写操作。<br>&emsp;&emsp;￼<br>&emsp;&emsp;另外，RingBufferFelds 里面定义的这些变量都是 <font color=#4D647F>final</font> 修饰的，意味着第一次加载之后不会再修改， 又<font color=#374EF4>由于「前后」各填充了</font><font color=#374EF4> 7 </font><font color=#374EF4>个不会被读写的</font><font color=#374EF4> long </font><font color=#374EF4>类型变量，所以无论怎么加载</font><font color=#374EF4> Cache Line</font><font color=#374EF4>，这整个</font><font color=#374EF4> Cache Line </font><font color=#374EF4>里都没有会发生更新操作的数据，于是只要数据被频繁地读取访问，就自然没有数据被换出</font><font color=#374EF4> Cache </font><font color=#374EF4>的可能，也因此不会产生伪共享的问题</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>2.6 中断是什么？<hr>系统用来响应硬件设备请求的一种机制<br>&emsp;&emsp;有中断处理程序, 要尽可能快的执行完, 减少对正常进程的影响<br>&emsp;&emsp;还有关闭中断<br>&emsp;&emsp;###<br>&emsp;&emsp;先来看看什么是中断？在计算机中，中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求。<br>&emsp;&emsp;这样的解释可能过于学术了，容易云里雾里，我就举个生活中取外卖的例子。<br>&emsp;&emsp;小林中午搬完砖，肚子饿了，点了份白切鸡外卖，这次我带闪了，没有被某团大数据杀熟。虽然平台上会显示配送进度，但是我也不能一直傻傻地盯着呀，时间很宝贵，当然得去干别的事情，等外卖到了配送员会通过「电话」通知我，电话响了，我就会停下手中地事情，去拿外卖。<br>&emsp;&emsp;这里的打电话，其实就是对应计算机里的中断，没接到电话的时候，我可以做其他的事情，只有接到了电话，也就是发生中断，我才会停下当前的事情，去进行另一个事情，也就是拿外卖。<br>&emsp;&emsp;从这个例子，我们可以知道，中断是一种异步的事件处理机制，可以提高系统的并发处理能力。<br>&emsp;&emsp;操作系统收到了中断请求，会打断其他进程的运行，所以<font color=#FEAE00>中断请求的响应程序，也就是中断处理程序，要尽可能快的执行完，这样可以减少对正常进程运行调度地影响。</font><br>&emsp;&emsp;而且，中断处理程序在响应中断时，可能还会「临时关闭中断」，这意味着，如果当前中断处理程序没有执行完之前，系统中其他的中断请求都无法被响应，也就说中断有可能会丢失，所以中断处理程序要短且快。<br>&emsp;&emsp;还是回到外卖的例子，小林到了晚上又点起了外卖，这次为了犒劳自己，共点了两份外卖，一份小龙虾和一份奶茶，并且是由不同地配送员来配送，那么问题来了，当第一份外卖送到时，配送员给我打了长长的电话，说了一些杂七杂八的事情，比如给个好评等等，但如果这时另一位配送员也想给我打电话。<br>&emsp;&emsp;很明显，这时第二位配送员因为我在通话中（相当于关闭了中断响应），自然就无法打通我的电话，他可能尝试了几次后就走掉了（相当于丢失了一次中断）。<hr><hr>2.6 什么是软中断？<hr>前面我们也提到了，中断请求的处理程序应该要短且快，这样才能减少对正常进程运行调度地影响，而且中断处理程序可能会暂时关闭中断，这时如果中断处理程序执行时间过长，可能在还未执行完中断处理程序前，会丢失当前其他设备的中断请求。<br>&emsp;&emsp;那 Linux 系统<font color=#374EF4>为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」</font>。<br>&emsp;&emsp;<font color=#374EF4>	•	</font><font color=#374EF4>上半部用来快速处理中断</font>，一般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。<br>&emsp;&emsp;<font color=#374EF4>	•	</font><font color=#374EF4>下半部用来延迟处理上半部未完成的工作</font>，一般以「内核线程」的方式运行。<br>&emsp;&emsp;前面的外卖例子，由于第一个配送员长时间跟我通话，则导致第二位配送员无法拨通我的电话，其实当我接到第一位配送员的电话，可以告诉配送员说我现在下楼，剩下的事情，等我们见面再说（上半部），然后就可以挂断电话，到楼下后，在拿外卖，以及跟配送员说其他的事情（下半部）。<br>&emsp;&emsp;这样，第一位配送员就不会占用我手机太多时间，当第二位配送员正好过来时，会有很大几率拨通我的电话。<br>&emsp;&emsp;再举一个计算机中的例子，常见的网卡接收网络包的例子。<br>&emsp;&emsp;网卡收到网络包后，会通过<font color=#374EF4>硬件中断</font>通知内核有新的数据到了，于是内核就会调用对应的中断处理程序来响应该事件，这个事件的处理也是会分成上半部和下半部。<br>&emsp;&emsp;上部分要做到快速处理，所以只要把网卡的数据读到内存中，然后更新一下硬件寄存器的状态，比如把状态更新为表示数据已经读到内存中的状态值。<br>&emsp;&emsp;接着，内核会触发一个<font color=#374EF4>软中断</font>，把一些处理比较耗时且复杂的事情，交给「软中断处理程序」去做，也就是中断的下半部，其主要是需要从内存中找到网络数据，再按照网络协议栈，对网络数据进行逐层解析和处理，最后把数据送给应用程序。<br>&emsp;&emsp;所以，中断处理程序的上部分和下半部可以理解为：<br>&emsp;&emsp;<font color=#374EF4>	•	</font><font color=#374EF4>上半部直接处理硬件请求，也就是硬中断</font>，主要是负责耗时短的工作，特点是快速执行；<br>&emsp;&emsp;<font color=#374EF4>	•	</font><font color=#374EF4>下半部是由内核触发，也就说软中断</font>，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行；<br>&emsp;&emsp;还有一个区别，硬中断（上半部）是会打断 CPU 正在执行的任务，然后立即执行中断处理程序，而软中断（下半部）是以内核线程的方式执行，并且每一个 CPU 都对应一个软中断内核线程，名字通常为「ksoftirqd/CPU 编号」，比如 0 号 CPU 对应的软中断内核线程的名字是 <font color=#4D647F>ksoftirqd/0</font><br>&emsp;&emsp;不过，软中断不只是包括硬件设备中断处理程序的下半部，一些内核自定义事件也属于软中断，比如内核调度等、RCU 锁（内核里常用的一种锁）等。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font>系统里有哪些软中断？<br>&emsp;&emsp;在 Linux 系统里，我们可以通过查看 <font color=#4D647F>/proc/softirqs</font> 的 内容来知晓「软中断」的运行情况，以及 <font color=#4D647F>/proc/interrupts</font> 的 内容来知晓「硬中断」的运行情况。<br>&emsp;&emsp;接下来，就来简单的解析下 <font color=#4D647F>/proc/softirqs</font> 文件的内容，在我服务器上查看到的文件内容如下：<br>&emsp;&emsp;￼<br>&emsp;&emsp;你可以看到，每一个 CPU 都有自己对应的不同类型软中断的<font color=#374EF4>累计运行次数</font>，有 3 点需要注意下。<br>&emsp;&emsp;第一点，要注意第一列的内容，它是代表着软中断的类型，在我的系统里，软中断包括了 10 个类型，分别对应不同的工作类型，比如 <font color=#4D647F>NET_RX</font> 表示网络接收中断，<font color=#4D647F>NET_TX</font> 表示网络发送中断、<font color=#4D647F>TIMER</font> 表示定时中断、<font color=#4D647F>RCU</font> 表示 RCU 锁中断、<font color=#4D647F>SCHED</font> 表示内核调度中断。<br>&emsp;&emsp;第二点，要注意同一种类型的软中断在不同 CPU 的分布情况，正常情况下，同一种中断在不同 CPU 上的累计次数相差不多，比如我的系统里，<font color=#4D647F>NET_RX</font> 在 CPU0 、CPU1、CPU2、CPU3 上的中断次数基本是同一个数量级，相差不多。<br>&emsp;&emsp;第三点，这些数值是系统运行以来的累计中断次数，数值的大小没什么参考意义，但是系统的<font color=#374EF4>中断次数的变化速率</font>才是我们要关注的，我们可以使用 <font color=#4D647F>watch -d cat /proc/softirqs</font> 命令查看中断次数的变化速率。<br>&emsp;&emsp;前面提到过，软中断是以内核线程的方式执行的，我们可以用 <font color=#4D647F>ps</font> 命令可以查看到，下面这个就是在我的服务器上查到软中断内核线程的结果：<br>&emsp;&emsp;￼<br>&emsp;&emsp;可以发现，内核线程的名字外面都有有中括号，这说明 ps 无法获取它们的命令行参数，所以一般来说，名字在中括号里的都可以认为是内核线程。<br>&emsp;&emsp;而且，你可以看到有 4 个 <font color=#4D647F>ksoftirqd</font> 内核线程，这是因为我这台服务器的 CPU 是 4 核心的，每个 CPU 核心都对应着一个内核线程。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>2.6 什么是软中断？ 目录<hr>今日的技术主题：<font color=#FEAE00>什么是软中断？</font>。<br>&emsp;&emsp;￼<hr><hr>2.6 如何定位软中断 CPU 使用率过高的问题？<hr>要想知道当前的系统的软中断情况，我们可以使用 <font color=#4D647F>top</font> 命令查看，下面是一台服务器上的 top 的数据：<br>&emsp;&emsp;￼<br>&emsp;&emsp;上图中的黄色部分 <font color=#4D647F>si</font>，就是 CPU 在软中断上的使用率，而且可以发现，每个 CPU 使用率都不高，两个 CPU 的使用率虽然只有 3% 和 4% 左右，但是都是用在软中断上了。<br>&emsp;&emsp;另外，也可以看到 CPU 使用率最高的进程也是软中断 <font color=#4D647F>ksoftirqd</font>，因此可以认为此时系统的开销主要来源于软中断。<br>&emsp;&emsp;如果要知道是哪种软中断类型导致的，我们可以使用 <font color=#4D647F>watch -d cat /proc/softirqs</font> 命令查看每个软中断类型的中断次数的变化速率。<br>&emsp;&emsp;￼<br>&emsp;&emsp;一般对于网络 I/O 比较高的 Web 服务器，<font color=#4D647F>NET_RX</font> 网络接收中断的变化速率相比其他中断类型快很多。<br>&emsp;&emsp;如果发现 <font color=#4D647F>NET_RX</font> 网络接收中断次数的变化速率过快，接下来就可以使用 <font color=#4D647F>sar -n DEV</font> 查看网卡的网络包接收速率情况，然后分析是哪个网卡有大量的网络包进来。<br>&emsp;&emsp;￼<br>&emsp;&emsp;接着，在通过 <font color=#4D647F>tcpdump</font> 抓包，分析这些包的来源，如果是非法的地址，可以考虑加防火墙，如果是正常流量，则要考虑硬件升级等。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>2.6 总结<hr>为了避免由于中断处理程序执行时间过长，而影响正常进程的调度，Linux 将中断处理程序分为上半部和下半部：<br>&emsp;&emsp;	•	上半部，对应硬中断，由硬件触发中断，用来快速处理中断；<br>&emsp;&emsp;	•	下半部，对应软中断，由内核触发中断，用来异步处理上半部未完成的工作；<br>&emsp;&emsp;Linux 中的软中断包括网络收发、定时、调度、RCU 锁等各种类型，可以通过查看 /proc/softirqs 来观察软中断的累计中断次数情况，如果要实时查看中断次数的变化率，可以使用 watch -d cat /proc/softirqs 命令。<br>&emsp;&emsp;每一个 CPU 都有各自的软中断内核线程，我们还可以用 ps 命令来查看内核线程，一般名字在中括号里面到，都认为是内核线程。<br>&emsp;&emsp;如果在 top 命令发现，CPU 在软中断上的使用率比较高，而且 CPU 使用率最高的进程也是软中断 ksoftirqd 的时候，这种一般可以认为系统的开销被软中断占据了。<br>&emsp;&emsp;这时我们就可以分析是哪种软中断类型导致的，一般来说都是因为网络接收软中断导致的，如果是的话，可以用 sar 命令查看是哪个网卡的有大量的网络包接收，再用 tcpdump 抓网络包，做进一步分析该网络包的源头是不是非法地址，如果是就需要考虑防火墙增加规则，如果不是，则考虑硬件升级等。<hr><hr>2.7 0.1 + 0.2 == 0.3 ?<hr>前面提到过，并不是所有小数都可以用「完整」的二进制来表示的，比如十进制 0.1 在转换成二进制小数的时候，是一串无限循环的二进制数，计算机是无法表达无限循环的二进制数的，毕竟计算机的资源是有限。<br>&emsp;&emsp;因此，计算机只能用「近似值」来表示该二进制，那么意味着计算机存放的小数可能不是一个真实值。<br>&emsp;&emsp;现在基本都是用 IEEE 754 规范的「单精度浮点类型」或「双精度浮点类型」来存储小数的，根据精度的不同，近似值也会不同。<br>&emsp;&emsp;那计算机是存储 0.1 是一个怎么样的二进制浮点数呢？<br>&emsp;&emsp;偷个懒，我就不自己手动算了，可以使用 binaryconvert 这个工具，将十进制 0.1 小数转换成 float 浮点数：<br>&emsp;&emsp;￼<br>&emsp;&emsp;可以看到，8 位指数部分是 <font color=#4D647F>01111011</font>，23 位的尾数部分是 <font color=#4D647F>10011001100110011001101</font>，可以看到尾数部分是 <font color=#4D647F>0011</font> 是一直循环的，只不过尾数是有长度限制的，所以只会显示一部分，所以是一个近似值，精度十分有限。<br>&emsp;&emsp;接下来，我们看看 0.2 的 float 浮点数：<br>&emsp;&emsp;￼<br>&emsp;&emsp;可以看到，8 位指数部分是 <font color=#4D647F>01111100</font>，稍微和 0.1 的指数不同，23 位的尾数部分是 <font color=#4D647F>10011001100110011001101</font> 和 0.1 的尾数部分是相同的，也是一个近似值。<br>&emsp;&emsp;0.1 的二进制浮点数转换成十进制的结果是 <font color=#4D647F>0.100000001490116119384765625</font>：<br>&emsp;&emsp;￼<br>&emsp;&emsp;0.2 的二进制浮点数转换成十进制的结果是 <font color=#4D647F>0.20000000298023223876953125</font>：<br>&emsp;&emsp;￼<br>&emsp;&emsp;这两个结果相加就是 <font color=#4D647F>0.300000004470348358154296875</font>：<br>&emsp;&emsp;￼<br>&emsp;&emsp;所以，你会看到<font color=#374EF4>在计算机中</font><font color=#374EF4> 0.1 + 0.2 </font><font color=#374EF4>并不等于完整的</font><font color=#374EF4> 0.3</font>。<br>&emsp;&emsp;这主要是<font color=#374EF4>因为有的小数无法可以用「完整」的二进制来表示，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数</font>。<br>&emsp;&emsp;我们在 JavaScript 里执行 0.1 + 0.2，你会得到下面这个结果：<br>&emsp;&emsp;￼<br>&emsp;&emsp;结果和我们前面推到的类似，因为 JavaScript 对于数字都是使用 IEEE 754 标准下的双精度浮点类型来存储的。<br>&emsp;&emsp;而我们二进制只能精准表达 2 除尽的数字 1/2, 1/4, 1/8，但是对于 0.1(1/10) 和 0.2(1/5)，在二进制中都无法精准表示时，需要根据精度舍入。<br>&emsp;&emsp;我们人类熟悉的十进制运算系统，可以精准表达 2 和 5 除尽的数字，例如 1/2, 1/4, 1/5(0.2), 1/8, 1/10(0.1)。<br>&emsp;&emsp;当然，十进制也有无法除尽的地方，例如 1/3, 1/7，也需要根据精度舍入。<hr><hr>2.7 为什么 0.1 + 0.2 不等于 0.3 ？<hr>我们来思考几个问题：<br>&emsp;&emsp;	•	为什么负数要用补码表示？<br>&emsp;&emsp;	•	十进制小数怎么转成二进制？<br>&emsp;&emsp;	•	计算机是怎么存小数的？<br>&emsp;&emsp;	•	0.1 + 0.2 == 0.3 吗？<br>&emsp;&emsp;	•	...<br>&emsp;&emsp;别看这些问题都看似简单，但是其实还是有点东西的这些问题。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>2.7 为什么负数要用补码表示？<hr>十进制转换二进制的方法相信大家都熟能生巧了，如果你说你还不知道，我觉得你还是太谦虚，可能你只是忘记了，即使你真的忘记了，不怕，贴心的小林在和你一起回忆一下。<br>&emsp;&emsp;十进制数转二进制采用的是<font color=#374EF4>除</font><font color=#374EF4> 2 </font><font color=#374EF4>取余法</font>，比如数字 8 转二进制的过程如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;接着，我们看看「整数类型」的数字在计算机的存储方式，这其实很简单，也很直观，就是将十进制的数字转换成二进制即可。<br>&emsp;&emsp;我们以 <font color=#4D647F>int</font> 类型的数字作为例子，int 类型是 <font color=#4D647F>32</font> 位的，其中<font color=#374EF4>最高位是作为「符号标志位」</font>，正数的符号位是 <font color=#4D647F>0</font>，负数的符号位是 <font color=#4D647F>1</font>，<font color=#374EF4>剩余的</font><font color=#374EF4> 31 </font><font color=#374EF4>位则表示二进制数据</font>。<br>&emsp;&emsp;那么，对于 int 类型的数字 1 的二进制数表示如下：<br>&emsp;&emsp;￼<br>&emsp;&emsp;而负数就比较特殊了点，负数在计算机中是以「补码」表示的，<font color=#374EF4>所谓的补码就是把正数的二进制全部取反再加</font><font color=#374EF4> 1</font>，比如 -1 的二进制是把数字 1 的二进制取反后再加 1，如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;不知道你有没有想过，为什么计算机要用补码的方式来表示负数？在回答这个问题前，我们假设不用补码的方式来表示负数，而只是把最高位的符号标志位变为 1 表示负数，如下图过程：<br>&emsp;&emsp;￼<br>&emsp;&emsp;如果采用这种方式来表示负数的二进制的话，试想一下 <font color=#4D647F>-2 + 1</font> 的运算过程，如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;按道理，<font color=#4D647F>-2 + 1 = -1</font>，但是上面的运算过程中得到结果却是 <font color=#4D647F>-3</font>，所可以发现，这种负数的表示方式是不能用常规的加法来计算了，就需要特殊处理，要先判断数字是否为负数，如果是负数就要把加法操作变成减法操作才可以得到正确对结果。<br>&emsp;&emsp;到这里，我们就可以回答前面提到的「负数为什么要用补码方式来表示」的问题了。<br>&emsp;&emsp;如果负数不是使用补码的方式表示，则在做基本对加减法运算的时候，<font color=#374EF4>还需要多一步操作来判断是否为负数，如果为负数，还得把加法反转成减法，或者把减法反转成加法</font>，这就非常不好了，毕竟加减法运算在计算机里是很常使用的，所以为了性能考虑，应该要尽量简化这个运算过程。<br>&emsp;&emsp;<font color=#374EF4>而用了补码的表示方式，对于负数的加减法操作，实际上是和正数加减法操作一样的</font>。你可以看到下图，用补码表示的负数在运算 <font color=#4D647F>-2 + 1</font> 过程的时候，其结果是正确的：<br>&emsp;&emsp;￼<hr><hr>2.7 十进制小数与二进制的转换<hr>好了，整数十进制转二进制我们知道了，接下来看看小数是怎么转二进制的，小数部分的转换不同于整数部分，它采用的是<font color=#374EF4>乘</font><font color=#374EF4> 2 </font><font color=#374EF4>取整法</font>，将十进制中的小数部分乘以 2 作为二进制的一位，然后继续取小数部分乘以 2 作为下一位，直到不存在小数为止。<br>&emsp;&emsp;话不多说，我们就以 <font color=#4D647F>8.625</font> 转二进制作为例子，直接上图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;最后把「整数部分 + 小数部分」结合在一起后，其结果就是 <font color=#4D647F>1000.101</font>。<br>&emsp;&emsp;但是，并不是所有小数都可以用二进制表示，前面提到的 0.625 小数是一个特例，刚好通过乘 2 取整法的方式完整的转换成二进制。<br>&emsp;&emsp;如果我们用相同的方式，来把 <font color=#4D647F>0.1</font> 转换成二进制，过程如下：<br>&emsp;&emsp;￼<br>&emsp;&emsp;可以发现，<font color=#4D647F>0.1</font> 的二进制表示是无限循环的。<br>&emsp;&emsp;<font color=#374EF4>由于计算机的资源是有限的，所以是没办法用二进制精确的表示</font><font color=#374EF4> 0.1</font><font color=#374EF4>，只能用「近似值」来表示，就是在有限的精度情况下，最大化接近</font><font color=#374EF4> 0.1 </font><font color=#374EF4>的二进制数，于是就会造成精度缺失的情况</font>。<br>&emsp;&emsp;对于二进制小数转十进制时，需要注意一点，小数点后面的指数幂是<font color=#374EF4>负数</font>。<br>&emsp;&emsp;比如，二进制 <font color=#4D647F>0.1</font> 转成十进制就是 <font color=#4D647F>2^(-1)</font>，也就是十进制 <font color=#4D647F>0.5</font>，二进制 <font color=#4D647F>0.01</font> 转成十进制就是 <font color=#4D647F>2^-2</font>，也就是十进制 <font color=#4D647F>0.25</font>，以此类推。<br>&emsp;&emsp;举个例子，二进制 <font color=#4D647F>1010.101</font> 转十进制的过程，如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>2.7 总结<hr>总结<br>&emsp;&emsp;最后，再来回答开头的问题。<br>&emsp;&emsp;为什么负数要用补码表示？<br>&emsp;&emsp;负数之所以用补码的方式来表示，主要是为了统一和正数的加减法操作一样，毕竟数字的加减法是很常用的一个操作，就不要搞特殊化，尽量以统一的方式来运算。<br>&emsp;&emsp;十进制小数怎么转成二进制？<br>&emsp;&emsp;十进制整数转二进制使用的是「除 2 取余法」，十进制小数使用的是「乘 2 取整法」。<br>&emsp;&emsp;计算机是怎么存小数的？<br>&emsp;&emsp;计算机是以浮点数的形式存储小数的，大多数计算机都是 IEEE 754 标准定义的浮点数格式，包含三个部分：<br>&emsp;&emsp;	•	符号位：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；<br>&emsp;&emsp;	•	指数位：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，指数位的长度越长则数值的表达范围就越大；<br>&emsp;&emsp;	•	尾数位：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度；<br>&emsp;&emsp;用 32 位来表示的浮点数，则称为单精度浮点数，也就是我们编程语言中的 float 变量，而用 64 位来表示的浮点数，称为双精度浮点数，也就是 double 变量。<br>&emsp;&emsp;0.1 + 0.2 == 0.3 吗？<br>&emsp;&emsp;不是的，0.1 和 0.2 这两个数字用二进制表达会是一个一直循环的二进制数，比如 0.1 的二进制表示为 0.0 0011 0011 0011… （0011 无限循环)，对于计算机而言，0.1 无法精确表达，这是浮点数计算造成精度损失的根源。<br>&emsp;&emsp;因此，IEEE 754 标准定义的浮点数只能根据精度舍入，然后用「近似值」来表示该二进制，那么意味着计算机存放的小数可能不是一个真实值。<br>&emsp;&emsp;0.1 + 0.2 并不等于完整的 0.3，这主要是因为这两个小数无法用「完整」的二进制来表示，只能根据精度舍入，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。<hr><hr>2.7 计算机是怎么存小数的？<hr><font color=#4D647F>1000.101</font> 这种二进制小数是「定点数」形式，代表着小数点是定死的，不能移动，如果你移动了它的小数点，这个数就变了， 就不再是它原来的值了。<br>&emsp;&emsp;然而，计算机并不是这样存储的小数的，计算机存储小数的采用的是<font color=#374EF4>浮点数</font>，名字里的「浮点」表示小数点是可以浮动的。<br>&emsp;&emsp;比如 <font color=#4D647F>1000.101</font> 这个二进制数，可以表示成 <font color=#4D647F>1.000101 x 2^3</font>，类似于数学上的科学记数法。<br>&emsp;&emsp;既然提到了科学计数法，我再帮大家复习一下。<br>&emsp;&emsp;比如有个很大的十进制数 1230000，我们可以也可以表示成 <font color=#4D647F>1.23 x 10^6</font>，这种方式就称为科学记数法。<br>&emsp;&emsp;该方法在小数点左边只有一个数字，而且把这种整数部分没有前导 0 的数字称为<font color=#374EF4>规格化</font>，比如 <font color=#4D647F>1.0 x 10^(-9)</font> 是规格化的科学记数法，而 <font color=#4D647F>0.1 x 10^(-9)</font> 和 <font color=#4D647F>10.0 x 10^(-9)</font> 就不是了。<br>&emsp;&emsp;因此，如果二进制要用到科学记数法，同时要规范化，那么不仅要保证基数为 2，还要保证小数点左侧只有 1 位，而且必须为 1。<br>&emsp;&emsp;所以通常将 <font color=#4D647F>1000.101</font> 这种二进制数，规格化表示成 <font color=#4D647F>1.000101 x 2^3</font>，其中，最为关键的是 000101 和 3 这两个东西，它就可以包含了这个二进制小数的所有信息：<br>&emsp;&emsp;<font color=#4D647F>	•	</font><font color=#4D647F>000101</font> 称为<font color=#374EF4>尾数</font>，即小数点后面的数字；<br>&emsp;&emsp;<font color=#4D647F>	•	</font><font color=#4D647F>3</font> 称为<font color=#374EF4>指数</font>，指定了小数点在数据中的位置；<br>&emsp;&emsp;现在绝大多数计算机使用的浮点数，一般采用的是 IEEE 制定的国际标准，这种标准形式如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;这三个重要部分的意义如下：<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>符号位</font>：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>指数位</font>：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，<font color=#374EF4>指数位的长度越长则数值的表达范围就越大</font>；<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>尾数位</font>：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且<font color=#374EF4>尾数的长度决定了这个数的精度</font>，因此如果要表示精度更高的小数，则就要提高尾数位的长度；<br>&emsp;&emsp;用 <font color=#4D647F>32</font> 位来表示的浮点数，则称为<font color=#374EF4>单精度浮点数</font>，也就是我们编程语言中的 <font color=#4D647F>float</font> 变量，而用 <font color=#4D647F>64</font> 位来表示的浮点数，称为<font color=#374EF4>双精度浮点数</font>，也就是 <font color=#4D647F>double</font> 变量，它们的结构如下：<br>&emsp;&emsp;￼<br>&emsp;&emsp;可以看到：<br>&emsp;&emsp;	•	double 的尾数部分是 52 位，float 的尾数部分是 23 位，由于同时都带有一个固定隐含位（这个后面会说），所以 double 有 53 个二进制有效位，float 有 24 个二进制有效位，所以所以它们的精度在十进制中分别是 <font color=#4D647F>log10(2^53)</font> 约等于 <font color=#4D647F>15.95</font> 和 <font color=#4D647F>log10(2^24)</font> 约等于 <font color=#4D647F>7.22</font> 位，因此 double 的有效数字是 <font color=#4D647F>15~16</font> 位，float 的有效数字是 <font color=#4D647F>7~8</font> 位，这些有效位是包含整数部分和小数部分；<br>&emsp;&emsp;	•	double 的指数部分是 11 位，而 float 的指数位是 8 位，意味着 double 相比 float 能表示更大的数值范围；<br>&emsp;&emsp;那二进制小数，是如何转换成二进制浮点数的呢？<br>&emsp;&emsp;我们就以 <font color=#4D647F>10.625</font> 作为例子，看看这个数字在 float 里是如何存储的。<br>&emsp;&emsp;￼<br>&emsp;&emsp;首先，我们计算出 10.625 的二进制小数为 1010.101。<br>&emsp;&emsp;然后<font color=#374EF4>把小数点，移动到第一个有效数字后面</font>，即将 1010.101 右移 <font color=#4D647F>3</font> 位成 <font color=#4D647F>1.010101</font>，右移 3 位就代表 +3，左移 3 位就是 -3。<br>&emsp;&emsp;<font color=#374EF4>float </font><font color=#374EF4>中的「指数位」就跟这里移动的位数有关系，把移动的位数再加上「偏移量」，</font><font color=#374EF4>float </font><font color=#374EF4>的话偏移量是</font><font color=#374EF4> 127</font><font color=#374EF4>，相加后就是指数位的值了</font>，即指数位这 8 位存的是 <font color=#4D647F>10000010</font>（十进制 130），因此你可以认为「指数位」相当于指明了小数点在数据中的位置。<br>&emsp;&emsp;<font color=#4D647F>1.010101</font> 这个数的<font color=#374EF4>小数点右侧的数字就是</font><font color=#374EF4> float </font><font color=#374EF4>里的「尾数位」</font>，由于尾数位是 23 位，则后面要补充 0，所以最终尾数位存储的数字是 <font color=#4D647F>01010100000000000000000</font>。<br>&emsp;&emsp;在算指数的时候，你可能会有疑问为什么要加上偏移量呢？<br>&emsp;&emsp;前面也提到，指数可能是正数，也可能是负数，即指数是有符号的整数，而有符号整数的计算是比无符号整数麻烦的，所以为了减少不必要的麻烦，在实际存储指数的时候，需要把指数转换成<font color=#374EF4>无符号整数</font>。<br>&emsp;&emsp;float 的指数部分是 8 位，IEEE 标准规定单精度浮点的指数取值范围是 <font color=#4D647F>-126 ~ +127</font>，于是为了把指数转换成无符号整数，就要加个<font color=#374EF4>偏移量</font>，比如 float 的指数偏移量是 <font color=#4D647F>127</font>，这样指数就不会出现负数了。<br>&emsp;&emsp;比如，指数如果是 8，则实际存储的指数是 8 + 127（偏移量）= 135，即把 135 转换为二进制之后再存储，而当我们需要计算实际的十进制数的时候，再把指数减去「偏移量」即可。<br>&emsp;&emsp;细心的朋友肯定发现，移动后的小数点左侧的有效位（即 1）消失了，它并没有存储到 float 里。<br>&emsp;&emsp;这是因为 IEEE 标准规定，二进制浮点数的小数点左侧只能有 1 位，并且还只能是 1，<font color=#374EF4>既然这一位永远都是</font><font color=#374EF4> 1</font><font color=#374EF4>，那就可以不用存起来了</font>。<br>&emsp;&emsp;于是就让 23 位尾数只存储小数部分，然后在计算时会<font color=#374EF4>自动把这个</font><font color=#374EF4> 1 </font><font color=#374EF4>加上，这样就可以节约</font><font color=#374EF4> 1 </font><font color=#374EF4>位的空间，尾数就能多存一位小数，相应的精度就更高了一点</font>。<br>&emsp;&emsp;那么，对于我们在从 float 的二进制浮点数转换成十进制时，要考虑到这个隐含的 1，转换公式如下：<br>&emsp;&emsp;￼<br>&emsp;&emsp;举个例子，我们把下图这个 float 的数据转换成十进制，过程如下：<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>34、在执行malloc申请内存的时候，操作系统是怎么做的？<hr>从操作系统层面上看，malloc是通过两个系统调用来实现的： brk和mmap<br>&emsp;&emsp;<br>&emsp;&emsp;- <font color=#FEAE00>brk</font><font color=#FEAE00>是将进程数据段</font><font color=#FEAE00>(.data)</font><font color=#FEAE00>的最高地址指针向高处移动，这一步可以扩大进程在运行时的堆大小</font><font color=#FEAE00><br>&emsp;&emsp;</font>- <font color=#FEAE00>mmap</font><font color=#FEAE00>是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。</font><br>&emsp;&emsp;<br>&emsp;&emsp;通常，分配的内存<font color=#FEAE00>小于</font><font color=#FEAE00>128k</font><font color=#FEAE00>时，使用</font><font color=#FEAE00>brk</font><font color=#FEAE00>调用来获得虚拟内存，大于</font><font color=#FEAE00>128k</font><font color=#FEAE00>时就使用</font><font color=#FEAE00>mmap</font><font color=#FEAE00>来获得虚拟内存。</font><br>&emsp;&emsp;<br>&emsp;&emsp;进程先通过这两个系统调用获取或者扩大进程的虚拟内存，获得相应的虚拟地址，<font color=#FEAE00>在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成。</font><hr><hr>37、局部性原理你知道吗？主要有哪两大局部性原理？各自是什么？<br>&emsp;&emsp;<br>&emsp;&emsp;图<hr>时间 + 空间 ## <br>&emsp;&emsp;<br>&emsp;&emsp;时间:(指令+数据) 如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行<br>&emsp;&emsp;<br>&emsp;&emsp;空间局部性:(数据: 循环+连续) 一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212344455.png)<hr><hr>4.1 为什么要有<font color=#FEAE00>虚拟内存</font>？<hr>本篇跟大家说说<font color=#FEAE00>内存管理</font>，内存管理还是比较重要的一个环节，理解了它，至少对整个操作系统的工作会有一个初步的轮廓，这也难怪面试的时候常问内存管理。<br>&emsp;&emsp;干就完事，本文的提纲：<br>&emsp;&emsp;￼<hr><hr>45、常见的几种磁盘调度算法<hr>先来先服务, 最短寻道时间, 电梯扫描算法, 循环扫描算法, LOOK, C-LOOK<br>&emsp;&emsp;旋转, 寻道, 数据传输时间<br>&emsp;&emsp;##<br>&emsp;&emsp;读写一个磁盘块的时间的影响因素有：<br>&emsp;&emsp;<br>&emsp;&emsp;- 旋转时间<br>&emsp;&emsp;- 寻道时间<br>&emsp;&emsp;- 的数据传输时间<br>&emsp;&emsp;<br>&emsp;&emsp;其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。<br>&emsp;&emsp;<br>&emsp;&emsp;### 1. 先来先服务<br>&emsp;&emsp;按照磁盘请求的顺序进行调度。<br>&emsp;&emsp;优点是公平和简单。<br>&emsp;&emsp;缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。<br>&emsp;&emsp;### 2. 最短寻道时间优先 shortest seek first SSF<br>&emsp;&emsp;优先调度与当前磁头所在磁道距离最近的磁道。<br>&emsp;&emsp;虽然平均寻道时间比较低，但是不够公平。<br>&emsp;&emsp;饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象<br>&emsp;&emsp;### 3. 电梯扫描算法<br>&emsp;&emsp;总是保持一个方向运行，直到该方向没有请求为止<br>&emsp;&emsp;因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。<br>&emsp;&emsp;缺点是, 中间部分相比其他部分 相应频率高很多<br>&emsp;&emsp;## 4. 循环扫描算法 CSCAN circular scan<br>&emsp;&emsp;快速移动回来<br>&emsp;&emsp;这个过程是很快的，并且返回中途不处理任何请求，该算法的特点，就是磁道只响应一个方向上的请求。<br>&emsp;&emsp;优点: 各个位置磁道相应频率比较均匀<br>&emsp;&emsp;## 5. LOOK C-LOOK 算法<br>&emsp;&emsp;不用移动到最远端, 也可以相应请求<br>&emsp;&emsp;<hr><hr>47、<font color=#FEAE00>抖动</font>你知道是什么吗？它也叫<font color=#FEAE00>颠簸</font>现象<hr>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种<font color=#FEAE00>频繁的页面调度行为称为抖动，或颠簸</font>。产生抖动的主要原因是<font color=#FEAE00>进程频繁访问的页面数目高于可用的物理块数</font>(分配给进程的物理块不够)<br>&emsp;&emsp;<br>&emsp;&emsp;为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率 为了研究为应该为每个进程分配多少个物理块，Denning 提出了<font color=#FEAE00>进程工作集</font>” 的概念<hr><hr>4级流水线的顺序: 指令周期(Instruction Cycle) ?<hr>取址 译码 执行 存储<br>&emsp;&emsp;##<br>&emsp;&emsp;* Fetch: 取出PC中的指令<br>&emsp;&emsp;* Decode: 指令译码 (控制单元)<br>&emsp;&emsp;* Execute：指令执行 (算数逻辑单元)<br>&emsp;&emsp;* Store：数据写会到内存或者寄存器中<hr><hr>50、常见内存分配内存错误<br>&emsp;&emsp;<br>&emsp;&emsp;todo 太长<hr>（1）内存分配未成功，却使用了它。<br>&emsp;&emsp;<br>&emsp;&emsp;编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。<br>&emsp;&emsp;<br>&emsp;&emsp;（2）内存分配虽然成功，但是尚未初始化就引用它。<br>&emsp;&emsp;<br>&emsp;&emsp;犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。<br>&emsp;&emsp;<br>&emsp;&emsp;（3）内存分配成功并且已经初始化，但操作越过了内存的边界。<br>&emsp;&emsp;<br>&emsp;&emsp;例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。<br>&emsp;&emsp;<br>&emsp;&emsp;（4）忘记了释放内存，造成内存泄露。<br>&emsp;&emsp;<br>&emsp;&emsp;含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然挂掉，系统出现提示：内存耗尽。动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。<br>&emsp;&emsp;<br>&emsp;&emsp;（5）释放了内存却继续使用它。常见于以下有三种情况：<br>&emsp;&emsp;<br>&emsp;&emsp;- 程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。<br>&emsp;&emsp;- 函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。<br>&emsp;&emsp;- 使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。<hr><hr>53、ASCII、Unicode和UTF-8编码的区别？<hr>### ASCII<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#FEAE00>ASCII </font><font color=#FEAE00>只有</font><font color=#FEAE00>127</font><font color=#FEAE00>个字符，表示英文字母的大小写、数字和一些符号，</font>但由于其他语言用ASCII 编码表示字节不够，例如：常用中文需要两个字节，且不能和ASCII冲突，中国定制了GB2312编码格式，相同的，其他国家的语言也有属于自己的编码格式。<br>&emsp;&emsp;<br>&emsp;&emsp;### Unicode<br>&emsp;&emsp;<br>&emsp;&emsp;由于每个国家的语言都有属于自己的编码格式，在多语言编辑文本中会出现乱码，这样Unicode应运而生，<font color=#FEAE00>Unicode</font><font color=#FEAE00>就是将这些语言统一到一套编码格式中，通常两个字节表示一个字符</font>，而ASCII是一个字节表示一个字符，这样如果你编译的文本是全英文的，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。<br>&emsp;&emsp;<br>&emsp;&emsp;### UTF-8<br>&emsp;&emsp;<br>&emsp;&emsp;为了解决上述问题，又出现了把Unicode编码转化为“可变长编码”UTF-8编码，UTF-8编码将Unicode字符按数字大小编码为1-6个字节，英文字母被编码成一个字节，常用汉字被编码成三个字节，如果你编译的文本是纯英文的，那么用UTF-8就会非常节省空间，并且ASCII码也是UTF-8的一部分。<br>&emsp;&emsp;<br>&emsp;&emsp;### 三者之间的联系<br>&emsp;&emsp;<br>&emsp;&emsp;搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：<br>&emsp;&emsp;<br>&emsp;&emsp;(1) <font color=#FEAE00>在计算机内存中，统一使用</font><font color=#FEAE00>Unicode</font><font color=#FEAE00>编码，当需要保存到硬盘或者需要传输的时候，就转换为</font><font color=#FEAE00>UTF-8</font><font color=#FEAE00>编码</font><font color=#FEAE00><br>&emsp;&emsp;</font><br>&emsp;&emsp;(2)用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。如下图（截取他人图片）<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212345239.png)<br>&emsp;&emsp;<br>&emsp;&emsp;浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212345501.png)<hr><hr>54、原子操作的是如何实现的 CAS<br>&emsp;&emsp;<br>&emsp;&emsp;todo 好底层<hr>处理器使用基于对<font color=#FEAE00>缓存加锁或总线加锁的方式</font>来实现多处理器之间的原子操作。首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。Pentium 6和最新的处理器能自动保证单处理器对<font color=#FEAE00>同一个缓存行</font>里进行16/32/64位的操作是原子的，但是复杂的内存操作处理器是不能自动保证其原子性的，比如<font color=#FEAE00>跨总线宽度、跨多个缓存行和跨页表</font>的访问。但是，处理器提供<font color=#FEAE00>总线锁定和缓存锁定</font>两个机制来保证复杂内存操作的原子性。<br>&emsp;&emsp;<br>&emsp;&emsp;（1）<font color=#FEAE00>使用总线锁保证原子性</font><font color=#FEAE00> </font>第一个机制是通过<font color=#FEAE00>总线锁保证原子性</font>。如果多个处理器同时对共享变量进行读改写操作（i++就是经典的读改写操作），那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致<br>&emsp;&emsp;<br>&emsp;&emsp;原因可能是<font color=#FEAE00>多个处理器同时从各自的缓存中</font>读取变量i，分别进行<font color=#FEAE00>加</font><font color=#FEAE00>1</font><font color=#FEAE00>操作，然后分别写入系统内存中</font>。那么，想要保证读改写共享变量的操作是原子的，就必须保证<font color=#FEAE00>CPU1</font><font color=#FEAE00>读改写共享变量的时候，</font><font color=#FEAE00>CPU2</font><font color=#FEAE00>不能操作缓存了该共享变量内存地址的缓存</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;处理器使用总线锁就是来解决这个问题的。所谓总线锁就是使用处理器提供的<font color=#FEAE00>一个</font><font color=#FEAE00>LOCK</font><font color=#FEAE00>＃信号</font>，当一个处理器在总线上输出此信号时，其他处理器的请求将被<font color=#FEAE00>阻塞住</font>，那么该处理器可以独占共享内存。<br>&emsp;&emsp;<br>&emsp;&emsp;（2）<font color=#FEAE00>使用缓存锁保证原子性</font> 第二个机制是通过<font color=#FEAE00>缓存锁定来保证原子性</font>。在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但<font color=#FEAE00>总线锁定把</font><font color=#FEAE00>CPU</font><font color=#FEAE00>和内存之间的通信锁住了</font>，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。<br>&emsp;&emsp;<br>&emsp;&emsp;频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在Pentium 6和目前的处理器中可以使用“<font color=#FEAE00>缓存锁定</font>”的方式来实现复杂的原子性。<br>&emsp;&emsp;<br>&emsp;&emsp;所谓“<font color=#FEAE00>缓存锁定”</font>是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为<font color=#FEAE00>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据</font>，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效，在如上图所示的例子中，当CPU1修改缓存行中的i时使用了缓存锁定，那么CPU2就不能使用同时缓存i的缓存行。<br>&emsp;&emsp;<br>&emsp;&emsp;但是有两种情况下处理器不会使用缓存锁定。 第一种情况是：当操作的数据不能被缓存在处理器内部，或<font color=#FEAE00>操作的数据跨多个缓存行（</font><font color=#FEAE00>cache line</font><font color=#FEAE00>）时，则处理器会调用总线锁定</font>。 第二种情况是：有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。<hr><hr>58、<font color=#FEAE00>共享</font>是什么？<hr>共享是指<font color=#FEAE00>系统中的资源</font>可以被多个并发进程共同使用。<br>&emsp;&emsp;<br>&emsp;&emsp;有两种共享方式：<font color=#FEAE00>互斥共享和同时共享</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;互斥共享的资源称为<font color=#FEAE00>临界资源</font>，例如打印机等，在同一时刻只允许一个进程访问，需要用<font color=#FEAE00>同步机制</font>来实现互斥访问。<hr><hr>63、冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）<hr>存储 控制 运算 输入 输出 总线(控制 数据 地址) ## <br>&emsp;&emsp;- 存储器：内存<br>&emsp;&emsp;- 控制器：南桥北桥<br>&emsp;&emsp;- 运算器：CPU<br>&emsp;&emsp;- 输入设备：键盘<br>&emsp;&emsp;- 输出设备：显示器、网卡<br>&emsp;&emsp;<br>&emsp;&emsp;3个总线<br>&emsp;&emsp;* 控制总线：用于发送和接收信号，比如中断 、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线<br>&emsp;&emsp;* 数据总线<br>&emsp;&emsp;* 地址总线<hr><hr>8.1 键盘敲入 A 字母时，操作系统期间发生了什么？<br>&emsp;&emsp;<hr>键盘可以说是我们最常使用的输入硬件设备了，但身为程序员的你，你知道「<font color=#FEAE00>键盘敲入</font><font color=#FEAE00>A </font><font color=#FEAE00>字母时，操作系统期间发生了什么吗</font><font color=#FEAE00>」？</font><br>&emsp;&emsp;那要想知道这个发生的过程，我们得先了解了解「操作系统是如何管理多种多样的的输入输出设备」的，等了解完这个后，我们再来看看这个问题，你就会发现问题已经被迎刃而解了。<br>&emsp;&emsp;￼<hr><hr>CPU Cache 有多快？<hr>你可能会好奇为什么有了内存，还需要 CPU Cache？根据摩尔定律，CPU 的访问速度每 18 个月就会翻倍，相当于每年增长 60% 左右，内存的速度当然也会不断增长，但是增长的速度远小于 CPU，平均每年只增长 7% 左右。于是，CPU 与内存的访问性能的差距不断拉大。<br>&emsp;&emsp;到现在，一次内存访问所需时间是 <font color=#4D647F>200~300</font> 多个时钟周期，这意味着 CPU 和内存的访问速度已经相差 <font color=#4D647F>200~300</font> 多倍了。<br>&emsp;&emsp;为了弥补 CPU 与内存两者之间的性能差异，就在 CPU 内部引入了 CPU Cache，也称高速缓存。<br>&emsp;&emsp;CPU Cache 通常分为大小不等的三级缓存，分别是 <font color=#374EF4>L1 Cache</font><font color=#374EF4>、</font><font color=#374EF4>L2 Cache </font><font color=#374EF4>和</font><font color=#374EF4> L3 Cache</font>。<br>&emsp;&emsp;由于 CPU Cache 所使用的材料是 SRAM，价格比内存使用的 DRAM 高出很多，在当今每生产 1 MB 大小的 CPU Cache 需要 7 美金的成本，而内存只需要 0.015 美金的成本，成本方面相差了 466 倍，所以 CPU Cache 不像内存那样动辄以 GB 计算，它的大小是以 KB 或 MB 来计算的。<br>&emsp;&emsp;在 Linux 系统中，我们可以使用下图的方式来查看各级 CPU Cache 的大小，比如我这手上这台服务器，离 CPU 核心最近的 L1 Cache 是 32KB，其次是 L2 Cache 是 256KB，最大的 L3 Cache 则是 3MB。<br>&emsp;&emsp;￼<br>&emsp;&emsp;其中，<font color=#374EF4>L1 Cache </font><font color=#374EF4>通常会分为「数据缓存」和「指令缓存」</font>，这意味着数据和指令在 L1 Cache 这一层是分开缓存的，上图中的 <font color=#4D647F>index0</font> 也就是数据缓存，而 <font color=#4D647F>index1</font> 则是指令缓存，它两的大小通常是一样的。<br>&emsp;&emsp;另外，你也会注意到，L3 Cache 比 L1 Cache 和 L2 Cache 大很多，这是因为 <font color=#374EF4>L1 Cache </font><font color=#374EF4>和</font><font color=#374EF4> L2 Cache </font><font color=#374EF4>都是每个</font><font color=#374EF4> CPU </font><font color=#374EF4>核心独有的，而</font><font color=#374EF4> L3 Cache </font><font color=#374EF4>是多个</font><font color=#374EF4> CPU </font><font color=#374EF4>核心共享的。</font><br>&emsp;&emsp;程序执行时，会先将内存中的数据加载到共享的 L3 Cache 中，再加载到每个核心独有的 L2 Cache，最后进入到最快的 L1 Cache，之后才会被 CPU 读取。它们之间的层级关系，如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;越靠近 CPU 核心的缓存其访问速度越快，CPU 访问 L1 Cache 只需要 <font color=#4D647F>2~4</font> 个时钟周期，访问 L2 Cache 大约 <font color=#4D647F>10~20</font> 个时钟周期，访问 L3 Cache 大约 <font color=#4D647F>20~60</font> 个时钟周期，而访问内存速度大概在 <font color=#4D647F>200~300</font> 个 时钟周期之间。如下表格：<br>&emsp;&emsp;￼<br>&emsp;&emsp;<font color=#374EF4>所以，</font><font color=#374EF4>CPU </font><font color=#374EF4>从</font><font color=#374EF4> L1 Cache </font><font color=#374EF4>读取数据的速度，相比从内存读取的速度，会快</font><font color=#374EF4> </font><font color=#4D647F>100</font><font color=#374EF4> </font><font color=#374EF4>多倍。</font><br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>CPU Cache 的数据结构和读取过程是什么样的？<hr>我们先简单了解下 CPU Cache 的结构，CPU Cache 是由很多个 Cache Line 组成的，Cache Line 是 CPU 从内存读取数据的基本单位，而 Cache Line 是由各种标志（Tag）+ 数据块（Data Block）组成，你可以在下图清晰的看到：<br>&emsp;&emsp;￼<br>&emsp;&emsp;CPU Cache 的数据是从内存中读取过来的，它是以一小块一小块读取数据的，而不是按照单个数组元素来读取数据的，在 CPU Cache 中的，这样一小块一小块的数据，称为 <font color=#374EF4>Cache Line</font><font color=#374EF4>（缓存块）</font>。<br>&emsp;&emsp;你可以在你的 Linux 系统，用下面这种方式来查看 CPU 的 Cache Line，你可以看我服务器的 L1 Cache Line 大小是 64 字节，也就意味着 <font color=#374EF4>L1 Cache </font><font color=#374EF4>一次载入数据的大小是</font><font color=#374EF4> 64 </font><font color=#374EF4>字节</font>。<br>&emsp;&emsp;￼<br>&emsp;&emsp;比如，有一个 <font color=#4D647F>int array</font><font color=#4D647F>[</font><font color=#4D647F>100</font><font color=#4D647F>]</font> 的数组，当载入 <font color=#4D647F>array</font><font color=#4D647F>[</font><font color=#4D647F>0</font><font color=#4D647F>]</font> 时，由于这个数组元素的大小在内存只占 4 字节，不足 64 字节，CPU 就会<font color=#374EF4>顺序加载</font>数组元素到 <font color=#4D647F>array</font><font color=#4D647F>[</font><font color=#4D647F>15</font><font color=#4D647F>]</font>，意味着 <font color=#4D647F>array</font><font color=#4D647F>[</font><font color=#4D647F>0</font><font color=#4D647F>]</font><font color=#4D647F>~array</font><font color=#4D647F>[</font><font color=#4D647F>15</font><font color=#4D647F>]</font> 数组元素都会被缓存在 CPU Cache 中了，因此当下次访问这些数组元素时，会直接从 CPU Cache 读取，而不用再从内存中读取，大大提高了 CPU 读取数据的性能。<br>&emsp;&emsp;事实上，CPU 读取数据的时候，无论数据是否存放到 Cache 中，CPU 都是先访问 Cache，只有当 Cache 中找不到数据时，才会去访问内存，并把内存中的数据读入到 Cache 中，CPU 再从 CPU Cache 读取数据。<br>&emsp;&emsp;￼<br>&emsp;&emsp;这样的访问机制，跟我们使用「内存作为硬盘的缓存」的逻辑是一样的，如果内存有缓存的数据，则直接返回，否则要访问龟速一般的硬盘。<br>&emsp;&emsp;那 CPU 怎么知道要访问的内存数据，是否在 Cache 里？如果在的话，如何找到 Cache 对应的数据呢？我们从最简单、基础的<font color=#374EF4>直接映射</font><font color=#374EF4> Cache</font><font color=#374EF4>（</font><font color=#7414AF>Direct Mapped Cache</font><font color=#374EF4>）</font> 说起，来看看整个 CPU Cache 的数据结构和访问逻辑。<br>&emsp;&emsp;前面，我们提到 CPU 访问内存数据时，是一小块一小块数据读取的，具体这一小块数据的大小，取决于 <font color=#4D647F>coherency_line_size</font> 的值，一般 64 字节。在内存中，这一块的数据我们称为<font color=#374EF4>内存块（</font><font color=#7414AF>Block</font><font color=#374EF4>）</font>，读取的时候我们要拿到数据所在内存块的地址。<br>&emsp;&emsp;对于直接映射 Cache 采用的策略，就是把内存块的地址始终「映射」在一个 CPU Cache Line（缓存块） 的地址，至于映射关系实现方式，则是使用「取模运算」，取模运算的结果就是内存块地址对应的 CPU Cache Line（缓存块） 的地址。<br>&emsp;&emsp;举个例子，内存共被划分为 32 个内存块，CPU Cache 共有 8 个 CPU Cache Line，假设 CPU 想要访问第 15 号内存块，如果 15 号内存块中的数据已经缓存在 CPU Cache Line 中的话，则是一定映射在 7 号 CPU Cache Line 中，因为 <font color=#4D647F>15 % 8</font> 的值是 7。<br>&emsp;&emsp;机智的你肯定发现了，使用取模方式映射的话，就会出现多个内存块对应同一个 CPU Cache Line，比如上面的例子，除了 15 号内存块是映射在 7 号 CPU Cache Line 中，还有 7 号、23 号、31 号内存块都是映射到 7 号 CPU Cache Line 中。<br>&emsp;&emsp;￼<br>&emsp;&emsp;因此，为了区别不同的内存块，在对应的 CPU Cache Line 中我们还会存储一个<font color=#374EF4>组标记（</font><font color=#374EF4>Tag</font><font color=#374EF4>）</font>。这个组标记会记录当前 CPU Cache Line 中存储的数据对应的内存块，我们可以用这个组标记来区分不同的内存块。<br>&emsp;&emsp;除了组标记信息外，CPU Cache Line 还有两个信息：<br>&emsp;&emsp;	•	一个是，从内存加载过来的实际存放<font color=#374EF4>数据（</font><font color=#7414AF>Data</font><font color=#374EF4>）</font>。<br>&emsp;&emsp;	•	另一个是，<font color=#374EF4>有效位（</font><font color=#7414AF>Valid bit</font><font color=#374EF4>）</font>，它是用来标记对应的 CPU Cache Line 中的数据是否是有效的，如果有效位是 0，无论 CPU Cache Line 中是否有数据，CPU 都会直接访问内存，重新加载数据。<br>&emsp;&emsp;CPU 在从 CPU Cache 读取数据的时候，并不是读取 CPU Cache Line 中的整个数据块，而是读取 CPU 所需要的一个数据片段，这样的数据统称为一个<font color=#374EF4>字（</font><font color=#7414AF>Word</font><font color=#374EF4>）</font>。那怎么在对应的 CPU Cache Line 中数据块中找到所需的字呢？答案是，需要一个<font color=#374EF4>偏移量（</font><font color=#374EF4>Offset</font><font color=#374EF4>）</font>。<br>&emsp;&emsp;因此，一个内存的访问地址，包括<font color=#374EF4>组标记、</font><font color=#374EF4>CPU Cache Line </font><font color=#374EF4>索引、偏移量</font>这三种信息，于是 CPU 就能通过这些信息，在 CPU Cache 中找到缓存的数据。而对于 CPU Cache 里的数据结构，则是由<font color=#374EF4>索引</font><font color=#374EF4> + </font><font color=#374EF4>有效位</font><font color=#374EF4> + </font><font color=#374EF4>组标记</font><font color=#374EF4> + </font><font color=#374EF4>数据块</font>组成。<br>&emsp;&emsp;￼<br>&emsp;&emsp;如果内存中的数据已经在 CPU Cahe 中了，那 CPU 访问一个内存地址的时候，会经历这 4 个步骤：<br>&emsp;&emsp;	1	根据内存地址中索引信息，计算在 CPU Cahe 中的索引，也就是找出对应的 CPU Cache Line 的地址；<br>&emsp;&emsp;	2	找到对应 CPU Cache Line 后，判断 CPU Cache Line 中的有效位，确认 CPU Cache Line 中数据是否是有效的，如果是无效的，CPU 就会直接访问内存，并重新加载数据，如果数据有效，则往下执行；<br>&emsp;&emsp;	3	对比内存地址中组标记和 CPU Cache Line 中的组标记，确认 CPU Cache Line 中的数据是我们要访问的内存数据，如果不是的话，CPU 就会直接访问内存，并重新加载数据，如果是的话，则往下执行；<br>&emsp;&emsp;	4	根据内存地址中偏移量信息，从 CPU Cache Line 的数据块中，读取对应的字。<br>&emsp;&emsp;到这里，相信你对直接映射 Cache 有了一定认识，但其实除了直接映射 Cache 之外，还有其他通过内存地址找到 CPU Cache 中的数据的策略，比如全相连 Cache （<font color=#7414AF>Fully Associative Cache</font>）、组相连 Cache （<font color=#7414AF>Set Associative Cache</font>）等，这几种策策略的数据结构都比较相似，我们理解了直接映射 Cache 的工作方式，其他的策略如果你有兴趣去看，相信很快就能理解的了。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>CPU cache 缓存的大小和速度? <hr>速度  2-4 10-20 20-60 大小 几十KB往上 * 10<br>&emsp;&emsp;##<br>&emsp;&emsp;L1: 2~4 cycle  几十KB 分为 指令 和 数据缓存<br>&emsp;&emsp;L2: 10~20 cycle 几百KB<br>&emsp;&emsp;L3: 20~60 cycle 几MB<br>&emsp;&emsp;<br>&emsp;&emsp;<hr><hr>CPU 是如何工作的 总结<hr>最后我们再来回答开头的问题。<br>&emsp;&emsp;64 位相比 32 位 CPU 的优势在哪吗？64 位 CPU 的计算性能一定比 32 位 CPU 高很多吗？<br>&emsp;&emsp;64 位相比 32 位 CPU 的优势主要体现在两个方面：<br>&emsp;&emsp;	•	64 位 CPU 可以一次计算超过 32 位的数字，而 32 位 CPU 如果要计算超过 32 位的数字，要分多步骤进行计算，效率就没那么高，但是大部分应用程序很少会计算那么大的数字，所以<font color=#374EF4>只有运算大数字的时候，</font><font color=#374EF4>64 </font><font color=#374EF4>位</font><font color=#374EF4> CPU </font><font color=#374EF4>的优势才能体现出来，否则和</font><font color=#374EF4> 32 </font><font color=#374EF4>位</font><font color=#374EF4> CPU </font><font color=#374EF4>的计算性能相差不大</font>。<br>&emsp;&emsp;	•	64 位 CPU 可以<font color=#374EF4>寻址更大的内存空间</font>，32 位 CPU 最大的寻址地址是 4G，即使你加了 8G 大小的内存，也还是只能寻址到 4G，而 64 位 CPU 最大寻址地址是 <font color=#4D647F>2^64</font>，远超于 32 位 CPU 最大寻址地址的 <font color=#4D647F>2^32</font>。<br>&emsp;&emsp;你知道软件的 32 位和 64 位之间的区别吗？再来 32 位的操作系统可以运行在 64 位的电脑上吗？64 位的操作系统可以运行在 32 位的电脑上吗？如果不行，原因是什么？<br>&emsp;&emsp;64 位和 32 位软件，实际上代表指令是 64 位还是 32 位的：<br>&emsp;&emsp;	•	如果 32 位指令在 64 位机器上执行，需要一套兼容机制，就可以做到兼容运行了。但是<font color=#374EF4>如果</font><font color=#374EF4> 64 </font><font color=#374EF4>位指令在</font><font color=#374EF4> 32 </font><font color=#374EF4>位机器上执行，就比较困难了，因为</font><font color=#374EF4> 32 </font><font color=#374EF4>位的寄存器存不下</font><font color=#374EF4> 64 </font><font color=#374EF4>位的指令</font>；<br>&emsp;&emsp;	•	操作系统其实也是一种程序，我们也会看到操作系统会分成 32 位操作系统、64 位操作系统，其代表意义就是操作系统中程序的指令是多少位，比如 64 位操作系统，指令也就是 64 位，因此不能装在 32 位机器上。<br>&emsp;&emsp;总之，硬件的 64 位和 32 位指的是 CPU 的位宽，软件的 64 位和 32 位指的是指令的位宽。<hr><hr>CPU通过总线执行指令的顺序?<hr>地址(指定) 控制(读/写) 数据(传送)<br>&emsp;&emsp;##<br>&emsp;&emsp;* 通过地址总线指定内存的地址<br>&emsp;&emsp;* 通过控制总线控制 读 / 写<br>&emsp;&emsp;* 通过数据总线传输数据<hr><hr><font color=#FEAE00>I/O </font><font color=#FEAE00>控制</font>方式<hr>在前面我知道，每种设备都有一个设备控制器，控制器相当于一个小 CPU，它可以自己处理一些事情，但有个问题是，当 CPU 给设备发送了一个指令，让设备控制器去读设备的数据，<font color=#FEAE00>它读完的时候，要怎么通知</font><font color=#FEAE00> CPU</font> 呢？<br>&emsp;&emsp;控制器的寄存器一般会有<font color=#FEAE00>状态标记位</font>，用来标识输入或输出操作是否完成。于是，我们想到第一种<font color=#00A2FF>轮询等待</font>的方法，让 CPU 一直查寄存器的状态，直到状态标记为完成，很明显，这种方式非常的傻瓜，它会占用 CPU 的全部时间。<br>&emsp;&emsp;那我们就想到第二种方法 —— <font color=#00A2FF>中断</font>，<font color=#FEAE00>通知操作系统数据已经准备好了</font>。我们一般会有一个硬件的<font color=#00A2FF>中断控制器</font>，当设备完成任务后触发中断到中断控制器，中断控制器就通知 CPU，一个中断产生了，CPU 需要停下当前手里的事情来处理中断。<br>&emsp;&emsp;另外，中断有两种，一种<font color=#00A2FF>软中断</font>，例如代码调用 <font color=#4D647F>INT</font> 指令触发，一种是<font color=#00A2FF>硬件中断</font>，就是硬件通过中断控制器触发的。<br>&emsp;&emsp;但中断的方式对于频繁读写数据的磁盘，并不友好，这样 CPU 容易经常被打断，会占用 CPU 大量的时间。对于这一类设备的问题的解决方法是使用 <font color=#00A2FF>DMA</font><font color=#374EF4>（</font><font color=#7414AF>Direct Memory Access</font><font color=#374EF4>）</font> 功能，它可以使得设备在 CPU 不参与的情况下，能够自行完成把设备 I/O 数据放入到内存。那要实现 DMA 功能要有 「DMA 控制器」硬件的支持。<br>&emsp;&emsp;￼<br>&emsp;&emsp;<font color=#929292>DMA </font><font color=#929292>的工作方式如下：</font><font color=#929292><br>&emsp;&emsp;	•	CPU </font><font color=#929292>需对</font><font color=#929292> DMA </font><font color=#929292>控制器下发指令，告诉它想读取多少数据，读完的数据放在内存的某个地方就可以了；</font><font color=#929292><br>&emsp;&emsp;	•	</font><font color=#929292>接下来，</font><font color=#929292>DMA </font><font color=#929292>控制器会向磁盘控制器发出指令，通知它从磁盘读数据到其内部的缓冲区中，接着磁盘控制器将缓冲区的数据传输到内存；</font><font color=#929292><br>&emsp;&emsp;	•	</font><font color=#929292>当磁盘控制器把数据传输到内存的操作完成后，磁盘控制器在总线上发出一个确认成功的信号到</font><font color=#929292> DMA </font><font color=#929292>控制器；</font><font color=#929292><br>&emsp;&emsp;	•	DMA </font><font color=#929292>控制器收到信号后，</font><font color=#929292>DMA </font><font color=#929292>控制器发中断通知</font><font color=#929292> CPU </font><font color=#929292>指令完成，</font><font color=#929292>CPU </font><font color=#929292>就可以直接用内存里面现成的数据了；</font><br>&emsp;&emsp;可以看到， <font color=#FEAE00>CPU </font><font color=#FEAE00>当要读取磁盘数据的时候，只需给</font><font color=#FEAE00> DMA </font><font color=#FEAE00>控制器发送指令</font>，然后返回去做其他事情，当磁盘数据拷贝到内存后，<font color=#FEAE00>DMA </font><font color=#FEAE00>控制机器通过中断的方式，告诉</font><font color=#FEAE00> CPU </font><font color=#FEAE00>数据已经准备好了</font>，可以从内存读数据了。仅仅在传送开始和结束时需要 CPU 干预。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>IO::Page Cache 与 <font color=#FEAE00>buffer cache</font><hr>执行 free 命令，注意到会有两列名为 buffers 和 cached，也有一行名为 “-/+ buffers/cache”。<br>&emsp;&emsp;~ free -m<br>&emsp;&emsp;             total       used       free     shared    <font color=#FEAE00>buffers     cached</font><br>&emsp;&emsp;Mem:        128956      96440      32515          0       5368      39900<br>&emsp;&emsp;<font color=#FEAE00>-/+ buffers/cache</font>:      51172      77784<br>&emsp;&emsp;Swap:        16002          0      16001<br>&emsp;&emsp;其中，<font color=#FEAE00>cached </font><font color=#FEAE00>列表示当前的页缓存（</font><font color=#FEAE00>Page Cache</font><font color=#FEAE00>）</font>占用量，<font color=#FEAE00>buffers </font><font color=#FEAE00>列表示当前的块缓存（</font><font color=#FEAE00>buffer cache</font>）占用量。<br>&emsp;&emsp;用一句话来解释：<font color=#FEAE00>Page Cache </font><font color=#FEAE00>用于缓存文件的页数据，</font><font color=#FEAE00>buffer cache </font><font color=#FEAE00>用于缓存块设备（如磁盘）的块数据。</font><br>&emsp;&emsp;	•	页是逻辑上的概念，因此 <font color=#FEAE00>Page Cache </font><font color=#FEAE00>是与文件系统同级的；</font><br>&emsp;&emsp;	•	块是物理上的概念，因此 <font color=#FEAE00>buffer cache </font><font color=#FEAE00>是与块设备驱动程序同级的。</font><br>&emsp;&emsp;Page Cache 与 buffer cache 的<font color=#FEAE00>共同目的都是加速数据</font><font color=#FEAE00> I/O</font><font color=#FEAE00>：</font><br>&emsp;&emsp;	•	写数据时首先写到缓存，将写入的<font color=#FEAE00>页标记为</font><font color=#FEAE00> dirty</font>，然后向<font color=#FEAE00>外部存储</font><font color=#FEAE00> flush</font>，也就是缓存写机制中的 <font color=#FEAE00>write-back</font><font color=#FEAE00>（另一种是</font><font color=#FEAE00> write-through</font>，Linux 默认情况下不采用）；<br>&emsp;&emsp;	•	读数据时首先读取缓存，<font color=#FEAE00>如果未命中，再去外部存储读取</font>，并且将读取来的数据也加入缓存。操作系统总是<font color=#FEAE00>积极地将所有空闲内存都用作</font><font color=#FEAE00> Page Cache </font><font color=#FEAE00>和</font><font color=#FEAE00> buffer cache</font>，当内存不够用时也会用 LRU 等算法淘汰缓存页。<br>&emsp;&emsp;在 Linux 2.4 版本的内核之前，Page Cache 与 buffer cache 是完全分离的。但是，块设备大多是磁盘，磁盘上的数据又大多通过文件系统来组织，<font color=#FEAE00>这种设计导致很多数据被缓存了两次，浪费内存</font>。<br>&emsp;&emsp;<font color=#FEAE00>所以在</font><font color=#FEAE00> 2.4 </font><font color=#FEAE00>版本内核之后，两块缓存近似融合在了一起：如果一个文件的页加载到了</font><font color=#FEAE00> Page Cache</font><font color=#FEAE00>，那么同时</font><font color=#FEAE00> buffer cache </font><font color=#FEAE00>只需要维护块指向页的指针就可以了</font>。只有那些没有文件表示的块，或者绕过了文件系统直接操作（如dd命令）的块，才会真正放到 buffer cache 里。<br>&emsp;&emsp;因此，<font color=#00AB8E>我</font><font color=#FEAE00>们现在提起</font><font color=#FEAE00> Page Cache</font><font color=#FEAE00>，基本上都同时指</font><font color=#FEAE00> Page Cache </font><font color=#FEAE00>和</font><font color=#FEAE00> buffer cache </font><font color=#FEAE00>两者，本文之后也不再区分，直接统称为</font><font color=#FEAE00> Page Cache</font><font color=#FEAE00>。</font><br>&emsp;&emsp;下图近似地示出 32-bit Linux 系统中可能的一种 Page Cache 结构，其中<font color=#FEAE00> block size </font><font color=#FEAE00>大小为</font><font color=#FEAE00> 1KB</font><font color=#FEAE00>，</font><font color=#FEAE00>page size </font><font color=#FEAE00>大小为</font><font color=#FEAE00> 4KB</font><font color=#FEAE00>。</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;Page Cache 中的每个文件都是<font color=#FEAE00>一棵基数树</font>（<font color=#FEAE00>radix tree</font><font color=#FEAE00>，本质上是多叉搜索树</font>），树的每个节点都是一个页。根据文件内的偏移量就可以快速定位到所在的页，如下图所示。关于基数树的原理可以参见英文维基，这里就不细说了。<br>&emsp;&emsp;￼<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>IO::Page Cache 与文件<font color=#FEAE00>持久化的一致性</font><font color=#FEAE00>&</font><font color=#FEAE00>可靠性</font><font color=#FEAE00><br>&emsp;&emsp;</font>如何保证可靠性?<hr>现代 Linux 的 Page Cache 正如其名，是对磁盘上 page（页）的内存缓存，同时可以用于读/写操作。<br>&emsp;&emsp;任何系统<font color=#FEAE00>引入缓存，就会引发一致性问题</font>：内存中的<font color=#FEAE00>数据与磁盘中的数据不一致</font>，例如常见后端架构中的 Redis 缓存与 MySQL 数据库就存在一致性问题。<br>&emsp;&emsp;Linux 提供<font color=#FEAE00>多种机制来保证数据一致性</font>，但无论是单机上的内存与磁盘一致性，还是分布式组件中节点 1 与节点 2 、节点 3 的数据一致性问题，理解的关键是 <font color=#FEAE00>trade-off</font><font color=#FEAE00>：吞吐量与数据一致性保证是一对矛盾</font>。<br>&emsp;&emsp;首先，需要我们理解一下文件的数据。<font color=#00AB8E>文件</font><font color=#00AB8E> = </font><font color=#00AB8E>数据</font><font color=#00AB8E> + </font><font color=#00AB8E>元数据</font>。元数据用来描述文件的各种属性，也必须存储在磁盘上。因此，我们说保证文件一致性其实包含了两个方面：<font color=#FEAE00>数据一致</font><font color=#FEAE00>+</font><font color=#FEAE00>元数据一致</font>。<br>&emsp;&emsp;文件的元数据包括：文件大小、创建时间、访问时间、属主属组等信息。<br>&emsp;&emsp;我们考虑如下一致性问题：如果发生<font color=#FEAE00>写操作并且对应的数据在</font><font color=#FEAE00> Page Cache </font>中，那么写操作就会直接作用于 Page Cache 中，此时如果数据还没刷新到磁盘，那么<font color=#FEAE00>内存中的数据就领先于磁盘</font>，此时对应 page 就被称为 <font color=#FEAE00>Dirty page</font>。<br>&emsp;&emsp;当前 Linux 下以两种方式实现文件一致性：<br>&emsp;&emsp;<font color=#374EF4>	</font><font color=#00AB8E>1	Write Through</font><font color=#00AB8E>（写穿）</font>：向用户层提供特定接口，应用程序可<font color=#FEAE00>主动调用接口来保证文件一致性；</font><br>&emsp;&emsp;<font color=#374EF4>	</font><font color=#00AB8E>2	Write back</font><font color=#00AB8E>（写回）</font>：系统中存在<font color=#FEAE00>定期任务</font>（表现形式为内核线程），周期性地同步文件系统中文件脏数据块，这是默认的 Linux 一致性方案；<br>&emsp;&emsp;上述两种方式最终都<font color=#FEAE00>依赖于系统调用</font>，主要分为如下三种系统调用：<br>&emsp;&emsp;<font color=#00AB8E>fsync(fd)</font>：将 fd 代表的文件的脏数据和脏元数据<font color=#FEAE00>全部刷新至磁盘</font>中。<br>&emsp;&emsp;<font color=#00AB8E>fdatasync(fd)</font>：将 fd 代表的文件的脏数据刷新至磁盘，同时<font color=#FEAE00>对必要的元数据刷新至磁盘中</font>，这里所说的<font color=#FEAE00>必要</font>的概念是指：对接下来访问文件有关键作用的信息，如<font color=#FEAE00>文件大小，而文件修改时间等不属于必要信息</font><br>&emsp;&emsp;<font color=#00AB8E>sync()</font>：则是对<font color=#FEAE00>系统中所有的脏的文件数据</font>元数据刷新至磁盘中<br>&emsp;&emsp;上述三种系统调用可以分别由用户进程与内核进程发起。下面我们研究一下内核线程的<font color=#FEAE00>相关特性</font>。<br>&emsp;&emsp;	1	创建的针对回写任务的内核线程数由系统中持久存储设备决定，为每个存储设备创建<font color=#FEAE00>单独的刷新线程</font>；<br>&emsp;&emsp;	2	关于多线程的架构问题，Linux 内核采取了 Lighthttp 的做法，即系统中存在一个管理线程和多个刷新线程（每个持久存储设备对应一个刷新线程）。管理线程监控设备上的脏页面情况，若设备一段时间内没有产生脏页面，就销毁设备上的刷新线程；若监测到设备上有脏页面需要回写且尚未为该设备创建刷新线程，那么创建刷新线程处理脏页面回写。而刷新线程的任务较为单调，只负责将设备中的脏页面回写至持久存储设备中。<br>&emsp;&emsp;	3	刷新线程刷新设备上脏页面大致设计如下：<br>&emsp;&emsp;	◦	每个设备保存<font color=#FEAE00>脏文件链表</font>，保存的是该设备上存储的脏文件的 inode 节点。所谓的回写文件脏页面即回写该 inode 链表上的某些文件的脏页面；<br>&emsp;&emsp;	◦	系统中存在多个回写时机，第一是应用程序主动调用<font color=#FEAE00>回写接口（</font><font color=#FEAE00>fsync</font><font color=#FEAE00>，</font><font color=#FEAE00>fdatasync </font><font color=#FEAE00>以及</font><font color=#FEAE00> sync </font><font color=#FEAE00>等）</font>，第二管理线程周期性地唤醒设备上的回写线程进行回写，第三是某些应用程序/内核任务发现内存不足时要回收部分缓存页面而事先进行脏页面回写，设计一个统一的框架来管理这些回写任务非常有必要。<br>&emsp;&emsp;Write Through 与 Write back 在持久化的可靠性上有所不同：<br>&emsp;&emsp;	•	<font color=#FEAE00>Write Through </font><font color=#FEAE00>以牺牲系统</font><font color=#FEAE00> I/O </font><font color=#FEAE00>吞吐量作为代价</font>，向上层应用确保一旦写入，数据就已经落盘，不会丢失；<br>&emsp;&emsp;	•	<font color=#FEAE00>Write back </font><font color=#FEAE00>在系统发生宕机的情况下无法确保数据已经落盘</font>，因此存在数据丢失的问题。不过，在程序挂了，例如被 kill -9，Page Cache 中的数据操作系统还是会确保落盘；<br>&emsp;&emsp;<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>IO::Page Cache 与<font color=#FEAE00>预读</font><hr>操作系统为基于 Page Cache 的读缓存机制提供<font color=#FEAE00>预读机制</font>（<font color=#EA37E7>PAGE_READAHEAD</font>），一个例子是：<br>&emsp;&emsp;	•	用户线程仅仅请求读取磁盘上文件 A 的 offset 为 0-3KB 范围内的数据，由于磁盘的基本读写单位为 block（4KB），于是操作系统至少会读 0-4KB 的内容，这恰好可以在一个 page 中装下。<br>&emsp;&emsp;	•	但是操作系统出于局部性原理会选择将磁盘块 offset [4KB,8KB)、[8KB,12KB) 以及 [12KB,16KB) 都加载到内存，于是额外在内存中申请了 3 个 page；<br>&emsp;&emsp;下图代表了操作系统的预读机制：<br>&emsp;&emsp;￼<br>&emsp;&emsp;上图中，应用程序利用 read 系统调动读取 4KB 数据，<font color=#FEAE00>实际上内核使用</font><font color=#FEAE00> readahead </font><font color=#FEAE00>机制完成了</font><font color=#FEAE00> 16KB </font><font color=#FEAE00>数据的读取。</font><hr><hr><font color=#FEAE00>IO::Page Cache </font><font color=#313E50>是什么？</font><hr><font color=#313E50>为了理解</font><font color=#313E50> Page Cache</font><font color=#313E50>，我们不妨先看一下</font><font color=#313E50> </font><font color=#FEAE00>Linux </font><font color=#FEAE00>的文件</font><font color=#FEAE00> I/O </font><font color=#FEAE00>系统</font><font color=#313E50>，如下图所示：</font><font color=#313E50><br>&emsp;&emsp;</font>￼<font color=#313E50><br>&emsp;&emsp;</font><font color=#313E50>上图中，红色部分为</font><font color=#313E50> Page Cache</font><font color=#313E50>。可见</font><font color=#313E50> Page Cache </font><font color=#313E50>的本质是</font><font color=#FEAE00>由</font><font color=#FEAE00> Linux </font><font color=#FEAE00>内核管理的内存区域</font><font color=#313E50>。我们</font><font color=#FEAE00>通过</font><font color=#FEAE00> mmap </font><font color=#FEAE00>以及</font><font color=#FEAE00> buffered I/O </font><font color=#FEAE00>将文件读取到内存空间</font><font color=#313E50>实际上都是读取到</font><font color=#313E50> Page Cache </font><font color=#313E50>中。</font><font color=#313E50><br>&emsp;&emsp;</font><hr><hr>IO::Page Cache 的<font color=#FEAE00>优劣势</font><hr>Page Cache 的优势<br>&emsp;&emsp;<font color=#FEAE00>1.</font><font color=#FEAE00>加快数据访问</font><br>&emsp;&emsp;如果数据能够在内存中进行缓存，那么下一次访问就不需要通过磁盘 I/O 了，直接命中内存缓存即可。<br>&emsp;&emsp;由于内存访问比磁盘访问快很多，因此加快数据访问是 Page Cache 的一大优势。<br>&emsp;&emsp;<font color=#FEAE00>2.</font><font color=#FEAE00>减少</font><font color=#FEAE00> I/O </font><font color=#FEAE00>次数，提高系统磁盘</font><font color=#FEAE00> I/O </font><font color=#FEAE00>吞吐量</font><br>&emsp;&emsp;得益于 Page Cache 的缓存以及预读能力，而程序又往往符合局部性原理，因此通过一次 I/O 将多个 page 装入 Page Cache 能够减少磁盘 I/O 次数， 进而提高系统磁盘 I/O 吞吐量。<br>&emsp;&emsp;# <font color=#FEAE00>Page Cache </font><font color=#FEAE00>的劣势</font><br>&emsp;&emsp;page cache 也有其劣势，最直接的缺点是需要<font color=#FEAE00>占用额外物理内存空间</font>，物理内存在比较紧俏的时候可能会导致频繁的 swap 操作，最终导致系统的磁盘 I/O 负载的上升。<br>&emsp;&emsp;Page Cache 的另一个缺陷是对应用层并没有提供很好的管理 API，<font color=#FEAE00>几乎是透明管理</font>。应用层即使想优化 Page Cache 的使用策略也很难进行。因此一些<font color=#FEAE00>应用选择在用户空间实现自己的</font><font color=#FEAE00> page </font><font color=#FEAE00>管理，</font>而不使用 page cache，例如 MySQL InnoDB 存储引擎以 16KB 的页进行管理。<br>&emsp;&emsp;Page Cache 最后一个缺陷是在某些应用场景下比 Direct I/O 多一次磁盘读 I/O 以及磁盘写 I/O。<br>&emsp;&emsp;Direct I/O 即直接 I/O。其名字中的”直接”二字用于区分使用 page cache 机制的缓存 I/O。<br>&emsp;&emsp;	•	缓存文件 I/O：用户空间要读写一个文件并<font color=#FEAE00>不直接</font><font color=#FEAE00>与</font>磁盘交互，而是中间夹了一层缓存，即 page cache；<br>&emsp;&emsp;	•	直接文件 I/O：用户空间读取的文件<font color=#FEAE00>直接</font>与磁盘交互，没有中间 page cache 层；<br>&emsp;&emsp;“直接”在这里还有另一层语义：其他所有技术中，数据至少需要在内核空间存储一份，<font color=#FEAE00>但是在</font><font color=#FEAE00> Direct I/O </font><font color=#FEAE00>技术中，数据直接存储在用户空间中，绕过了内核。</font><br>&emsp;&emsp;Direct I/O 模式如下图所示：<br>&emsp;&emsp;￼<br>&emsp;&emsp;此时用户空间直接通过 DMA 的方式与磁盘以及网卡进行数据拷贝。<br>&emsp;&emsp;<font color=#FEAE00>Direct I/O </font><font color=#FEAE00>的读写非常有特点</font><font color=#FEAE00>：</font><br>&emsp;&emsp;	•	Write 操作：由于其不使用 page cache，所以其进行写文件，如果返回成功，数据就真的落盘了（不考虑磁盘自带的缓存）；<br>&emsp;&emsp;	•	Read 操作：由于其不使用 page cache，每次读操作是真的从磁盘中读取，不会从文件系统的缓存中读取。<hr><hr><font color=#FEAE00>IO::Swap</font> 与<font color=#FEAE00>缺页中断</font><hr><font color=#FEAE00>Swap </font><font color=#FEAE00>机制指的是当物理内存不够用</font>，内存管理单元（Memory Mangament Unit，MMU）需要提供<font color=#FEAE00>调度算法</font>来回收相关内存空间，然后将清理出来的内存空间给当前内存申请方。<br>&emsp;&emsp;Swap 机制存在的本质原因是 Linux 系统提供了<font color=#FEAE00>虚拟内存管理机制</font>，每一个进程认为其独占内存空间，因此所有进程的<font color=#FEAE00>内存空间之和远远大于物理内存</font>。所有进程的内存空间之和超过物理内存的部分就需要交换到磁盘上。<br>&emsp;&emsp;操作系统以 <font color=#FEAE00>page </font><font color=#FEAE00>为单位管理内存</font>，当进程发现需要访问的数据不在内存时，操作系统可能会将数据以页的方式加载到内存中。上述过程被称为<font color=#00AB8E>缺页中断</font>，当操作系统发生缺页中断时，就会通过系统调用将 page 再次读到内存中。<br>&emsp;&emsp;但主内存的空间是有限的，当主内存中不包含可以使用的空间时，操作系统会从选择合适的物理内存页驱逐回磁盘，为新的内存页让出位置，<font color=#FEAE00>选择待驱逐页的过程在操作系统中叫做</font><font color=#00AB8E>页面替换（</font><font color=#00AB8E>Page Replacement</font><font color=#00AB8E>）</font>，替换操作又会触发 swap 机制。<br>&emsp;&emsp;如果<font color=#1DB100>物理内存足够大，那么可能不需要</font><font color=#1DB100> Swap </font><font color=#1DB100>机制</font>，但是 Swap 在这种情况下还是有一定优势：对于有<font color=#FEAE00>发生内存泄漏几率的应用程序</font>（进程），Swap 交换分区更是重要，这可以确保<font color=#FEAE00>内存泄露不至于导致物理内存不够用</font>，最终导致系统崩溃。但内存泄露会引起频繁的 swap，此时非常影响操作系统的性能。<br>&emsp;&emsp;Linux 通过一个 <font color=#FEAE00>swappiness </font>参数来控制 Swap 机制：这个参数值可为 0-100，控制系统 swap 的优先级：<br>&emsp;&emsp;	•	<font color=#FEAE00>高数值：较高频率的</font><font color=#FEAE00> swap</font>，进程不活跃时主动将其转换出物理内存。<br>&emsp;&emsp;	•	<font color=#FEAE00>低数值：较低频率的</font><font color=#FEAE00> swap</font>，这可以确保交互式不因为内存空间频繁地交换到磁盘而提高响应延迟。<br>&emsp;&emsp;# 最后，为什么 <font color=#FEAE00>SwapCached</font> 也是 Page Cache 的一部分？<br>&emsp;&emsp;这是因为当<font color=#FEAE00>匿名页（</font><font color=#FEAE00>Inactive(anon) </font>以及 <font color=#FEAE00>Active(anon)</font>）先被交换（<font color=#FEAE00>swap out</font>）到磁盘上后，然后再加载回（swap in）内存中，由于读入到内存后原来的 <font color=#FEAE00>Swap File </font><font color=#FEAE00>还在</font>，所以 <font color=#FEAE00>SwapCached </font><font color=#FEAE00>也可以认为是</font><font color=#FEAE00> File-backed page</font>，即属于 Page Cache。这个过程如下图所示。<br>&emsp;&emsp;￼<hr><hr><font color=#FEAE00>IO::page </font>与 <font color=#FEAE00>Page Cache</font><hr>page的分类，page cache的回收<br>&emsp;&emsp;<br>&emsp;&emsp;p<font color=#313E50>age </font><font color=#313E50>是内存管理分配的基本单位，</font><font color=#FEAE00> Page Cache </font><font color=#FEAE00>由多个</font><font color=#FEAE00> page </font><font color=#FEAE00>构成</font><font color=#313E50>。</font><font color=#313E50>page </font><font color=#313E50>在操作系统中通常为</font><font color=#FEAE00> 4KB </font><font color=#FEAE00>大小（</font><font color=#FEAE00>32bits/64bits</font><font color=#FEAE00>）</font><font color=#313E50>，而</font><font color=#313E50> Page Cache </font><font color=#313E50>的大小则为</font><font color=#313E50> 4KB </font><font color=#313E50>的整数倍。</font><font color=#313E50><br>&emsp;&emsp;</font><font color=#1B2462>另一方面，并不是所有</font><font color=#1B2462> page </font><font color=#1B2462>都被组织为</font><font color=#1B2462> Page Cache</font><font color=#313E50>。</font><font color=#313E50><br>&emsp;&emsp;</font><font color=#313E50>Linux </font><font color=#313E50>系统上供用户可访问的内存分为两个类型，即：</font><font color=#313E50><br>&emsp;&emsp;</font><font color=#313E50>	•	</font><font color=#00AB8E>File-backed pages</font><font color=#313E50>：</font><font color=#FEAE00>文件备份页</font><font color=#313E50>也就是</font><font color=#313E50> Page Cache </font><font color=#313E50>中的</font><font color=#313E50> page</font><font color=#313E50>，对应于磁盘上的若干数据块；对于这些页最大的问题是</font><font color=#FEAE00>脏页回盘</font><font color=#313E50>；</font><font color=#313E50><br>&emsp;&emsp;</font><font color=#313E50>	•	</font><font color=#00AB8E>Anonymous pages</font><font color=#313E50>：</font><font color=#FEAE00>匿名页</font><font color=#313E50>不对应磁盘上的任何磁盘数据块，它们是</font><font color=#FEAE00>进程的运行是内存空间</font><font color=#313E50>（例如方法栈、局部变量表等属性）；</font><font color=#313E50><br>&emsp;&emsp;</font><font color=#1B2462>为什么</font><font color=#1B2462> Linux </font><font color=#1B2462>不把</font><font color=#1B2462> Page Cache </font><font color=#1B2462>称为</font><font color=#1B2462> </font><font color=#FEAE00>block cache</font><font color=#1B2462>，这不是更好吗？</font><font color=#313E50><br>&emsp;&emsp;</font><font color=#313E50>这是因为从磁盘中加载到内存的数据</font><font color=#FEAE00>不仅仅放在</font><font color=#FEAE00> Page Cache </font><font color=#FEAE00>中，还放在</font><font color=#FEAE00> buffer cache </font><font color=#FEAE00>中。</font><font color=#313E50><br>&emsp;&emsp;</font><font color=#313E50>例如通过</font><font color=#313E50> </font><font color=#FEAE00>Direct I/O</font><font color=#313E50> </font><font color=#313E50>技术的磁盘文件就不会进入</font><font color=#313E50> Page Cache </font><font color=#313E50>中。当然，这个问题也有</font><font color=#313E50> Linux </font><font color=#313E50>历史设计的原因，毕竟这只是一个称呼，含义随着</font><font color=#313E50> Linux </font><font color=#313E50>系统的演进也逐渐不同。</font><font color=#313E50><br>&emsp;&emsp;</font><font color=#313E50>下面比较一下</font><font color=#313E50> File-backed pages </font><font color=#313E50>与</font><font color=#313E50> Anonymous pages </font><font color=#313E50>在</font><font color=#313E50> Swap </font><font color=#313E50>机制下的性能。</font><font color=#313E50><br>&emsp;&emsp;</font><font color=#FEAE00>内存是一种珍惜资源</font><font color=#313E50>，当内存不够用时，内存管理单元（</font><font color=#FEAE00>Memory Mangament Unit</font><font color=#313E50>）需要提供调度算法来回收相关内存空间。内存空间回收的方式通常就是</font><font color=#313E50> </font><font color=#FEAE00>swap</font><font color=#FEAE00>，即交换到持久化存储</font><font color=#313E50>设备上。</font><font color=#313E50><br>&emsp;&emsp;</font><font color=#FEAE00>File-backed pages</font><font color=#FEAE00>（</font><font color=#FEAE00>Page Cache</font><font color=#FEAE00>）</font><font color=#313E50>的内存回收代价较低。</font><font color=#313E50>Page Cache </font><font color=#313E50>通常对应于一个文件上的若干顺序块，因此可以</font><font color=#FEAE00>通过顺序</font><font color=#FEAE00> I/O </font><font color=#FEAE00>的方式落盘</font><font color=#313E50>。另一方面，如果</font><font color=#313E50> Page Cache </font><font color=#313E50>上</font><font color=#FEAE00>没有进行写操作（所谓的没有脏页</font><font color=#313E50>），甚至不会将</font><font color=#313E50> Page Cache </font><font color=#313E50>回盘，因为数据的内容完全可以通过再次读取磁盘文件得到。</font><font color=#313E50><br>&emsp;&emsp;</font><font color=#313E50>Page Cache </font><font color=#313E50>的主要难点在于脏页回盘，这个内容会在后面进行详细说明。</font><font color=#313E50><br>&emsp;&emsp;</font><font color=#313E50>Anonymous pages </font><font color=#313E50>的</font><font color=#FEAE00>内存回收代价较高</font><font color=#313E50>。这是因为</font><font color=#313E50> </font><font color=#FEAE00>Anonymous pages </font><font color=#FEAE00>通常随机地写入</font><font color=#313E50>持久化交换设备</font><font color=#FEAE00>??????</font><font color=#313E50>。另一方面，无论是否有写操作，为了确保数据不丢失，</font><font color=#313E50>Anonymous pages </font><font color=#313E50>在</font><font color=#313E50> </font><font color=#FEAE00>swap </font><font color=#FEAE00>时必须持久化到磁盘</font><font color=#313E50>。</font><font color=#313E50><br>&emsp;&emsp;</font><font color=#1E2C62>#</font><font color=#1E2C62><br>&emsp;&emsp;</font><hr><hr><font color=#313E50>IO::</font><font color=#313E50>如何</font><font color=#FEAE00>查看系统</font><font color=#313E50>的</font><font color=#313E50> Page Cache</font><font color=#313E50>？</font><hr><font color=#313E50>通过读取</font><font color=#313E50> </font><font color=#313F50>/proc/meminfo</font><font color=#313E50> </font><font color=#313E50>文件，能够实时获取系统内存情况：</font><font color=#313E50><br>&emsp;&emsp;</font>$ <font color=#603A1F>cat</font> /proc/meminfo<br>&emsp;&emsp;...<br>&emsp;&emsp;Buffers:            <font color=#603A1F>1224</font> kB<br>&emsp;&emsp;Cached:           <font color=#603A1F>111472</font> kB<br>&emsp;&emsp;SwapCached:        <font color=#603A1F>36364</font> kB<br>&emsp;&emsp;Active:          <font color=#603A1F>6224232</font> kB<br>&emsp;&emsp;Inactive:         <font color=#603A1F>979432</font> kB<br>&emsp;&emsp;Active(anon):    <font color=#603A1F>6173036</font> kB<br>&emsp;&emsp;Inactive(anon):   <font color=#603A1F>927932</font> kB<br>&emsp;&emsp;Active(file):      <font color=#603A1F>51196</font> kB<br>&emsp;&emsp;Inactive(file):    <font color=#603A1F>51500</font> kB<br>&emsp;&emsp;...<br>&emsp;&emsp;Shmem:             <font color=#603A1F>10000</font> kB<br>&emsp;&emsp;...<br>&emsp;&emsp;SReclaimable:      <font color=#603A1F>43532</font> kB<br>&emsp;&emsp;...<br>&emsp;&emsp;<font color=#313E50>根据上面的数据，你可以简单得出这样的公式（等式两边之和都是</font><font color=#313E50> 112696 KB</font><font color=#313E50>）：</font><font color=#313E50><br>&emsp;&emsp;</font><font color=#FEAE00>Buffers + Cached + SwapCached</font> = Active(file) + Inactive(file) + Shmem + SwapCached<br>&emsp;&emsp;<font color=#313E50>两边等式都是</font><font color=#313E50> Page Cache</font><font color=#313E50>，即：</font><font color=#313E50><br>&emsp;&emsp;</font>Page Cache = Buffers + Cached + SwapCached<br>&emsp;&emsp;<font color=#313E50>通过阅读下面的小节，就能够理解为什么</font><font color=#313E50> </font><font color=#FEAE00>SwapCached </font><font color=#FEAE00>与</font><font color=#FEAE00> Buffers </font><font color=#313E50>也是</font><font color=#313E50> Page Cache </font><font color=#313E50>的一部分。</font><hr><hr><font color=#FEAE00>IO::</font><font color=#FEAE00>文件</font><font color=#FEAE00>I/O</font>的种类?  4 个类别对比<hr>文件的读写方式各有千秋，对于文件的 I/O 分类也非常多，常见的有<br>&emsp;&emsp;	<font color=#FEAE00>•	</font><font color=#FEAE00>缓冲与非缓冲</font><font color=#FEAE00> I/O<br>&emsp;&emsp;	•	</font><font color=#FEAE00>直接与非直接</font><font color=#FEAE00> I/O<br>&emsp;&emsp;	•	</font><font color=#FEAE00>阻塞与非阻塞</font><font color=#FEAE00> I/O VS </font><font color=#FEAE00>同步与异步</font><font color=#FEAE00> I/O</font><br>&emsp;&emsp;接下来，分别对这些分类讨论讨论。<br>&emsp;&emsp;# 缓冲与非缓冲 I/O<br>&emsp;&emsp;文件操作的标准库是可以实现数据的缓存，那么<font color=#FEAE00>根据「是否利用标准库缓冲」，可以把文件</font><font color=#FEAE00> I/O </font><font color=#FEAE00>分为缓冲</font><font color=#FEAE00> I/O </font><font color=#FEAE00>和非缓冲</font><font color=#FEAE00> I/O</font>：<br>&emsp;&emsp;	•	<font color=#FEAE00>缓冲</font><font color=#FEAE00> I/O</font>，利用的是<font color=#FEAE00>标准库的缓存</font>实现文件的加速访问，而标准库再通过系统调用访问文件。<br>&emsp;&emsp;	•	<font color=#FEAE00>非缓冲</font><font color=#FEAE00> I/O</font>，直接通过<font color=#FEAE00>系统调用访问文件</font>，不经过标准库缓存。<br>&emsp;&emsp;这里所说的「<font color=#00AB8E>缓冲</font>」特指<font color=#FEAE00>标准库内部实现的缓冲</font>。<br>&emsp;&emsp;比方说，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来，这样做的目的是，减少系统调用的次数，毕竟<font color=#FEAE00>系统调用是有</font><font color=#FEAE00> CPU </font><font color=#FEAE00>上下文切换的开销的</font>。<br>&emsp;&emsp;# 直接与非直接 I/O<br>&emsp;&emsp;我们都知道磁盘 I/O 是非常慢的，所以 Linux 内核为了减少磁盘 I/O 次数，在系统调用后，会把用户数据拷贝到内核中缓存起来，这个<font color=#FEAE00>内核缓存空间</font>也就是「<font color=#FEAE00>页缓存</font>」，只有当缓存满足某些条件的时候，才发起磁盘 I/O 的请求。<br>&emsp;&emsp;那么，<font color=#FEAE00>根据是「否利用操作系统的缓存」，可以把文件</font><font color=#FEAE00> I/O </font><font color=#FEAE00>分为直接</font><font color=#FEAE00> I/O </font><font color=#FEAE00>与非直接</font><font color=#FEAE00> I/O</font>：<br>&emsp;&emsp;	•	<font color=#FEAE00>直接</font><font color=#FEAE00> I/O</font>，不会发生<font color=#FEAE00>内核缓存和用户程序</font>之间数据复制，而是直接经过文件系统访问磁盘。<br>&emsp;&emsp;	•	<font color=#FEAE00>非直接</font><font color=#FEAE00> I/O</font>，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。<br>&emsp;&emsp;如果你在使用文件操作类的系统调用函数时，指定了 <font color=#FEAE00>O_DIRECT</font> 标志，则表示使用直接 I/O。如果没有设置过，默认使用的是非直接 I/O。<br>&emsp;&emsp;如果用了非直接 I/O 进行写数据操作，内核什么情况下才会把缓存数据写入到磁盘？<br>&emsp;&emsp;以下几种场景会<font color=#FEAE00>触发内核缓存的数据写入磁盘</font>：<br>&emsp;&emsp;	•	在调用 <font color=#4D647F>write</font> 的最后，当发现内核缓存的<font color=#FEAE00>数据太多</font>的时候，内核会把数据写到磁盘上；<br>&emsp;&emsp;	•	用户主动调用 <font color=#FEAE00>sync</font>，内核缓存会刷到磁盘上；<br>&emsp;&emsp;	•	当<font color=#FEAE00>内存十分紧张</font>，无法再分配页面时，也会把内核缓存的数据刷到磁盘上；<br>&emsp;&emsp;	•	内核缓存的数据的缓存时间<font color=#FEAE00>超过某个时间时</font>，也会把数据刷到磁盘上；<br>&emsp;&emsp;# <font color=#FEAE00>阻塞与非阻塞</font> I/O VS 同步与异步 I/O<br>&emsp;&emsp;为什么把阻塞 / 非阻塞与同步与异步放一起说的呢？因为它们确实非常相似，也非常容易混淆，不过它们之间的关系还是有点微妙的。<br>&emsp;&emsp;先来看看<font color=#FEAE00>阻塞</font><font color=#FEAE00> I/O</font>，当用户程序执行 <font color=#4D647F>read</font> ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，<font color=#4D647F>read</font> 才会返回。<br>&emsp;&emsp;注意，<font color=#FEAE00>阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程</font>。过程如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;知道了阻塞 I/O ，来看看<font color=#FEAE00>非阻塞</font><font color=#FEAE00> I/O</font>，非阻塞的 read 请求在数据未准备好的情况下立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，<font color=#FEAE00>内核将数据拷贝到应用程序缓冲区，</font><font color=#FEAE00>read </font><font color=#FEAE00>调用才可以获取到结果</font>。过程如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;注意，<font color=#00AB8E>这里最后一次</font><font color=#00AB8E> read </font><font color=#00AB8E>调用，获取数据的过程，是一个同步的过程，是需要等待的过程。这里的同步指的是内核态的数据拷贝到用户程序的缓存区这个过程。</font><br>&emsp;&emsp;举个例子，访问管道或 socket 时，如果设置了 <font color=#FEAE00>O_NONBLOCK</font> 标志，那么就表示使用的是非阻塞 I/O 的方式访问，而不做任何设置的话，默认是阻塞 I/O。<br>&emsp;&emsp;应用程序每次轮询内核的 I/O 是否准备好，感觉有点傻乎乎，因为轮询的过程中，应用程序啥也做不了，只是在循环。<br>&emsp;&emsp;为了解决这种傻乎乎轮询方式，于是 <font color=#FEAE00>I/O </font><font color=#FEAE00>多路复用</font>技术就出来了，如 select、poll，它是通过 I/O 事件分发，当内核数据准备好时，再以事件通知应用程序进行操作。<br>&emsp;&emsp;这个做法大大改善了应用进程对 CPU 的利用率，在没有被通知的情况下，应用进程可以使用 CPU 做其他的事情。<br>&emsp;&emsp;下图是使用 <font color=#FEAE00>select I/O </font>多路复用过程。注意，<font color=#4D647F>read</font> 获取数据的过程（数据从内核态拷贝到用户态的过程），也是一个<font color=#FEAE00>同步的过程</font>，需要等待：<br>&emsp;&emsp;￼<br>&emsp;&emsp;实际上，无论是阻塞 I/O、非阻塞 I/O，还是基于非阻塞 I/O 的多路复用<font color=#FEAE00>都是同步调用。因为它们在</font><font color=#FEAE00> read </font><font color=#FEAE00>调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，</font><font color=#FEAE00>read </font><font color=#FEAE00>调用就会在这个同步过程中等待比较长的时间。</font><br>&emsp;&emsp;而真正的<font color=#1DB100>异步</font><font color=#1DB100> I/O</font><font color=#1DB100> </font>是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都不用等待。<br>&emsp;&emsp;当我们发起 <font color=#1DB100>aio_read </font>之后，就立即返回，内核自动将数据从内核空间拷贝到应用程序空间，这个拷贝过程同样是异步的，内核自动完成的，和前面的同步操作不一样，应用程序并不需要主动发起拷贝动作。过程如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;下面这张图，总结了以上几种 I/O 模型：<br>&emsp;&emsp;￼<br>&emsp;&emsp;在前面我们知道了，I/O 是分为两个过程的：<br>&emsp;&emsp;<font color=#FEAE00>	1	</font><font color=#FEAE00>数据准备的过程</font><font color=#FEAE00><br>&emsp;&emsp;	2	</font><font color=#FEAE00>数据从内核空间拷贝到用户进程缓冲区的过程</font><br>&emsp;&emsp;阻塞 I/O 会阻塞在「过程 1 」和「过程 2」，而非阻塞 I/O 和基于非阻塞 I/O 的多路复用只会阻塞在「过程 2」，所以这三个都可以认为是同步 I/O。<br>&emsp;&emsp;异步 I/O 则不同，「过程 1 」和「过程 2 」都不会阻塞。<br>&emsp;&emsp;用故事去理解这几种 I/O 模型<br>&emsp;&emsp;举个你去饭堂吃饭的例子，你好比用户程序，饭堂好比操作系统。<br>&emsp;&emsp;阻塞 I/O 好比，你去饭堂吃饭，但是饭堂的菜还没做好，然后你就一直在那里等啊等，等了好长一段时间终于等到饭堂阿姨把菜端了出来（数据准备的过程），但是你还得继续等阿姨把菜（内核空间）打到你的饭盒里（用户空间），经历完这两个过程，你才可以离开。<br>&emsp;&emsp;非阻塞 I/O 好比，你去了饭堂，问阿姨菜做好了没有，阿姨告诉你没，你就离开了，过几十分钟，你又来饭堂问阿姨，阿姨说做好了，于是阿姨帮你把菜打到你的饭盒里，这个过程你是得等待的。<br>&emsp;&emsp;基于非阻塞的 I/O 多路复用好比，你去饭堂吃饭，发现有一排窗口，饭堂阿姨告诉你这些窗口都还没做好菜，<font color=#FEAE00>等做好了再通知你，于是等啊等（</font><font color=#FEAE00>select </font><font color=#FEAE00>调用中），</font>过了一会阿姨通知你菜做好了，但是不知道哪个窗口的菜做好了，你自己看吧。于是你只能一个一个窗口去确认，后面发现 5 号窗口菜做好了，于是你让 5 号窗口的阿姨帮你打菜到饭盒里，这个打菜的过程你是要等待的，虽然时间不长。打完菜后，你自然就可以离开了。<br>&emsp;&emsp;<font color=#FEAE00>异步</font><font color=#FEAE00> I/O </font><font color=#FEAE00>好比，你让饭堂阿姨将菜做好并把菜打到饭盒里后，把饭盒送到你面前</font>，整个过程你都不需要任何等待。<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr><font color=#313E50>IO::</font><font color=#313E50>进程写文件时，进程发生了</font><font color=#FEAE00>崩溃</font><font color=#313E50>，已写入的</font><font color=#FEAE00>数据会丢失吗</font><font color=#313E50>？</font><hr><font color=#313E50>答案，是不会的。</font><font color=#313E50><br>&emsp;&emsp;</font>￼<font color=#313E50><br>&emsp;&emsp;</font><font color=#313E50>因为进程在</font><font color=#FEAE00>执行</font><font color=#FEAE00> write </font><font color=#FEAE00>（使用缓冲</font><font color=#FEAE00> IO</font><font color=#FEAE00>）</font><font color=#313E50>系统调用的时候，实际上是将文件数据写到了</font><font color=#FEAE00>内核的</font><font color=#FEAE00> page cache</font><font color=#313E50>，它是</font><font color=#FEAE00>文件系统中用于缓存文件数据的缓冲</font><font color=#313E50>，所以即使</font><font color=#FEAE00>进程崩溃了</font><font color=#313E50>，文件数据还是</font><font color=#FEAE00>保留在内核的</font><font color=#FEAE00> page cache</font><font color=#313E50>，我们读数据的时候，也是从内核的</font><font color=#313E50> page cache </font><font color=#313E50>读取，因此还是依然读的进程崩溃前写入的数据。</font><font color=#313E50><br>&emsp;&emsp;</font><font color=#FEAE00>内核会找个合适的时机</font><font color=#313E50>，将</font><font color=#313E50> page cache </font><font color=#313E50>中的数据</font><font color=#FEAE00>持久化到磁盘</font><font color=#313E50>。但是如果</font><font color=#313E50> page cache </font><font color=#313E50>里的文件数据，在持久化到磁盘化到磁盘之前，系统发生了崩溃，那这部分数据就会丢失了。</font><font color=#313E50><br>&emsp;&emsp;</font><font color=#313E50>当然，</font><font color=#313E50> </font><font color=#313E50>我们也可以在程序里调用</font><font color=#FEAE00> fsync </font><font color=#FEAE00>函数</font><font color=#313E50>，在写文文件的时候，</font><font color=#FEAE00>立刻将文件数据持久化到磁盘</font><font color=#313E50>，这样就可以解决系统崩溃导致的文件数据丢失的问题。</font><hr><hr>IO::阻塞和非阻塞各有什么优缺点? <hr><hr>VFS:: Linux 中目录的<font color=#FEAE00>存储方式</font><hr>在前面，我们知道了一个普通文件是如何存储的，但还有一个特殊的文件，经常用到的<font color=#FEAE00>目录，它是如何保存的呢</font>？<br>&emsp;&emsp;基于 Linux 一切皆文件的设计思想，目录其实也是个文件，你甚至可以通过 <font color=#4D647F>vim</font> 打开它，它也有 inode，inode 里面也是指向一些块。<br>&emsp;&emsp;和普通文件不同的是，<font color=#FEAE00>普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。</font><br>&emsp;&emsp;在目录文件的块中，最简单的保存格式就是<font color=#00AB8E>列表</font>，就是一项一项地将目录下的文件信息（如<font color=#FEAE00>文件名、文件</font><font color=#FEAE00> inode</font><font color=#FEAE00>、文件类型等</font>）列在表里。<br>&emsp;&emsp;列表中每一项就代表该目录下的文件的文件名和对应的 inode，通过这个 inode，就可以找到真正的文件。<br>&emsp;&emsp;￼<br>&emsp;&emsp;通常，第一项是「<font color=#4D647F>.</font>」，表示当前目录，第二项是「<font color=#4D647F>..</font>」，表示上一级目录，接下来就是一项一项的文件名和 inode。<br>&emsp;&emsp;如果一个<font color=#1DB100>目录有超级多的文件</font>，我们要想在这个目录下找文件，按照列表一项一项的找，效率就不高了。<br>&emsp;&emsp;于是，保存目录的格式改成<font color=#1DB100>哈希表</font>，对文件名进行哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。<br>&emsp;&emsp;Linux 系统的 <font color=#FEAE00>ext </font><font color=#FEAE00>文件系统就是采用了哈希表</font>，来保存目录的内容，这种方法的优点是查找非常迅速，插入和删除也较简单，不过需要一些<font color=#FEAE00>预备措施来避免哈希冲突。</font><br>&emsp;&emsp;目录查询是通过在磁盘上<font color=#FEAE00>反复搜索完成</font>，需要不断地进行 I/O 操作，开销较大。所以，为了减少 I/O 操作，把当前使用的文件目录缓存在内存，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了文件系统的访问速度。<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr><font color=#FEAE00>VFS::7.1 1. </font><font color=#FEAE00>文件系统</font>的<font color=#FEAE00>组成：数据结构</font>。<br>&emsp;&emsp;2.什么是目录项？<br>&emsp;&emsp;3.文件系统如何存储在硬盘？<hr><font color=#00AB8E>文件系统</font>是操作系统中负责<font color=#FEAE00>管理持久数据的子系统</font>，说简单点，就是负责把用户的文件<font color=#FEAE00>存到磁盘硬件</font>中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以<font color=#00AB8E>持久化</font>的保存文件。<br>&emsp;&emsp;文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。<br>&emsp;&emsp;Linux 最经典的一句话是：「<font color=#FEAE00>一切皆文件</font>」，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。<br>&emsp;&emsp;Linux 文件系统会为每个文件分配两个数据结构：<font color=#FEAE00>索引节点</font><font color=#00AB8E>（</font><font color=#EA3DD9>index node</font><font color=#00AB8E>）和</font><font color=#FEAE00>目录项</font><font color=#00AB8E>（</font><font color=#EA3BE8>directory entry</font><font color=#00AB8E>）</font>，它们主要用来记录文件的<font color=#FEAE00>元信息和目录层次结构</font>。<br>&emsp;&emsp;	•	<font color=#00AB8E>索引节点</font>，也就是<font color=#1DB100> </font><font color=#EA42D0>inode</font>，用来记录文件的<font color=#FEAE00>元</font>信息，比如 <font color=#FEAE00>inode </font>编号、文件<font color=#FEAE00>大小</font>、访问<font color=#FEAE00>权限</font>、<font color=#FEAE00>创建</font>时间、<font color=#FEAE00>修改</font>时间、<font color=#FEAE00>数据在磁盘的位置</font>等等。索引节点是文件的<font color=#00AB8E>唯一</font>标识，它们之间一一对应，也同样都会被存储在硬盘中，所以<font color=#FEAE00>索引节点同样占用磁盘空间</font><font color=#FEAE00>。</font><br>&emsp;&emsp;	•	<font color=#00AB8E>目录项</font>，也就是 <font color=#EB53DE>dentry</font>，用来记录文件的<font color=#FEAE00>名字</font>、<font color=#FEAE00>索引节点指针</font>以及与其他目录项的<font color=#FEAE00>层级关联关系</font>。多个目录项关联起来，就会形成<font color=#FEAE00>目录结构</font>，但它与索引节点不同的是，<font color=#FEAE00>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存</font><font color=#FEAE00>。</font><br>&emsp;&emsp;由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以<font color=#FEAE00>目录项和索引节点</font>的关系是<font color=#FEAE00>多对一</font>，也就是说，一个文件可以有多个别字。比如，<font color=#00AB8E>硬链接</font>的实现就是多个目录项中的索引节点指向同一个文件。<br>&emsp;&emsp;注意，<font color=#FEAE00>目录也是文件</font>，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。<br>&emsp;&emsp;# <font color=#FEAE00>目录项和目录</font>是一个东西吗？<br>&emsp;&emsp;虽然名字很相近，但是它们不是一个东西，<font color=#00AB8E>目录</font><font color=#FEAE00>是个文件</font>，<font color=#FEAE00>持久化</font>存储在磁盘，而<font color=#00AB8E>目录项</font><font color=#FEAE00>是内核一个数据结构</font>，<font color=#FEAE00>缓存</font>在内存。<br>&emsp;&emsp;如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构<font color=#FEAE00>缓存</font>在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。<br>&emsp;&emsp;注意，<font color=#FEAE00>目录项</font>这个数据结构不只是表示目录，<font color=#FEAE00>也是可以表示文件</font>的。<br>&emsp;&emsp;# 那文件数据是<font color=#FEAE00>如何存储在磁盘</font>的呢？<br>&emsp;&emsp;磁盘读写的最小单位是<font color=#00AB8E>扇区</font>，扇区的大小只有 <font color=#FEAE00>512B</font> 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。<br>&emsp;&emsp;所以，文件系统把多个扇区组成了一个<font color=#00AB8E>逻辑块</font>，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 <font color=#FEAE00>4KB</font>，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。<br>&emsp;&emsp;以上就是<font color=#FEAE00>索引节点、目录项以及文件数据</font>的关系，下面这个图就很好的展示了它们之间的关系：<br>&emsp;&emsp;￼<br>&emsp;&emsp;索引节点是存储在硬盘上的数据，那么为了加速文件的访问，通常会把索引节点加载到内存中。<br>&emsp;&emsp;另外，磁盘进行<font color=#FEAE00>格式化</font>的时候，会被分成<font color=#FEAE00>三个存储区域</font>，分别是超级块、索引节点区和数据块区。<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>超级块</font>，用来存储<font color=#FEAE00>文件系统的详细信息</font>，比如块个数、块大小、空闲块等等。<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>索引节点区</font>，用来存储<font color=#FEAE00>索引节点</font>；<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>数据块区</font>，用来<font color=#FEAE00>存储文件或目录</font>数据；<br>&emsp;&emsp;我们不可能把超级块和索引节点区全部加载到内存，这样内存肯定撑不住，所以只有当需要使用的时候，才将其加载进内存，它们<font color=#FEAE00>加载进内存的时机是不同的：</font><br>&emsp;&emsp;	•	<font color=#00AB8E>超级块：当文件系统挂载时进入内存</font>；<br>&emsp;&emsp;	•	<font color=#00AB8E>索引节点区：当文件被访问时进入内存</font>；<hr><hr>VFS::7.2 虚拟文件系统及映射关系？<br>&emsp;&emsp;vfs种类？3种<hr>文件系统的种类众多，而操作系统希望<font color=#00A2FF>对用户提供一个统一的接口</font>，于是在用户层与文件系统层引入了中间层，这个中间层就称为<font color=#00A2FF>虚拟文件系统</font><font color=#374EF4>（</font><font color=#7414AF>Virtual File System</font><font color=#7414AF>，</font><font color=#7414AF>VFS</font><font color=#374EF4>）。</font><br>&emsp;&emsp;<font color=#00AB8E>VFS</font> 定义了一组所有文件系统都支持的<font color=#FEAE00>数据结构和标准接口</font>，这样程序员不需要了解文件系统的工作原理，只需要<font color=#FEAE00>了解</font><font color=#FEAE00> VFS </font><font color=#FEAE00>提供的统一接口</font>即可。<br>&emsp;&emsp;在 Linux 文件系统中，用户空间、系统调用、<font color=#FEAE00>虚拟机文件系统</font>、缓存、文件系统以及存储之间的关系如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;Linux <font color=#FEAE00>支持的文件系统也不少</font>，根据存储位置的不同，可以把文件系统分为三类：<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>磁盘的文件系统</font>，它是直接把数据存储在磁盘中，比如 <font color=#FEAE00>Ext 2/3/4</font><font color=#FEAE00>、</font><font color=#FEAE00>XFS</font> 等都是这类文件系统。<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>内存的文件系统</font>，这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 <font color=#FEAE00>/proc </font><font color=#FEAE00>和</font><font color=#FEAE00> /sys </font>文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据。<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>网络的文件系统</font>，用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。<br>&emsp;&emsp;文件系统首先要先<font color=#FEAE00>挂载到某个目录</font>才可以正常使用，比如 Linux 系统在启动时，会把<font color=#FEAE00>文件系统挂载到根目录</font>。<hr><hr><font color=#FEAE00>VFS::</font><font color=#FEAE00>文件</font>的<font color=#FEAE00>使用</font><font color=#FEAE00>:(</font><font color=#FEAE00>用户和内核视角</font><font color=#FEAE00>)<br>&emsp;&emsp;</font><font color=#FEAE00>打开文件表</font><font color=#FEAE00>的数据结构</font><font color=#FEAE00><br>&emsp;&emsp;</font><font color=#FEAE00>操作系统操作文件</font><hr>我们从用户角度来看文件的话，就是我们要怎么<font color=#FEAE00>使用文件</font>？首先，我们得通过系统调用来打开一个文件。<br>&emsp;&emsp;￼<br>&emsp;&emsp;fd <font color=#519696>=</font> <font color=#AA5925>open</font>(name, flag); # 打开文件<br>&emsp;&emsp;...<br>&emsp;&emsp;<font color=#AA5925>write</font>(fd,...);         # 写数据<br>&emsp;&emsp;...<br>&emsp;&emsp;<font color=#AA5925>close</font>(fd);             # 关闭文件<br>&emsp;&emsp;上面简单的代码是<font color=#FEAE00>读取一个文件的过程</font>：<br>&emsp;&emsp;	•	首先用 <font color=#4D647F>open</font> 系统调用打开文件，<font color=#4D647F>open</font> 的参数中包含文件的路径名和文件名。<br>&emsp;&emsp;	•	使用 <font color=#4D647F>write</font> 写数据，其中 <font color=#4D647F>write</font> 使用 <font color=#4D647F>open</font> 所返回的<font color=#00AB8E>文件描述符</font>，并不使用文件名作为参数。<br>&emsp;&emsp;	•	使用完文件后，要用 <font color=#4D647F>close</font> 系统调用<font color=#FEAE00>关闭文件</font>，避免<font color=#FEAE00>资源的泄露</font>。<br>&emsp;&emsp;我们打开了一个文件后，操作系统会<font color=#FEAE00>跟踪进程打开的所有文件</font>，所谓的跟踪呢，就是操作系统为每个进程维护一个<font color=#FEAE00>打开文件表</font>，文件表里的每一项代表「<font color=#00AB8E>文件描述符</font>」，所以说文件描述符是打开文件的标识。<br>&emsp;&emsp;￼<br>&emsp;&emsp;操作系统在打开文件表中维护着<font color=#FEAE00>打开文件的状态和信息</font>：<br>&emsp;&emsp;	•	<font color=#1DB100>文件指针</font>：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是<font color=#FEAE00>唯一的</font>；<br>&emsp;&emsp;	•	<font color=#1DB100>文件打开计数器</font>：文件<font color=#FEAE00>关闭时</font>，操作系统必须<font color=#FEAE00>重用其打开文件表条目</font>，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，<font color=#FEAE00>必须等待最后一个进程关闭文件</font><font color=#FEAE00>(???</font><font color=#FEAE00>多个是共用这个表的么</font><font color=#FEAE00>?) </font>，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目；<br>&emsp;&emsp;	•	<font color=#1DB100>文件磁盘位置</font>：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，<font color=#FEAE00>以免每个操作都从磁盘中读取</font>；<br>&emsp;&emsp;	•	<font color=#1DB100>访问权限</font>：每个进程打开文件都需要有一个<font color=#FEAE00>访问模式</font>（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I/O 请求；<br>&emsp;&emsp;在用户视角里，<font color=#FEAE00>文件就是一个持久化的数据结构</font>，但操作系统并不会关心你想存在磁盘上的任何的数据结构，操作系统的视角是<font color=#FEAE00>如何把文件数据和磁盘块对应起来。</font><br>&emsp;&emsp;所以，用户和操作系统对文件的读写操作是有差异的，<font color=#FEAE00>用户习惯以字节</font>的方式读写文件，而<font color=#FEAE00>操作系统则是以数据块</font>来读写文件，那<font color=#00AB8E>屏蔽掉这种差异</font>的工作就是文件系统了。<br>&emsp;&emsp;我们来分别看一下，读文件和写文件的过程：<br>&emsp;&emsp;	•	当<font color=#FEAE00>用户进程</font>从文件读取 <font color=#FEAE00>1 </font><font color=#FEAE00>个字节</font>大小的数据时，<font color=#FEAE00>文件系统</font>则需要获取字节所在的<font color=#FEAE00>数据块</font>，再返回数据块对应的用户进程所需的数据部分。<br>&emsp;&emsp;	•	当用户进程把 1 个字节大小的数据写进文件时，文件系统则找到需要写入数据的数据块的位置，然后修改数据块中对应的部分，最后再把数据块写回磁盘。<br>&emsp;&emsp;所以说，<font color=#00AB8E>文件系统的基本操作单位是数据块</font>。<hr><hr>VFS::文件的<font color=#FEAE00>存储</font><font color=#FEAE00> </font><font color=#FEAE00>连续</font><font color=#FEAE00>/</font><font color=#FEAE00>非连续</font><hr>文件的数据是要存储在硬盘上面的，数据在磁盘上的存放方式，就像程序在内存中存放的方式那样，有以下两种：<br>&emsp;&emsp;	•	<font color=#FEAE00>连续空间</font>存放方式<br>&emsp;&emsp;	•	<font color=#FEAE00>非连续空间</font>存放方式<br>&emsp;&emsp;其中，非连续空间存放方式又可以分为「<font color=#FEAE00>链表方式</font>」和「<font color=#FEAE00>索引方式</font>」。<br>&emsp;&emsp;不同的存储方式，有各自的特点，重点是要分析它们的存储效率和读写性能，接下来分别对每种存储方式说一下。<br>&emsp;&emsp;# <font color=#FEAE00>连续空间存放方式</font><br>&emsp;&emsp;连续空间存放方式顾名思义，<font color=#FEAE00>文件存放在磁盘「连续的」物理空间中</font>。这种模式下，文件的数据都是紧密相连，<font color=#FEAE00>读写效率很高</font>，因为一次磁盘寻道就可以读出整个文件。<br>&emsp;&emsp;使用连续存放的方式有一个前提，必须<font color=#FEAE00>先知道一个文件的大小</font>，这样文件系统才会根据文件的大小在磁盘上找到一块连续的空间分配给文件。<br>&emsp;&emsp;所以，<font color=#00AB8E>文件头里需要指定「起始块的位置」和「长度」</font>，有了这两个信息就可以很好的表示文件存放方式是<font color=#FEAE00>一块连续的磁盘空间</font>。<br>&emsp;&emsp;注意，此处说的文件头，就类似于 Linux 的 <font color=#00AB8E>inode</font>。<br>&emsp;&emsp;￼<br>&emsp;&emsp;连续空间存放的方式虽然读写效率高，<font color=#FEAE00>但是有「磁盘空间碎片」和「文件长度不易扩展」的缺陷。</font><br>&emsp;&emsp;如下图，如果文件 <font color=#FEAE00>B </font><font color=#FEAE00>被删除</font>，磁盘上就留下一块<font color=#FEAE00>空缺</font>，这时，如果新来的文件小于其中的一个空缺，我们就可以将其放在相应空缺里。但如果该文件的<font color=#FEAE00>大小大于所有的空缺</font>，但却小于空缺大小之和，则虽然磁盘上有足够的空缺，但该文件还是不能存放。当然了，我们可以通过<font color=#FEAE00>将现有文件进行挪动来腾出空间以容纳新的文件</font>，但是这个在磁盘挪动文件是非常耗时，所以这种方式不太现实。<br>&emsp;&emsp;￼<br>&emsp;&emsp;另外一个缺陷是<font color=#FEAE00>文件长度扩展不方便</font>，例如上图中的文件 A 要想扩大一下，需要更多的磁盘空间，唯一的办法就只能是<font color=#FEAE00>挪动的方式</font>，前面也说了，这种方式<font color=#FEAE00>效率</font>是<font color=#FEAE00>非常低</font>的。<br>&emsp;&emsp;那么有没有更好的方式来解决上面的问题呢？答案当然有，既然连续空间存放的方式不太行，那么我们就改变存放的方式，使用<font color=#FEAE00>非连续空间存</font>放方式来解决这些缺陷。<br>&emsp;&emsp;# <font color=#FEAE00>非连续空间存放方式</font><br>&emsp;&emsp;非连续空间存放方式分为「<font color=#00AB8E>链表方式</font>」和「<font color=#00AB8E>索引方式</font>」。<br>&emsp;&emsp;我们先来看看链表的方式。<br>&emsp;&emsp;链表的方式存放是<font color=#FEAE00>离散的，不用连续的</font>，于是就可以<font color=#FEAE00>消除磁盘碎片</font>，可大大提高磁盘空间的利用率，同时<font color=#FEAE00>文件的长度可以动态扩展</font>。根据实现的方式的不同，链表可分为「<font color=#FEAE00>隐式链表</font>」和「<font color=#FEAE00>显式链接</font>」两种形式。<br>&emsp;&emsp;文件要以「<font color=#FEAE00>隐式链表</font>」的方式存放的话，<font color=#FEAE00>实现的方式是文件头要包含「第一块」和「最后一块」的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置</font>，这样一个数据块连着一个数据块，从链头开始就可以顺着指针找到所有的数据块，所以存放的方式可以是<font color=#FEAE00>不连续的</font>。<br>&emsp;&emsp;￼<br>&emsp;&emsp;隐式链表的存放方式的<font color=#FEAE00>缺点在于无法直接访问数据块，只能通过指针顺序访问文件，以及数据块指针消耗了一定的存储空间</font>。隐式链接分配的<font color=#FEAE00>稳定性较差</font>，系统在运行过程中由于软件或者硬件错误<font color=#FEAE00>导致链表中的指针丢失或损坏，会导致文件数据的丢失。</font><br>&emsp;&emsp;如果取出<font color=#FEAE00>每个磁盘块的指针</font>，把它放在<font color=#FEAE00>内存的一个表中</font>，就可以解决上述隐式链表的两个不足。那么，这种实现方式是「<font color=#FEAE00>显式链接</font>」，它指<font color=#FEAE00>把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中</font>，该表在整个磁盘仅设置一张，<font color=#FEAE00>每个表项中存放链接指针，指向下一个数据块号</font><font color=#FEAE00>。</font><br>&emsp;&emsp;对于显式链接的工作方式，我们举个例子，文件 A 依次使用了磁盘块 4、7、2、10 和 12 ，文件 B 依次使用了磁盘块 6、3、11 和 14 。利用下图中的表，可以从第 4 块开始，顺着链走到最后，找到文件 A 的全部磁盘块。同样，从第 6 块开始，顺着链走到最后，也能够找出文件 B 的全部磁盘块。最后，这两个链都以一个不属于有效磁盘编号的特殊标记（如 -1 ）结束。内存中的这样一个表格称为<font color=#FEAE00>文件分配表</font><font color=#7414AF>File Allocation Table</font><font color=#7414AF>，</font><font color=#7414AF>FAT</font>。<br>&emsp;&emsp;￼<br>&emsp;&emsp;由于<font color=#FEAE00>查找记录的过程是在内存</font>中进行的，因而不仅显著地<font color=#FEAE00>提高了检索速度</font>，而且<font color=#FEAE00>大大减少了访问磁盘的次数</font>。但也正是整个表都存放在内存中的关系，它的主要的缺点是<font color=#FEAE00>不适用于大磁盘</font>。<br>&emsp;&emsp;比如，对于 200GB 的磁盘和 1KB 大小的块，这张表需要有 <font color=#FEAE00>2 </font><font color=#FEAE00>亿项</font>，每一项对应于这 2 亿个磁盘块中的一个块，每项如果需要 4 个字节，那<font color=#FEAE00>这张表要占用</font><font color=#FEAE00> 800MB </font><font color=#FEAE00>内存</font>，很显然 FAT 方案对于大磁盘而言不太合适。<br>&emsp;&emsp;接下来，我们来看看<font color=#FEAE00>索引</font>的方式。<br>&emsp;&emsp;链表的方式解决了连续分配的磁盘碎片和文件动态扩展的问题，但是不能有效支持直接访问（FAT除外），索引的方式可以解决这个问题。<br>&emsp;&emsp;索引的实现是为每个文件创建一个「<font color=#FEAE00>索引数据块</font>」，里面存放的是<font color=#FEAE00>指向文件数据块的指针列表</font>，说白了就像书的目录一样，要找哪个章节的内容，看目录查就可以。<br>&emsp;&emsp;另外，<font color=#FEAE00>文件头需要包含指向「索引数据块」的指针</font>，这样就可以通过文件头知道索引数据块的位置，再通过索引数据块里的索引信息找到对应的数据块。<br>&emsp;&emsp;创建文件时，<font color=#FEAE00>索引块的所有指针都设为空</font>。当首次写入第 i 块时，先从空闲空间中取得一个块，再将其地址写到索引块的第 i 个条目。<br>&emsp;&emsp;￼<br>&emsp;&emsp;索引的方式优点在于：<br>&emsp;&emsp;	•	文件的<font color=#FEAE00>创建、增大、缩小很方便</font>；<br>&emsp;&emsp;	•	不会有<font color=#FEAE00>碎片</font>的问题；<br>&emsp;&emsp;	•	支持顺序读写和随机读写；<br>&emsp;&emsp;由于<font color=#FEAE00>索引数据也是存放在磁盘块的</font>，如果<font color=#FEAE00>文件很小</font>，明明只需一块就可以存放的下，但还是需要额外分配一块来存放索引数据，所以缺陷之一就是<font color=#FEAE00>存储索引带来的开销。</font><br>&emsp;&emsp;如果文件很大，大到一个索引数据块放不下索引信息，这时又要如何处理大文件的存放呢？我们可以通过<font color=#FEAE00>组合</font>的方式，来处理大文件的存。<br>&emsp;&emsp;先来看看<font color=#FEAE00>链表</font><font color=#FEAE00> + </font><font color=#FEAE00>索引</font>的组合，这种组合称为「<font color=#FEAE00>链式索引块</font>」，它的实现方式是<font color=#FEAE00>在索引数据块留出一个存放下一个索引数据块的指针</font>，于是当一个索引数据块的索引信息用完了，就可以通过指针的方式，找到下一个索引数据块的信息。那这种方式也会出现前面提到的链表方式的问题，万一某个指针损坏了，后面的数据也就会无法读取了。<br>&emsp;&emsp;￼<br>&emsp;&emsp;还有另外一种组合方式是索引 + 索引的方式，这种组合称为「<font color=#FEAE00>多级索引块</font>」，实现方式是<font color=#FEAE00>通过一个索引块来存放多个索引数据块</font>，一层套一层索引，像极了俄罗斯套娃是吧。<br>&emsp;&emsp;￼<br>&emsp;&emsp;# Unix 文件的实现方式<br>&emsp;&emsp;我们先把前面提到的文件实现方式，做个比较：<br>&emsp;&emsp;￼<br>&emsp;&emsp;那早期 Unix 文件系统是<font color=#FEAE00>组合了前面的文件存放方式的优点</font>，如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;它是根据文件的大小，存放的方式会有所变化：<br>&emsp;&emsp;	•	如果存放文件所需的数据块小于 10 块，则采用<font color=#FEAE00>直接查找的方式</font>；<br>&emsp;&emsp;	•	如果存放文件所需的数据块超过 10 块，则采用一级间接索引方式；<br>&emsp;&emsp;	•	如果前面两种方式都不够存放大文件，则采用二级间接索引方式；<br>&emsp;&emsp;	•	如果二级间接索引也不够存放大文件，这采用三级间接索引方式；<br>&emsp;&emsp;那么，文件头（<font color=#7414AF>Inode</font>）就需要包含 <font color=#FEAE00>13 </font><font color=#FEAE00>个指针</font>：<br>&emsp;&emsp;	•	<font color=#FEAE00>10 </font><font color=#FEAE00>个指向数据块</font>的指针；<br>&emsp;&emsp;	•	第 11 个<font color=#FEAE00>指向索引块</font>的指针；<br>&emsp;&emsp;	•	第 12 个指向<font color=#FEAE00>二级索引块</font>的指针；<br>&emsp;&emsp;	•	第 13 个指向<font color=#FEAE00>三级索引块</font>的指针；<br>&emsp;&emsp;所以，这种方式能很灵活地支持小文件和大文件的存放：<br>&emsp;&emsp;	•	对于小文件使用直接查找的方式可减少索引数据块的开销；<br>&emsp;&emsp;	•	对于大文件则以多级索引的方式来支持，所以大文件在访问数据块时需要大量查询；<br>&emsp;&emsp;这个方案就用在了 <font color=#FEAE00>Linux Ext 2/3 </font><font color=#FEAE00>文件系统里，虽然解决大文件的存储</font>，但是对于<font color=#FEAE00>大文件的访问</font>，需要大量的查询，效率比较低。<br>&emsp;&emsp;为了解决这个问题，<font color=#FEAE00>Ext 4 </font><font color=#FEAE00>做了一定的改变</font>，具体怎么解决的，本文就不展开了。<br>&emsp;&emsp;<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>VFS::文件系统的<font color=#FEAE00>结构</font><font color=#FEAE00>: Linux </font><font color=#FEAE00>位图模式的结构</font><hr>前面提到 Linux 是用<font color=#FEAE00>位图</font>的方式管理空闲空间，用户在创建一个新文件时，Linux 内核会通过 inode 的位图找到空闲可用的 inode，并进行分配。要存储数据时，会通过块的位图找到空闲的块，并分配，但仔细计算一下还是有问题的。<br>&emsp;&emsp;数据块的<font color=#FEAE00>位图是放在磁盘块里的</font>，假设是放在一个块里，一个块 4K，每位表示一个数据块，共可以表示 <font color=#4D647F>4 * 1024 * 8 = 2^15</font> 个空闲块，由于<font color=#FEAE00> 1 </font><font color=#FEAE00>个数据块是</font><font color=#FEAE00> 4K </font>大小，那么最大可以表示的空间为 <font color=#4D647F>2^15 * 4 * 1024 = 2^27</font> 个 byte，也就是 <font color=#FEAE00>128M</font><font color=#FEAE00>。</font><br>&emsp;&emsp;也就是说按照上面的结构，如果采用「<font color=#FEAE00>一个块的位图</font><font color=#FEAE00> + </font><font color=#FEAE00>一系列的块</font>」，外加「<font color=#FEAE00>一个块的</font><font color=#FEAE00> inode </font><font color=#FEAE00>的位图</font><font color=#FEAE00> + </font><font color=#FEAE00>一系列的</font><font color=#FEAE00> inode </font><font color=#FEAE00>的结构</font>」能表示的最大空间也就 128M，这太少了，现在很多文件都比这个大。<br>&emsp;&emsp;在 Linux 文件系统，把这个结构称为一个<font color=#FEAE00>块组</font>，那么有 <font color=#FEAE00>N </font><font color=#FEAE00>多的块组，就能够表示</font><font color=#FEAE00> N </font><font color=#FEAE00>大的文件。</font><br>&emsp;&emsp;下图给出了 Linux Ext2 整个文件系统的结构和块组的内容，文件系统都由大量块组组成，在硬盘上相继排布：<br>&emsp;&emsp;￼<br>&emsp;&emsp;最前面的第一个块是<font color=#FEAE00>引导块</font>，在系统启动时用于启用引导，接着后面就是一个一个连续的块组了，块组的内容如下：<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>超级块</font>，包含的是文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>块组描述符</font>，包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>数据位图和</font><font color=#7414AF> inode </font><font color=#7414AF>位图</font>， 用于表示对应的数据块或 inode 是空闲的，还是被使用中。<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>inode </font><font color=#7414AF>列表</font>，包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>数据块</font>，包含文件的有用数据。<br>&emsp;&emsp;你可以会发现每个块组里有很多重复的信息，比如<font color=#00AB8E>超级块和块组描述符表，这两个都是全局信息，而且非常的重要</font>，这么做是有两个原因：<br>&emsp;&emsp;	•	如果<font color=#FEAE00>系统崩溃破坏了超级块或块组描述符</font>，有关文件系统结构和内容的所有信息都会丢失。如果有<font color=#FEAE00>冗余的副本</font>，该信息是可能恢复的。<br>&emsp;&emsp;	•	通过<font color=#FEAE00>使文件和管理数据尽可能接近</font>，<font color=#FEAE00>减少了磁头寻道和旋转</font>，这可以提高文件系统的性能。<br>&emsp;&emsp;不过，Ext2 的后续版本采用了<font color=#FEAE00>稀疏技术</font>。该做法是，超级块和块组描述符表不再存储到文件系统的每个块组中，而是只写入到块组 0、块组 1 和其他 ID 可以表示为 3、 5、7 的幂的块组中。<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr><font color=#FEAE00>VFS::</font><font color=#FEAE00>空闲空间</font>管理 的 三种方法<hr>前面说到的文件的存储是针对已经被占用的数据块组织和管理，接下来的问题是，如果我要<font color=#FEAE00>保存一个数据块</font>，我应该放在硬盘上的<font color=#FEAE00>哪个位置呢</font>？难道需要将所有的块扫描一遍，找个空的地方随便放吗？<br>&emsp;&emsp;那这种方式效率就太低了，所以针对磁盘的空闲空间也是要引入管理的机制，接下来介绍几种常见的方法：<br>&emsp;&emsp;	<font color=#FEAE00>•	</font><font color=#FEAE00>空闲表法</font><font color=#FEAE00><br>&emsp;&emsp;	•	</font><font color=#FEAE00>空闲链表法</font><font color=#FEAE00><br>&emsp;&emsp;	•	</font><font color=#FEAE00>位图法</font><br>&emsp;&emsp;# 空闲表法<br>&emsp;&emsp;空闲表法就是为<font color=#FEAE00>所有空闲空间建立一张表</font>，表内容包括<font color=#FEAE00>空闲区的第一个块号</font>和<font color=#FEAE00>该空闲区的块个数</font>，注意，这个方式是<font color=#FEAE00>连续分配的</font>。如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到<font color=#FEAE00>找到一个合适的空闲区域</font>为止。当用户撤销一个文件时，系统回收文件空间。这时，也需顺序扫描空闲表，寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中。<br>&emsp;&emsp;这种方法仅<font color=#FEAE00>当有少量的空闲区时</font>才有较好的效果。因为，如果存储空间中有着<font color=#FEAE00>大量的小的空闲区，则空闲表变得很大</font>，这样查询效率会很低。另外，这种分配技术适用于<font color=#FEAE00>建立连续文件。</font><br>&emsp;&emsp;# 空闲链表法<br>&emsp;&emsp;我们也可以使用「<font color=#FEAE00>链表</font>」的方式来管理空闲空间，每一个空闲块里有一个指针指向下一个空闲块，这样也能很方便的找到空闲块并管理起来。如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;当创建文件需要一块或几块时，就从<font color=#FEAE00>链头上依次取下一块或几块</font>。反之，当回收空间时，把这些<font color=#FEAE00>空闲块依次接到链头上</font>。<br>&emsp;&emsp;这种技术只要在<font color=#FEAE00>主存中保存一个指针</font>，令它指向第一个空闲块。其特点是<font color=#FEAE00>简单，但不能随机访问</font>，工作效率低，因为每当在链上增加或移动空闲块时需要做很多 I/O 操作，同时数据块的指针消耗了一定的存储空间。<br>&emsp;&emsp;空闲表法和空闲链表法都<font color=#FEAE00>不适合用于大型文件系统</font>，因为这会使<font color=#FEAE00>空闲表或空闲链表太大。</font><br>&emsp;&emsp;# 位图法<br>&emsp;&emsp;位图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。<br>&emsp;&emsp;当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。它形式如下：<br>&emsp;&emsp;1111110011111110001110110111111100111 ...<br>&emsp;&emsp;在 <font color=#FEAE00>Linux </font><font color=#FEAE00>文件系统就采用了位图的方式</font>来管理空闲空间，不仅用于数据空闲块的管理，还用于 <font color=#FEAE00>inode </font><font color=#FEAE00>空闲块的管理</font>，因为 inode 也是存储在磁盘的，自然也要有对其管理。<br>&emsp;&emsp;<font color=#FEAE00>其实这里还有遗漏</font><font color=#FEAE00>: </font><font color=#FEAE00>比如</font><font color=#FEAE00> </font><font color=#FEAE00>位图的话是多级的么</font><font color=#FEAE00>? </font><font color=#FEAE00>位图的话应该取多大</font><font color=#FEAE00>? </font><font color=#FEAE00>之类的东西</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr><font color=#FEAE00>VFS::</font><font color=#FEAE00>软链接</font>和<font color=#FEAE00>硬链接的实现存储方式</font><hr>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过<font color=#FEAE00>硬链接</font><font color=#7414AF>Hard Link</font> 和<font color=#FEAE00>软链接</font><font color=#7414AF>Symbolic Link</font> 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。<br>&emsp;&emsp;硬链接是<font color=#FEAE00>多个目录项中的「索引节点」指向一个文件</font>，也就是<font color=#FEAE00>指向同一个</font><font color=#FEAE00> inode</font>，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以<font color=#FEAE00>硬链接是不可用于跨文件系统的</font>。由于多个目录项都是指向一个 inode，那么<font color=#FEAE00>只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</font><br>&emsp;&emsp;￼<br>&emsp;&emsp;软链接相当于重新创建一个文件，这个文件有<font color=#FEAE00>独立的</font><font color=#FEAE00> inode</font>，但是这个<font color=#FEAE00>文件的内容是另外一个文件的路径</font>，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以<font color=#1DB100>软链接是可以跨文件系统的</font>，甚至<font color=#FEAE00>目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</font><br>&emsp;&emsp;￼<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>a = 1 + 2 执行具体过程<hr>知道了基本的程序执行过程后，接下来用 <font color=#4D647F>a = 1 + 2</font> 的作为例子，进一步分析该程序在冯诺伊曼模型的执行过程。<br>&emsp;&emsp;CPU 是不认识 <font color=#4D647F>a = 1 + 2</font> 这个字符串，这些字符串只是方便我们程序员认识，要想这段程序能跑起来，还需要把整个程序翻译成<font color=#374EF4>汇编语言</font>的程序，这个过程称为编译成汇编代码。<br>&emsp;&emsp;针对汇编代码，我们还需要用汇编器翻译成机器码，这些机器码由 0 和 1 组成的机器语言，这一条条机器码，就是一条条的<font color=#374EF4>计算机指令</font>，这个才是 CPU 能够真正认识的东西。<br>&emsp;&emsp;下面来看看 <font color=#4D647F>a = 1 + 2</font> 在 32 位 CPU 的执行过程。<br>&emsp;&emsp;程序编译过程中，编译器通过分析代码，发现 1 和 2 是数据，于是程序运行时，内存会有个专门的区域来存放这些数据，这个区域就是「数据段」。如下图，数据 1 和 2 的区域位置：<br>&emsp;&emsp;	•	数据 1 被存放到 0x100 位置；<br>&emsp;&emsp;	•	数据 2 被存放到 0x104 位置；<br>&emsp;&emsp;注意，数据和指令是分开区域存放的，存放指令区域的地方称为「正文段」。<br>&emsp;&emsp;￼<br>&emsp;&emsp;编译器会把 <font color=#4D647F>a = 1 + 2</font> 翻译成 4 条指令，存放到正文段中。如图，这 4 条指令被存放到了 0x200 ~ 0x20c 的区域中：<br>&emsp;&emsp;	•	0x200 的内容是 <font color=#4D647F>load</font> 指令将 0x100 地址中的数据 1 装入到寄存器 <font color=#4D647F>R0</font>；<br>&emsp;&emsp;	•	0x204 的内容是 <font color=#4D647F>load</font> 指令将 0x104 地址中的数据 2 装入到寄存器 <font color=#4D647F>R1</font>；<br>&emsp;&emsp;	•	0x208 的内容是 <font color=#4D647F>add</font> 指令将寄存器 <font color=#4D647F>R0</font> 和 <font color=#4D647F>R1</font> 的数据相加，并把结果存放到寄存器 <font color=#4D647F>R2</font>；<br>&emsp;&emsp;	•	0x20c 的内容是 <font color=#4D647F>store</font> 指令将寄存器 <font color=#4D647F>R2</font> 中的数据存回数据段中的 0x108 地址中，这个地址也就是变量 <font color=#4D647F>a</font> 内存中的地址；<br>&emsp;&emsp;编译完成后，具体执行程序的时候，程序计数器会被设置为 0x200 地址，然后依次执行这 4 条指令。<br>&emsp;&emsp;上面的例子中，由于是在 32 位 CPU 执行的，因此一条指令是占 32 位大小，所以你会发现每条指令间隔 4 个字节。<br>&emsp;&emsp;而数据的大小是根据你在程序中指定的变量类型，比如 <font color=#4D647F>int</font> 类型的数据则占 4 个字节，<font color=#4D647F>char</font> 类型的数据则占 1 个字节。<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font>指令<br>&emsp;&emsp;上面的例子中，图中指令的内容我写的是简易的汇编代码，目的是为了方便理解指令的具体内容，事实上指令的内容是一串二进制数字的机器码，每条指令都有对应的机器码，CPU 通过解析机器码来知道指令的内容。<br>&emsp;&emsp;不同的 CPU 有不同的指令集，也就是对应着不同的汇编语言和不同的机器码，接下来选用最简单的 MIPS 指集，来看看机器码是如何生成的，这样也能明白二进制的机器码的具体含义。<br>&emsp;&emsp;MIPS 的指令是一个 32 位的整数，高 6 位代表着操作码，表示这条指令是一条什么样的指令，剩下的 26 位不同指令类型所表示的内容也就不相同，主要有三种类型R、I 和 J。<br>&emsp;&emsp;￼<br>&emsp;&emsp;一起具体看看这三种类型的含义：<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>R </font><font color=#7414AF>指令</font>，用在算术和逻辑操作，里面有读取和写入数据的寄存器地址。如果是逻辑位移操作，后面还有位移操作的「位移量」，而最后的「功能码」则是再前面的操作码不够的时候，扩展操作码来表示对应的具体指令的；<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>I </font><font color=#7414AF>指令</font>，用在数据传输、条件分支等。这个类型的指令，就没有了位移量和功能码，也没有了第三个寄存器，而是把这三部分直接合并成了一个地址值或一个常数；<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>J </font><font color=#7414AF>指令</font>，用在跳转，高 6 位之外的 26 位都是一个跳转后的地址；<br>&emsp;&emsp;接下来，我们把前面例子的这条指令：「<font color=#4D647F>add</font> 指令将寄存器 <font color=#4D647F>R0</font> 和 <font color=#4D647F>R1</font> 的数据相加，并把结果放入到 <font color=#4D647F>R2</font>」，翻译成机器码。<br>&emsp;&emsp;￼<br>&emsp;&emsp;加和运算 add 指令是属于 R 指令类型：<br>&emsp;&emsp;	•	add 对应的 MIPS 指令里操作码是 <font color=#4D647F>000000</font>，以及最末尾的功能码是 <font color=#4D647F>100000</font>，这些数值都是固定的，查一下 MIPS 指令集的手册就能知道的；<br>&emsp;&emsp;	•	rs 代表第一个寄存器 R0 的编号，即 <font color=#4D647F>00000</font>；<br>&emsp;&emsp;	•	rt 代表第二个寄存器 R1 的编号，即 <font color=#4D647F>00001</font>；<br>&emsp;&emsp;	•	rd 代表目标的临时寄存器 R2 的编号，即 <font color=#4D647F>00010</font>；<br>&emsp;&emsp;	•	因为不是位移操作，所以位移量是 <font color=#4D647F>00000</font><br>&emsp;&emsp;把上面这些数字拼在一起就是一条 32 位的 MIPS 加法指令了，那么用 16 进制表示的机器码则是 <font color=#4D647F>0x00011020</font>。<br>&emsp;&emsp;编译器在编译程序的时候，会构造指令，这个过程叫做指令的编码。CPU 执行程序的时候，就会解析指令，这个过程叫作指令的解码。<br>&emsp;&emsp;现代大多数 CPU 都使用来流水线的方式来执行指令，所谓的流水线就是把一个任务拆分成多个小任务，于是一条指令通常分为 4 个阶段，称为 4 级流水线，如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;四个阶段的具体含义：<br>&emsp;&emsp;	1	CPU 通过程序计数器读取对应内存地址的指令，这个部分称为 <font color=#374EF4>Fetch</font><font color=#374EF4>（取得指令）</font>；<br>&emsp;&emsp;	2	CPU 对指令进行解码，这个部分称为 <font color=#374EF4>Decode</font><font color=#374EF4>（指令译码）</font>；<br>&emsp;&emsp;	3	CPU 执行指令，这个部分称为 <font color=#374EF4>Execution</font><font color=#374EF4>（执行指令）</font>；<br>&emsp;&emsp;	4	CPU 将计算结果存回寄存器或者将寄存器的值存入内存，这个部分称为 <font color=#374EF4>Store</font><font color=#374EF4>（数据回写）</font>；<br>&emsp;&emsp;上面这 4 个阶段，我们称为<font color=#374EF4>指令周期（</font><font color=#7414AF>Instrution Cycle</font><font color=#374EF4>）</font>，CPU 的工作就是一个周期接着一个周期，周而复始。<br>&emsp;&emsp;事实上，不同的阶段其实是由计算机中的不同组件完成的：<br>&emsp;&emsp;￼<br>&emsp;&emsp;	•	取指令的阶段，我们的指令是存放在<font color=#374EF4>存储器</font>里的，实际上，通过程序计数器和指令寄存器取出指令的过程，是由<font color=#374EF4>控制器</font>操作的；<br>&emsp;&emsp;	•	指令的译码过程，也是由<font color=#374EF4>控制器</font>进行的；<br>&emsp;&emsp;	•	指令执行的过程，无论是进行算术操作、逻辑操作，还是进行数据传输、条件分支操作，都是由<font color=#374EF4>算术逻辑单元</font>操作的，也就是由<font color=#374EF4>运算器</font>处理的。但是如果是一个简单的无条件地址跳转，则是直接在<font color=#374EF4>控制器</font>里面完成的，不需要用到运算器。<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font>指令的类型<br>&emsp;&emsp;指令从功能角度划分，可以分为 5 大类：<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>数据传输类型的指令</font>，比如 <font color=#4D647F>store/load</font> 是寄存器与内存间数据传输的指令，<font color=#4D647F>mov</font> 是将一个内存地址的数据移动到另一个内存地址的指令；<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>运算类型的指令</font>，比如加减乘除、位运算、比较大小等等，它们最多只能处理两个寄存器中的数据；<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>跳转类型的指令</font>，通过修改程序计数器的值来达到跳转执行指令的过程，比如编程中常见的 <font color=#4D647F>if-else</font>、<font color=#4D647F>swtich-case</font>、函数调用等。<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>信号类型的指令</font>，比如发生中断的指令 <font color=#4D647F>trap</font>；<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>闲置类型的指令</font>，比如指令 <font color=#4D647F>nop</font>，执行后 CPU 会空转一个周期；<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font>指令的执行速度<br>&emsp;&emsp;CPU 的硬件参数都会有 <font color=#4D647F>GHz</font> 这个参数，比如一个 1 GHz 的 CPU，指的是时钟频率是 1 G，代表着 1 秒会产生 1G 次数的脉冲信号，每一次脉冲信号高低电平的转换就是一个周期，称为时钟周期。<br>&emsp;&emsp;对于 CPU 来说，在一个时钟周期内，CPU 仅能完成一个最基本的动作，时钟频率越高，时钟周期就越短，工作速度也就越快。<br>&emsp;&emsp;一个时钟周期一定能执行完一条指令吗？答案是不一定的，大多数指令不能在一个时钟周期完成，通常需要若干个时钟周期。不同的指令需要的时钟周期是不同的，加法和乘法都对应着一条 CPU 指令，但是乘法需要的时钟周期就要比加法多。<br>&emsp;&emsp;如何让程序跑的更快？<br>&emsp;&emsp;程序执行的时候，耗费的 CPU 时间少就说明程序是快的，对于程序的 CPU 执行时间，我们可以拆解成 <font color=#374EF4>CPU </font><font color=#374EF4>时钟周期数（</font><font color=#7414AF>CPU Cycles</font><font color=#374EF4>）和时钟周期时间（</font><font color=#7414AF>Clock Cycle Time</font><font color=#374EF4>）的乘积</font>。<br>&emsp;&emsp;￼<br>&emsp;&emsp;时钟周期时间就是我们前面提及的 CPU 主频，主频越高说明 CPU 的工作速度就越快，比如我手头上的电脑的 CPU 是 2.4 GHz 四核 Intel Core i5，这里的 2.4 GHz 就是电脑的主频，时钟周期时间就是 1/2.4G。<br>&emsp;&emsp;要想 CPU 跑的更快，自然缩短时钟周期时间，也就是提升 CPU 主频，但是今非彼日，摩尔定律早已失效，当今的 CPU 主频已经很难再做到翻倍的效果了。<br>&emsp;&emsp;另外，换一个更好的 CPU，这个也是我们软件工程师控制不了的事情，我们应该把目光放到另外一个乘法因子 —— CPU 时钟周期数，如果能减少程序所需的 CPU 时钟周期数量，一样也是能提升程序的性能的。<br>&emsp;&emsp;对于 CPU 时钟周期数我们可以进一步拆解成：「<font color=#374EF4>指令数</font><font color=#374EF4> x </font><font color=#374EF4>每条指令的平均时钟周期数（</font><font color=#7414AF>Cycles Per Instruction</font><font color=#374EF4>，简称</font><font color=#374EF4> </font><font color=#4D647F>CPI</font><font color=#374EF4>）</font>」，于是程序的 CPU 执行时间的公式可变成如下：<br>&emsp;&emsp;￼<br>&emsp;&emsp;因此，要想程序跑的更快，优化这三者即可：<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>指令数</font>，表示执行程序所需要多少条指令，以及哪些指令。这个层面是基本靠编译器来优化，毕竟同样的代码，在不同的编译器，编译出来的计算机指令会有各种不同的表示方式。<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>每条指令的平均时钟周期数</font><font color=#7414AF> CPI</font>，表示一条指令需要多少个时钟周期数，现代大多数 CPU 通过流水线技术（Pipeline），让一条指令需要的 CPU 时钟周期数尽可能的少；<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>时钟周期时间</font>，表示计算机主频，取决于计算机硬件。有的 CPU 支持超频技术，打开了超频意味着把 CPU 内部的时钟给调快了，于是 CPU 工作速度就变快了，但是也是有代价的，CPU 跑的越快，散热的压力就会越大，CPU 会很容易奔溃。<br>&emsp;&emsp;很多厂商为了跑分而跑分，基本都是在这三个方面入手的哦，特别是超频这一块。<hr><hr>brk如何申请小字节数? 申请时候至少一页, 要申请小于一页<hr><hr>brk是系统调用么?<hr><hr>brk频繁调用有什么问题? 上下文切换消耗<hr><hr>cpu的位宽是什么? 和线路位宽关系<hr>* 32位和64位<br>&emsp;&emsp;* 决定了CPU一次可以计算数字的大小<br>&emsp;&emsp;* 总线的宽度 <br>&emsp;&emsp;* 串行与并行： 线路的位宽最好一次能访问到所有的内存地址<br>&emsp;&emsp;* CPU位宽 最好不要小于线路位宽，不然转换很吃力<hr><hr>cpu的组成部件? <hr>* 控制单元<br>&emsp;&emsp;* 逻辑运算单元ALU<br>&emsp;&emsp;* 寄存器<br>&emsp;&emsp;todo 以及总线吧<hr><hr>epoll::I/O 多路复用<hr>既然为每个请求分配一个进程/线程的方式不合适，那有没有可能<font color=#FEAE00>只使用一个进程来维护多个</font><font color=#FEAE00> Socket </font>呢？答案是有的，那就是<font color=#FEAE00> </font><font color=#FEAE00>I/O </font><font color=#FEAE00>多路复用</font>技术。<br>&emsp;&emsp;￼<br>&emsp;&emsp;一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，<font color=#FEAE00>耗时控制在</font><font color=#FEAE00> 1 </font><font color=#FEAE00>毫秒以内，这样</font><font color=#FEAE00> 1 </font><font color=#FEAE00>秒内就可以处理上千个请求</font>，把时间拉长来看，<font color=#FEAE00>多个请求复用了一个进程，这就是多路复用</font>，这种思想很类似一个 CPU 并发多个进程，所以也叫做<font color=#FEAE00>时分多路复用</font>。<br>&emsp;&emsp;我们熟悉的 <font color=#FEAE00>select/poll/epoll</font> 内核提供给用户态的多路复用系统调用，<font color=#00AB8E>进程可以通过一个系统调用函数从内核中获取多个事件</font><font color=#00AB8E>。</font><br>&emsp;&emsp;select/poll/epoll 是<font color=#FEAE00>如何获取网络事件的呢</font>？在获取事件时，先把<font color=#FEAE00>所有连接（文件描述符）传给内核</font>，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可。<br>&emsp;&emsp;select/poll/epoll 这是三个多路复用接口，都能实现 C10K 吗？接下来，我们分别说说它们。<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>epoll::epoll?<hr>先复习下 epoll 的用法。如下的代码中，先用<font color=#FEAE00>epoll_create </font>创建一个 <font color=#FEAE00>epoll</font><font color=#FEAE00>对象</font><font color=#FEAE00> epfd</font>，再通过 <font color=#FEAE00>epoll_ctl </font>将需要监视的 socket 添加到epfd中，最后调用 <font color=#FEAE00>epoll_wait </font>等待数据。<br>&emsp;&emsp;<font color=#5E3563>int</font> s <font color=#519696>=</font> <font color=#AA5925>socket</font>(AF_INET, SOCK_STREAM, <font color=#AA5925>0</font>);<br>&emsp;&emsp;<font color=#AA5925>bind</font>(s, ...);<br>&emsp;&emsp;<font color=#AA5925>listen</font>(s, ...)<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5E3563>int</font> epfd <font color=#519696>=</font> <font color=#AA5925>epoll_create</font>(...);<br>&emsp;&emsp;<font color=#AA5925>epoll_ctl</font>(epfd, ...); <font color=#666666>//</font><font color=#666666>将所有需要监听的</font><font color=#666666>socket</font><font color=#666666>添加到</font><font color=#666666>epfd</font><font color=#666666>中</font><br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5E3563>while</font>(<font color=#AA5925>1</font>) {<br>&emsp;&emsp;    <font color=#5E3563>int</font> n <font color=#519696>=</font> <font color=#AA5925>epoll_wait</font>(...);<br>&emsp;&emsp;    <font color=#5E3563>for</font>(接收到数据的socket){<br>&emsp;&emsp;        <font color=#666666>//</font><font color=#666666>处理</font><br>&emsp;&emsp;    }<br>&emsp;&emsp;}<br>&emsp;&emsp;epoll 通过两个方面，<font color=#FEAE00>很好解决了</font><font color=#FEAE00> select/poll </font>的问题。<br>&emsp;&emsp;<font color=#7414AF>第一点</font>，epoll 在内核里使用<font color=#00AB8E>红黑树来跟踪进程所有待检测的文件描述字</font>，把需要监控的 socket 通过 <font color=#1DB100>epoll_ctl()</font> 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 <font color=#00AB8E>O(logn)</font>。而 select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 <font color=#FEAE00>select/poll </font>每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，<font color=#FEAE00>减少了内核和用户空间大量的数据拷贝和内存分配。</font><br>&emsp;&emsp;<font color=#7414AF>第二点</font>， epoll 使用<font color=#FEAE00>事件驱动</font>的机制，内核里<font color=#FEAE00>维护了一个链表来记录就绪事件</font>，当某个 socket 有事件发生时，通过<font color=#FEAE00>回调函数</font>内核会将其加入到这个就绪事件列表中，当用户调用<font color=#FEAE00> epoll_wait() </font>函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。<br>&emsp;&emsp;从下图你可以看到 epoll 相关的接口作用：<br>&emsp;&emsp;￼<br>&emsp;&emsp;epoll 的方式即使监听的 Socket 数量越多的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了，上限就为系统定义的进程打开的最大文件描述符个数。因而<font color=#FEAE00>，</font><font color=#FEAE00>epoll </font><font color=#FEAE00>被称为解决</font><font color=#FEAE00> C10K </font><font color=#FEAE00>问题的利器</font>。<br>&emsp;&emsp;插个题外话，网上文章不少说，<font color=#4D647F>epoll_wait</font> 返回时，对于就绪的事件，epoll 使用的是共享内存的方式，即用户态和内核态都指向了就绪链表，所以就避免了内存拷贝消耗。<br>&emsp;&emsp;这是错的！<font color=#FEAE00>看过</font><font color=#FEAE00> epoll </font><font color=#FEAE00>内核源码的都知道，</font><font color=#FEAE00>压根就没有使用共享内存这个玩意</font>。你可以从下面这份代码看到， epoll_wait 实现的<font color=#FEAE00>内核代码中调用了</font><font color=#FEAE00> __put_user </font><font color=#FEAE00>函数</font>，这个函数就是将数据从内核拷贝到用户空间。<br>&emsp;&emsp;￼<br>&emsp;&emsp;好了，这个题外话就说到这了，我们继续！<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>epoll::select/poll ?<hr>select 实现多路复用的方式是，将已连接的<font color=#FEAE00> Socket </font><font color=#FEAE00>都放到一个</font><font color=#FEAE00>文件描述符集合</font>，然后调用 select 函数将文件描述符集合<font color=#FEAE00>拷贝</font>到内核里，让<font color=#FEAE00>内核来检查</font>是否有网络事件产生，检查的方式很粗暴，就是通过<font color=#FEAE00>遍历</font><font color=#FEAE00>文件描述符集合的方式</font>，当检查到有事件产生后，<font color=#FEAE00>将此</font><font color=#FEAE00> Socket </font><font color=#FEAE00>标记为可读或可写</font>， 接着再把整个文件描述符集合<font color=#FEAE00>拷贝</font><font color=#FEAE00>回用户态里</font>，然后用户态还需要再通过<font color=#FEAE00>遍历</font>的方法<font color=#FEAE00>找到可读或可写的</font><font color=#FEAE00> Socket</font>，然后再对其处理。<br>&emsp;&emsp;所以，对于 select 这种方式，需要进行 <font color=#00AB8E>2 </font><font color=#00AB8E>次「遍历」文件描述符集合</font>，一次是在内核态里，一个次是在用户态里 ，而且还会发生<font color=#1DB100> </font><font color=#1DB100>2 </font><font color=#1DB100>次「拷贝」文件描述符集合</font>，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。<br>&emsp;&emsp;select 使用固定长度的 <font color=#FEAE00>BitsMap</font><font color=#FEAE00>，</font>表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 <font color=#FEAE00>1024</font>，只能监听 0~1023 的文件描述符。<br>&emsp;&emsp;poll 不再用 BitsMap 来存储所关注的文件描述符，<font color=#FEAE00>取而代之用动态数组</font>，以<font color=#FEAE00>链表形式来组织</font>，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。<br>&emsp;&emsp;但是 poll 和 select 并没有太大的本质区别，<font color=#00AB8E>都是使用「线性结构」存储进程关注的</font><font color=#00AB8E> Socket </font><font color=#00AB8E>集合，因此都需要遍历文件描述符集合来找到可读或可写的</font><font color=#00AB8E> Socket</font><font color=#00AB8E>，时间复杂度为</font><font color=#00AB8E> O(n)</font><font color=#00AB8E>，而且也需要在用户态与内核态之间拷贝文件描述符集合</font>，这种方式随着并发数上来，性能的损耗会呈<font color=#FEAE00>指数级增长</font>。<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr><font color=#FEAE00>epoll::</font><font color=#FEAE00>多线程</font>模型? 线程池是什么？<hr>线程间是共享的 pthread_create()<br>&emsp;&emsp;上下文切换没有(fd,pcb,代码,全局数据,堆,共享库)<br>&emsp;&emsp;只有私有数据和寄存器等.<br>&emsp;&emsp;---<br>&emsp;&emsp;既然进程间上下文切换的“包袱”很重，那我们就搞个比较轻量级的模型来应对多用户的请求 —— <font color=#FEAE00>多线程模型</font>。<br>&emsp;&emsp;线程是运行在进程中的一个“<font color=#FEAE00>逻辑流</font>”，单进程中可以运行多个线程，同进程里的线程可以共享进程的部分资源的，比如文件描述符列表、进程空间、代码、全局数据、堆、共享库等，<font color=#FEAE00>这些共享些资源在上下文切换时是不需要切换</font>，而<font color=#FEAE00>只需要切换线程的私有数据、寄存器</font>等不共享的数据，因此同一个进程下的线程上下文切换的开销要比进程小得多。<br>&emsp;&emsp;当服务器与客户端 TCP 完成连接后，通过<font color=#FEAE00> pthread_create()</font> 函数创建线程，然后将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到<font color=#FEAE00>并发处理的目的</font>。<br>&emsp;&emsp;如果每来一个连接就创建一个线程，线程运行完后，还得操作系统还得销毁线程，虽说线程切换的上写文开销不大，<font color=#FEAE00>但是如果频繁创建和销毁线程，系统开销也是不小的。</font><br>&emsp;&emsp;那么，我们可以使用<font color=#FEAE00>线程池</font>的方式来避免线程的频繁创建和销毁，所谓的线程池，就是提前创建若干个线程，这样当由新连接建立时，将这个<font color=#FEAE00>已连接的</font><font color=#FEAE00> Socket </font><font color=#FEAE00>放入到一个队列里，</font>然后线程池里的线程负责<font color=#FEAE00>从队列中取出「已连接</font><font color=#FEAE00> Socket </font><font color=#FEAE00>」</font>进行处理。<br>&emsp;&emsp;￼<br>&emsp;&emsp;需要注意的是，这个队列是<font color=#FEAE00>全局的</font>，每个线程都会操作，为了避免多线程竞争，线程在操作这个队列前要加锁。<br>&emsp;&emsp;上面基于进程或者线程模型的，其实还是有问题的。新到来一个 TCP 连接，就需要分配一个进程或者线程，那么如果要达到 C10K，意味着要一台机器维护 1 万个连接，相当于要维护 1 万个进程/线程，操作系统就算死扛也是扛不住的。<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr><font color=#FEAE00>epoll::</font><font color=#FEAE00>多进程</font>模型?<hr>使用 fork 来进行, <br>&emsp;&emsp;上下文切换的开销<br>&emsp;&emsp;僵尸进程需要自己回收掉<br>&emsp;&emsp;---<br>&emsp;&emsp;基于最原始的<font color=#FEAE00>阻塞网络</font><font color=#FEAE00> I/O</font>， 如果服务器要支持多个客户端，其中比较传统的方式，就是<font color=#FEAE00>使用</font><font color=#FEAE00>多进程模型</font>，也就是为每个客户端分配一个进程来处理请求。<br>&emsp;&emsp;服务器的主进程负责监听客户的连接，一旦与客户端连接完成，<font color=#FEAE00>accept() </font><font color=#FEAE00>函数就会返回一个「已连接</font><font color=#FEAE00> Socket</font><font color=#FEAE00>」</font>，这时就通过 <font color=#FEAE00>fork() </font><font color=#FEAE00>函数创建一个子进程</font>，实际上就把父进程所有相关的东西都<font color=#FEAE00>复制</font>一份，包括文件描述符、内存地址空间、程序计数器、执行的代码等。<br>&emsp;&emsp;这两个进程刚复制完的时候，几乎一摸一样。不过，会根据<font color=#FEAE00>返回值</font>来区分是父进程还是子进程，如果<font color=#FEAE00>返回值是</font><font color=#FEAE00> 0</font><font color=#FEAE00>，则是子进程</font>；如果返回值是其他的整数，就是父进程。<br>&emsp;&emsp;正因为子进程会<font color=#FEAE00>复制父进程的文件描述符</font><font color=#FEAE00>，</font>于是就可以直接使用「已连接 Socket 」和客户端通信了，<br>&emsp;&emsp;可以发现，<font color=#FEAE00>子进程不需要关心「监听</font><font color=#FEAE00> Socket</font>」，只需要关心「已连接 Socket」；父进程则相反，将客户服务交给子进程来处理，因此<font color=#FEAE00>父进程</font>不需要关心「已连接 Socket」，只需要关心「<font color=#FEAE00>监听</font><font color=#FEAE00> Socket</font>」。<br>&emsp;&emsp;下面这张图描述了从连接请求到连接建立，父进程创建生子进程为客户服务。<br>&emsp;&emsp;￼<br>&emsp;&emsp;另外，当「<font color=#FEAE00>子进程」退出时，实际上内核里还会保留该进程的一些信息</font>，也是会占用内存的，如果不做好“回收”工作，就会变成<font color=#FEAE00>僵尸进程</font>，随着<font color=#FEAE00>僵尸进程越多，会慢慢耗尽我们的系统资源。</font><br>&emsp;&emsp;因此，父进程要“善后”好自己的孩子，怎么善后呢？那么有两种方式可以在子进程退出后回收资源，<font color=#FEAE00>分别是调用</font><font color=#FEAE00> wait() </font><font color=#FEAE00>和</font><font color=#FEAE00> waitpid() </font><font color=#FEAE00>函数</font>。<br>&emsp;&emsp;这种用<font color=#FEAE00>多个进程</font>来应付多个客户端的方式，在应对 100 个客户端还是可行的，但是当客户端数量高达一万时，肯定扛不住的，因为每产生一个进程，必会占据一定的系统资源，而且进程间上下文切换的“包袱”是很重的，性能会大打折扣。<br>&emsp;&emsp;进程的<font color=#FEAE00>上下文切换</font>不仅包含了虚拟内存、栈、全局变量等<font color=#FEAE00>用户空间的资源</font>，还包括了<font color=#FEAE00>内核堆栈、寄存器等内核空间</font>的资源。<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>epoll::如何服务更多的用户？<br>&emsp;&emsp;从理论服务的最大用户上讲<hr>前面提到的 TCP Socket 调用流程是最简单、最基本的，它基本只能一对一通信，因为使用的是<font color=#FEAE00>同步阻塞的方式，</font>当服务端在还没处理完一个客户端的网络 I/O 时，或者 读写操作发生阻塞时，其他客户端是无法与服务端连接的。<br>&emsp;&emsp;可如果我们服务器只能服务一个客户，那这样就太浪费资源了，于是我们要<font color=#FEAE00>改进这个网络</font><font color=#FEAE00> I/O </font><font color=#FEAE00>模型，以支持更多的客户端。</font><br>&emsp;&emsp;在改进网络 I/O 模型前，我先来提一个问题，你知道服务器<font color=#FEAE00>单机理论最大能连接多少个客户端？</font><br>&emsp;&emsp;相信你知道 TCP 连接是由四元组唯一确认的，这个四元组就是：<font color=#FEAE00>本机</font><font color=#FEAE00>IP, </font><font color=#FEAE00>本机端口</font><font color=#FEAE00>, </font><font color=#FEAE00>对端</font><font color=#FEAE00>IP, </font><font color=#FEAE00>对端端口</font><font color=#FEAE00>。</font><br>&emsp;&emsp;服务器作为服务方，通常会在本地固定监听一个端口，等待客户端的连接。因此服务器的本地 IP 和端口是固定的，于是对于服务端 TCP 连接的四元组只有对端 IP 和端口是会变化的，所以<font color=#FEAE00>最大</font><font color=#FEAE00> TCP </font><font color=#FEAE00>连接数</font><font color=#FEAE00> = </font><font color=#FEAE00>客户端</font><font color=#FEAE00> IP </font><font color=#FEAE00>数</font><font color=#FEAE00>×</font><font color=#FEAE00>客户端端口数</font><font color=#FEAE00>。</font><br>&emsp;&emsp;对于 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是<font color=#FEAE00>服务端单机最大</font><font color=#FEAE00> TCP </font><font color=#FEAE00>连接数约为</font><font color=#FEAE00> 2 </font><font color=#FEAE00>的</font><font color=#FEAE00> 48 </font><font color=#FEAE00>次方</font><font color=#FEAE00>。</font><br>&emsp;&emsp;这个理论值相当“丰满”，但是服务器肯定承载不了那么大的连接数，主要会受两个方面的限制：<br>&emsp;&emsp;<font color=#374EF4>	</font><font color=#00AB8E>•	</font><font color=#00AB8E>文件描述符</font><font color=#00AB8E>，</font>Socket 实际上是一个文件，也就会对应一个文件描述符。在 Linux 下，单个进程打开的文件描述符数是有限制的，没有经过修改的值一般都是 1024，不过我们可以通过 ulimit 增大文件描述符的数目；<br>&emsp;&emsp;<font color=#374EF4>	</font><font color=#00AB8E>•	</font><font color=#00AB8E>系统内存</font>，每个 TCP 连接在内核中都有对应的数据结构，意味着每个连接都是会占用一定内存的；<br>&emsp;&emsp;那如果服务器的内存只有 2 GB，网卡是千兆的，能支持并发 1 万请求吗？<br>&emsp;&emsp;<font color=#FEAE00>并发</font><font color=#FEAE00> 1 </font><font color=#FEAE00>万请求</font>，也就是<font color=#FEAE00>经典的</font><font color=#FEAE00> C10K </font><font color=#FEAE00>问题</font><font color=#FEAE00> </font><font color=#FEAE00>，</font><font color=#FEAE00>C </font><font color=#FEAE00>是</font><font color=#FEAE00> Client </font><font color=#FEAE00>单词首字母缩写</font>，C10K 就是单机同时处理 1 万个请求的问题。<br>&emsp;&emsp;从硬件资源角度看，对于<font color=#FEAE00> 2GB </font><font color=#FEAE00>内存千兆网卡</font>的服务器，如果每个请求处理占用不到 <font color=#FEAE00>200KB </font><font color=#FEAE00>的内存和</font><font color=#FEAE00> 100Kbit </font><font color=#FEAE00>的网络带宽就可以满足并发</font><font color=#FEAE00> 1 </font><font color=#FEAE00>万个请求</font>。<br>&emsp;&emsp;不过，要想真正实现 C10K 的服务器，要考虑的地方在于服务器的网络 I/O 模型，效率低的模型，会加重系统开销，从而会离 C10K 的目标越来越远。<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>epoll::最<font color=#1DB100>基本的</font><font color=#1DB100> Socket </font>模型?<br>&emsp;&emsp;收发包的数据结构 如何层层解析的<hr>socket -> bind -> listen -> accpet -> read/write->close<br>&emsp;&emsp;<br>&emsp;&emsp;socket -> bind -> connect .... <br>&emsp;&emsp;---<br>&emsp;&emsp;<br>&emsp;&emsp;要想客户端和服务器能在网络中通信，那必须得使用 Socket 编程，它是进程间通信里比较特别的方式，特别之处在于它是<font color=#FEAE00>可以跨主机间通信</font>。<br>&emsp;&emsp;Socket 的<font color=#FEAE00>中文名叫作插口</font>，咋一看还挺迷惑的。事实上，双方要进行网络通信前，各自得创建一个 Socket，这相当于客户端和服务器都开了一个“口子”，双方读取和发送数据的时候，都通过这个“口子”。这样一看，是不是觉得很像弄了一根网线，一头插在客户端，一头插在服务端，然后进行通信。<br>&emsp;&emsp;创建 Socket 的时候，可以指定网络层使用的是 IPv4 还是 IPv6，传输层使用的是 TCP 还是 UDP。<br>&emsp;&emsp;UDP 的 Socket 编程相对简单些，这里我们只介绍基于 TCP 的 Socket 编程。<br>&emsp;&emsp;服务器的程序要先跑起来，然后等待客户端的连接和数据，我们先来看看<font color=#FEAE00>服务端的</font><font color=#FEAE00> Socket </font><font color=#FEAE00>编程过程是怎样的。</font><br>&emsp;&emsp;服务端首先调用<font color=#FEAE00> socket() </font>函数，创建网络协议为 <font color=#FEAE00>IPv4</font>，以及传输协议为 TCP 的 Socket ，接着调用 <font color=#FEAE00>bind() </font>函数，给这个 Socket 绑定一个 <font color=#FEAE00>IP </font><font color=#FEAE00>地址和端口</font>，绑定这两个的目的是什么？<br>&emsp;&emsp;	•	绑定端口的目的：当内核收到 TCP 报文，通过 TCP 头里面的端口号，来找到我们的应用程序，然后把数据传递给我们。<br>&emsp;&emsp;	•	绑定 IP 地址的目的：一台机器是可以有多个网卡的，每个网卡都有对应的 IP 地址，当绑定一个网卡时，内核在收到该网卡上的包，才会发给我们；<br>&emsp;&emsp;绑定完 IP 地址和端口后，<font color=#FEAE00>就可以调用</font><font color=#FEAE00> </font><font color=#00AB8E>listen() </font><font color=#FEAE00>函数进行监听</font>，此时对应 TCP 状态图中的 <font color=#4D647F>listen</font>，如果我们要判定服务器中一个网络程序有没有启动，<font color=#FEAE00>可以通过</font><font color=#FEAE00> netstat </font><font color=#FEAE00>命令查看对应的端口号是否有被监听。</font><br>&emsp;&emsp;服务端进入了监听状态后，<font color=#FEAE00>通过调用</font><font color=#FEAE00> accept() </font><font color=#FEAE00>函数</font>，来从内核获取客户端的连接，如果没有客户端连接，则会<font color=#FEAE00>阻塞等待客户端连接的到来</font>。<br>&emsp;&emsp;那客户端是怎么发起连接的呢？客户端在创建好 Socket 后，<font color=#FEAE00>调用</font><font color=#FEAE00> connect() </font><font color=#FEAE00>函数发起连接</font>，该函数的参数要指明服务端的 IP 地址和端口号，然后万众期待的 TCP 三次握手就开始了。<br>&emsp;&emsp;在 TCP 连接的过程中，服务器的内核实际上为每个 Socket 维护了两个队列：<br>&emsp;&emsp;	•	一个是还没完全建立连接的队列，称为 <font color=#FEAE00>TCP </font><font color=#FEAE00>半连接队列</font>，这个队列都是没有完成三次握手的连接，此时服务端处于 <font color=#4D647F>syn_rcvd</font> 的状态；<br>&emsp;&emsp;	•	一个是一件建立连接的队列，称为<font color=#FEAE00> </font><font color=#FEAE00>TCP </font><font color=#FEAE00>全连接队列</font>，这个队列都是完成了三次握手的连接，此时服务端处于 <font color=#4D647F>established</font> 状态；<br>&emsp;&emsp;当 TCP 全连接队列不为空后，服务端的 <font color=#4D647F>accept()</font> 函数，就会从内核中的 TCP 全连接队列里拿出一个已经完成连接的 Socket 返回应用程序，后续数据传输都用这个 Socket。<br>&emsp;&emsp;注意，<font color=#FEAE00>监听的</font><font color=#FEAE00> Socket </font><font color=#FEAE00>和真正用来传数据的</font><font color=#FEAE00> Socket</font> 是两个：<br>&emsp;&emsp;	•	一个叫作<font color=#FEAE00>监听</font><font color=#FEAE00> Socket</font>；<br>&emsp;&emsp;	•	一个叫作<font color=#FEAE00>已连接</font><font color=#FEAE00> Socket</font>；<br>&emsp;&emsp;连接建立后，客户端和服务端就开始相互传输数据了，双方都可以通过 <font color=#4D647F>read()</font> 和 <font color=#4D647F>write()</font> 函数来读写数据。<br>&emsp;&emsp;至此， TCP 协议的 Socket 程序的调用过程就结束了，整个过程如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;看到这，不知道你有没有觉得读写<font color=#FEAE00> Socket </font><font color=#FEAE00>的方式，好像读写文件一样</font>。<br>&emsp;&emsp;是的，基于 Linux 一切皆文件的理念，在内核中 Socket 也是以「文件」的形式存在的，也是有对应的文件描述符。<br>&emsp;&emsp;PS : 下面会说到<font color=#FEAE00>内核里的数据结构</font>，不感兴趣的可以跳过这一部分，不会对后续的内容有影响。<br>&emsp;&emsp;文件描述符的作用是什么？<font color=#FEAE00>每一个进程都有一个数据结构</font><font color=#FEAE00> task_struct</font>，该结构体里有一个<font color=#FEAE00>指向「文件描述符数组</font>」的成员指针。该数组里列出这个进程打开的所有文件的文件描述符。数组的<font color=#FEAE00>下标是文件描述符</font>，是一个整数，而数组的<font color=#FEAE00>内容是一个指针，</font>指向内核中<font color=#FEAE00>所有打开的文件的列表</font>，也就是说内核可以通过文件描述符找到对应打开的文件。<br>&emsp;&emsp;然后<font color=#FEAE00>每个文件都有一个</font><font color=#FEAE00> inode</font>，Socket 文件的 inode 指向了内核中的 Socket 结构，在这个结构体里有两个队列，分别是<font color=#FEAE00>发送队列</font>和<font color=#FEAE00>接收队列</font>，这个两个队列里面保存的是一个个<font color=#FEAE00> struct sk_buff</font>，用链表的组织形式串起来。<br>&emsp;&emsp;<font color=#00AB8E>sk_buff </font><font color=#00AB8E>可以表示各个层的数据包，在应用层数据包叫</font><font color=#00AB8E> data</font><font color=#00AB8E>，在</font><font color=#00AB8E> TCP </font><font color=#00AB8E>层我们称为</font><font color=#00AB8E> segment</font><font color=#00AB8E>，在</font><font color=#00AB8E> IP </font><font color=#00AB8E>层我们叫</font><font color=#00AB8E> packet</font><font color=#00AB8E>，在数据链路层称为</font><font color=#00AB8E> frame</font><font color=#00AB8E>。</font><br>&emsp;&emsp;你可能会好奇，为什么全部数据包只用一个结构体来描述呢？协议栈采用的是分层结构，上层向下层传递数据时需要增加包头，下层向上层数据时又需要去掉包头，<font color=#FEAE00>如果每一层都用一个结构体，那在层之间传递数据的时候，就要发生多次拷贝，这将大大降低</font><font color=#FEAE00> CPU </font><font color=#FEAE00>效率。</font><br>&emsp;&emsp;于是，为了在层级之间传递数据时，不发生拷贝，只用 sk_buff 一个结构体来描述所有的网络包，那它是如何做到的呢？<font color=#FEAE00>是通过调整</font><font color=#FEAE00> sk_buff </font><font color=#FEAE00>中</font><font color=#FEAE00> data </font><font color=#FEAE00>的指针</font>，比如：<br>&emsp;&emsp;	•	当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb->data 的值，来逐步剥离协议首部。<br>&emsp;&emsp;	•	当要发送报文时，创建 sk_buff 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，<font color=#FEAE00>通过减少</font><font color=#FEAE00> skb->data </font><font color=#FEAE00>的值来增加协议首部。</font><br>&emsp;&emsp;你可以从下面这张图看到，当发送报文时，data 指针的移动过程。<br>&emsp;&emsp;￼<hr><hr><font color=#FEAE00>epoll::</font><font color=#FEAE00>边缘触发</font><font color=#EA37DF>ET</font>和<font color=#FEAE00>水平触发</font><font color=#EA36D0>LT?</font><hr>边缘ET 通知一次<br>&emsp;&emsp;水平LT 不断通知。默认状态是水平的<br>&emsp;&emsp;---<br>&emsp;&emsp;epoll 支持两种事件触发模式，分别是<font color=#FEAE00>边缘触发</font><font color=#374EF4>（</font><font color=#7414AF>edge-triggered</font><font color=#7414AF>，</font><font color=#7414AF>ET</font><font color=#374EF4>）</font><font color=#FEAE00>和水平触发（</font><font color=#7414AF>level-triggered</font><font color=#7414AF>，</font><font color=#7414AF>LT</font><font color=#374EF4>）</font>。<br>&emsp;&emsp;这两个术语还挺抽象的，其实它们的区别还是很好理解的。<br>&emsp;&emsp;	•	使用<font color=#FEAE00>边缘触发模式</font>时，当被监控的 Socket 描述符上有可读事件发生时，<font color=#00AB8E>服务器端只会从</font><font color=#00AB8E> epoll_wait </font><font color=#00AB8E>中苏醒一次</font>，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要<font color=#FEAE00>保证一次性将内核缓冲区的数据读取完；</font><br>&emsp;&emsp;	•	使用<font color=#FEAE00>水平触发模式</font>时，当被监控的 Socket 上有可读事件发生时<font color=#00AB8E>，</font><font color=#00AB8E>服务器端不断地从</font><font color=#00AB8E> epoll_wait </font><font color=#00AB8E>中苏醒，直到内核缓冲区数据被</font><font color=#00AB8E> read </font><font color=#00AB8E>函数读完才结束</font>，目的是告诉我们有数据需要读取；<br>&emsp;&emsp;举个例子，你的快递被放到了一个快递箱里，如果快递箱只会通过短信通知你一次，即使你一直没有去取，它也<font color=#FEAE00>不会再发送第二条短信提醒你，这个方式就是边缘触发</font>；如果快递箱发现你的快递没有被取出，它就会<font color=#FEAE00>不停地发短信通知你，直到你取出了快递，它才消停，这个就是水平触发的方式</font>。<br>&emsp;&emsp;这就是两者的区别，水平触发的意思是只要满足事件的条件，比如内核中有数据需要读，就一直不断地把这个事件传递给用户；而边缘触发的意思是只有第一次满足条件的时候才触发，之后就不会再传递同样的事件了。<br>&emsp;&emsp;如果使用<font color=#FEAE00>水平触发模式</font>，当内核通知文件描述符可读写时，接下来还可以继续去检测它的状态，看它是否依然可读或可写。<font color=#FEAE00>所以在收到通知后，没必要一次执行尽可能多的读写操作。</font><br>&emsp;&emsp;如果使用边缘触发模式，I/O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，<font color=#FEAE00>所以在收到通知后应尽可能地读写数据，以免错失读写的机会</font>。因此，我们会<font color=#00AB8E>循环</font>从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时，<font color=#FEAE00>进程会阻塞在读写函数那里</font>，程序就没办法继续往下执行。所以，<font color=#00AB8E>边缘触发模式一般和非阻塞</font><font color=#00AB8E> I/O </font><font color=#00AB8E>搭配使用</font>，程序会一直执行 I/O 操作，直到系统调用（如 <font color=#4D647F>read</font> 和 <font color=#4D647F>write</font>）返回错误，错误类型为 <font color=#00AB8E>EAGAIN</font> 或 <font color=#00AB8E>EWOULDBLOCK</font>。<br>&emsp;&emsp;一般来说，<font color=#00AB8E>边缘触发的效率比水平触发的效率要高</font>，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。<br>&emsp;&emsp;<font color=#FEAE00>select/poll </font><font color=#FEAE00>只有水平触发</font>模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。<br>&emsp;&emsp;另外，使用 I/O 多路复用时，最好搭配<font color=#FEAE00>非阻塞</font><font color=#FEAE00> I/O </font><font color=#FEAE00>一起使用</font>，Linux 手册关于 select 的内容中有如下说明：<br>&emsp;&emsp;Under Linux, select() may report a socket file descriptor as "ready for reading", while nevertheless a subsequent read blocks. This could for example happen when data has arrived but upon examination has wrong checksum and is discarded. There may be other circumstances in which a file descriptor is spuriously reported as ready. Thus it may be safer to use O_NONBLOCK on sockets that should not block.<br>&emsp;&emsp;我谷歌翻译的结果：<br>&emsp;&emsp;在Linux下，select() 可能会将一个 <font color=#FEAE00>socket </font><font color=#FEAE00>文件描述符报告为</font><font color=#FEAE00> "</font><font color=#FEAE00>准备读取</font><font color=#FEAE00>"</font><font color=#FEAE00>，而后续的读取块却没有</font>。例如，当数据已经到达，但<font color=#FEAE00>经检查后发现有错误的校验和而被丢弃时</font>，就会发生这种情况。也有可能在其他情况下，文件描述符被错误地报告为就绪。因此，在不应该阻塞的 socket 上使用 <font color=#FEAE00>O_NONBLOCK </font><font color=#FEAE00>可能更安全</font>。<br>&emsp;&emsp;简单点理解，就是<font color=#00AB8E>多路复用</font><font color=#00AB8E> API </font><font color=#00AB8E>返回的事件并不一定可读写的</font>，如果使用阻塞 I/O， 那么在调用 read/write 时则会发生程序阻塞，因此最好搭配非阻塞 I/O，以便应对极少数的特殊情况。<hr><hr>gc::11、动态分区分配算法有哪几种？可以分别说说吗？<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;todo 太长<hr>### 1、首次适应算法<br>&emsp;&emsp;<br>&emsp;&emsp;算法思想：每次都从低地址开始查找，找到第–个能满足大小的空闲分区。<br>&emsp;&emsp;<br>&emsp;&emsp;如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链( 或空闲分[表)，找到大小能满足要求的第-一个空闲分区。<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220001798.png)<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-01-操作系统.html#_2、最佳适应算法)2、最佳适应算法<br>&emsp;&emsp;<br>&emsp;&emsp;算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区,即，优先使用更小的空闲区。<br>&emsp;&emsp;<br>&emsp;&emsp;如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。 ![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220001901.png)<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-01-操作系统.html#_3、最坏适应算法)3、最坏适应算法<br>&emsp;&emsp;<br>&emsp;&emsp;又称最大适应算法(Largest Fit)<br>&emsp;&emsp;<br>&emsp;&emsp;算法思想:为了解决最佳适应算法的问题—即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。<br>&emsp;&emsp;<br>&emsp;&emsp;如何实现:空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第-一个空闲分区。 ![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220001434.png)<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-01-操作系统.html#_4、邻近适应算法)4、邻近适应算法<br>&emsp;&emsp;<br>&emsp;&emsp;算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。<br>&emsp;&emsp;<br>&emsp;&emsp;如何实现：空闲分区以地址递增的顺序排列(可排成-一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。 ![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220001500.png)<br>&emsp;&emsp;<br>&emsp;&emsp;##### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-01-操作系统.html#_5、总结)5、总结<br>&emsp;&emsp;<br>&emsp;&emsp;首次适应不仅最简单，通常也是最好最快，不过首次适应算法会使得内存低地址部分出现很多小的空闲分区，而每次查找都要经过这些分区，因此也增加了查找的开销。邻近算法试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间分裂成小的碎片，它通常比首次适应算法结果要差。<br>&emsp;&emsp;<br>&emsp;&emsp;最佳导致大量碎片，最坏导致没有大的空间。<br>&emsp;&emsp;<br>&emsp;&emsp;进过实验，首次适应比最佳适应要好，他们都比最坏好。<br>&emsp;&emsp;<br>&emsp;&emsp;| 算法     | 算法思想                                           | 分区排列顺序                                 | 优点                                                         | 缺点                                                         |<br>&emsp;&emsp;| -------- | -------------------------------------------------- | -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |<br>&emsp;&emsp;| 首次适应 | 从头到尾找适合的分区                               | 空闲分区以地址递增次序排列                   | 综合看性能最好。算法开销小，回收分区后一.般不需要对空闲分区队列重新排序 |                                                              |<br>&emsp;&emsp;| 最佳适应 | 优先使用更小的分区，以保留更多大分区               | 空闲分区以容量递增次序排列                   | 会有更多的大分区被保留下来，更能满足大进程需求               | 会产生很多太小的、难以利用的碎片;算法开销大，回收分区后可能需要对空闲分区队列重新排序 |<br>&emsp;&emsp;| 最坏适应 | 优先使用更大的分区，以防止产生太小的不可用的碎片   | 空闲分区以容量递减次序排列                   | 可以减少难以利用的小碎片                                     | 大分区容易被用完，不利于大进程;算法开销大(原因同上)      |<br>&emsp;&emsp;| 邻近适应 | 由首次适应演变而来，每次从上次查找结束位置开始查找 | 空闲分区以地址递增次序排列(可排列成循环链表) | 不用每次都从低地址的小分区开始检索。算法开销小(原因同首次适应算法) | 会使高地址的大分区也被用完                                   |<hr><hr>gc::17、操作系统在对内存进行管理的时候需要做些什么?<hr>1. 操作系统<font color=#FEAE00>负责内存空间的分配与回收。</font><br>&emsp;&emsp;2. 操作系统<font color=#FEAE00>需要提供某种技术从逻辑上对内存空间进行扩充。</font><br>&emsp;&emsp;3. 操作系统需要提供<font color=#FEAE00>地址转换功能，</font>负责程序的逻辑地址与物理地址的转换。<br>&emsp;&emsp;4. 操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰<hr><hr>gc::60、为什么分段式存储管理有外部碎片而无内部碎片？为什么固定分区分配有内部碎片而不会有外部碎片？<br>&emsp;&emsp;<br>&emsp;&emsp;todo 更详细<hr>分段式分配是按需分配，而固定式分配是固定分配的方式。<hr><hr>gc::61、内部碎片与外部碎片<br>&emsp;&emsp;<br>&emsp;&emsp;todo<hr>内碎片：分配给某些进程的内存区域中有些部分没用上，常见于固定分配方式<br>&emsp;&emsp;<br>&emsp;&emsp;内存总量相同，100M<br>&emsp;&emsp;<br>&emsp;&emsp;固定分配，将100M分割成10块，每块10M，一个程序需要45M，那么需要分配5块，第五块只用了5M，剩下的5M就是内部碎片；<br>&emsp;&emsp;<br>&emsp;&emsp;分段式分配，按需分配，一个程序需要45M，就给分片45MB，剩下的55M供其它程序使用，不存在内部碎片。<br>&emsp;&emsp;<br>&emsp;&emsp;外碎片：内存中某些空闲区因为比较小，而难以利用上，一般出现在内存动态分配方式中<br>&emsp;&emsp;<br>&emsp;&emsp;分段式分配：内存总量相同，100M，比如，内存分配依次5M，15M，50M，25M，程序运行一段时间之后，5M，15M的程序运行完毕，释放内存，其他程序还在运行，再次分配一个10M的内存供其它程序使用，只能从头开始分片，这样，就会存在10M+5M的外部碎片<hr><hr>gc::62、如何消除碎片文件<hr>对于<font color=#FEAE00>外部碎片，通过</font><font color=#FEAE00>紧凑技术</font><font color=#FEAE00>消除，</font>就是操作系统不时地对进程进行移动和整理。但是这需要<font color=#FEAE00>动态重定位寄存器地支持，且相对费时</font>。紧凑地过程实际上类似于Windows系统中地磁盘整理程序，只不过后者是对外存空间地紧凑<br>&emsp;&emsp;<br>&emsp;&emsp;解决外部内存碎片的问题就是内存交换。<br>&emsp;&emsp;<br>&emsp;&emsp;可<font color=#929292>以把音乐程序占用的那</font><font color=#929292> 256MB </font><font color=#929292>内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的</font><font color=#929292> 512MB </font><font color=#929292>内存后面。这样就能空缺出连续的</font><font color=#929292> 256MB </font><font color=#929292>空间，于是新的</font><font color=#929292> 200MB </font><font color=#929292>程序就可以装载进来。</font><br>&emsp;&emsp;<br>&emsp;&emsp;回收内存时要尽可能地将相邻的空闲空间合并。<hr><hr>reactor::<font color=#FEAE00>Proactor</font><hr>proactor感知已完成读写的事件<br>&emsp;&emsp;---<br>&emsp;&emsp;<br>&emsp;&emsp;前面提到的 Reactor 是非阻塞同步网络模式，而 <font color=#00AB8E>Proactor </font><font color=#00AB8E>是异步网络模式</font><font color=#00AB8E>。</font><br>&emsp;&emsp;这里先给大家复习下阻塞、非阻塞、同步、异步 I/O 的概念。<br>&emsp;&emsp;先来看看<font color=#1DB100>阻塞</font><font color=#1DB100> I/O</font>，当用户程序执行 <font color=#4D647F>read</font> ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，<font color=#4D647F>read</font> 才会返回。<br>&emsp;&emsp;注意，<font color=#00AB8E>阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程</font>。过程如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;知道了阻塞 I/O ，来看看<font color=#00AB8E>非阻塞</font><font color=#00AB8E> I/O</font>，非阻塞的 read 请求在数据未准备好的情况下立即返回，可以继续往下执行，<font color=#00AB8E>此时应用程序不断轮询内核，直到数据准备好</font>，内核将数据拷贝到应用程序缓冲区，<font color=#4D647F>read</font> 调用才可以获取到结果。过程如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;注意，<font color=#00AB8E>这里最后一次</font><font color=#00AB8E> read </font><font color=#00AB8E>调用，获取数据的过程，是一个同步的过程，是需要等待的过程。这里的同步指的是内核态的数据拷贝到用户程序的缓存区这个过程。</font><br>&emsp;&emsp;举个例子，如果 socket 设置了 <font color=#FEAE00>O_NONBLOCK</font> 标志，那么就表示使用的是非阻塞 I/O 的方式访问，而不做任何设置的话，默认是阻塞 I/O。<br>&emsp;&emsp;因此，无论 read 和 send 是阻塞 I/O，还是非阻塞 I/O 都是同步调用。因为在 read 调用时，内核将数据从内核空间拷贝到用户空间的过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read 调用就会在这个同步过程中等待比较长的时间。<br>&emsp;&emsp;而真正的<font color=#00AB8E>异步</font><font color=#00AB8E> I/O</font><font color=#00AB8E> </font>是「内核数据准备好」和「数据从内核态拷贝到用户态」这<font color=#00AB8E>两个过程都不用等待</font>。<br>&emsp;&emsp;当我们发起 <font color=#FEAE00>aio_read </font>（异步 I/O） 之后，就立即返回，内核自动将数据从内核空间拷贝到用户空间，这个拷贝过程同样是异步的，内核自动完成的，和前面的同步操作不一样，<font color=#00AB8E>应用程序并不需要主动发起拷贝动作</font>。过程如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;举个你去饭堂吃饭的例子，你好比应用程序，饭堂好比操作系统。<br>&emsp;&emsp;阻塞 I/O 好比，你去饭堂吃饭，但是饭堂的菜还没做好，然后你就一直在那里等啊等，等了好长一段时间终于等到饭堂阿姨把菜端了出来（数据准备的过程），但是你还得继续等阿姨把菜（内核空间）打到你的饭盒里（用户空间），经历完这两个过程，你才可以离开。<br>&emsp;&emsp;非阻塞 I/O 好比，你去了饭堂，问阿姨菜做好了没有，阿姨告诉你没，你就离开了，过几十分钟，你又来饭堂问阿姨，阿姨说做好了，于是阿姨帮你把菜打到你的饭盒里，这个过程你是得等待的。<br>&emsp;&emsp;异步 I/O 好比，你让饭堂阿姨将菜做好并把菜打到饭盒里后，把饭盒送到你面前，整个过程你都不需要任何等待。<br>&emsp;&emsp;很明显，异步 I/O 比同步 I/O 性能更好，因为异步 I/O 在「内核数据准备好」和「数据从内核空间拷贝到用户空间」这两个过程都不用等待。<br>&emsp;&emsp;Proactor 正是采用了异步 I/O 技术，所以被称为异步网络模型。<br>&emsp;&emsp;现在我们再来理解 Reactor 和 Proactor 的区别，就比较清晰了。<br>&emsp;&emsp;<font color=#374EF4>	•	</font><font color=#FEAE00>Reactor </font><font color=#FEAE00>是非阻塞同步网络模式，感知的是就绪可读写事件</font>。在每次感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据读到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。<br>&emsp;&emsp;<font color=#374EF4>	•	</font><font color=#FEAE00>Proactor </font><font color=#FEAE00>是异步网络模式，</font><font color=#FEAE00> </font><font color=#FEAE00>感知的是已完成的读写事件</font>。在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息，这样系统内核才可以自动帮我们把数据的读写工作完成，这里的读写工作全程由操作系统来做，并不需要像 Reactor 那样还需要应用进程主动发起 read/write 来读写数据，操作系统完成读写工作后，就会通知应用进程直接处理数据。<br>&emsp;&emsp;因此，<font color=#FEAE00>Reactor </font><font color=#FEAE00>可以理解为「来了事件操作系统通知应用进程，让应用进程来处理」</font><font color=#929292>，而</font><font color=#929292> </font><font color=#FEAE00>Proactor </font><font color=#FEAE00>可以理解为「来了事件操作系统来处理，处理完再通知应用进程」</font>。这里的「事件」就是有新连接、有数据可读、有数据可写的这些 I/O 事件这里的「处理」包含从驱动读取到内核以及从内核读取到用户空间。<br>&emsp;&emsp;举个实际生活中的例子，Reactor 模式就是快递员在楼下，给你打电话告诉你快递到你家小区了，你需要自己下楼来拿快递。而在 Proactor 模式下，快递员直接将快递送到你家门口，然后通知你。<br>&emsp;&emsp;无论是 Reactor，还是 Proactor，都是一种基于「事件分发」的网络编程模式，区别在于 <font color=#FEAE00>Reactor </font><font color=#FEAE00>模式是基于「待完成」的</font><font color=#FEAE00> I/O </font><font color=#FEAE00>事件，而</font><font color=#FEAE00> Proactor </font><font color=#FEAE00>模式则是基于「已完成」的</font><font color=#FEAE00> I/O </font><font color=#FEAE00>事件</font><font color=#FEAE00>。</font><br>&emsp;&emsp;接下来，一起看看 Proactor 模式的示意图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;介绍一下 Proactor 模式的工作流程：<br>&emsp;&emsp;	•	Proactor Initiator 负责创建 Proactor 和 Handler 对象，并将 Proactor 和 Handler 都通过 Asynchronous Operation Processor 注册到内核；<br>&emsp;&emsp;	•	Asynchronous Operation Processor 负责处理注册请求，并处理 I/O 操作；<br>&emsp;&emsp;	•	Asynchronous Operation Processor 完成 I/O 操作后通知 Proactor；<br>&emsp;&emsp;	•	Proactor 根据不同的事件类型回调不同的 Handler 进行业务处理；<br>&emsp;&emsp;	•	Handler 完成业务处理；<br>&emsp;&emsp;可惜的是，在 Linux 下的异步 I/O 是不完善的，<font color=#FEAE00> aio </font><font color=#FEAE00>系列函数</font>是由 POSIX 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 aio 异步操作，网络编程中的 socket 是不支持的，这也使得基于 Linux 的高性能网络程序都是使用 Reactor 方案。<br>&emsp;&emsp;而 Windows 里实现了一套完整的支持 socket 的异步编程接口，这套接口就是 <font color=#00AB8E>IOCP</font>，是由操作系统级别实现的异步 I/O，真正意义上异步 I/O，因此在 Windows 里实现高性能网络程序可以使用效率更高的 Proactor 方案。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>reactor::<font color=#FEAE00>Reactor </font><font color=#FEAE00>三种模式</font><br>&emsp;&emsp;<hr>单 Reactor 单进程 / 线程<br>&emsp;&emsp;一般来说，C 语言实现的是「<font color=#FEAE00>单</font><font color=#FEAE00> Reactor</font><font color=#374EF4> </font><font color=#7414AF>单进程</font>」的方案，因为 C 语编写完的程序，运行后就是一个独立的进程，不需要在进程中再创建线程。<br>&emsp;&emsp;而 Java 语言实现的是「<font color=#FEAE00>单</font><font color=#FEAE00> Reactor</font><font color=#374EF4> </font><font color=#7414AF>单线程</font>」的方案，因为 Java 程序是跑在 Java 虚拟机这个进程上面的，虚拟机中有很多线程，我们写的 Java 程序只是其中的一个线程而已。<br>&emsp;&emsp;我们来看看「<font color=#FEAE00>单</font><font color=#FEAE00> Reactor </font><font color=#FEAE00>单进程</font>」的方案示意图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;可以看到进程里有 <font color=#FEAE00>Reactor</font><font color=#FEAE00>、</font><font color=#FEAE00>Acceptor</font><font color=#FEAE00>、</font><font color=#FEAE00>Handler</font> 这三个对象：<br>&emsp;&emsp;	•	Reactor 对象的作用是监听和分发事件；<br>&emsp;&emsp;	•	Acceptor 对象的作用是获取连接；<br>&emsp;&emsp;	•	Handler 对象的作用是处理业务；<br>&emsp;&emsp;对象里的 select、accept、read、send 是系统调用函数，dispatch 和 「业务处理」是需要完成的操作，其中 <font color=#FEAE00>dispatch </font><font color=#FEAE00>是分发事件操作</font>。<br>&emsp;&emsp;接下来，介绍下「单 Reactor 单进程」这个方案：<br>&emsp;&emsp;	•	Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；<br>&emsp;&emsp;	•	<font color=#FEAE00>如果是连接建立的事件，则交由</font><font color=#FEAE00> Acceptor </font><font color=#FEAE00>对象进行处理</font>，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；<br>&emsp;&emsp;	•	<font color=#FEAE00>如果不是连接建立事件，</font><font color=#FEAE00> </font><font color=#FEAE00>则交由当前连接对应的</font><font color=#FEAE00> Handler </font><font color=#FEAE00>对象来进行响应；</font><br>&emsp;&emsp;	•	Handler 对象通过 read -> 业务处理 -> send 的流程来完成完整的业务流程。<br>&emsp;&emsp;单 Reactor 单进程的方案因为全部工作都在同一个进程内完成，所以实现起来比较简单，不需要考虑进程间通信，也不用担心多进程竞争。<br>&emsp;&emsp;但是，这种方案存在 2 个缺点：<br>&emsp;&emsp;	•	第一个缺点，因为只有一个进程，<font color=#00AB8E>无法充分利用</font><font color=#00AB8E> </font><font color=#00AB8E>多核</font><font color=#00AB8E> CPU </font><font color=#00AB8E>的性能</font><font color=#00AB8E>；</font><br>&emsp;&emsp;	•	第二个缺点，Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，<font color=#00AB8E>如果业务处理耗时比较长，那么就造成响应的延迟</font><font color=#00AB8E>；</font><br>&emsp;&emsp;所以，单 Reactor 单进程的方案<font color=#00AB8E>不适用计算机密集型的场景，只适用于业务处理非常快速的场景</font><font color=#00AB8E>。</font><br>&emsp;&emsp;Redis 是由 C 语言实现的，在 Redis 6.0 版本之前采用的正是「<font color=#FEAE00>单</font><font color=#FEAE00> Reactor </font><font color=#FEAE00>单进程</font>」的方案，因为 Redis 业务处理主要是在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上，所以 Redis 对于命令的处理是单进程的方案。<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font>单 Reactor 多线程 / 多进程<br>&emsp;&emsp;如果要克服「单 Reactor 单线程 / 进程」方案的缺点，那么就需要引入多线程 / 多进程，这样就产生了<font color=#FEAE00>单</font><font color=#FEAE00> Reactor </font><font color=#FEAE00>多线程</font><font color=#FEAE00> / </font><font color=#FEAE00>多进程</font>的方案。<br>&emsp;&emsp;闻其名不如看其图，先来看看「单 Reactor 多线程」方案的示意图如下：<br>&emsp;&emsp;￼<br>&emsp;&emsp;详细说一下这个方案：<br>&emsp;&emsp;	•	Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 <font color=#FEAE00>dispatch </font><font color=#FEAE00>进行分发</font>，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；<br>&emsp;&emsp;	•	如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；<br>&emsp;&emsp;	•	如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；<br>&emsp;&emsp;上面的三个步骤和单 Reactor 单线程方案是一样的，接下来的步骤就开始不一样了：<br>&emsp;&emsp;	•	<font color=#FEAE00>Handler </font><font color=#FEAE00>对象不再负责业务处理，只负责数据的接收和发送</font>，Handler 对象通过 read 读取到数据后，会将数据发给子线程里的 Processor 对象进行业务处理；<br>&emsp;&emsp;	•	子线程里的 Processor 对象就进行业务处理，处理完后，将结果发给主线程中的 Handler 对象，接着由 Handler 通过 send 方法将响应结果发送给 client；<br>&emsp;&emsp;单 Reator 多线程的方案优势在于<font color=#FEAE00>能够充分利用多核</font><font color=#FEAE00> CPU </font><font color=#FEAE00>的能</font>，那既然引入多线程，那么自然就带来了多线程竞争资源的问题。<br>&emsp;&emsp;例如，子线程完成业务处理后，要把结果传递给主线程的 Handler 进行发送，这里涉及共享数据的竞争。<br>&emsp;&emsp;要避免多线程由于竞争共享资源而导致数据错乱的问题，<font color=#FEAE00>就需要在操作共享资源前加上互斥锁</font>，以保证任意时间里只有一个线程在操作共享资源，待该线程操作完释放互斥锁后，其他线程才有机会操作共享数据。<br>&emsp;&emsp;聊完单 Reactor 多线程的方案，接着来看看单 Reactor 多进程的方案。<br>&emsp;&emsp;事实上，单 Reactor 多进程相比单 Reactor 多线程实现起来很麻烦，主要因为要考虑子进程 <-> 父进程的双向通信，并且父进程还得知道子进程要将数据发送给哪个客户端。<br>&emsp;&emsp;而多线程间可以共享数据，虽然要额外考虑并发问题，但是这远比进程间通信的复杂度低得多，因此实际应用中也看不到单 Reactor 多进程的模式。<br>&emsp;&emsp;另外，「单 Reactor」的模式还有个问题，<font color=#FEAE00>因为一个</font><font color=#FEAE00> Reactor </font><font color=#FEAE00>对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方</font><font color=#FEAE00>。</font><br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font>多 Reactor 多进程 / 线程<br>&emsp;&emsp;要解决「单 Reactor」的问题，就是将「单 Reactor」实现成「多 Reactor」，这样就产生了第 <font color=#FEAE00>多</font><font color=#FEAE00> Reactor </font><font color=#FEAE00>多进程</font><font color=#FEAE00> / </font><font color=#FEAE00>线程</font>的方案。<br>&emsp;&emsp;老规矩，闻其名不如看其图。多 Reactor 多进程 / 线程方案的示意图如下（以线程为例）：<br>&emsp;&emsp;￼<br>&emsp;&emsp;方案详细说明如下：<br>&emsp;&emsp;	•	主线程中的 <font color=#FEAE00>MainReactor </font>对象通过 select 监控连接建立事件，收到事件后通过 <font color=#FEAE00>Acceptor </font><font color=#FEAE00>对象中的</font><font color=#FEAE00> accept </font><font color=#FEAE00>获取连接，将新的连接分配给某个子线程；</font><br>&emsp;&emsp;	•	子线程中的 <font color=#FEAE00>SubReactor </font><font color=#FEAE00>对象将</font><font color=#FEAE00> MainReactor</font> 对象分配的连接加入 select 继续进行监听，并创建一个 Handler 用于处理连接的响应事件。<br>&emsp;&emsp;	•	如果有新的事件发生时，SubReactor 对象会调用当前连接对应的 Handler 对象来进行响应。<br>&emsp;&emsp;	•	Handler 对象通过 read -> 业务处理 -> send 的流程来完成完整的业务流程。<br>&emsp;&emsp;多 Reactor 多线程的方案虽然看起来复杂的，但是实际实现时比单 Reactor 多线程的方案要简单的多，原因如下：<br>&emsp;&emsp;	•	主线程和子线程<font color=#FEAE00>分工明确，主线程只负责接收新连接，子线程负责完成后续的业务处理。</font><br>&emsp;&emsp;	•	主线程和子线程的交互很简单，主线程只需要把新连接传给子线程，子线程无须返回数据，直接就可以在子线程将处理结果发送给客户端。<br>&emsp;&emsp;大名鼎鼎的<font color=#FEAE00>两个开源软件</font><font color=#FEAE00> Netty </font><font color=#FEAE00>和</font><font color=#FEAE00> Memcache </font><font color=#FEAE00>都采用了「多</font><font color=#FEAE00> Reactor </font><font color=#FEAE00>多线程」的方案。</font><br>&emsp;&emsp;采用了「<font color=#FEAE00>多</font><font color=#FEAE00> Reactor </font><font color=#FEAE00>多进程」方案的开源软件是</font><font color=#FEAE00> Nginx</font><font color=#FEAE00>，不过方案与标准的多</font><font color=#FEAE00> Reactor </font><font color=#FEAE00>多进程有些差异</font>。<br>&emsp;&emsp;具体差异表现在主进程中仅仅用来初始化 socket，并没有创建 mainReactor 来 accept 连接，而是由子进程的 Reactor 来 accept 连接，通过锁来控制一次只有一个子进程进行 accept（防止出现惊群现象），子进程 accept 新连接后就放到自己的 Reactor 进行处理，不会再分配给其他子进程。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>reactor::高性能<font color=#FEAE00>网络模式</font>演进<hr>io多路复用形成反应堆 reactor模式<br>&emsp;&emsp;<br>&emsp;&emsp;---<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;如果要让服务器服务多个客户端，那么最直接的方式就是为<font color=#FEAE00>每一条连接创建线程</font>。<br>&emsp;&emsp;其实创建进程也是可以的，原理是一样的，进程和线程的区别在于线程比较轻量级些，线程的创建和线程间切换的成本要小些，为了描述简述，后面都以线程为例。<br>&emsp;&emsp;处理完业务逻辑后，随着连接关闭后线程也同样要销毁了，但是这样不停地创建和销毁线程，不仅会带来性能开销，也会造成浪费资源，而且如果要连接几万条连接，创建几万个线程去应对也是不现实的。<br>&emsp;&emsp;要这么解决这个问题呢？我们可以使用「<font color=#FEAE00>资源复用</font>」的方式。<br>&emsp;&emsp;也就是不用再为每个连接创建线程，而是创建一个「线程池」，<font color=#FEAE00>将连接分配给线程</font>，然后一个线程可以处理多个连接的业务。<br>&emsp;&emsp;不过，这样又引来一个新的问题，线程怎样才能高效地处理多个连接的业务？<br>&emsp;&emsp;当一个连接对应一个线程时，线程一般采用「read -> 业务处理 -> send」的处理流程，如果当前连接没有数据可读，那么线程会阻塞在 <font color=#4D647F>read</font> 操作上（ socket 默认情况是阻塞 I/O），不过这种阻塞方式并不影响其他线程。<br>&emsp;&emsp;但是引入了线程池，那么一个线程要处理多个连接的业务，线程在处理某个连接的 <font color=#4D647F>read</font> 操作时，如果遇到没有数据可读，<font color=#FEAE00>就会发生阻塞</font>，那么线程就没办法继续处理其他连接的业务。<br>&emsp;&emsp;要解决这一个问题，最简单的方式就是将 <font color=#FEAE00>socket </font><font color=#FEAE00>改成非阻塞</font>，然后线程不断地轮询调用 <font color=#4D647F>read</font> 操作来判断是否有数据，这种方式虽然该能够解决阻塞的问题，但是解决的方式比较粗暴，<font color=#FEAE00>因为轮询是要消耗</font><font color=#FEAE00> CPU </font><font color=#FEAE00>的</font>，而且随着一个 线程处理的连接越多，轮询的效率就会越低。<br>&emsp;&emsp;上面的问题在于，线程并不知道当前连接是否有数据可读，从而需要每次通过 <font color=#4D647F>read</font> 去试探。<br>&emsp;&emsp;那有没有办法在只有当连接上有数据的时候，线程才去发起读请求呢？答案是有的，实现这一技术的就是 I/O 多路复用。<br>&emsp;&emsp;<font color=#FEAE00>I/O </font><font color=#FEAE00>多路复用技术</font>会用<font color=#FEAE00>一个系统调用函数来监听</font>我们所有关心的连接，也就说可以在一个监控线程里面监控很多的连接。<br>&emsp;&emsp;￼<br>&emsp;&emsp;我们熟悉的 select/poll/epoll 就是内核提供给用户态的多路复用系统调用，线程可以通过一个系统调用函数从内核中获取多个事件。<br>&emsp;&emsp;PS：如果想知道 select/poll/epoll 的区别，可以看看小林之前写的这篇文章：<font color=#5478F6>这次答应我，一举拿下</font><font color=#5478F6> I/O </font><font color=#5478F6>多路复用！</font><font color=#5478F6><br>&emsp;&emsp;</font><font color=#5478F6>(opens new window)</font><font color=#5478F6><br>&emsp;&emsp;</font>select/poll/epoll 是如何获取网络事件的呢？<br>&emsp;&emsp;在获取事件时，先把我们要关心的连接传给内核，再由内核检测：<br>&emsp;&emsp;	•	<font color=#FEAE00>如果没有事件发生</font>，线程只需<font color=#FEAE00>阻塞在这个系统调用</font>，而无需像前面的线程池方案那样轮训调用 read 操作来判断是否有数据。<br>&emsp;&emsp;	•	如果有事件发生，内核会返回产生了事件的连接，线程就会从阻塞状态返回，然后在用户态中再处理这些连接对应的业务即可。<br>&emsp;&emsp;当下开源软件能做到网络高性能的原因就是 I/O 多路复用吗？<br>&emsp;&emsp;是的，基本是基于 I/O 多路复用，用过 I/O 多路复用接口写网络程序的同学，肯定知道<font color=#FEAE00>是面向过程的方式写代码</font>的，这样的开发的效率不高。<br>&emsp;&emsp;于是，大佬们基于面向对象的思想，对<font color=#FEAE00> I/O </font><font color=#FEAE00>多路复用作了一层封装</font>，让使用者不用考虑底层网络 API 的细节，只需要关注应用代码的编写。<br>&emsp;&emsp;大佬们还为这种模式取了个让人第一时间难以理解的名字：<font color=#00AB8E>Reactor </font><font color=#00AB8E>模式</font>。<br>&emsp;&emsp;Reactor 翻译过来的意思是「<font color=#00AB8E>反应堆</font>」，可能大家会联想到物理学里的核反应堆，实际上并不是的这个意思。<br>&emsp;&emsp;这里的反应指的是「<font color=#00AB8E>对事件反应</font>」，也就是<font color=#00AB8E>来了一个事件，</font><font color=#00AB8E>Reactor </font><font color=#00AB8E>就有相对应的反应</font><font color=#00AB8E>/</font><font color=#00AB8E>响应</font><font color=#00AB8E>。</font><br>&emsp;&emsp;事实上，Reactor 模式也叫<font color=#FEAE00> Dispatcher </font><font color=#FEAE00>模式</font>，我觉得这个名字更贴合该模式的含义，即<font color=#00AB8E> </font><font color=#00AB8E>I/O </font><font color=#00AB8E>多路复用监听事件，收到事件后，根据事件类型分配（</font><font color=#00AB8E>Dispatch</font><font color=#00AB8E>）给某个进程</font><font color=#00AB8E> / </font><font color=#00AB8E>线程</font><font color=#00AB8E>。</font><br>&emsp;&emsp;Reactor 模式主要由 Reactor 和处理资源池这两个核心部分组成，它俩负责的事情如下：<br>&emsp;&emsp;	•	<font color=#FEAE00>Reactor </font><font color=#FEAE00>负责监听和分发</font>事件，事件类型包含连接事件、读写事件；<br>&emsp;&emsp;	•	<font color=#FEAE00>处理资源池负责处理事件</font>，如 read -> 业务逻辑 -> send；<br>&emsp;&emsp;Reactor 模式是灵活多变的，可以应对不同的业务场景，灵活在于：<br>&emsp;&emsp;	•<font color=#00AB8E>	Reactor </font><font color=#00AB8E>的数量可以只有一个，也可以有多个</font>；<br>&emsp;&emsp;	•	<font color=#FEAE00>处理资源池可以是单个进程</font><font color=#FEAE00> / </font><font color=#FEAE00>线程</font>，也可以是多个进程 /线程；<br>&emsp;&emsp;将上面的两个因素排列组设一下，理论上就可以有 4 种方案选择：<br>&emsp;&emsp;	•	单 Reactor 单进程 / 线程；<br>&emsp;&emsp;	•	单 Reactor 多进程 / 线程；<br>&emsp;&emsp;	•	多 Reactor 单进程 / 线程；<br>&emsp;&emsp;	•	多 Reactor 多进程 / 线程；<br>&emsp;&emsp;其中，「多 Reactor 单进程 / 线程」实现方案相比「单 Reactor 单进程 / 线程」方案，不仅复杂而且也没有性能优势，因此实际中并没有应用。<br>&emsp;&emsp;剩下的 3 个方案都是比较经典的，且都有应用在实际的项目中：<br>&emsp;&emsp;	•	<font color=#FEAE00>单</font><font color=#FEAE00> Reactor </font><font color=#FEAE00>单进程</font><font color=#FEAE00> / </font><font color=#FEAE00>线程；</font><font color=#FEAE00><br>&emsp;&emsp;	•	</font><font color=#FEAE00>单</font><font color=#FEAE00> Reactor </font><font color=#FEAE00>多线程</font><font color=#FEAE00> / </font><font color=#FEAE00>进程；</font><font color=#FEAE00><br>&emsp;&emsp;	•	</font><font color=#FEAE00>多</font><font color=#FEAE00> Reactor </font><font color=#FEAE00>多进程</font><font color=#FEAE00> / </font><font color=#FEAE00>线程</font>；<br>&emsp;&emsp;方案具体使用进程还是线程，要看使用的编程语言以及平台有关：<br>&emsp;&emsp;	•	Java 语言一般使用线程，比如 Netty;<br>&emsp;&emsp;	•	C 语言使用进程和线程都可以，例如 Nginx 使用的是进程，Memcache 使用的是线程。<br>&emsp;&emsp;接下来，分别介绍这三个经典的 Reactor 方案。<hr><hr>一致性哈希::KV情况下, 使用<font color=#FEAE00>哈希算法</font>有什么问题？<hr>有的同学可能很快就想到了：<font color=#00AB8E>哈希算法</font>。因为对同一个关键字进行哈希计算，每次计算都是相同的值，<font color=#FEAE00>这样就可以将某个</font><font color=#FEAE00> key </font><font color=#FEAE00>确定到一个节点了</font>，可以满足分布式系统的负载均衡需求。<br>&emsp;&emsp;哈希算法最简单的做法就是进行取模运算，比如分布式系统中有 3 个节点，基于 <font color=#FEAE00>hash(key) % 3</font> 公式对数据进行了映射。<br>&emsp;&emsp;如果客户端要获取指定 key 的数据，通过下面的公式可以定位节点：<br>&emsp;&emsp;hash(key) % 3<br>&emsp;&emsp;如果经过上面这个公式计算后得到的值是 0，就说明该 key 需要去第一个节点获取。<br>&emsp;&emsp;但是有一个很致命的问题，<font color=#00AB8E>如果节点数量发生了变化，也就是在对系统做扩容或者缩容时，必须迁移改变了映射关系的数据</font>，否则会出现查询不到数据的问题。<br>&emsp;&emsp;举个例子，假设我们有一个由 A、B、C 三个节点组成分布式 KV 缓存系统，基于计算公式 <font color=#4D647F>hash(key) % 3</font> 将数据进行了映射，每个节点存储了不同的数据：<br>&emsp;&emsp;￼<br>&emsp;&emsp;现在有 3 个查询 key 的请求，分别查询 key-01，key-02，key-03 的数据，这三个 key 分别经过 hash() 函数计算后的值为 hash( key-01) = 6、hash( key-02) = 7、hash(key-03) = 8，然后再对这些值进行取模运算。<br>&emsp;&emsp;通过这样的哈希算法，每个 key 都可以定位到对应的节点。<br>&emsp;&emsp;￼<br>&emsp;&emsp;当 3 个节点不能满足业务需求了，<font color=#FEAE00>这时我们增加了一个节点，节点的数量从</font><font color=#FEAE00> 3 </font><font color=#FEAE00>变化为</font><font color=#FEAE00> 4</font>，意味取模哈希函数中基数的变化，这样会导致<font color=#00AB8E>大部分映射关系改变</font>，如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;比如，之前的 hash(key-01) % <font color=#4D647F>3</font> = 0，就变成了 hash(key-01) % <font color=#4D647F>4</font> = 2，查询 key-01 数据时，寻址到了节点 C，而 key-01 的数据是存储在节点 A 上的，不是在节点 C，所以会查询不到数据。<br>&emsp;&emsp;同样的道理，如果我们对<font color=#FEAE00>分布式系统进行缩容</font>，比如移除一个节点，也会因为取模哈希函数中基数的变化，可能出现查询不到数据的问题。<br>&emsp;&emsp;要解决这个问题的办法，就需要我们进行<font color=#00AB8E>迁移数据</font>，比如节点的数量从 3 变化为 4 时，要基于新的计算公式 hash(key) % 4 ，重新对数据和节点做映射。<br>&emsp;&emsp;假设总数据条数为 M，哈希算法在面对节点数量变化时，<font color=#FEAE00>最坏情况下所有数据都需要迁移，所以它的数据迁移规模是</font><font color=#FEAE00> O(M)</font>，这样数据的迁移成本太高了。<br>&emsp;&emsp;所以，我们应该要重新想一个新的算法，<font color=#00AB8E>来避免分布式系统在扩容或者缩容时，发生过多的数据迁移。</font><br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>一致性哈希::<font color=#FEAE00>一致性哈希</font> 多台服务器集群的时候如何分配请求? <br>&emsp;&emsp;<hr>1.轮训<br>&emsp;&emsp;2.分片情况下 负载均衡<br>&emsp;&emsp;---<br>&emsp;&emsp;<br>&emsp;&emsp;大多数网站背后肯定不是只有一台服务器提供服务，因为单机的并发量和数据量都是有限的，所以都会用<font color=#FEAE00>多台服务器构成集群</font>来对外提供服务。<br>&emsp;&emsp;但是问题来了，现在有那么多个节点（后面统称服务器为节点，因为少一个字），要如何<font color=#FEAE00>分配客户端的请求</font>呢？<br>&emsp;&emsp;￼<br>&emsp;&emsp;其实这个问题就是「<font color=#FEAE00>负载均衡问题</font>」。解决负载均衡问题的算法很多，不同的负载均衡算法，对应的就是不同的分配策略，适应的业务场景也不同。<br>&emsp;&emsp;最简单的方式，引入一个<font color=#FEAE00>中间的负载均衡层</font>，让它将外界的请求「<font color=#FEAE00>轮流</font>」的转发给内部的集群。比如集群有 3 个节点，外界请求有 3 个，那么每个节点都会处理 1 个请求，达到了分配请求的目的。<br>&emsp;&emsp;￼<br>&emsp;&emsp;考虑到每个节点的硬件配置有所区别，我们可以<font color=#FEAE00>引入权重值</font>，将硬件配置更好的节点的权重值设高，然后根据各个节点的权重值，按照一定比重分配在不同的节点上，让硬件配置更好的节点承担更多的请求，这种算法叫做<font color=#FEAE00>加权轮询</font>。<br>&emsp;&emsp;加权轮询算法使用场景是建立在<font color=#FEAE00>每个节点存储的数据都是相同的前提</font>。所以，每次读数据的请求，访问任意一个节点都能得到结果。<br>&emsp;&emsp;但是，加权轮询算法是无法应对「<font color=#FEAE00>分布式系统（数据分片的系统）</font>」的，因为分布式系统中，每个节点存储的数据是不同的。<br>&emsp;&emsp;当我们想提高系统的容量，就会将数据水平切分到不同的节点来存储，也就是将数据分布到了不同的节点。比如<font color=#00AB8E>一个分布式</font><font color=#00AB8E> KV</font><font color=#00AB8E>（</font><font color=#00AB8E>key-valu</font><font color=#00AB8E>）</font><font color=#00AB8E> </font><font color=#00AB8E>缓存系统，某个</font><font color=#00AB8E> key </font><font color=#00AB8E>应该到哪个或者哪些节点上获得，应该是确定的</font><font color=#00AB8E>，</font>不是说任意访问一个节点都可以得到缓存结果的。<br>&emsp;&emsp;因此，我们要想一个能应对分布式系统的负载均衡算法。<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>一致性哈希::如何通过<font color=#FEAE00>虚拟节点</font>提高均衡度？ && 总结<hr>要想解决节点能在哈希环上分配不均匀的问题，就是要有大量的节点，节点数越多，哈希环上的节点分布的就越均匀。<br>&emsp;&emsp;但问题是，实际中我们没有那么多节点。所以这个时候我们就加入<font color=#FEAE00>虚拟节点</font><font color=#FEAE00>，</font>也就是对一个真实节点做多个副本。<br>&emsp;&emsp;具体做法是，<font color=#FEAE00>不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系。</font><br>&emsp;&emsp;比如对每个节点分别设置 3 个虚拟节点：<br>&emsp;&emsp;	•	对节点 A 加上编号来作为虚拟节点：A-01、A-02、A-03<br>&emsp;&emsp;	•	对节点 B 加上编号来作为虚拟节点：B-01、B-02、B-03<br>&emsp;&emsp;	•	对节点 C 加上编号来作为虚拟节点：C-01、C-02、C-03<br>&emsp;&emsp;引入虚拟节点后，原本哈希环上只有 3 个节点的情况，就会变成有 9 个虚拟节点映射到哈希环上，哈希环上的节点数量多了 3 倍。<br>&emsp;&emsp;￼<br>&emsp;&emsp;你可以看到，<font color=#00AB8E>节点数量多了后，节点在哈希环上的分布就相对均匀了</font>。这时候，如果有访问请求寻址到「A-01」这个虚拟节点，接着再通过「A-01」虚拟节点找到真实节点 A，这样请求就能访问到真实节点 A 了。<br>&emsp;&emsp;上面为了方便你理解，每个真实节点仅包含 3 个虚拟节点，这样能起到的均衡效果其实很有限。而在实际的工程中，虚拟节点的数量会大很多，比如 <font color=#FEAE00>Nginx </font><font color=#FEAE00>的一致性哈希算法</font>，每个权重为 1 的<font color=#FEAE00>真实节点就含有</font><font color=#FEAE00>160 </font><font color=#FEAE00>个虚拟节点。</font><br>&emsp;&emsp;另外，虚拟节点除了会提高节点的均衡度，还会提高系统的稳定性。<font color=#00AB8E>当节点变化时，会有不同的节点共同分担系统的变化，因此稳定性更高</font><font color=#00AB8E>。</font><br>&emsp;&emsp;比如，当某个节点被移除时，对应该节点的多个虚拟节点均会移除，而这些虚拟节点按顺时针方向的下一个虚拟节点，可能会对应不同的真实节点，即这些不同的真实节点共同分担了节点变化导致的压力。<br>&emsp;&emsp;而且，有了虚拟节点后，还可以为硬件配置更好的节点增加权重，比如对权重更高的节点增加更多的虚拟机节点即可。<br>&emsp;&emsp;因此，<font color=#00AB8E>带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景</font><font color=#00AB8E>。</font><br>&emsp;&emsp;# 总结<br>&emsp;&emsp;不同的负载均衡算法适用的业务场景也不同的。<br>&emsp;&emsp;<font color=#FEAE00>轮询这类的</font>策略只能适用与每个节点的数据都是相同的场景，访问任意节点都能请求到数据。但是不适用分布式系统，因为分布式系统意味着数据水平切分到了不同的节点上，访问数据的时候，一定要寻址存储该数据的节点。<br>&emsp;&emsp;哈希算法虽然能建立数据和节点的映射关系，但是每次在节点数量发生变化的时候，最坏情况下所有数据都需要迁移，这样太麻烦了，所以不适用节点数量变化的场景。<br>&emsp;&emsp;<font color=#FEAE00>为了减少迁移的数据量</font>，就出现了一致性哈希算法。<br>&emsp;&emsp;一致性哈希是指将「<font color=#FEAE00>存储节点」和「数据</font>」都映射到一个首尾相连的哈希环上，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响。<br>&emsp;&emsp;但是一致性哈希算法不能够均匀的分布节点，会出现大量请求都集中在一个节点的情况，在这种情况下进行容灾与扩容时，容易出现雪崩的连锁反应。<br>&emsp;&emsp;为了解决一致性哈希算法不能够均匀的分布节点的问题，就需要引入虚拟节点，对一个真实节点做多个副本。不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系。<br>&emsp;&emsp;<font color=#FEAE00>引入虚拟节点后，可以会提高节点的均衡度，还会提高系统的稳定性</font>。所以，带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景。<br>&emsp;&emsp;完！<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>一致性哈希::未使用虚拟节点一致性哈希算法有什么问题？<hr><font color=#FEAE00>一致性哈希</font>算法就很好地解决了分布式系统在扩容或者缩容时，发生过多的数据迁移的问题。<br>&emsp;&emsp;一致哈希算法也用了取模运算，但与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而<font color=#00AB8E>一致哈希算法是对</font><font color=#00AB8E> 2^32 </font><font color=#00AB8E>进行取模运算，是一个固定的值</font><font color=#00AB8E>。</font><br>&emsp;&emsp;我们可以把一致哈希算法是对 2^32 进行取模运算的结果值组织成一个圆环，就像钟表一样，钟表的圆可以理解成由 60 个点组成的圆，而此处我们把这个圆想象成由 2^32 个点组成的圆，这个圆环被称<font color=#FEAE00>为</font><font color=#FEAE00>哈希环</font>，如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;一致性哈希要进行两步哈希：<br>&emsp;&emsp;	•	第一步：对存储节点进行哈希计算，也就是对存储节点做哈希映射，比如根据节点的 IP 地址进行哈希；<br>&emsp;&emsp;	•	第二步：当对数据进行存储或访问时，对数据进行哈希映射；<br>&emsp;&emsp;所以，<font color=#00AB8E>一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上</font>。<br>&emsp;&emsp;问题来了，对「数据」进行哈希映射得到一个结果要怎么找到存储该数据的节点呢？<br>&emsp;&emsp;答案是，映射的结果值往<font color=#00AB8E>顺时针的方向的找到第一个节点</font>，就是存储该数据的节点。<br>&emsp;&emsp;举个例子，有 3 个节点经过哈希计算，映射到了如下图的位置：<br>&emsp;&emsp;￼<br>&emsp;&emsp;接着，对要查询的 key-01 进行哈希计算，确定此 key-01 映射在哈希环的位置，然后从这个位置往顺时针的方向找到第一个节点，就是存储该 key-01 数据的节点。<br>&emsp;&emsp;比如，下图中的 key-01 映射的位置，往顺时针的方向找到第一个节点就是节点 A。<br>&emsp;&emsp;￼<br>&emsp;&emsp;所以，当需要对指定 key 的值进行读写的时候，要通过下面 2 步进行寻址：<br>&emsp;&emsp;	•	首先，对 key 进行哈希计算，确定此 key 在环上的位置；<br>&emsp;&emsp;	•	然后，从这个位置沿着顺时针方向走，遇到的第一节点就是存储 key 的节点。<br>&emsp;&emsp;知道了一致哈希寻址的方式，我们来看看，如果增加一个节点或者减少一个节点会发生大量的数据迁移吗？<br>&emsp;&emsp;假设节点数量从 3 增加到了 4，新的节点 D 经过哈希计算后映射到了下图中的位置：<br>&emsp;&emsp;￼<br>&emsp;&emsp;你可以看到，key-01、key-03 都不受影响，只有 key-02 需要被迁移节点 D。<br>&emsp;&emsp;假设节点数量从 3 减少到了 2，比如将节点 A 移除：<br>&emsp;&emsp;￼<br>&emsp;&emsp;你可以看到，key-02 和 key-03 不会受到影响，只有 key-01 需要被迁移节点 B。<br>&emsp;&emsp;因此，<font color=#FEAE00>在一致哈希算法中，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响</font>。<br>&emsp;&emsp;上面这些图中 3 个节点映射在哈希环还是比较分散的，所以看起来请求都会「均衡」到每个节点。<br>&emsp;&emsp;但是<font color=#FEAE00>一致性哈希算法并</font><font color=#1DB100>不保证节点</font><font color=#FEAE00>能够在哈希环上分布均匀</font>，这样就会带来一个问题，会<font color=#00AB8E>有大量的请求集中在一个节点上</font>。<br>&emsp;&emsp;比如，下图中 3 个节点的映射位置都在哈希环的右半边：<br>&emsp;&emsp;￼<br>&emsp;&emsp;这时候有一半以上的数据的寻址都会找节点 A，也就是访问请求主要集中的节点 A 上，这肯定不行的呀，说好的负载均衡呢，这种情况一点都不均衡。<br>&emsp;&emsp;另外，在这种节点分布不均匀的情况下，进行<font color=#FEAE00>容灾与扩容</font>时，哈希环上的相邻节点容易受到过大影响，容易发生<font color=#FEAE00>雪崩式的连锁反应</font>。<br>&emsp;&emsp;比如，上图中如果节点 A 被移除了，当节点 A 宕机后，根据一致性哈希算法的规则，其上数据应该全部迁移到相邻的节点 B 上，这样，节点 B 的数据量、访问量都会迅速增加很多倍，一旦新增的压力超过了节点 B 的处理能力上限，就会导致节点 B 崩溃，进而形成雪崩式的连锁反应。<br>&emsp;&emsp;所以，<font color=#00AB8E>一致性哈希算法虽然减少了数据迁移量，但是存在节点分布不均匀的问题</font><font color=#00AB8E>。</font><hr><hr>中断::40、Linux中异常和中断的区别<br>&emsp;&emsp;<br>&emsp;&emsp;todo 补充 中断处理的流程<hr>### 中断<br>&emsp;&emsp;<br>&emsp;&emsp;大家都知道，当我们在敲击键盘的同时就会产生中断，当硬盘读写完数据之后也会产生中断，所以，我们需要知道，中断是由硬件设备产生的，而它们从物理上说就是电信号，之后，它们通过中断控制器发送给CPU，接着CPU判断收到的中断来自于哪个硬件设备（这定义在内核中），最后，由CPU发送给内核，有内核处理中断。下面这张图显示了中断处理的流程：<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212344538.png)<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-02-操作系统.html#异常)异常<br>&emsp;&emsp;<br>&emsp;&emsp;我们在学习《计算机组成原理》的时候会知道两个概念，CPU处理程序的时候一旦程序不在内存中，会产生缺页异常；当运行除法程序时，当除数为0时，又会产生除0异常。所以，大家也需要记住的是，异常是由CPU产生的，同时，它会发送给内核，要求内核处理这些异常，下面这张图显示了异常处理的流程：<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212344494.png)<br>&emsp;&emsp;<br>&emsp;&emsp;### 相同点<br>&emsp;&emsp;<br>&emsp;&emsp;- 最后都是由CPU发送给内核，由内核去处理<br>&emsp;&emsp;- 处理程序的流程设计上是相似的<br>&emsp;&emsp;<br>&emsp;&emsp;### 不同点<br>&emsp;&emsp;<br>&emsp;&emsp;- 产生源不相同，异常是由CPU产生的，而中断是由硬件设备产生的<br>&emsp;&emsp;- 内核需要根据是异常还是中断调用不同的处理程序<br>&emsp;&emsp;- 中断不是时钟同步的，这意味着中断可能随时到来；异常由于是CPU产生的，所以它是时钟同步的<br>&emsp;&emsp;- 当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中<hr><hr>中断::4、外中断和异常有什么区别？<br>&emsp;&emsp;<br>&emsp;&emsp;todo 这两种处理程序<hr>外中断是指由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。<br>&emsp;&emsp;<br>&emsp;&emsp;而异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。<hr><hr>中断::中断了解么？ 都分为什么？<br>&emsp;&emsp;todo<hr><hr>中断::硬中断和软中断都是怎么实现的？ 内核中?<br>&emsp;&emsp;<hr>中断向量：中断服务程序的入口地址。<br>&emsp;&emsp;中断向量表：把系统中所有的中断类型码及其对应的中断向量按一定的规律存放在一个区域内，这个存储区域就叫做中断向量表。<br>&emsp;&emsp;内核陷入<br>&emsp;&emsp;关中断<br>&emsp;&emsp;扫描<br>&emsp;&emsp;保护现场<hr><hr>中断::系统调用、什么时候会阻塞，具体情况 <br>&emsp;&emsp;<br>&emsp;&emsp;todo<hr><hr>中断::系统里有<font color=#FEAE00>哪些软中断</font>? 怎么查看?<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;试一下<hr>通过 `<font color=#FEAE00>cat</font> <font color=#FEAE00>proc/softirps</font>` 来查看 软中断<br>&emsp;&emsp;`<font color=#FEAE00>cat</font> <font color=#FEAE00>proc/interrupts</font>` 来查看<font color=#FEAE00>硬中断</font><font color=#FEAE00><br>&emsp;&emsp;</font><br>&emsp;&emsp;可以查看到<font color=#FEAE00>每个</font><font color=#FEAE00>CPU</font><font color=#FEAE00>的累计运行次数</font>等. <br>&emsp;&emsp;比如 `<font color=#FEAE00>NET_RX</font>` 表示网络接收中断，`<font color=#FEAE00>NET_TX</font>` 表示网络发送中断、`<font color=#FEAE00>TIMER</font>` 表示定时中断、`<font color=#FEAE00>RCU</font>` 表示 RCU 锁中断、`<font color=#FEAE00>SCHED</font>` 表示<font color=#FEAE00>内核调度中断</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;排查错误时候使用 `<font color=#FEAE00>watch -d cat /proc/softirps</font>` 来查看变化速率<br>&emsp;&emsp;<br>&emsp;&emsp;软中断通过内核线程的方式执行: <br>&emsp;&emsp;`<font color=#FEAE00>ps aux | grep softirq</font>` <hr><hr><font color=#FEAE00>中断</font>是什么?  有什么好处? <hr>先来看看什么是中断？在计算机中，中断是系统<font color=#FEAE00>用来响应硬件设备请求</font>的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用<font color=#FEAE00>内核中的中断处理程序</font>来响应请求。<br>&emsp;&emsp;从这个例子，我们可以知道，中断是一种<font color=#1DB100>异步的事件处理机制，可以提高系统的并发处理能力。</font><br>&emsp;&emsp;操作系统收到了中断请求，会打断其他进程的运行，所以中断请求的响应程序，也就是<font color=#FEAE00>中断处理程序</font>，要<font color=#FEAE00>尽可能快的执行完</font>，这样可以减少对正常进程运行调度地影响。<br>&emsp;&emsp;而且，中断处理程序在响应中断时，可能还会「<font color=#FEAE00>临时关闭中断</font>」，这意味着，如果当前中断处理程序没有执行完之前，系统中其他的中断请求都无法被响应，也就说<font color=#FEAE00>中断有可能会丢失</font>，所以中断处理程序要短且快。<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;<hr><hr>交换::10、内存交换和覆盖有什么区别？<hr><font color=#FEAE00>交换技术主要是在不同进程</font>（或作业）之间进行，而覆盖则用于同一程序或进程中。<hr><hr>交换::27、内存的覆盖是什么？有什么特点？<hr>由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），<font color=#FEAE00>因此可以把用户空间分成为一个固定区和若干个覆盖区。</font>将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。<br>&emsp;&emsp;<br>&emsp;&emsp;覆盖技术的特点：<font color=#FEAE00>是打破了必须将一个进程的全部信息装入内存后才能运行的限制，</font>但当同时运行程序的代码量大于主存时仍不能运行，再而，大家要注意到，内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存。<hr><hr>交换::28、内存交换是什么？有什么特点？<hr>交换(对换)技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)<br>&emsp;&emsp;<br>&emsp;&emsp;换入：把准备好竞争CPU运行的程序从辅存移到内存。 换出：把处于等待状态（或CPU调度原则下被剥夺运行权力）的程序从内存移到辅存，把内存空间腾出来。<hr><hr>交换::29、什么时候会进行内存的交换？<hr>内存交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如:在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程;如果缺页率明显下降，就可以暂停换出。<hr><hr>交换::51、<font color=#FEAE00>内存交换</font>中，被<font color=#FEAE00>换出的进程</font>保存在磁盘的那个部分？<hr>保存在磁盘中，也就是外存中。具有对换功能的操作系统中，通常把<font color=#FEAE00>磁盘空间分为文件区和对换区两部分</font>。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。<font color=#FEAE00>由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度</font>，因此通常<font color=#FEAE00>对换区采用连续分配方</font>式(学过文件管理章节后即可理解)。总之，对换区的I/O速度比文件区的更快。<hr><hr>交换::52、在发生内存交换时，有些进程是被优先考虑的？你可以说一说吗？<hr><font color=#FEAE00>可优先换出阻塞进程</font><font color=#FEAE00>;</font><font color=#FEAE00>可换出优先级低的进程</font>;为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间… (注意: PCB 会常驻内存，不会被换出外存)<hr><hr>交换::55、内存交换你知道有哪些需要注意的关键点吗？<hr>1. <font color=#FEAE00>交换需要备份存储，通常是快速磁盘，它必须足够大，并且提供对这些内存映像的直接访问。</font><br>&emsp;&emsp;2. 为了有效使用CPU，需要每个进程的执行时间比交换时间长，而影响交换时间的主要是转移时间，转移时间与所交换的空间内存成正比。<br>&emsp;&emsp;3. <font color=#FEAE00>如果换出进程，比如确保该进程的内存空间成正比。</font><br>&emsp;&emsp;4. 交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用就可能很快。<br>&emsp;&emsp;5. 交换通常在有许多进程运行且内存空间吃紧时开始启动，而系统负荷降低就暂停。<br>&emsp;&emsp;6. 普通交换使用不多，但交换的策略的某些变种在许多系统中（如UNIX系统）仍然发挥作用。<hr><hr>什么是<font color=#FEAE00>软中断</font>? <br>&emsp;&emsp;<hr>前面我们也提到了，中断请求的处理程序应该要<font color=#FEAE00>短且快</font>，这样才能减少对正常进程运行调度地影响，而且中断处理程序可能会<font color=#FEAE00>暂时关闭中断</font>，这时如果中断处理程序执行时间过长，可能在还未执行完中断处理程序前，会丢失当前其他设备的中断请求。<br>&emsp;&emsp;那 Linux 系统为了解决<font color=#FEAE00>中断处理程序执行过长</font>和<font color=#FEAE00>中断丢失的问题</font>，将中断过程分成了两个阶段，分别是「上半部和下半部分」。<br>&emsp;&emsp;* 上半部: 硬中断 用来<font color=#FEAE00>快速处理中断</font>，一般会<font color=#FEAE00>暂时关闭中断请求</font>，主要负责处理跟<font color=#FEAE00>硬件紧密相关或者时间敏感</font>的事情。<br>&emsp;&emsp;* 下半部: 软中断 用来<font color=#FEAE00>延迟处理上半部未完成的工作</font>，一般以「<font color=#FEAE00>内核线程</font>」的方式运行。 (<font color=#FEAE00>软中断处理程序</font>) <br>&emsp;&emsp;区别2: 硬中断会打断CPU正在执行的任务, 然后立即执行中断处理程序, 而软中断对应软中断内核线程, [ksoftirqd/CPU 编号]<br>&emsp;&emsp;一些<font color=#FEAE00>内核自定义事件</font>也属于<font color=#FEAE00>软中断</font>，比如内核调度等、RCU 锁（内核里常用的一种锁）等。<br>&emsp;&emsp;<br>&emsp;&emsp;比如, <font color=#FEAE00>网卡接收网络包</font>: <br>&emsp;&emsp;网卡收到网络包后，会通过<font color=#FEAE00>硬件中断通知</font>内核有新的数据到了，于是内核就会调用对应的中断处理程序来响应该事件，这个事件的处理也是会分成上半部和下半部。<br>&emsp;&emsp;<br>&emsp;&emsp;上部分要做到快速处理，所以只要把<font color=#FEAE00>网卡的数据读到内存中，然后更新一下硬件寄存器的状态</font>，比如把状态更新为表示数据已经读到内存中的<font color=#FEAE00>状态值</font>。(<font color=#FEAE00>硬件相关</font>) <br>&emsp;&emsp;<br>&emsp;&emsp;接着，内核会触发一个<font color=#FEAE00>软中断</font>，把一些处理比较耗时且复杂的事情，交给「软中断处理程序」去做，也就是中断的下半部，其<font color=#FEAE00>主要是需要从内存中找到网络数据</font>，再按照<font color=#FEAE00>网络协议栈</font>，对网络数据<font color=#FEAE00>进行逐层解析和处理</font>，最后把数据送给应用程序。<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;<br>&emsp;&emsp;<hr><hr>冯诺依曼模型<hr>在 1945 年冯诺依曼和其他计算机科学家们提出了计算机具体实现的报告，其遵循了图灵机的设计，而且还提出用电子元件构造计算机，并约定了用二进制进行计算和存储。<br>&emsp;&emsp;最重要的是定义计算机基本结构为 5 个部分，分别是<font color=#374EF4>运算器、控制器、存储器、输入设备、输出设备</font>，这 5 个部分也被称为<font color=#374EF4>冯诺依曼模型</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;运算器、控制器是在中央处理器里的，存储器就我们常见的内存，输入输出设备则是计算机外接的设备，比如键盘就是输入设备，显示器就是输出设备。<br>&emsp;&emsp;存储单元和输入输出设备要与中央处理器打交道的话，离不开总线。所以，它们之间的关系如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;接下来，分别介绍内存、中央处理器、总线、输入输出设备。<br>&emsp;&emsp;# 内存<br>&emsp;&emsp;我们的程序和数据都是存储在内存，存储的区域是线性的。<br>&emsp;&emsp;在计算机数据存储中，存储数据的基本单位是<font color=#374EF4>字节（</font><font color=#7414AF>byte</font><font color=#374EF4>）</font>，1 字节等于 8 位（8 bit）。每一个字节都对应一个内存地址。<br>&emsp;&emsp;内存的地址是从 0 开始编号的，然后自增排列，最后一个地址为内存总字节数 - 1，这种结构好似我们程序里的数组，所以内存的读写任何一个数据的速度都是一样的。<br>&emsp;&emsp;# 中央处理器<br>&emsp;&emsp;中央处理器也就是我们常说的 CPU，32 位和 64 位 CPU 最主要区别在于一次能计算多少字节数据：<br>&emsp;&emsp;	•	32 位 CPU 一次可以计算 4 个字节；<br>&emsp;&emsp;	•	64 位 CPU 一次可以计算 8 个字节；<br>&emsp;&emsp;这里的 32 位和 64 位，通常称为 CPU 的位宽。<br>&emsp;&emsp;之所以 CPU 要这样设计，是为了能计算更大的数值，如果是 8 位的 CPU，那么一次只能计算 1 个字节 <font color=#4D647F>0~255</font> 范围内的数值，这样就无法一次完成计算 <font color=#4D647F>10000 * 500</font> ，于是为了能一次计算大数的运算，CPU 需要支持多个 byte 一起计算，所以 CPU 位宽越大，可以计算的数值就越大，比如说 32 位 CPU 能计算的最大整数是 <font color=#4D647F>4294967295</font>。<br>&emsp;&emsp;CPU 内部还有一些组件，常见的有<font color=#374EF4>寄存器、控制单元和逻辑运算单元</font>等。其中，控制单元负责控制 CPU 工作，逻辑运算单元负责计算，而寄存器可以分为多种类，每种寄存器的功能又不尽相同。<br>&emsp;&emsp;CPU 中的寄存器主要作用是存储计算时的数据，你可能好奇为什么有了内存还需要寄存器？原因很简单，因为内存离 CPU 太远了，而寄存器就在 CPU 里，还紧挨着控制单元和逻辑运算单元，自然计算时速度会很快。<br>&emsp;&emsp;常见的寄存器种类：<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>通用寄存器</font>，用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>程序计数器</font>，用来存储 CPU 要执行下一条指令「所在的内存地址」，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令的地址。<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>指令寄存器</font>，用来存放程序计数器指向的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里。<br>&emsp;&emsp;# 总线<br>&emsp;&emsp;总线是用于 CPU 和内存以及其他设备之间的通信，总线可分为 3 种：<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>地址总线</font>，用于指定 CPU 将要操作的内存地址；<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>数据总线</font>，用于读写内存的数据；<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>控制总线</font>，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线；<br>&emsp;&emsp;当 CPU 要读写内存数据的时候，一般需要通过下面这三个总线：<br>&emsp;&emsp;	•	首先要通过「地址总线」来指定内存的地址；<br>&emsp;&emsp;	•	然后通过「控制总线」控制是读或写命令；<br>&emsp;&emsp;	•	最后通过「数据总线」来传输数据；<br>&emsp;&emsp;# 输入、输出设备<br>&emsp;&emsp;输入设备向计算机输入数据，计算机经过计算后，把数据输出给输出设备。期间，如果输入设备是键盘，按下按键时是需要和 CPU 进行交互的，这时就需要用到控制总线了。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>分布::41、Windows和Linux环境下内存分布情况<hr>通过这张图你可以看到，用户空间内存，从低到高分别是 7 种不同的内存段：<br>&emsp;&emsp;<br>&emsp;&emsp;* 程序文件段，包括二进制可执行代码；<br>&emsp;&emsp;* 已初始化数据段，包括静态常量；<br>&emsp;&emsp;* 未初始化数据段，包括未初始化的静态变量；<br>&emsp;&emsp;* 堆段，包括动态分配的内存，从低地址开始向上增长；<br>&emsp;&emsp;* 文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）<br>&emsp;&emsp;* 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便我们自定义大小；<hr><hr>分布::42、一个由C/C++编译的程序占用的内存分为哪几个部分？<hr>1、栈区（stack）— 地址向下增长，由编译器自动分配释放，存放函数的参数值，局部变量的值等。先进后出。<br>&emsp;&emsp;<br>&emsp;&emsp;2、堆区（heap）— 地址向上增长，一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。<br>&emsp;&emsp;<br>&emsp;&emsp;3、全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后由系统释放<br>&emsp;&emsp;<br>&emsp;&emsp;4、文字常量区 —常量字符串就是放在这里的。程序结束后由系统释放<br>&emsp;&emsp;<br>&emsp;&emsp;5、程序代码区(text)—存放函数体的二进制代码。<hr><hr>同步::信号量如何保证PV的原子性<hr><hr>图灵机的工作方式?<hr>图灵机的工作方式<br>&emsp;&emsp;要想知道程序执行的原理，我们可以先从「图灵机」说起，图灵的基本思想是用机器来模拟人们用纸笔进行数学运算的过程，而且还定义了计算机由哪些部分组成，程序又是如何执行的。<br>&emsp;&emsp;图灵机长什么样子呢？你从下图可以看到图灵机的实际样子：<br>&emsp;&emsp;￼<br>&emsp;&emsp;图灵机的基本组成如下：<br>&emsp;&emsp;	•	有一条「纸带」，纸带由一个个连续的格子组成，每个格子可以写入字符，纸带就好比内存，而纸带上的格子的字符就好比内存中的数据或程序；<br>&emsp;&emsp;	•	有一个「读写头」，读写头可以读取纸带上任意格子的字符，也可以把字符写入到纸带的格子；<br>&emsp;&emsp;	•	读写头上有一些部件，比如存储单元、控制单元以及运算单元： 1、存储单元用于存放数据； 2、控制单元用于识别字符是数据还是指令，以及控制程序的流程等； 3、运算单元用于执行运算指令；<br>&emsp;&emsp;知道了图灵机的组成后，我们以简单数学运算的 <font color=#4D647F>1 + 2</font> 作为例子，来看看它是怎么执行这行代码的。<br>&emsp;&emsp;	•	首先，用读写头把 「1、2、+」这 3 个字符分别写入到纸带上的 3 个格子，然后读写头先停在 1 字符对应的格子上；<br>&emsp;&emsp;￼<br>&emsp;&emsp;	•	接着，读写头读入 1 到存储设备中，这个存储设备称为图灵机的状态；<br>&emsp;&emsp;￼<br>&emsp;&emsp;	•	然后读写头向右移动一个格，用同样的方式把 2 读入到图灵机的状态，于是现在图灵机的状态中存储着两个连续的数字， 1 和 2；<br>&emsp;&emsp;￼<br>&emsp;&emsp;	•	读写头再往右移动一个格，就会碰到 + 号，读写头读到 + 号后，将 + 号传输给「控制单元」，控制单元发现是一个 + 号而不是数字，所以没有存入到状态中，因为 <font color=#4D647F>+</font> 号是运算符指令，作用是加和目前的状态，于是通知「运算单元」工作。运算单元收到要加和状态中的值的通知后，就会把状态中的 1 和 2 读入并计算，再将计算的结果 3 存放到状态中；<br>&emsp;&emsp;￼<br>&emsp;&emsp;	•	最后，运算单元将结果返回给控制单元，控制单元将结果传输给读写头，读写头向右移动，把结果 3 写入到纸带的格子中；<br>&emsp;&emsp;￼<br>&emsp;&emsp;通过上面的图灵机计算 <font color=#4D647F>1 + 2</font> 的过程，可以发现图灵机主要功能就是读取纸带格子中的内容，然后交给控制单元识别字符是数字还是运算符指令，如果是数字则存入到图灵机状态中，如果是运算符，则通知运算符单元读取状态中的数值进行计算，计算结果最终返回给读写头，读写头把结果写入到纸带的格子中。<br>&emsp;&emsp;事实上，图灵机这个看起来很简单的工作方式，和我们今天的计算机是基本一样的。接下来，我们一同再看看当今计算机的组成以及工作方式。<hr><hr>图灵机的组成和工作方式?<hr>纸带, 读写头, 控制单元, 运算单元, 状态寄存器(机)?<br>&emsp;&emsp;##<br>&emsp;&emsp;* 纸带<br>&emsp;&emsp;* 读写头<br>&emsp;&emsp;* 存储单元 控制单元 运算单元<br>&emsp;&emsp;* 当前的状态，当前读到的东西 决定应该做出的指令<br>&emsp;&emsp;* 程序就是一个 状态机 ？<hr><hr>堆栈::43、一般情况下在Linux/windows平台下<font color=#FEAE00>栈空间的大小</font><hr>Linux环境下有操作系统决定，一般是8MB，8192KB，通过ulimit命令查看以及修改<br>&emsp;&emsp;<br>&emsp;&emsp;Windows环境下由编译器决定，VC++6.0一般是1M<br>&emsp;&emsp;<br>&emsp;&emsp;### Linux<br>&emsp;&emsp;<br>&emsp;&emsp;linux下非编译器决定栈大小，而是由操作系统环境决定，默认是8192KB（8M）；而在Windows平台下栈的大小是被记录在可执行文件中的（由编译器来设置)，即：windows下可以由编译器决定栈大小，而在Linux下是由系统环境变量来控制栈的大小的。<br>&emsp;&emsp;<br>&emsp;&emsp;在Linux下通过如下命令可查看和设置栈的大小：<br>&emsp;&emsp;<br>&emsp;&emsp;```shell<br>&emsp;&emsp;$ ulimit -a            # 显示当前栈的大小 （ulimit为系统命令，非编译器命令）       <br>&emsp;&emsp;$ ulimit -s 32768      # 设置当前栈的大小为32M<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;### Windows<br>&emsp;&emsp;<br>&emsp;&emsp;下程序栈空间的大小，VC++ 6.0 默认的栈空间是1M。<br>&emsp;&emsp;<br>&emsp;&emsp;VC6.0中修改堆栈大小的方法：<br>&emsp;&emsp;<br>&emsp;&emsp;- 选择 "Project->Setting"<br>&emsp;&emsp;- 选择 "Link"<br>&emsp;&emsp;- 选择 "Category"中的 "Output"<br>&emsp;&emsp;- 在 "Stack allocations"中的"Reserve:"中输栈的大小<hr><hr>堆栈::44、程序从<font color=#FEAE00>堆中</font>动态分配内存时，<font color=#FEAE00>虚拟内存</font>上怎么操作的<hr>页表：是一个存放在物理内存中的数据结构，它记录了虚拟页与物理页的映射关系<br>&emsp;&emsp;<br>&emsp;&emsp;在进行动态内存分配时，例如malloc()函数或者其他高级语言中的new关键字，操作系统会在硬盘中创建或申请一段虚拟内存空间，并更新到页表（分配一个页表条目（PTE），使该PTE指向硬盘上这个新创建的虚拟页），通过PTE建立虚拟页和物理页的映射关系。<hr><hr>堆栈::48、从<font color=#FEAE00>堆和栈上</font>建立对象哪个快？（考察堆和栈的分配效率比较）<hr>联系块表来说<br>&emsp;&emsp;<br>&emsp;&emsp;从两方面来考虑：<br>&emsp;&emsp;<br>&emsp;&emsp;- <font color=#FEAE00>分配和释放</font>，堆在分配和释放时都要调<font color=#FEAE00>用函数（</font><font color=#FEAE00>malloc,free)</font><font color=#FEAE00>，</font>比如分配时会到堆空间去寻找足够大小的空间（因为多次分配释放后会造成内存碎片），这些都会花费一定的时间，具体可以看看malloc和free的源代码，函数做了很多额外的工作，而栈却不需要这些。<br>&emsp;&emsp;- <font color=#FEAE00>访问时间</font>，<font color=#FEAE00>访问堆的一个具体单元，需要两次访问内存</font>，第一次得取得指针，第二次才是真正的数据，而栈只需访问一次。另外，堆的内容被操作系统交换到外存的概率比栈大，<font color=#FEAE00>栈一般是不会被交换出去的</font>。<hr><hr>堆栈::49、<font color=#FEAE00>程序内内存分配</font>方式有哪些（不是操作系统 orz<hr>内存分配方式<br>&emsp;&emsp;<br>&emsp;&emsp;（1） <font color=#FEAE00>从静态存储区域分配</font>。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。<br>&emsp;&emsp;<br>&emsp;&emsp;（2） <font color=#FEAE00>在栈上创建</font>。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。<font color=#FEAE00>栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;（3） <font color=#FEAE00>从堆上分配</font>，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。<hr><hr>多::生产者消费者模型实现<br>&emsp;&emsp;<br>&emsp;&emsp;todo 好像有了 在o. 16、进程同步的四种方法？ todo 整理<hr><hr>如何优化brk较少频繁系统调用? JeMalloc, tcMalloc, ptMalloc<hr><hr>如何写出让 CPU 跑得更快的代码？<hr>我们知道 CPU 访问内存的速度，比访问 CPU Cache 的速度慢了 100 多倍，所以如果 CPU 所要操作的数据在 CPU Cache 中的话，这样将会带来很大的性能提升。访问的数据在 CPU Cache 中的话，意味着<font color=#374EF4>缓存命中</font>，缓存命中率越高的话，代码的性能就会越好，CPU 也就跑的越快。<br>&emsp;&emsp;于是，「如何写出让 CPU 跑得更快的代码？」这个问题，可以改成「如何写出 CPU 缓存命中率高的代码？」。<br>&emsp;&emsp;在前面我也提到， L1 Cache 通常分为「数据缓存」和「指令缓存」，这是因为 CPU 会分别处理数据和指令，比如 <font color=#4D647F>1+1=2</font> 这个运算，<font color=#4D647F>+</font> 就是指令，会被放在「指令缓存」中，而输入数字 <font color=#4D647F>1</font> 则会被放在「数据缓存」里。<br>&emsp;&emsp;因此，<font color=#374EF4>我们要分开来看「数据缓存」和「指令缓存」的缓存命中率</font>。<br>&emsp;&emsp;# 如何提升数据缓存的命中率？<br>&emsp;&emsp;假设要遍历二维数组，有以下两种形式，虽然代码执行结果是一样，但你觉得哪种形式效率最高呢？为什么高呢？<br>&emsp;&emsp;￼<br>&emsp;&emsp;经过测试，形式一 <font color=#4D647F>array</font><font color=#4D647F>[</font><font color=#4D647F>i</font><font color=#4D647F>][</font><font color=#4D647F>j</font><font color=#4D647F>]</font> 执行时间比形式二 <font color=#4D647F>array</font><font color=#4D647F>[</font><font color=#4D647F>j</font><font color=#4D647F>][</font><font color=#4D647F>i</font><font color=#4D647F>]</font> 快好几倍。<br>&emsp;&emsp;之所以有这么大的差距，是因为二维数组 <font color=#4D647F>array</font> 所占用的内存是连续的，比如长度 <font color=#4D647F>N</font> 的值是 <font color=#4D647F>2</font> 的话，那么内存中的数组元素的布局顺序是这样的：<br>&emsp;&emsp;￼<br>&emsp;&emsp;形式一用 <font color=#4D647F>array</font><font color=#4D647F>[</font><font color=#4D647F>i</font><font color=#4D647F>][</font><font color=#4D647F>j</font><font color=#4D647F>]</font> 访问数组元素的顺序，正是和内存中数组元素存放的顺序一致。当 CPU 访问 <font color=#4D647F>array</font><font color=#4D647F>[</font><font color=#4D647F>0</font><font color=#4D647F>][</font><font color=#4D647F>0</font><font color=#4D647F>]</font> 时，由于该数据不在 Cache 中，于是会「顺序」把跟随其后的 3 个元素从内存中加载到 CPU Cache，这样当 CPU 访问后面的 3 个数组元素时，就能在 CPU Cache 中成功地找到数据，这意味着缓存命中率很高，缓存命中的数据不需要访问内存，这便大大提高了代码的性能。<br>&emsp;&emsp;而如果用形式二的 <font color=#4D647F>array</font><font color=#4D647F>[</font><font color=#4D647F>j</font><font color=#4D647F>][</font><font color=#4D647F>i</font><font color=#4D647F>]</font> 来访问，则访问的顺序就是：<br>&emsp;&emsp;￼<br>&emsp;&emsp;你可以看到，访问的方式跳跃式的，而不是顺序的，那么如果 N 的数值很大，那么操作 <font color=#4D647F>array</font><font color=#4D647F>[</font><font color=#4D647F>j</font><font color=#4D647F>][</font><font color=#4D647F>i</font><font color=#4D647F>]</font> 时，是没办法把 <font color=#4D647F>array</font><font color=#4D647F>[</font><font color=#4D647F>j+1</font><font color=#4D647F>][</font><font color=#4D647F>i</font><font color=#4D647F>]</font> 也读入到 CPU Cache 中的，既然 <font color=#4D647F>array</font><font color=#4D647F>[</font><font color=#4D647F>j+1</font><font color=#4D647F>][</font><font color=#4D647F>i</font><font color=#4D647F>]</font> 没有读取到 CPU Cache，那么就需要从内存读取该数据元素了。很明显，这种不连续性、跳跃式访问数据元素的方式，可能不能充分利用到了 CPU Cache 的特性，从而代码的性能不高。<br>&emsp;&emsp;那访问 <font color=#4D647F>array</font><font color=#4D647F>[</font><font color=#4D647F>0</font><font color=#4D647F>][</font><font color=#4D647F>0</font><font color=#4D647F>]</font> 元素时，CPU 具体会一次从内存中加载多少元素到 CPU Cache 呢？这个问题，在前面我们也提到过，这跟 CPU Cache Line 有关，它表示 <font color=#374EF4>CPU Cache </font><font color=#374EF4>一次性能加载数据的大小</font>，可以在 Linux 里通过 <font color=#4D647F>coherency_line_size</font> 配置查看 它的大小，通常是 64 个字节。<br>&emsp;&emsp;￼<br>&emsp;&emsp;也就是说，当 CPU 访问内存数据时，如果数据不在 CPU Cache 中，则会一次性会连续加载 64 字节大小的数据到 CPU Cache，那么当访问 <font color=#4D647F>array</font><font color=#4D647F>[</font><font color=#4D647F>0</font><font color=#4D647F>][</font><font color=#4D647F>0</font><font color=#4D647F>]</font> 时，由于该元素不足 64 字节，于是就会往后<font color=#374EF4>顺序</font>读取 <font color=#4D647F>array</font><font color=#4D647F>[</font><font color=#4D647F>0</font><font color=#4D647F>][</font><font color=#4D647F>0</font><font color=#4D647F>]</font><font color=#4D647F>~array</font><font color=#4D647F>[</font><font color=#4D647F>0</font><font color=#4D647F>][</font><font color=#4D647F>15</font><font color=#4D647F>]</font> 到 CPU Cache 中。顺序访问的 <font color=#4D647F>array</font><font color=#4D647F>[</font><font color=#4D647F>i</font><font color=#4D647F>][</font><font color=#4D647F>j</font><font color=#4D647F>]</font> 因为利用了这一特点，所以就会比跳跃式访问的 <font color=#4D647F>array</font><font color=#4D647F>[</font><font color=#4D647F>j</font><font color=#4D647F>][</font><font color=#4D647F>i</font><font color=#4D647F>]</font> 要快。<br>&emsp;&emsp;<font color=#374EF4>因此，遇到这种遍历数组的情况时，按照内存布局顺序访问，将可以有效的利用</font><font color=#374EF4> CPU Cache </font><font color=#374EF4>带来的好处，这样我们代码的性能就会得到很大的提升，</font><br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font>如何提升指令缓存的命中率？<br>&emsp;&emsp;提升数据的缓存命中率的方式，是按照内存布局顺序访问，那针对指令的缓存该如何提升呢？<br>&emsp;&emsp;我们以一个例子来看看，有一个元素为 0 到 100 之间随机数字组成的一维数组：<br>&emsp;&emsp;￼<br>&emsp;&emsp;接下来，对这个数组做两个操作：<br>&emsp;&emsp;￼<br>&emsp;&emsp;	•	第一个操作，循环遍历数组，把小于 50 的数组元素置为 0；<br>&emsp;&emsp;	•	第二个操作，将数组排序；<br>&emsp;&emsp;那么问题来了，你觉得先遍历再排序速度快，还是先排序再遍历速度快呢？<br>&emsp;&emsp;在回答这个问题之前，我们先了解 CPU 的<font color=#374EF4>分支预测器</font>。对于 if 条件语句，意味着此时至少可以选择跳转到两段不同的指令执行，也就是 if 还是 else 中的指令。那么，<font color=#374EF4>如果分支预测可以预测到接下来要执行</font><font color=#374EF4> if </font><font color=#374EF4>里的指令，还是</font><font color=#374EF4> else </font><font color=#374EF4>指令的话，就可以「提前」把这些指令放在指令缓存中，这样</font><font color=#374EF4> CPU </font><font color=#374EF4>可以直接从</font><font color=#374EF4> Cache </font><font color=#374EF4>读取到指令，于是执行速度就会很快</font>。<br>&emsp;&emsp;当数组中的元素是随机的，分支预测就无法有效工作，而当数组元素都是是顺序的，分支预测器会动态地根据历史命中数据对未来进行预测，这样命中率就会很高。<br>&emsp;&emsp;因此，先排序再遍历速度会更快，这是因为排序之后，数字是从小到大的，那么前几次循环命中 <font color=#4D647F>if < 50</font> 的次数会比较多，于是分支预测就会缓存 <font color=#4D647F>if</font> 里的 <font color=#4D647F>array</font><font color=#4D647F>[</font><font color=#4D647F>i</font><font color=#4D647F>]</font><font color=#4D647F> = 0</font> 指令到 Cache 中，后续 CPU 执行该指令就只需要从 Cache 读取就好了。<br>&emsp;&emsp;如果你肯定代码中的 <font color=#4D647F>if</font> 中的表达式判断为 <font color=#4D647F>true</font> 的概率比较高，我们可以使用显示分支预测工具，比如在 C/C++ 语言中编译器提供了 <font color=#4D647F>likely</font> 和 <font color=#4D647F>unlikely</font> 这两种宏，如果 <font color=#4D647F>if</font> 条件为 <font color=#4D647F>ture</font> 的概率大，则可以用 <font color=#4D647F>likely</font> 宏把 <font color=#4D647F>if</font> 里的表达式包裹起来，反之用 <font color=#4D647F>unlikely</font> 宏。<br>&emsp;&emsp;￼<br>&emsp;&emsp;实际上，CPU 自身的动态分支预测已经是比较准的了，所以只有当非常确信 CPU 预测的不准，且能够知道实际的概率情况时，才建议使用这两种宏。<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font>如何提升多核 CPU 的缓存命中率？<br>&emsp;&emsp;在单核 CPU，虽然只能执行一个线程，但是操作系统给每个线程分配了一个时间片，时间片用完了，就调度下一个线程，于是各个线程就按时间片交替地占用 CPU，从宏观上看起来各个线程同时在执行。<br>&emsp;&emsp;而现代 CPU 都是多核心的，线程可能在不同 CPU 核心来回切换执行，这对 CPU Cache 不是有利的，虽然 L3 Cache 是多核心之间共享的，但是 L1 和 L2 Cache 都是每个核心独有的，<font color=#374EF4>如果一个线程在不同核心来回切换，各个核心的缓存命中率就会受到影响</font>，相反如果线程都在同一个核心上执行，那么其数据的 L1 和 L2 Cache 的缓存命中率可以得到有效提高，缓存命中率高就意味着 CPU 可以减少访问 内存的频率。<br>&emsp;&emsp;当有多个同时执行「计算密集型」的线程，为了防止因为切换到不同的核心，而导致缓存命中率下降的问题，我们可以把<font color=#374EF4>线程绑定在某一个</font><font color=#374EF4> CPU </font><font color=#374EF4>核心上</font>，这样性能可以得到非常可观的提升。<br>&emsp;&emsp;在 Linux 上提供了 <font color=#4D647F>sched_setaffinity</font> 方法，来实现将线程绑定到某个 CPU 核心这一功能。<br>&emsp;&emsp;￼<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>如何创建守护进程?<hr>fork(), setsid(), fork(), close(fd), chdir('/') unmask(0), signal(SIGCHILD, SIG_IGN) 七步<br>&emsp;&emsp;##<br>&emsp;&emsp;linux daemon <br>&emsp;&emsp;（1）fork产生子进程，然后父进程exit退出, 便于后台执行<br>&emsp;&emsp;（2）setsid（）创建一个新会话期session, 成为新的会话组长和进程组长。控制终端、登录会话和进程组通常是从父进程继承下来的，守护进程要摆脱它们，不受它们的影响.<br>&emsp;&emsp;（3)  fork(), 禁止进程重新打开控制终端。经过以上步骤，进程已经成为一个无终端的会话组长，但是它可以重新申请打开一个终端。为了避免这种情况发生，可以通过使进程不再是会话组长来实现。再一次通过fork（）创建新的子进程，使调用fork的进程退出。<br>&emsp;&emsp;<br>&emsp;&emsp;（4) close(fd) 关闭不再需要的文件描述符。子进程从父进程继承打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。首先获得最高文件描述符值，然后用一个循环程序，关闭0到最高文件描述符值的所有文件描述符。<br>&emsp;&emsp;<br>&emsp;&emsp;（5）chdir('/') 将当前目录更改为根目录。<br>&emsp;&emsp;<br>&emsp;&emsp;（6）unmask(0) 子进程从父进程继承的文件创建屏蔽字可能会拒绝某些许可权。为防止这一点，使用unmask（0）将屏蔽字清零。<br>&emsp;&emsp;<br>&emsp;&emsp;（7）signal(SIGCHLD,SIG_IGN); 处理SIGCHLD信号。对于服务器进程，在请求到来时往往生成子进程处理请求。如果子进程等待父进程捕获状态，则子进程将成为僵尸进程（zombie），从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将SIGCHLD信号的操作设为SIG_IGN。这样，子进程结束时不会产生僵尸进程。<br>&emsp;&emsp;<hr><hr>如何定位<font color=#FEAE00>软中断</font><font color=#FEAE00> CPU </font><font color=#FEAE00>使用率过高</font>的问题? <hr>可以通过 `<font color=#FEAE00>top</font>` 命令, 看到每个 CPU 的 `<font color=#FEAE00>si</font>`, 就是软中断使用率 <br>&emsp;&emsp;以及 `<font color=#FEAE00>ksoftirpd</font>` 的CPU使用率<br>&emsp;&emsp;<br>&emsp;&emsp;如果发现 `<font color=#FEAE00>NET_RX</font>` <font color=#00AB8E>网络接收中断</font>次数的变化速率过快，接下来就可以使用 `<font color=#FEAE00>sar -n DEV</font>` 查看网卡的网络包接收速率情况，然后分析是哪个网卡有大量的网络包进来。<br>&emsp;&emsp;<br>&emsp;&emsp;接着，在通过 `<font color=#FEAE00>tcpdump</font>` 抓包，<font color=#FEAE00>分析这些包的来源</font>，如果是非法的地址，可以考虑加防火墙，如果是正常流量，则要考虑硬件升级等。<hr><hr>如何让程序跑的更快(什么决定, 如何优化)?<hr>指令数, CPI(流水线, 缓存) 时钟周期(跑的更快)<br>&emsp;&emsp;##<br>&emsp;&emsp;如果从缓存的角度： blabla的<br>&emsp;&emsp;<br>&emsp;&emsp;* CPU时钟周期数(CPU Cycles) * 时钟周期时间(Clock Cycle Time)<br>&emsp;&emsp;* 指令数 * CPI(Cycles Per Instruction) = CPU Cycles 可以拆开<br>&emsp;&emsp;* 因此优化：<br>&emsp;&emsp;  * 指令数<br>&emsp;&emsp;  * 每条指令的平均周期数 CPI, 流水线技术<br>&emsp;&emsp;  * 时钟周期时间：主频更快<hr><hr>存储器的层次关系<hr>现代的一台计算机，都用上了 CPU Cahce、内存、到 SSD 或 HDD 硬盘这些存储器设备了。<br>&emsp;&emsp;其中，存储空间越大的存储器设备，其访问速度越慢，所需成本也相对越少。<br>&emsp;&emsp;CPU 并不会直接和每一种存储器设备直接打交道，而是每一种存储器设备只和它相邻的存储器设备打交道。<br>&emsp;&emsp;比如，CPU Cache 的数据是从内存加载过来的，写回数据的时候也只写回到内存，CPU Cache 不会直接把数据写到硬盘，也不会直接从硬盘加载数据，而是先加载到内存，再从内存加载到 CPU Cache 中。<br>&emsp;&emsp;￼<br>&emsp;&emsp;所以，<font color=#374EF4>每个存储器只和相邻的一层存储器设备打交道，并且存储设备为了追求更快的速度，所需的材料成本必然也是更高，也正因为成本太高，所以</font><font color=#374EF4> CPU </font><font color=#374EF4>内部的寄存器、</font><font color=#374EF4>L1\L2\L3 Cache </font><font color=#374EF4>只好用较小的容量，相反内存、硬盘则可用更大的容量，这就我们今天所说的存储器层次结构</font>。<br>&emsp;&emsp;另外，当 CPU 需要访问内存中某个数据的时候，如果寄存器有这个数据，CPU 就直接从寄存器取数据即可，如果寄存器没有这个数据，CPU 就会查询 L1 高速缓存，如果 L1 没有，则查询 L2 高速缓存，L2 还是没有的话就查询 L3 高速缓存，L3 依然没有的话，才去内存中取数据。<br>&emsp;&emsp;￼<br>&emsp;&emsp;所以，存储层次结构也形成了<font color=#374EF4>缓存</font>的体系。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font>存储器之间的实际价格和性能差距<br>&emsp;&emsp;前面我们知道了，速度越快的存储器，造价成本往往也越高，那我们就以实际的数据来看看，不同层级的存储器之间的性能和价格差异。<br>&emsp;&emsp;下面这张表格是不同层级的存储器之间的成本对比图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;你可以看到 L1 Cache 的访问延时是 1 纳秒，而内存已经是 100 纳秒了，相比 L1 Cache 速度慢了 <font color=#4D647F>100</font> 倍。另外，机械硬盘的访问延时更是高达 10 毫秒，相比 L1 Cache 速度慢了 <font color=#4D647F>10000000</font> 倍，差了好几个数量级别。<br>&emsp;&emsp;在价格上，每生成 MB 大小的 L1 Cache 相比内存贵了 <font color=#4D647F>466</font> 倍，相比机械硬盘那更是贵了 <font color=#4D647F>175000</font> 倍。<br>&emsp;&emsp;我在某东逛了下各个存储器设备的零售价，8G 内存 + 1T 机械硬盘 + 256G 固态硬盘的总价格，都不及一块 Intle i5-10400 的 CPU 的价格，这款 CPU 的高速缓存的总大小也就十多 MB。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>存储器的层次结构<hr>我们想象中一个场景，大学期末准备考试了，你前去图书馆临时抱佛脚。那么，在看书的时候，我们的大脑会思考问题，也会记忆知识点，另外我们通常也会把常用的书放在自己的桌子上，当我们要找一本不常用的书，则会去图书馆的书架找。<br>&emsp;&emsp;就是这么一个小小的场景，已经把计算机的存储结构基本都涵盖了。<br>&emsp;&emsp;我们可以把 CPU 比喻成我们的大脑，大脑正在思考的东西，就好比 CPU 中的<font color=#374EF4>寄存器</font>，处理速度是最快的，但是能存储的数据也是最少的，毕竟我们也不能一下同时思考太多的事情，除非你练过。<br>&emsp;&emsp;我们大脑中的记忆，就好比 <font color=#374EF4>CPU Cache</font>，中文称为 CPU 高速缓存，处理速度相比寄存器慢了一点，但是能存储的数据也稍微多了一些。<br>&emsp;&emsp;CPU Cache 通常会分为 <font color=#374EF4>L1</font><font color=#374EF4>、</font><font color=#374EF4>L2</font><font color=#374EF4>、</font><font color=#374EF4>L3 </font><font color=#374EF4>三层</font>，其中 L1 Cache 通常分成「数据缓存」和「指令缓存」，L1 是距离 CPU 最近的，因此它比 L2、L3 的读写速度都快、存储空间都小。我们大脑中短期记忆，就好比 L1 Cache，而长期记忆就好比 L2/L3 Cache。<br>&emsp;&emsp;寄存器和 CPU Cache 都是在 CPU 内部，跟 CPU 挨着很近，因此它们的读写速度都相当的快，但是能存储的数据很少，毕竟 CPU 就这么丁点大。<br>&emsp;&emsp;知道 CPU 内部的存储器的层次分布，我们放眼看看 CPU 外部的存储器。<br>&emsp;&emsp;当我们大脑记忆中没有资料的时候，可以从书桌或书架上拿书来阅读，那我们桌子上的书，就好比<font color=#374EF4>内存</font>，我们虽然可以一伸手就可以拿到，但读写速度肯定远慢于寄存器，那图书馆书架上的书，就好比<font color=#374EF4>硬盘</font>，能存储的数据非常大，但是读写速度相比内存差好几个数量级，更别说跟寄存器的差距了。<br>&emsp;&emsp;￼<br>&emsp;&emsp;我们从图书馆书架取书，把书放到桌子上，再阅读书，我们大脑就会记忆知识点，然后再经过大脑思考，这一系列过程相当于，数据从硬盘加载到内存，再从内存加载到 CPU 的寄存器和 Cache 中，然后再通过 CPU 进行处理和计算。<br>&emsp;&emsp;<font color=#374EF4>对于存储器，它的速度越快、能耗会越高、而且材料的成本也是越贵的，以至于速度快的存储器的容量都比较小。</font><br>&emsp;&emsp;CPU 里的寄存器和 Cache，是整个计算机存储器中价格最贵的，虽然存储空间很小，但是读写速度是极快的，而相对比较便宜的内存和硬盘，速度肯定比不上 CPU 内部的存储器，但是能弥补存储空间的不足。<br>&emsp;&emsp;存储器通常可以分为这么几个级别：<br>&emsp;&emsp;￼<br>&emsp;&emsp;	•	寄存器；<br>&emsp;&emsp;	•	CPU Cache；<br>&emsp;&emsp;	1	L1-Cache；<br>&emsp;&emsp;	2	L2-Cache；<br>&emsp;&emsp;	3	L3-Cahce；<br>&emsp;&emsp;	•	内存；<br>&emsp;&emsp;	•	SSD/HDD 硬盘<br>&emsp;&emsp;# 寄存器<br>&emsp;&emsp;最靠近 CPU 的控制单元和逻辑计算单元的存储器，就是寄存器了，它使用的材料速度也是最快的，因此价格也是最贵的，那么数量不能很多。<br>&emsp;&emsp;存储器的数量通常在几十到几百之间，每个寄存器可以用来存储一定的字节（byte）的数据。比如：<br>&emsp;&emsp;	•	32 位 CPU 中大多数寄存器可以存储 <font color=#4D647F>4</font> 个字节；<br>&emsp;&emsp;	•	64 位 CPU 中大多数寄存器可以存储 <font color=#4D647F>8</font> 个字节。<br>&emsp;&emsp;寄存器的访问速度非常快，一般要求在半个 CPU 时钟周期内完成读写，CPU 时钟周期跟 CPU 主频息息相关，比如 2 GHz 主频的 CPU，那么它的时钟周期就是 1/2G，也就是 0.5ns（纳秒）。<br>&emsp;&emsp;CPU 处理一条指令的时候，除了读写寄存器，还需要解码指令、控制指令执行和计算。如果寄存器的速度太慢，则会拉长指令的处理周期，从而给用户的感觉，就是电脑「很慢」。<br>&emsp;&emsp;# CPU Cache<br>&emsp;&emsp;CPU Cache 用的是一种叫 <font color=#374EF4>SRAM</font><font color=#374EF4>（</font><font color=#7414AF>Static Random-Access</font><font color=#374EF4> Memory</font><font color=#374EF4>，静态随机存储器）</font> 的芯片。<br>&emsp;&emsp;SRAM 之所以叫「静态」存储器，是因为只要有电，数据就可以保持存在，而一旦断电，数据就会丢失了。<br>&emsp;&emsp;在 SRAM 里面，一个 bit 的数据，通常需要 6 个晶体管，所以 SRAM 的存储密度不高，同样的物理空间下，能存储的数据是有限的，不过也因为 SRAM 的电路简单，所以访问速度非常快。<br>&emsp;&emsp;CPU 的高速缓存，通常可以分为 L1、L2、L3 这样的三层高速缓存，也称为一级缓存、二级缓存、三级缓存。<br>&emsp;&emsp;￼<br>&emsp;&emsp;# L1 高速缓存<br>&emsp;&emsp;L1 高速缓存的访问速度几乎和寄存器一样快，通常只需要 <font color=#4D647F>2~4</font> 个时钟周期，而大小在几十 KB 到几百 KB 不等。<br>&emsp;&emsp;每个 CPU 核心都有一块属于自己的 L1 高速缓存，指令和数据在 L1 是分开存放的，所以 L1 高速缓存通常分成<font color=#374EF4>指令缓存</font>和<font color=#374EF4>数据缓存</font>。<br>&emsp;&emsp;在 Linux 系统，我们可以通过这条命令，查看 CPU 里的 L1 Cache 「数据」缓存的容量大小：<br>&emsp;&emsp;$ <font color=#AA5925>cat</font> /sys/devices/system/cpu/cpu0/cache/index0/size<br>&emsp;&emsp;32K<br>&emsp;&emsp;而查看 L1 Cache 「指令」缓存的容量大小，则是：<br>&emsp;&emsp;$ <font color=#AA5925>cat</font> /sys/devices/system/cpu/cpu0/cache/index1/size<br>&emsp;&emsp;32K<br>&emsp;&emsp;# L2 高速缓存<br>&emsp;&emsp;L2 高速缓存同样每个 CPU 核心都有，但是 L2 高速缓存位置比 L1 高速缓存距离 CPU 核心 更远，它大小比 L1 高速缓存更大，CPU 型号不同大小也就不同，通常大小在几百 KB 到几 MB 不等，访问速度则更慢，速度在 <font color=#4D647F>10~20</font> 个时钟周期。<br>&emsp;&emsp;在 Linux 系统，我们可以通过这条命令，查看 CPU 里的 L2 Cache 的容量大小：<br>&emsp;&emsp;$ <font color=#AA5925>cat</font> /sys/devices/system/cpu/cpu0/cache/index2/size<br>&emsp;&emsp;256K<br>&emsp;&emsp;# L3 高速缓存<br>&emsp;&emsp;L3 高速缓存通常是多个 CPU 核心共用的，位置比 L2 高速缓存距离 CPU 核心 更远，大小也会更大些，通常大小在几 MB 到几十 MB 不等，具体值根据 CPU 型号而定。<br>&emsp;&emsp;访问速度相对也比较慢一些，访问速度在 <font color=#4D647F>20~60</font>个时钟周期。<br>&emsp;&emsp;在 Linux 系统，我们可以通过这条命令，查看 CPU 里的 L3 Cache 的容量大小：<br>&emsp;&emsp;$ <font color=#AA5925>cat</font> /sys/devices/system/cpu/cpu0/cache/index3/size <br>&emsp;&emsp;3072K<br>&emsp;&emsp;# 内存<br>&emsp;&emsp;内存用的芯片和 CPU Cache 有所不同，它使用的是一种叫作 <font color=#374EF4>DRAM </font><font color=#374EF4>（</font><font color=#7414AF>Dynamic Random Access Memory</font><font color=#374EF4>，动态随机存取存储器）</font> 的芯片。<br>&emsp;&emsp;相比 SRAM，DRAM 的密度更高，功耗更低，有更大的容量，而且造价比 SRAM 芯片便宜很多。<br>&emsp;&emsp;DRAM 存储一个 bit 数据，只需要一个晶体管和一个电容就能存储，但是因为数据会被存储在电容里，电容会不断漏电，所以需要「定时刷新」电容，才能保证数据不会被丢失，这就是 DRAM 之所以被称为「动态」存储器的原因，只有不断刷新，数据才能被存储起来。<br>&emsp;&emsp;DRAM 的数据访问电路和刷新电路都比 SRAM 更复杂，所以访问的速度会更慢，内存速度大概在 <font color=#4D647F>200~300</font> 个 时钟周期之间。<br>&emsp;&emsp;# SSD/HDD 硬盘<br>&emsp;&emsp;SSD（<font color=#7414AF>Solid-state disk</font>） 就是我们常说的固体硬盘，结构和内存类似，但是它相比内存的优点是断电后数据还是存在的，而内存、寄存器、高速缓存断电后数据都会丢失。内存的读写速度比 SSD 大概快 <font color=#4D647F>10~1000</font> 倍。<br>&emsp;&emsp;当然，还有一款传统的硬盘，也就是机械硬盘（<font color=#7414AF>Hard Disk Drive, HDD</font>），它是通过物理读写的方式来访问数据的，因此它访问速度是非常慢的，它的速度比内存慢 <font color=#4D647F>10W</font> 倍左右。<br>&emsp;&emsp;由于 SSD 的价格快接近机械硬盘了，因此机械硬盘已经逐渐被 SSD 替代了。<hr><hr>存储系统 I/O 软件分层<hr>前面说到了不少东西，设备、设备控制器、驱动程序、通用块层，现在再结合文件系统原理，我们来看看 Linux 存储系统的 <font color=#FEAE00>I/O </font><font color=#FEAE00>软件分层</font>。<br>&emsp;&emsp;可以把 Linux 存储系统的 I/O 由上到下可以分为三个层次，分别是<font color=#FEAE00>文件系统层、通用块层、设备层</font>。他们整个的层次关系如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;这三个层次的作用是：<br>&emsp;&emsp;	•	<font color=#FEAE00>文件系统层</font>，包括虚拟文件系统和其他文件系统的具体实现，它向上为应用程序统一提供了标准的文件访问接口，向下会通过通用块层来存储和管理磁盘数据。<br>&emsp;&emsp;	•	<font color=#FEAE00>通用块层</font>，包括<font color=#FEAE00>块设备的</font><font color=#FEAE00> I/O </font><font color=#FEAE00>队列和</font><font color=#FEAE00> I/O </font><font color=#FEAE00>调度器</font>，它会对文件系统的 I/O 请求进行排队，再通过 I/O 调度器，选择一个 I/O 发给下一层的设备层。<br>&emsp;&emsp;	•	<font color=#FEAE00>设备层</font>，包括<font color=#FEAE00>硬件设备、设备控制器和驱动程序</font>，负责最终物理设备的 I/O 操作。<br>&emsp;&emsp;有了文件系统接口之后，不但可以通过文件系统的命令行操作设备，也可以通过应用程序，调用 <font color=#4D647F>read</font>、<font color=#4D647F>write</font> 函数，就像读写文件一样操作设备，所以说<font color=#FEAE00>设备在</font><font color=#FEAE00> Linux </font><font color=#FEAE00>下，也只是一个特殊的文件</font>。<br>&emsp;&emsp;但是，除了读写操作，还需要有检查特定于设备的功能和属性。于是，需要 <font color=#FEAE00>ioctl </font><font color=#FEAE00>接口</font>，它表示输入输出控制接口，是用于<font color=#FEAE00>配置和修改特定设备属性的通用接口</font>。<br>&emsp;&emsp;另外，存储系统的 I/O 是整个系统最慢的一个环节，所以 Linux 提供了不少缓存机制来提高 I/O 的效率。<br>&emsp;&emsp;	•	为了提高文件访问的效率，会使用<font color=#00A2FF>页缓存、索引节点缓存、目录项缓存</font>等多种缓存机制，目的是为了减少对块设备的直接调用。<br>&emsp;&emsp;	•	为了提高块设备的访问效率， 会使用<font color=#00A2FF>缓冲区</font>，来缓存块设备的数据。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>寄存器的分类? <hr>通用, 程序计数, 指令<br>&emsp;&emsp;##<br>&emsp;&emsp;* 通用寄存器：存放运算的数据<br>&emsp;&emsp;* 程序计数器：PC，存放下一条要执行的指令<br>&emsp;&emsp;* 指令寄存器：存放PC指向的指令<hr><hr>并发::16、进程同步的四种方法？<br>&emsp;&emsp;<br>&emsp;&emsp;todo 整理<hr>### 1. 临界区<br>&emsp;&emsp;<br>&emsp;&emsp;对临界资源进行访问的那段代码称为临界区。<br>&emsp;&emsp;<br>&emsp;&emsp;为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。<br>&emsp;&emsp;<br>&emsp;&emsp;```html<br>&emsp;&emsp;// entry section<br>&emsp;&emsp;// critical section;<br>&emsp;&emsp;// exit section<br>&emsp;&emsp; <br>&emsp;&emsp;        @阿秀: 代码已成功复制到剪贴板<br>&emsp;&emsp;    <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;1<br>&emsp;&emsp;2<br>&emsp;&emsp;3<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-01-操作系统.html#_2-同步与互斥)2. 同步与互斥<br>&emsp;&emsp;<br>&emsp;&emsp;- 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。<br>&emsp;&emsp;- 互斥：多个进程在同一时刻只有一个进程能进入临界区。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-01-操作系统.html#_3-信号量)3. 信号量<br>&emsp;&emsp;<br>&emsp;&emsp;信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。<br>&emsp;&emsp;<br>&emsp;&emsp;- down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；<br>&emsp;&emsp;- up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。<br>&emsp;&emsp;<br>&emsp;&emsp;down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。<br>&emsp;&emsp;<br>&emsp;&emsp;如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。<br>&emsp;&emsp;<br>&emsp;&emsp;```c<br>&emsp;&emsp;typedef int semaphore;<br>&emsp;&emsp;semaphore mutex = 1;<br>&emsp;&emsp;void P1() {<br>&emsp;&emsp;    down(&mutex);<br>&emsp;&emsp;    // 临界区<br>&emsp;&emsp;    up(&mutex);<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;void P2() {<br>&emsp;&emsp;    down(&mutex);<br>&emsp;&emsp;    // 临界区<br>&emsp;&emsp;    up(&mutex);<br>&emsp;&emsp;}<br>&emsp;&emsp; <br>&emsp;&emsp;        @阿秀: 代码已成功复制到剪贴板<br>&emsp;&emsp;    <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;1<br>&emsp;&emsp;2<br>&emsp;&emsp;3<br>&emsp;&emsp;4<br>&emsp;&emsp;5<br>&emsp;&emsp;6<br>&emsp;&emsp;7<br>&emsp;&emsp;8<br>&emsp;&emsp;9<br>&emsp;&emsp;10<br>&emsp;&emsp;11<br>&emsp;&emsp;12<br>&emsp;&emsp;13<br>&emsp;&emsp;<br>&emsp;&emsp;使用信号量实现生产者-消费者问题<br>&emsp;&emsp;<br>&emsp;&emsp;问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。<br>&emsp;&emsp;<br>&emsp;&emsp;因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。<br>&emsp;&emsp;<br>&emsp;&emsp;为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。<br>&emsp;&emsp;<br>&emsp;&emsp;其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。<br>&emsp;&emsp;<br>&emsp;&emsp;注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。<br>&emsp;&emsp;<br>&emsp;&emsp;消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。<br>&emsp;&emsp;<br>&emsp;&emsp;```c<br>&emsp;&emsp;#define N 100<br>&emsp;&emsp;typedef int semaphore;<br>&emsp;&emsp;semaphore mutex = 1;<br>&emsp;&emsp;semaphore empty = N;<br>&emsp;&emsp;semaphore full = 0;<br>&emsp;&emsp;<br>&emsp;&emsp;void producer() {<br>&emsp;&emsp;    while(TRUE) {<br>&emsp;&emsp;        int item = produce_item();<br>&emsp;&emsp;        down(&empty);<br>&emsp;&emsp;        down(&mutex);<br>&emsp;&emsp;        insert_item(item);<br>&emsp;&emsp;        up(&mutex);<br>&emsp;&emsp;        up(&full);<br>&emsp;&emsp;    }<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;void consumer() {<br>&emsp;&emsp;    while(TRUE) {<br>&emsp;&emsp;        down(&full);<br>&emsp;&emsp;        down(&mutex);<br>&emsp;&emsp;        int item = remove_item();<br>&emsp;&emsp;        consume_item(item);<br>&emsp;&emsp;        up(&mutex);<br>&emsp;&emsp;        up(&empty);<br>&emsp;&emsp;    }<br>&emsp;&emsp;}<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;### 4. 管程<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#FEAE00>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</font><br>&emsp;&emsp;<br>&emsp;&emsp;c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。<br>&emsp;&emsp;<br>&emsp;&emsp;```pascal<br>&emsp;&emsp;monitor ProducerConsumer<br>&emsp;&emsp;    integer i;<br>&emsp;&emsp;    condition c;<br>&emsp;&emsp;<br>&emsp;&emsp;    procedure insert();<br>&emsp;&emsp;    begin<br>&emsp;&emsp;        // ...<br>&emsp;&emsp;    end;<br>&emsp;&emsp;<br>&emsp;&emsp;    procedure remove();<br>&emsp;&emsp;    begin<br>&emsp;&emsp;        // ...<br>&emsp;&emsp;    end;<br>&emsp;&emsp;end monitor;<br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。<br>&emsp;&emsp;<br>&emsp;&emsp;管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。<br>&emsp;&emsp;<br>&emsp;&emsp;使用管程实现生产者-消费者问题<br>&emsp;&emsp;<br>&emsp;&emsp;```pascal<br>&emsp;&emsp;// 管程<br>&emsp;&emsp;monitor ProducerConsumer<br>&emsp;&emsp;    condition full, empty;<br>&emsp;&emsp;    integer count := 0;<br>&emsp;&emsp;    condition c;<br>&emsp;&emsp;<br>&emsp;&emsp;    procedure insert(item: integer);<br>&emsp;&emsp;    begin<br>&emsp;&emsp;        if count = N then wait(full);<br>&emsp;&emsp;        insert_item(item);<br>&emsp;&emsp;        count := count + 1;<br>&emsp;&emsp;        if count = 1 then signal(empty);<br>&emsp;&emsp;    end;<br>&emsp;&emsp;<br>&emsp;&emsp;    function remove: integer;<br>&emsp;&emsp;    begin<br>&emsp;&emsp;        if count = 0 then wait(empty);<br>&emsp;&emsp;        remove = remove_item;<br>&emsp;&emsp;        count := count - 1;<br>&emsp;&emsp;        if count = N -1 then signal(full);<br>&emsp;&emsp;    end;<br>&emsp;&emsp;end monitor;<br>&emsp;&emsp;<br>&emsp;&emsp;// 生产者客户端<br>&emsp;&emsp;procedure producer<br>&emsp;&emsp;begin<br>&emsp;&emsp;    while true do<br>&emsp;&emsp;    begin<br>&emsp;&emsp;        item = produce_item;<br>&emsp;&emsp;        ProducerConsumer.insert(item);<br>&emsp;&emsp;    end<br>&emsp;&emsp;end;<br>&emsp;&emsp;<br>&emsp;&emsp;// 消费者客户端<br>&emsp;&emsp;procedure consumer<br>&emsp;&emsp;begin<br>&emsp;&emsp;    while true do<br>&emsp;&emsp;    begin<br>&emsp;&emsp;        item = ProducerConsumer.remove;<br>&emsp;&emsp;        consume_item(item);<br>&emsp;&emsp;    end<br>&emsp;&emsp;end;<br>&emsp;&emsp;```<hr><hr>并发::22、操作系统经典问题之哲学家进餐问题<br>&emsp;&emsp;<br>&emsp;&emsp;todo 多<hr>![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343455.png)<br>&emsp;&emsp;<br>&emsp;&emsp;五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。<br>&emsp;&emsp;<br>&emsp;&emsp;下面是一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。<br>&emsp;&emsp;<br>&emsp;&emsp;```c<br>&emsp;&emsp;#define N 5<br>&emsp;&emsp;<br>&emsp;&emsp;void philosopher(int i) {<br>&emsp;&emsp;    while(TRUE) {<br>&emsp;&emsp;        think();<br>&emsp;&emsp;        take(i);       // 拿起左边的筷子<br>&emsp;&emsp;        take((i+1)%N); // 拿起右边的筷子<br>&emsp;&emsp;        eat();<br>&emsp;&emsp;        put(i);<br>&emsp;&emsp;        put((i+1)%N);<br>&emsp;&emsp;    }<br>&emsp;&emsp;}<br>&emsp;&emsp; <br>&emsp;&emsp;```<br>&emsp;&emsp;<br>&emsp;&emsp;为了防止死锁的发生，可以设置两个条件：<br>&emsp;&emsp;<br>&emsp;&emsp;- 必须同时拿起左右两根筷子；<br>&emsp;&emsp;- 只有在两个邻居都没有进餐的情况下才允许进餐。<br>&emsp;&emsp;<br>&emsp;&emsp;```c<br>&emsp;&emsp;#define N 5<br>&emsp;&emsp;#define LEFT (i + N - 1) % N // 左邻居<br>&emsp;&emsp;#define RIGHT (i + 1) % N    // 右邻居<br>&emsp;&emsp;#define THINKING 0<br>&emsp;&emsp;#define HUNGRY   1<br>&emsp;&emsp;#define EATING   2<br>&emsp;&emsp;typedef int semaphore;<br>&emsp;&emsp;int state[N];                // 跟踪每个哲学家的状态<br>&emsp;&emsp;semaphore mutex = 1;         // 临界区的互斥，临界区是 state 数组，对其修改需要互斥<br>&emsp;&emsp;semaphore s[N];              // 每个哲学家一个信号量<br>&emsp;&emsp;<br>&emsp;&emsp;void philosopher(int i) {<br>&emsp;&emsp;    while(TRUE) {<br>&emsp;&emsp;        think(i);<br>&emsp;&emsp;        take_two(i);<br>&emsp;&emsp;        eat(i);<br>&emsp;&emsp;        put_two(i);<br>&emsp;&emsp;    }<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;void take_two(int i) {<br>&emsp;&emsp;    down(&mutex);<br>&emsp;&emsp;    state[i] = HUNGRY;<br>&emsp;&emsp;    check(i);<br>&emsp;&emsp;    up(&mutex);<br>&emsp;&emsp;    down(&s[i]); // 只有收到通知之后才可以开始吃，否则会一直等下去<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;void put_two(i) {<br>&emsp;&emsp;    down(&mutex);<br>&emsp;&emsp;    state[i] = THINKING;<br>&emsp;&emsp;    check(LEFT); // 尝试通知左右邻居，自己吃完了，你们可以开始吃了<br>&emsp;&emsp;    check(RIGHT);<br>&emsp;&emsp;    up(&mutex);<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;void eat(int i) {<br>&emsp;&emsp;    down(&mutex);<br>&emsp;&emsp;    state[i] = EATING;<br>&emsp;&emsp;    up(&mutex);<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;// 检查两个邻居是否都没有用餐，如果是的话，就 up(&s[i])，使得 down(&s[i]) 能够得到通知并继续执行<br>&emsp;&emsp;void check(i) {         <br>&emsp;&emsp;    if(state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] !=EATING) {<br>&emsp;&emsp;        state[i] = EATING;<br>&emsp;&emsp;        up(&s[i]);<br>&emsp;&emsp;    }<br>&emsp;&emsp;}<br>&emsp;&emsp; <br>&emsp;&emsp;```<hr><hr>并发::23、操作系统经典问题之读者-写者问题<br>&emsp;&emsp;<br>&emsp;&emsp;todo 代码<hr>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。<br>&emsp;&emsp;<br>&emsp;&emsp;一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。<br>&emsp;&emsp;<br>&emsp;&emsp;```c<br>&emsp;&emsp;typedef int semaphore;<br>&emsp;&emsp;semaphore count_mutex = 1;<br>&emsp;&emsp;semaphore data_mutex = 1;<br>&emsp;&emsp;int count = 0;<br>&emsp;&emsp;<br>&emsp;&emsp;void reader() {<br>&emsp;&emsp;    while(TRUE) {<br>&emsp;&emsp;        down(&count_mutex);<br>&emsp;&emsp;        count++;<br>&emsp;&emsp;        if(count == 1) down(&data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问<br>&emsp;&emsp;        up(&count_mutex);<br>&emsp;&emsp;        read();<br>&emsp;&emsp;        down(&count_mutex);<br>&emsp;&emsp;        count--;<br>&emsp;&emsp;        if(count == 0) up(&data_mutex);//最后一个读者要对数据进行解锁，防止写进程无法访问<br>&emsp;&emsp;        up(&count_mutex);<br>&emsp;&emsp;    }<br>&emsp;&emsp;}<br>&emsp;&emsp;<br>&emsp;&emsp;void writer() {<br>&emsp;&emsp;    while(TRUE) {<br>&emsp;&emsp;        down(&data_mutex);<br>&emsp;&emsp;        write();<br>&emsp;&emsp;        up(&data_mutex);<br>&emsp;&emsp;    }<br>&emsp;&emsp;}<br>&emsp;&emsp;```<hr><hr>并发::24.1、你知道哪几种线程锁（POSIX）？<br>&emsp;&emsp;<br>&emsp;&emsp;todo<hr>###  互斥锁（mutex）<br>&emsp;&emsp;<br>&emsp;&emsp;互斥锁属于sleep-waiting类型的锁。例如在一个双核的机器上有两个线程A和B，它们分别运行在core 0和core 1上。假设线程A想要通过pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞，此时会通过上下文切换将线程A置于等待队列中，此时core 0就可以运行其他的任务（如线程C）。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-02-操作系统.html#条件变量-cond)条件变量(cond)<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-02-操作系统.html#自旋锁-spin)自旋锁(spin)<br>&emsp;&emsp;<br>&emsp;&emsp;自旋锁属于busy-waiting类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，如果自旋锁已经被线程B所持有，那么线程A就会一直在core 0上进行忙等待并不停的进行锁请求，检查该自旋锁是否已经被线程B释放，直到得到这个锁为止。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。<br>&emsp;&emsp;<br>&emsp;&emsp;虽然它的效率比互斥锁高，但是它也有些不足之处：<br>&emsp;&emsp;<br>&emsp;&emsp;- 自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。<br>&emsp;&emsp;- 在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。<br>&emsp;&emsp;- 自旋锁只有在内核可抢占式或SMP的情况下才真正需要，在单CPU且不可抢占式的内核下，自旋锁的操作为空操作。自旋锁适用于锁使用者保持锁时间比较短的情况下。<hr><hr>并发::24、介绍一下几种典型的锁？<hr>### 读写锁<br>&emsp;&emsp;<br>&emsp;&emsp;- 多个读者可以同时进行读<br>&emsp;&emsp;- 写者必须互斥（只允许一个写者写，也不能读者写者同时进行）<br>&emsp;&emsp;- 顺序：写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）<br>&emsp;&emsp;<br>&emsp;&emsp;### 互斥锁<br>&emsp;&emsp;<br>&emsp;&emsp;一次只能一个线程拥有互斥锁，其他线程只有等待<br>&emsp;&emsp;<br>&emsp;&emsp;互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁<br>&emsp;&emsp;<br>&emsp;&emsp;### 条件变量<br>&emsp;&emsp;<br>&emsp;&emsp;互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。<br>&emsp;&emsp;<br>&emsp;&emsp;### 自旋锁<br>&emsp;&emsp;如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。<hr><hr>并发::30、终端退出，终端运行的进程会怎样<br>&emsp;&emsp;<br>&emsp;&emsp;todo 常见的 singal<hr><font color=#FEAE00>终端在退出时会发送</font><font color=#FEAE00>SIGHUP</font><font color=#FEAE00>给对应的</font><font color=#FEAE00>bash</font><font color=#FEAE00>进程，</font><font color=#FEAE00>bash</font><font color=#FEAE00>进程收到这个信号后首先将它发给</font><font color=#FEAE00>session</font><font color=#FEAE00>下面的进程，如果程序没有对</font><font color=#FEAE00>SIGHUP</font><font color=#FEAE00>信号做特殊处理</font>，那么进程就会随着终端关闭而退出<br>&emsp;&emsp;<br>&emsp;&emsp;sig hang-up<hr><hr>并发::31、如何让进程后台运行<br>&emsp;&emsp;<br>&emsp;&emsp;五种方式<hr>（1）命令后面加上&即可，实际上，这样是将命令放入到一个作业队列中了<br>&emsp;&emsp;<br>&emsp;&emsp;（2）ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程<br>&emsp;&emsp;<br>&emsp;&emsp;（3）<font color=#FEAE00>nohup + &</font><font color=#FEAE00>，将标准输出和标准错误缺省会被重定向到</font><font color=#FEAE00> nohup.out </font><font color=#FEAE00>文件中，忽略所有挂断（</font><font color=#FEAE00>SIGHUP</font><font color=#FEAE00>）信号</font><font color=#FEAE00><br>&emsp;&emsp;</font><br>&emsp;&emsp;（4）<font color=#FEAE00>运行指令前面</font><font color=#FEAE00> + setsid</font><font color=#FEAE00>，使其父进程编程</font><font color=#FEAE00>init</font><font color=#FEAE00>进程，不受</font><font color=#FEAE00>HUP</font><font color=#FEAE00>信号的影响</font><br>&emsp;&emsp;<br>&emsp;&emsp;（5）将 命令+ &放在()括号中，也可以是进程不受HUP信号的影响<hr><hr>并发::56、系统并发和并行，都是什么？<hr><font color=#FEAE00>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</font><br>&emsp;&emsp;<br>&emsp;&emsp;并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。<br>&emsp;&emsp;<br>&emsp;&emsp;操作系统通过引入进程和线程，使得程序能够并发运行。<hr><hr>并发::65、服务器高并发的解决方案你知道多少？<hr>1. <font color=#FEAE00>应用数据与静态资源分离</font><font color=#FEAE00> </font><font color=#FEAE00>将静态资源（图片，视频，</font><font color=#FEAE00>js</font><font color=#FEAE00>，</font><font color=#FEAE00>css</font><font color=#FEAE00>等</font>）单独保存到专门的静态资源服务器中，在客户端访问的时候从静态资源服务器中返回静态资源，从主服务器中返回应用数据。<br>&emsp;&emsp;2. <font color=#FEAE00>客户端缓存</font><font color=#FEAE00> </font><font color=#FEAE00>因为效率最高，消耗资源最小的就是纯静态的</font><font color=#FEAE00>html</font><font color=#FEAE00>页面，所以可以把网站上的页面尽可能用静态的来实现</font>，在页面过期或者有数据更新之后再将页面重新缓存。或者先生成静态页面，然后用ajax异步请求获取动态数据。<br>&emsp;&emsp;3. <font color=#FEAE00>集群和分布式</font><font color=#FEAE00> </font><font color=#FEAE00>（集群是所有的服务器都有相同的功能，请求哪台都可以，主要起分流作用）</font><br>&emsp;&emsp;  （分布式是将不同的业务放到不同的服务器中，处理一个请求可能需要使用到多台服务器，起到加快请求处理的速度。）<br>&emsp;&emsp;  可以使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度。<br>&emsp;&emsp;4. <font color=#FEAE00>反向代理</font><font color=#FEAE00> </font><font color=#FEAE00>在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。</font><hr><hr>并发::8、Linux下同步机制？<hr>- POSIX信号量：可用于进程同步，也可用于线程同步。<br>&emsp;&emsp;- POSIX互斥锁 + 条件变量：只能用于线程同步。<hr><hr>并发::为什么多线程比多进程性能好<hr><hr>总结<br>&emsp;&emsp;<hr>由于随着计算机技术的发展，CPU 与 内存的访问速度相差越来越多，如今差距已经高达好几百倍了，所以 CPU 内部嵌入了 CPU Cache 组件，作为内存与 CPU 之间的缓存层，CPU Cache 由于离 CPU 核心很近，所以访问速度也是非常快的，但由于所需材料成本比较高，它不像内存动辄几个 GB 大小，而是仅有几十 KB 到 MB 大小。<br>&emsp;&emsp;当 CPU 访问数据的时候，先是访问 CPU Cache，如果缓存命中的话，则直接返回数据，就不用每次都从内存读取速度了。因此，缓存命中率越高，代码的性能越好。<br>&emsp;&emsp;但需要注意的是，当 CPU 访问数据时，如果 CPU Cache 没有缓存该数据，则会从内存读取数据，但是并不是只读一个数据，而是一次性读取一块一块的数据存放到 CPU Cache 中，之后才会被 CPU 读取。<br>&emsp;&emsp;内存地址映射到 CPU Cache 地址里的策略有很多种，其中比较简单是直接映射 Cache，它巧妙的把内存地址拆分成「索引 + 组标记 + 偏移量」的方式，使得我们可以将很大的内存地址，映射到很小的 CPU Cache 地址里。<br>&emsp;&emsp;要想写出让 CPU 跑得更快的代码，就需要写出缓存命中率高的代码，CPU L1 Cache 分为数据缓存和指令缓存，因而需要分别提高它们的缓存命中率：<br>&emsp;&emsp;	•	对于数据缓存，我们在遍历数据的时候，应该按照内存布局的顺序操作，这是因为 CPU Cache 是根据 CPU Cache Line 批量操作数据的，所以顺序地操作连续内存数据时，性能能得到有效的提升；<br>&emsp;&emsp;	•	对于指令缓存，有规律的条件分支语句能够让 CPU 的分支预测器发挥作用，进一步提高执行的效率；<br>&emsp;&emsp;另外，对于多核 CPU 系统，线程可能在不同 CPU 核心来回切换，这样各个核心的缓存命中率就会受到影响，于是要想提高线程的缓存命中率，可以考虑把线程绑定 CPU 到某一个 CPU 核心。<hr><hr>挂起和正常的五个状态 有什么不同么？<br>&emsp;&emsp;todo<br>&emsp;&emsp;<hr><hr>指令的类型都有哪些?<hr>数据传送, 运算, 跳转, 信号, 闲置<br>&emsp;&emsp;##<br>&emsp;&emsp;* 数据传送指令： store / load<br>&emsp;&emsp;* 运算类型指令：加减乘除，位运算，比较大小<br>&emsp;&emsp;* 跳转指令：修改PC的值， if else switch 函数调用<br>&emsp;&emsp;* 信号类型的指令：发生中断的指令 trap<br>&emsp;&emsp;* 闲置类型的指令：指令 nop, 气泡？？？忘了<hr><hr>死锁::59.2 死锁的四个必要条件<hr>理论上认为死锁产生有以下四个必要条件，缺一不可：<br>&emsp;&emsp;<br>&emsp;&emsp;1. 互斥条件：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。<br>&emsp;&emsp;2. 不可剥夺条件：进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放。<br>&emsp;&emsp;3. 请求和保持条件：进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。<br>&emsp;&emsp;4. 循环等待条件：存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。<hr><hr>死锁::59.3 死锁的解决方案 todo<hr>保证上锁的顺序一致。<br>&emsp;&emsp;<br>&emsp;&emsp;- 鸵鸟策略<br>&emsp;&emsp;- 死锁检测与死锁恢复<br>&emsp;&emsp;- 死锁预防<br>&emsp;&emsp;- 死锁避免<hr><hr>死锁::59.4 什么是死锁的鸵鸟策略?<hr>把头埋在沙子里，假装根本没发生问题。<br>&emsp;&emsp;<br>&emsp;&emsp;因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。<br>&emsp;&emsp;<br>&emsp;&emsp;当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。<br>&emsp;&emsp;<br>&emsp;&emsp;大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。<hr><hr>死锁::59.5 死锁检测与死锁恢复<br>&emsp;&emsp;<br>&emsp;&emsp;todo 图<hr>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。<br>&emsp;&emsp;<br>&emsp;&emsp;1、每种类型一个资源的死锁检测<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212345141.png)<br>&emsp;&emsp;<br>&emsp;&emsp;上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。<br>&emsp;&emsp;<br>&emsp;&emsp;图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。<br>&emsp;&emsp;<br>&emsp;&emsp;每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。<br>&emsp;&emsp;<br>&emsp;&emsp;2、每种类型多个资源的死锁检测<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212345141.png)<br>&emsp;&emsp;<br>&emsp;&emsp;上图中，有三个进程四个资源，每个数据代表的含义如下：<br>&emsp;&emsp;<br>&emsp;&emsp;- E 向量：资源总量<br>&emsp;&emsp;- A 向量：资源剩余量<br>&emsp;&emsp;- C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量<br>&emsp;&emsp;- R 矩阵：每个进程请求的资源数量<br>&emsp;&emsp;<br>&emsp;&emsp;进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A = (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。<br>&emsp;&emsp;<br>&emsp;&emsp;算法总结如下：<br>&emsp;&emsp;<br>&emsp;&emsp;每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。<br>&emsp;&emsp;<br>&emsp;&emsp;1. 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。<br>&emsp;&emsp;2. 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。<br>&emsp;&emsp;3. 如果没有这样一个进程，算法终止。<hr><hr>死锁::59.6 死锁恢复方法<br>&emsp;&emsp;<br>&emsp;&emsp;重复？<hr>- 利用抢占恢复<br>&emsp;&emsp;- 利用回滚恢复<br>&emsp;&emsp;- 通过杀死进程恢复<hr><hr>死锁::59.7 死锁预防方法<hr>在程序运行之前预防发生死锁。<br>&emsp;&emsp;<br>&emsp;&emsp;1. 破坏互斥条件<br>&emsp;&emsp;<br>&emsp;&emsp; 例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。<br>&emsp;&emsp;<br>&emsp;&emsp;1. 破坏请求和保持条件<br>&emsp;&emsp;<br>&emsp;&emsp; 一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。<br>&emsp;&emsp;<br>&emsp;&emsp;1. 破坏不剥夺条件<br>&emsp;&emsp;<br>&emsp;&emsp; 允许抢占资源<br>&emsp;&emsp;<br>&emsp;&emsp;1. 破坏循环请求等待<br>&emsp;&emsp;<br>&emsp;&emsp; 给资源统一编号，进程只能按编号顺序来请求资源。<hr><hr>死锁::59.8 死锁避免<hr>在程序运行时避免发生死锁。<br>&emsp;&emsp;<br>&emsp;&emsp;1. #### 安全状态<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212345923.png)<br>&emsp;&emsp;<br>&emsp;&emsp;图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。<br>&emsp;&emsp;<br>&emsp;&emsp;定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。<br>&emsp;&emsp;<br>&emsp;&emsp;安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。<br>&emsp;&emsp;<br>&emsp;&emsp;1. #### 单个资源的银行家算法<br>&emsp;&emsp;<br>&emsp;&emsp;一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212345716.png)<br>&emsp;&emsp;<br>&emsp;&emsp;上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。<br>&emsp;&emsp;<br>&emsp;&emsp;1. #### 多个资源的银行家算法<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212345258.png)<br>&emsp;&emsp;<br>&emsp;&emsp;上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。<br>&emsp;&emsp;<br>&emsp;&emsp;#### 4、检查一个状态是否安全的算法如下：<br>&emsp;&emsp;<br>&emsp;&emsp;- 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。<br>&emsp;&emsp;- 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。<br>&emsp;&emsp;- 重复以上两步，直到所有进程都标记为终止，则状态时安全的。<br>&emsp;&emsp;<br>&emsp;&emsp;如果一个状态不是安全的，需要拒绝进入这个状态。<hr><hr>死锁::59、死锁是什么?<hr>死锁是指两个（多个）线程相互等待对方数据的过程，死锁的产生会导致程序卡死，不解锁程序将永远无法进行下去。<hr><hr><font color=#929292>死锁</font><font color=#929292>::</font>无锁的实现方式<hr><hr>死锁::程序发生死锁了, 如何调试?<hr><hr>程序执行的基本过程<hr>在前面，我们知道了程序在图灵机的执行过程，接下来我们来看看程序在冯诺依曼模型上是怎么执行的。<br>&emsp;&emsp;程序实际上是一条一条指令，所以程序的运行过程就是把每一条指令一步一步的执行起来，负责执行指令的就是 CPU 了。<br>&emsp;&emsp;￼<br>&emsp;&emsp;那 CPU 执行程序的过程如下：<br>&emsp;&emsp;	•	第一步，CPU 读取「程序计数器」的值，这个值是指令的内存地址，然后 CPU 的「控制单元」操作「地址总线」指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过「数据总线」将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到「指令寄存器」。<br>&emsp;&emsp;	•	第二步，CPU 分析「指令寄存器」中的指令，确定指令的类型和参数，如果是计算类型的指令，就把指令交给「逻辑运算单元」运算；如果是存储类型的指令，则交由「控制单元」执行；<br>&emsp;&emsp;	•	第三步，CPU 执行完指令后，「程序计数器」的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此「程序计数器」的值会自增 4；<br>&emsp;&emsp;简单总结一下就是，一个程序执行的时候，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。<br>&emsp;&emsp;CPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环的过程被称为 <font color=#374EF4>CPU </font><font color=#374EF4>的指令周期</font>。<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>程序执行的基本过程 MIPS处理器?<hr>* 读取 PC 值，然后 控制单元 操作 地址总线指定访问的内存地址，内存设备准备好数据后，通过 数据总线 将指令数据传送给CPU，收到数据后，存入到 指令寄存器 中<br>&emsp;&emsp;* CPU分析 指令寄存器 中的指令， 确定类型和参数。计算类型 -》逻辑运算单元，存储类型 -》控制单元<br>&emsp;&emsp;* 执行完指令后，PC 自增，指向下一条指令，由CPU位宽决定，32位CPU会自增4<hr><hr>系统调用的开销? CPU上下文切换<hr><hr>线程安全问题<hr><hr>线路位宽与 CPU 位宽<hr>数据是如何通过线路传输的呢？其实是通过操作电压，低电压表示 0，高压电压则表示 1。<br>&emsp;&emsp;如果构造了高低高这样的信号，其实就是 101 二进制数据，十进制则表示 5，如果只有一条线路，就意味着每次只能传递 1 bit 的数据，即 0 或 1，那么传输 101 这个数据，就需要 3 次才能传输完成，这样的效率非常低。<br>&emsp;&emsp;这样一位一位传输的方式，称为串行，下一个 bit 必须等待上一个 bit 传输完成才能进行传输。当然，想一次多传一些数据，增加线路即可，这时数据就可以并行传输。<br>&emsp;&emsp;为了避免低效率的串行传输的方式，线路的位宽最好一次就能访问到所有的内存地址。<br>&emsp;&emsp;CPU 要想操作的内存地址就需要地址总线：<br>&emsp;&emsp;	•	如果地址总线只有 1 条，那每次只能表示 「0 或 1」这两种地址，所以 CPU 能操作的内存地址最大数量为 2（2^1）个（注意，不要理解成同时能操作 2 个内存地址）；<br>&emsp;&emsp;	•	如果地址总线有 2 条，那么能表示 00、01、10、11 这四种地址，所以 CPU 能操作的内存地址最大数量为 4（2^2）个。<br>&emsp;&emsp;那么，想要 CPU 操作 4G 大的内存，那么就需要 32 条地址总线，因为 <font color=#4D647F>2 ^ 32 = 4G</font>。<br>&emsp;&emsp;知道了线路位宽的意义后，我们再来看看 CPU 位宽。<br>&emsp;&emsp;CPU 的位宽最好不要小于线路位宽，比如 32 位 CPU 控制 40 位宽的地址总线和数据总线的话，工作起来就会非常复杂且麻烦，所以 32 位的 CPU 最好和 32 位宽的线路搭配，因为 32 位 CPU 一次最多只能操作 32 位宽的地址总线和数据总线。<br>&emsp;&emsp;如果用 32 位 CPU 去加和两个 64 位大小的数字，就需要把这 2 个 64 位的数字分成 2 个低位 32 位数字和 2 个高位 32 位数字来计算，先加个两个低位的 32 位数字，算出进位，然后加和两个高位的 32 位数字，最后再加上进位，就能算出结果了，可以发现 32 位 CPU 并不能一次性计算出加和两个 64 位数字的结果。<br>&emsp;&emsp;对于 64 位 CPU 就可以一次性算出加和两个 64 位数字的结果，因为 64 位 CPU 可以一次读入 64 位的数字，并且 64 位 CPU 内部的逻辑运算单元也支持 64 位数字的计算。<br>&emsp;&emsp;但是并不代表 64 位 CPU 性能比 32 位 CPU 高很多，很少应用需要算超过 32 位的数字，所以<font color=#374EF4>如果计算的数额不超过</font><font color=#374EF4> 32 </font><font color=#374EF4>位数字的情况下，</font><font color=#374EF4>32 </font><font color=#374EF4>位和</font><font color=#374EF4> 64 </font><font color=#374EF4>位</font><font color=#374EF4> CPU </font><font color=#374EF4>之间没什么区别的，只有当计算超过</font><font color=#374EF4> 32 </font><font color=#374EF4>位数字的情况下，</font><font color=#374EF4>64 </font><font color=#374EF4>位的优势才能体现出来</font>。<br>&emsp;&emsp;另外，32 位 CPU 最大只能操作 4GB 内存，就算你装了 8 GB 内存条，也没用。而 64 位 CPU 寻址范围则很大，理论最大的寻址空间为 <font color=#4D647F>2^64</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>编译::14、一个程序从代码变成可执行文件的过程，你能说出来多少？<hr>预处理 编译 汇编 链接<br>&emsp;&emsp;四个过程：<br>&emsp;&emsp;<br>&emsp;&emsp;（1）预编译 主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下<br>&emsp;&emsp;<br>&emsp;&emsp;1、删除所有的#define，展开所有的宏定义。<br>&emsp;&emsp;<br>&emsp;&emsp;2、处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。<br>&emsp;&emsp;<br>&emsp;&emsp;3、处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他 文件。<br>&emsp;&emsp;<br>&emsp;&emsp;4、删除所有的注释，“//”和“/**/”。<br>&emsp;&emsp;<br>&emsp;&emsp;5、保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重 复引用。<br>&emsp;&emsp;<br>&emsp;&emsp;6、添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是 能够显示行号。<br>&emsp;&emsp;<br>&emsp;&emsp;（2）编译 <font color=#FEAE00>把预编译之后生成的</font><font color=#FEAE00>xxx.i</font><font color=#FEAE00>或</font><font color=#FEAE00>xxx.ii</font><font color=#FEAE00>文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</font><font color=#FEAE00><br>&emsp;&emsp;</font><br>&emsp;&emsp;1、词法分析：<font color=#FEAE00>利用类似于“有限状态机”的算法</font>，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。<br>&emsp;&emsp;<br>&emsp;&emsp;2、语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。<br>&emsp;&emsp;<br>&emsp;&emsp;3、语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。<br>&emsp;&emsp;<br>&emsp;&emsp;4、优化：源代码级别的一个优化过程。<br>&emsp;&emsp;<br>&emsp;&emsp;5、目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。<br>&emsp;&emsp;<br>&emsp;&emsp;6、目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。<br>&emsp;&emsp;<br>&emsp;&emsp;（3）汇编<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#FEAE00>将汇编代码转变成机器可以执行的指令</font><font color=#FEAE00>(</font><font color=#FEAE00>机器码文件</font><font color=#FEAE00>)</font><font color=#FEAE00>。</font> 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。<br>&emsp;&emsp;<br>&emsp;&emsp;经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux下)、xxx.obj(Windows下)。<br>&emsp;&emsp;<br>&emsp;&emsp;（4）链接<br>&emsp;&emsp;<br>&emsp;&emsp;将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：<br>&emsp;&emsp;<br>&emsp;&emsp;1、静态链接： <font color=#FEAE00>函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时</font>，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本； 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。<br>&emsp;&emsp;<br>&emsp;&emsp;运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。<br>&emsp;&emsp;<br>&emsp;&emsp;2、动态链接： <font color=#FEAE00>动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，</font>在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。<br>&emsp;&emsp;<br>&emsp;&emsp;共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；<br>&emsp;&emsp;<br>&emsp;&emsp;更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。<br>&emsp;&emsp;<br>&emsp;&emsp;性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。<hr><hr>编译::开放性问题 一个文件程序的生命周期？<br>&emsp;&emsp;<br>&emsp;&emsp;如何运行<br>&emsp;&emsp;如何结束？<br>&emsp;&emsp;todo<hr><hr>虚拟::12、虚拟技术你了解吗？<hr>虚拟技术把一个物理实体转换为多个逻辑实体。<br>&emsp;&emsp;<br>&emsp;&emsp;主要有两种虚拟技术：<font color=#FEAE00>时（时间）分复用技术和空（空间）分复用技术</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;多进程与多线程：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。<br>&emsp;&emsp;<br>&emsp;&emsp;虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。<hr><hr>虚拟::15、通过例子讲解逻辑地址转换为物理地址的基本过程<br>&emsp;&emsp;<br>&emsp;&emsp;todo 加图片<hr>可以借助进程的页表将逻辑地址转换为物理地址。<br>&emsp;&emsp;<br>&emsp;&emsp;通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB) 中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。<br>&emsp;&emsp;<br>&emsp;&emsp;注意:页面大小是2的整数幂 设页面大小为L，逻辑地址A到物理地址E的变换过程如下:<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220001941.png)<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220001638.png) 例:若页面大小L为1K字节，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E。 等价描述：某系统按字节寻址，逻辑地址结构中，页内偏移量占10位(说明一个页面的大小为2^10B = 1KB)，页号2对应的内存块号 b=8，将逻辑地址A=2500转换为物理地址E。<hr><hr>虚拟::20、虚拟内存的目的是什么？<br>&emsp;&emsp;<br>&emsp;&emsp;todo 图<hr>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。<br>&emsp;&emsp;<br>&emsp;&emsp;为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。<br>&emsp;&emsp;<br>&emsp;&emsp;这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。<br>&emsp;&emsp;<br>&emsp;&emsp;从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。<br>&emsp;&emsp;<br>&emsp;&emsp;例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220001833.png)<hr><hr>虚拟::21、说一下你理解中的内存？他有什么作用呢？<br>&emsp;&emsp;<br>&emsp;&emsp;todo 图<hr>![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343183.png)<hr><hr>虚拟::25、<font color=#FEAE00>逻辑地址</font><font color=#FEAE00>VS</font><font color=#FEAE00>物理地址</font><font color=#FEAE00><br>&emsp;&emsp;</font><br>&emsp;&emsp;<br>&emsp;&emsp;对不对？<hr>注意 不是虚拟内存里面的<br>&emsp;&emsp;<br>&emsp;&emsp;Eg:编译时只需确定变量x存放的相对地址是100 ( 也就是说相对于进程在内存中的起始地址而言的地址)。CPU想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。 相对地址又称逻辑地址，绝对地址又称物理地址。<hr><hr>虚拟::32、什么是快表，你知道多少关于快表的知识？<br>&emsp;&emsp;todo 图<hr>快表，又称联想寄存器(TLB) ，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212343703.png)<hr><hr>虚拟::33、地址变换中，有快表和没快表，有什么区别？<br>&emsp;&emsp;todo<hr>|                        | 地址变换过程                                                 | 访问一个逻辑地址的访存次数                      |<br>&emsp;&emsp;| ---------------------- | ------------------------------------------------------------ | ----------------------------------------------- |<br>&emsp;&emsp;| 基本地址变换机构       | ①算页号、页内偏移量 ②检查页号合法性 ③查页表，找到页面存放的内存块号 ④根据内存块号与页内偏移量得到物理地址 ⑤访问目标内存单元 | 两次访存                                        |<br>&emsp;&emsp;| 具有快表的地址变换机构 | ①算页号、页内偏移量 ②检查页号合法性 ③查快表。若命中，即可知道页面存放的内存块号，可直接进行⑤;若未命中则进行④ ④查页表，找到页面存放的内存块号，并且将页表项复制到快表中 ⑤根据内存块号与页内偏移量得到物理地址 ⑥访问目标内存单元 | 快表命中，只需一次访存 快表未命中，需要两次访存 |<hr><hr>虚拟::46、<font color=#FEAE00>交换空间</font>与<font color=#FEAE00>虚拟内存</font>的关系<br>&emsp;&emsp;<br>&emsp;&emsp;todo 感觉错的<hr>### 交换空间<br>&emsp;&emsp;<br>&emsp;&emsp;Linux 中的交换空间（Swap space）在物理内存（RAM）被充满时被使用。如果系统需要更多的内存资源，而物理内存已经充满，内存中不活跃的页就会被移到交换空间去。虽然交换空间可以为带有少量内存的机器提供帮助，但是这种方法不应该被当做是对内存的取代。交换空间位于硬盘驱动器上，它比进入物理内存要慢。 交换空间可以是一个专用的交换分区（推荐的方法），交换文件，或两者的组合。 交换空间的总大小应该相当于你的计算机内存的两倍和 32 MB这两个值中较大的一个，但是它不能超过 2048MB（2 GB）。<br>&emsp;&emsp;<br>&emsp;&emsp;### 虚拟内存<br>&emsp;&emsp;<br>&emsp;&emsp;虚拟内存是文件数据交叉链接的活动文件。是WINDOWS目录下的一个"WIN386.SWP"文件，这个文件会不断地扩大和自动缩小。 就速度方面而言,CPU的L1和L2缓存速度最快，内存次之，硬盘再次之。但是虚拟内存使用的是硬盘的空间，为什么我们要使用速度最慢的硬盘来做 为虚拟内存呢？因为电脑中所有运行的程序都需要经过内存来执行，如果执行的程序很大或很多，就会导致我们只有可怜的256M/512M内存消耗殆尽。而硬盘空间动辄几十G上百G，为了解决这个问题，Windows中运用了虚拟内存技术，即拿出一部分硬盘空间来充当内存使用。<hr><hr>虚拟::9、如果系统中具有快表后，那么地址的转换过程变成什么样了？<hr>> ①<font color=#FEAE00>CPU</font><font color=#FEAE00>给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</font><br>&emsp;&emsp;><br>&emsp;&emsp;> ②如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。<br>&emsp;&emsp;><br>&emsp;&emsp;> ③如果没有找到匹配的页号，<font color=#FEAE00>则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址</font>，最后，访问该物理地址对应的内存单元。因此,若快表未命中，则访问某个逻辑地址需要两次访存(注意:在找到页表项后，应同时将其存入快表,以便后面可能的再次访问。但若快表已满，则必须按照-定的算法对旧的页表项进行替换)<br>&emsp;&emsp;<br>&emsp;&emsp;由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。 因为局部性原理，–般来说快表的命中率可以达到90%以上。<br>&emsp;&emsp;<br>&emsp;&emsp;例:某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问- -次快表耗时1us， 访问一次内存耗时100us。若快表的命中率为90%，那么访问一个逻辑地址的平均耗时是多少? (1+100) * 0.9 + (1+100+100) * 0.1 = 111 us 有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是(1+100) * 0.9+ (100+100) *0.1=110.9 us 若未采用快表机制，则访问一个逻辑地址需要100+100 = 200us 显然，引入快表机制后，访问一个逻辑地址的速度快多了。<hr><hr>虚拟内存 是什么?<hr>如果你是电子相关专业的，肯定在大学里捣鼓过单片机。<br>&emsp;&emsp;单片机是没有操作系统的，所以每次写完代码，都需要借助工具把程序烧录进去，这样程序才能跑起来。<br>&emsp;&emsp;另外，<font color=#FEAE00>单片机的</font><font color=#FEAE00> CPU </font><font color=#FEAE00>是直接操作内存的「物理地址」</font>。<br>&emsp;&emsp;￼<br>&emsp;&emsp;在这种情况下，要想在内存中同时运行两个程序是不可能的。如果第一个程序在 2000 的位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容，所以同时运行两个程序是根本行不通的，这两个程序会立刻崩溃。<br>&emsp;&emsp;操作系统是如何解决这个问题呢？<br>&emsp;&emsp;这里关键的问题是这两个程序都引用了绝对物理地址，而这正是我们最需要避免的。<br>&emsp;&emsp;我们可以把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一<font color=#FEAE00>套「</font><font color=#FEAE00>虚拟地址</font><font color=#FEAE00>」</font>，人人都有，大家自己玩自己的地址就行，互不干涉。但是有个前提每个进程都不能访问物理地址，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了。<br>&emsp;&emsp;￼<br>&emsp;&emsp;<font color=#FEAE00>操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</font><br>&emsp;&emsp;如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。<br>&emsp;&emsp;于是，这里就引出了两种地址的概念：<br>&emsp;&emsp;	•	我们程序所使用的内存地址叫做<font color=#FEAE00>虚拟内存地址</font>（<font color=#7414AF>Virtual Memory Address</font>）<br>&emsp;&emsp;	•	实际存在硬件里面的空间地址叫<font color=#FEAE00>物理内存地址</font>（<font color=#7414AF>Physical Memory Address</font>）。<br>&emsp;&emsp;操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，如下图所示：<br>&emsp;&emsp;￼<br>&emsp;&emsp;操作系统是如何管理虚拟地址与物理地址之间的关系？<br>&emsp;&emsp;主要有两种方式，分别是<font color=#FEAE00>内存分段和内存分页</font><font color=#FEAE00>，</font>分段是比较早提出的，我们先来看看内存分段。<hr><hr>设备控制器<hr>我们的电脑设备可以接非常多的输入输出设备，比如键盘、鼠标、显示器、网卡、硬盘、打印机、音响等等，每个设备的用法和功能都不同，那操作系统是如何把这些<font color=#FEAE00>输入输出设备统一管</font>理的呢?<br>&emsp;&emsp;为了屏蔽设备之间的差异，每个设备都有一个叫<font color=#FEAE00>设备控制器</font><font color=#7414AF>Device Control</font>的组件，比如硬盘有硬盘控制器、显示器有视频控制器等。<br>&emsp;&emsp;￼<br>&emsp;&emsp;因为这些控制器都很清楚的知道对应设备的用法和功能，所以 CPU 是通过设备控制器来和设备打交道的。<br>&emsp;&emsp;设备控制器里有芯片，它可执行自己的逻辑，也有自己的寄存器，用来与 CPU 进行通信，比如：<br>&emsp;&emsp;	•	<font color=#FEAE00>通过写入这些寄存器</font>，操作系统可以命令设备发送数据、接收数据、开启或关闭，或者执行某些其他操作。<br>&emsp;&emsp;	•	<font color=#FEAE00>通过读取这些寄存器</font>，操作系统可以了解设备的状态，是否准备好接收一个新的命令等。<br>&emsp;&emsp;实际上，控制器是有三类寄存器，它们分别是<font color=#FEAE00>状态寄存器</font><font color=#7414AF>Status Register</font>、 <font color=#FEAE00>命令寄存器</font><font color=#7414AF>Command Register</font><font color=#FEAE00>以及数据寄存器</font><font color=#7414AF>Data Register</font>，如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;这三个寄存器的作用：<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>数据寄存器</font>，CPU 向 I/O 设备写入需要传输的数据，比如要打印的内容是「Hello」，CPU 就要先发送一个 H 字符给到对应的 I/O 设备。<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>命令寄存器</font>，CPU 发送一个命令，告诉 I/O 设备，要进行输入/输出操作，于是就会交给 I/O 设备去工作，<font color=#FEAE00>任务完成后，会把状态寄存器里面的状态标记为完成</font>。<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>状态寄存器</font>，目的是告诉 CPU ，现在已经在工作或工作已经完成，如果已经在工作状态，CPU 再发送数据或者命令过来，都是没有用的，直到前面的工作已经完成，状态寄存标记成已完成，CPU 才能发送下一个字符和命令。<br>&emsp;&emsp;CPU 通过读写设备控制器中的寄存器控制设备，这可比 CPU 直接控制输入输出设备，要方便和标准很多。<br>&emsp;&emsp;另外， 输入输出设备可分为两大类 ：<font color=#FEAE00>块设备</font><font color=#7414AF>Block Device</font><font color=#FEAE00>和字符设备</font><font color=#7414AF>Character Device</font>。<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>块设备</font>，把数据存<font color=#FEAE00>储在固定大小的块中</font>，每个块有自己的地址，硬盘、USB 是常见的块设备。<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>字符设备</font>，以字符为单位发送或接收一个字符流，<font color=#FEAE00>字符设备是不可寻址的</font>，也没有任何寻道操作，鼠标是常见的字符设备。<br>&emsp;&emsp;块设备通常传输的数据量会非常大，于是控制器设立了一个可读写的<font color=#FEAE00>数据缓冲区</font>。<br>&emsp;&emsp;	•	CPU 写入数据到控制器的缓冲区时，当缓冲区的数据囤够了一部分，才会发给设备。<br>&emsp;&emsp;	•	CPU 从控制器的缓冲区读取数据时，也需要缓冲区囤够了一部分，才拷贝到内存。<br>&emsp;&emsp;这样做是为了，<font color=#FEAE00>减少对设备的频繁操作</font>。<br>&emsp;&emsp;那 CPU 是如何与设备的控制寄存器和数据缓冲区进行通信的？存在两个方法：<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>端口</font><font color=#7414AF> I/O</font>，每个控制寄存器被分配一个 I/O 端口，可以通过特殊的汇编指令操作这些寄存器，比如 <font color=#FEAE00>in/out </font><font color=#FEAE00>类似的指令</font>。<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>内存映射</font><font color=#7414AF> I/O</font>，将所有控制寄存器映射到内存空间中，这样就可以像读写内存一样读写数据缓冲区。<font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>设备驱动程序<hr>虽然设备控制器屏蔽了设备的众多细节，但每种设备的控制器的寄存器、缓冲区等使用模式都是不同的，所以为了屏蔽「设备控制器」的差异，引入了<font color=#FEAE00>设备驱动程序</font>。<br>&emsp;&emsp;￼<br>&emsp;&emsp;<font color=#FEAE00>设备控制器</font>不属于操作系统范畴，它是属于<font color=#FEAE00>硬件</font>，而设<font color=#FEAE00>备驱动程序属于操作系统</font>的一部分，操作系统的内核代码可以像本地调用代码一样使用设备驱动程序的接口，而设备驱动程序是面向设备控制器的代码，它发出操控设备控制器的指令后，才可以操作设备控制器。<br>&emsp;&emsp;不同的设备控制器虽然功能不同，但是<font color=#FEAE00>设备驱动程序会提供统一的接口给操作系统</font>，这样不同的设备驱动程序，就可以以<font color=#FEAE00>相同的方式接入操作系统</font>。如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;前面提到了不少关于中断的事情，设备完成了事情，则会发送中断来通知操作系统。那操作系统就需要有一个地方来<font color=#FEAE00>处理这个中断</font>，这个地方也就是在设备驱动程序里，它会及时响应控制器发来的中断请求，并根据这个中断的类型调用响应的<font color=#FEAE00>中断处理程序</font>进行处理。<br>&emsp;&emsp;通常，设备驱动程序初始化的时候，要先<font color=#FEAE00>注册一个该设备的中断处理函数</font>。<br>&emsp;&emsp;￼<br>&emsp;&emsp;我们来看看，中断处理程序的处理流程：<br>&emsp;&emsp;	1	在 I/O 时，设备控制器如果已经准备好数据，则会通过<font color=#FEAE00>中断控制器向</font><font color=#FEAE00> CPU </font><font color=#FEAE00>发送中断</font>请求；<br>&emsp;&emsp;	2	<font color=#FEAE00>保护被中断进程的</font><font color=#FEAE00> CPU </font><font color=#FEAE00>上下文</font>；<br>&emsp;&emsp;	3	<font color=#FEAE00>转入</font>相应的设备中断处理函数；<br>&emsp;&emsp;	4	进行中断处理；<br>&emsp;&emsp;	5<font color=#FEAE00>	</font><font color=#FEAE00>恢复被中断进程的上下文</font>；<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>调度::13、进程状态的切换你知道多少？<hr>![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220001439.png)<br>&emsp;&emsp;<br>&emsp;&emsp;- 就绪状态（ready）：等待被调度<br>&emsp;&emsp;- 运行状态（running）<br>&emsp;&emsp;- 阻塞状态（waiting）：等待资源<br>&emsp;&emsp;<br>&emsp;&emsp;应该注意以下内容：<br>&emsp;&emsp;<br>&emsp;&emsp;- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。<br>&emsp;&emsp;- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。<hr><hr>调度::6、进程调度算法你了解多少？<hr>先来先服务, 短作业优先, 最短剩余时间优先(抢占), 时间片轮转, 最高优先级, 多级反馈队列<br>&emsp;&emsp;抢占 / 非抢占<br>&emsp;&emsp;##<br>&emsp;&emsp;### 1、 <font color=#1DB100>先来先服务</font> first-come first-serverd（FCFS）<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#1DB100>非抢占式</font>的调度算法，按照请求的顺序进行调度。<br>&emsp;&emsp;<br>&emsp;&emsp;有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了<font color=#1DB100>短作业等待时间过长</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;### 2	、 <font color=#1DB100>短作业优先</font> shortest job first（SJF）<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#1DB100>非抢占式</font>的调度算法，按估计运行时间最短的顺序进行调度。<br>&emsp;&emsp;<br>&emsp;&emsp;长作业有可能会<font color=#1DB100>饿死</font>，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。<br>&emsp;&emsp;<br>&emsp;&emsp;### 3、<font color=#1DB100>最短剩余时间优先</font> shortest remaining time next（SRTN）<br>&emsp;&emsp;<br>&emsp;&emsp;最短作业优先的<font color=#1DB100>抢占式版本</font>，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。<br>&emsp;&emsp;<br>&emsp;&emsp;如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。<br>&emsp;&emsp;<br>&emsp;&emsp;### 4. 时间片轮转<br>&emsp;&emsp;<br>&emsp;&emsp;将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。<br>&emsp;&emsp;<br>&emsp;&emsp;当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。<br>&emsp;&emsp;<br>&emsp;&emsp;时间片轮转算法的效率和时间片的大小有很大关系：<br>&emsp;&emsp;<br>&emsp;&emsp;- 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。<br>&emsp;&emsp;- 而如果时间片过长，那么实时性就不能得到保证。<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220000782.png)<br>&emsp;&emsp;<br>&emsp;&emsp;### 5、优先级调度<br>&emsp;&emsp;<br>&emsp;&emsp;为每个进程分配一个优先级，按优先级进行调度。<br>&emsp;&emsp;<br>&emsp;&emsp;为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。<br>&emsp;&emsp;<br>&emsp;&emsp;### 6、多级反馈队列<br>&emsp;&emsp;<br>&emsp;&emsp;一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。<br>&emsp;&emsp;<br>&emsp;&emsp;多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。<br>&emsp;&emsp;<br>&emsp;&emsp;这种方式下，之前的进程只需要交换 7 次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。<br>&emsp;&emsp;<br>&emsp;&emsp;可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。<br>&emsp;&emsp;￼<br>&emsp;&emsp;<br>&emsp;&emsp;<hr><hr>调度::你刚才说了挂起状态， 什么时候会挂起？<br>&emsp;&emsp;<br>&emsp;&emsp;todo<hr><hr>调度::操作系统中进程的几个状态？<br>&emsp;&emsp;<br>&emsp;&emsp;todo<hr><hr>进程::2.2、线程和进程的区别？<hr>- 调度：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。<br>&emsp;&emsp;- 并发性：一个进程内多个线程可以并发（最好和CPU核数相等）；多个进程可以并发。<br>&emsp;&emsp;- 拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。<br>&emsp;&emsp;- 系统开销：线程创建销毁只需要处理PC值，状态码，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁task_struct结构。<hr><hr>进程::26、怎么回收线程？有哪几种方法？<br>&emsp;&emsp;<br>&emsp;&emsp;todo<hr>- 等待线程结束：int pthread_join(pthread_t tid, void** retval);<br>&emsp;&emsp;<br>&emsp;&emsp;  主线程调用，等待子线程退出并回收其资源，类似于进程中wait/waitpid回收僵尸进程，调用pthread_join的线程会被阻塞。<br>&emsp;&emsp;<br>&emsp;&emsp;  - tid：创建线程时通过指针得到tid值。<br>&emsp;&emsp;  - retval：指向返回值的指针。<br>&emsp;&emsp;<br>&emsp;&emsp;- 结束线程：pthread_exit(void *retval);<br>&emsp;&emsp;<br>&emsp;&emsp;  子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过pthread_join获得。<br>&emsp;&emsp;<br>&emsp;&emsp;  - retval：同上。<br>&emsp;&emsp;<br>&emsp;&emsp;- 分离线程：int pthread_detach(pthread_t tid);<br>&emsp;&emsp;<br>&emsp;&emsp;  主线程、子线程均可调用。主线程中pthread_detach(tid)，子线程中pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源。<br>&emsp;&emsp;<br>&emsp;&emsp;  - tid：同上<hr><hr>进程::2、线程与进程的比较<hr>1、线程启动速度快，轻量级<br>&emsp;&emsp;<br>&emsp;&emsp;2、线程的系统开销小<br>&emsp;&emsp;<br>&emsp;&emsp;3、线程使用有一定难度，需要处理数据一致性问题<br>&emsp;&emsp;<br>&emsp;&emsp;4、同一线程共享的有堆、全局变量、静态变量、指针，引用、文件等，而独自占有栈<hr><hr>进程::35、 守护进程、僵尸进程和孤儿进程<hr>### 守护进程<br>&emsp;&emsp;指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的，如web服务器进程http等<br>&emsp;&emsp;父进程是 init 进程. <br>&emsp;&emsp;包括 syslogd httpd mysqld sendmaild 等程序<br>&emsp;&emsp;需要特殊处理 stdout 和 stderr<br>&emsp;&emsp;<br>&emsp;&emsp;[[ 如何创建守护进程<br>&emsp;&emsp;### 孤儿进程<br>&emsp;&emsp;如果父进程先退出，子进程还没退出，那么子进程的父进程将变为init进程。（注：任何一个进程都必须有父进程）。<br>&emsp;&emsp;没有危害, 由init进程来完成收集工作<br>&emsp;&emsp;### 僵尸进程<br>&emsp;&emsp;    如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程。<br>&emsp;&emsp;    就是先退出了, 但是还没有wait掉. <br>&emsp;&emsp;    设置僵尸进程的目的是维护子进程的信息，以便父进程在以后某个时候获取。<font color=#FEAE00>这些信息至少包括进程</font><font color=#FEAE00>ID</font><font color=#FEAE00>，进程的终止状态，以及该进程使用的</font><font color=#FEAE00>CPU</font><font color=#FEAE00>时间，所以当终止子进程的父进程调用</font><font color=#FEAE00>wait</font><font color=#FEAE00>或</font><font color=#FEAE00>waitpid</font><font color=#FEAE00>时就可以得到这些信息。</font><br>&emsp;&emsp;    如果一个进程终止，而该进程有子进程处于僵尸状态，<font color=#FEAE00>那么它的所有僵尸子进程的父进程</font><font color=#FEAE00>ID</font><font color=#FEAE00>将被重置为</font><font color=#FEAE00>1</font><font color=#FEAE00>（</font><font color=#FEAE00>init</font><font color=#FEAE00>进程）</font>。继承这些子进程的init进程将清理它们（也就是说init进程将wait它们，从而去除它们的僵尸状态）。<hr><hr>进程::36、如何避免僵尸进程？<hr>- 通过<font color=#FEAE00>signal(SIGCHLD, SIG_IGN)</font><font color=#FEAE00>通知内核对子进程的结束不关心，由内核回收。</font>如果不想让父进程挂起，可以在父进程中加入一条语句：signal(SIGCHLD,SIG_IGN);表示父进程忽略SIGCHLD信号，该信号是子进程退出的时候向父进程发送的。<br>&emsp;&emsp;- 父<font color=#FEAE00>进程调用</font><font color=#FEAE00>wait/waitpid</font><font color=#FEAE00>等函数等待子进程结束，如果尚无子进程退出</font><font color=#FEAE00>wait</font><font color=#FEAE00>会导致父进程阻塞。</font><font color=#FEAE00>waitpid</font><font color=#FEAE00>可以通过传递</font><font color=#FEAE00>WNOHANG</font><font color=#FEAE00>使父进程不阻塞立即返回。</font><br>&emsp;&emsp;- 如果父进程很忙可以用signal注册信号处理函数，<font color=#FEAE00>在信号处理函数调用</font><font color=#FEAE00>wait/waitpid</font><font color=#FEAE00>等待子进程退出。</font><br>&emsp;&emsp;- <font color=#FEAE00>通过两次调用</font><font color=#FEAE00>fork</font><font color=#FEAE00>。父进程首先调用</font><font color=#FEAE00>fork</font><font color=#FEAE00>创建一个子进程然后</font><font color=#FEAE00>waitpid</font><font color=#FEAE00>等待子进程退出，</font>子进程再fork一个孙进程后退出。这样子进程退出后会被父进程等待回收，而对于孙子进程其父进程已经退出所以孙进程成为一个孤儿进程，孤儿进程由init进程接管，孙进程结束后，init会等待回收。<br>&emsp;&emsp;<br>&emsp;&emsp;第一种方法忽略SIGCHLD信号，这常用于并发服务器的性能的一个技巧因为并发服务器常常fork很多子进程，子进程终结之后需要服务器进程去wait清理资源。如果将此信号的处理方式设为忽略，可让内核把僵尸子进程转交给init进程去处理，省去了大量僵尸进程占用系统资源。<hr><hr>进程::38、父进程、子进程、进程组、作业和会话<br>&emsp;&emsp;<br>&emsp;&emsp;todo 分开<hr>### 父进程<br>&emsp;&emsp;<br>&emsp;&emsp;已创建一个或多个子进程的进程<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-02-操作系统.html#子进程)子进程<br>&emsp;&emsp;<br>&emsp;&emsp;由fork创建的新进程被称为子进程（child process）。该函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新进程（子进程）的进程 id。将子进程id返回给父进程的理由是：因为一个进程的子进程可以多于一个，没有一个函数使一个进程可以获得其所有子进程的进程id。对子进程来说，之所以fork返回0给它，是因为它随时可以调用getpid()来获取自己的pid；也可以调用getppid()来获取父进程的id。(进程id 0总是由交换进程使用，所以一个子进程的进程id不可能为0 )。<br>&emsp;&emsp;<br>&emsp;&emsp;fork之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这2个进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两进程的程序计数器pc值相同，也就是说，子进程是从fork返回处开始执行的），但有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork不成功，父进程会返回错误。<br>&emsp;&emsp;<br>&emsp;&emsp;子进程从父进程继承的有：<br>&emsp;&emsp;<br>&emsp;&emsp;1.进程的资格(真实(real)/有效(effective)/已保存(saved)用户号(UIDs)和组号(GIDs))<br>&emsp;&emsp;<br>&emsp;&emsp;2.环境(environment)<br>&emsp;&emsp;<br>&emsp;&emsp;3.堆栈<br>&emsp;&emsp;<br>&emsp;&emsp;4.内存<br>&emsp;&emsp;<br>&emsp;&emsp;5.进程组号<br>&emsp;&emsp;<br>&emsp;&emsp;独有：<br>&emsp;&emsp;<br>&emsp;&emsp;1.进程号；<br>&emsp;&emsp;<br>&emsp;&emsp;2.不同的父进程号(译者注：即子进程的父进程号与父进程的父进程号不同， 父进程号可由getppid函数得到)；<br>&emsp;&emsp;<br>&emsp;&emsp;3.资源使用(resource utilizations)设定为0<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-02-操作系统.html#进程组)进程组<br>&emsp;&emsp;<br>&emsp;&emsp;进程组就是多个进程的集合，其中肯定有一个组长，其进程PID等于进程组的PGID。只要在某个进程组中一个进程存在，该进程组就存在，这与其组长进程是否终止无关。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-02-操作系统.html#作业)作业<br>&emsp;&emsp;<br>&emsp;&emsp;shell分前后台来控制的不是进程而是作业（job）或者进程组（Process Group）。<br>&emsp;&emsp;<br>&emsp;&emsp;一个前台作业可以由多个进程组成，一个后台也可以由多个进程组成，shell可以运行一个前台作业和任意多个后台作业，这称为作业控制<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-02-操作系统.html#为什么只能运行一个前台作业)为什么只能运行一个前台作业？<br>&emsp;&emsp;<br>&emsp;&emsp;答：当我们在前台新起了一个作业，shell就被提到了后台，因此shell就没有办法再继续接受我们的指令并且解析运行了。 但是如果前台进程退出了，shell就会有被提到前台来，就可以继续接受我们的命令并且解析运行。<br>&emsp;&emsp;<br>&emsp;&emsp;作业与进程组的区别：如果作业中的某个进程有创建了子进程，则该子进程是不属于该作业的。 一旦作业运行结束，shell就把自己提到前台（子进程还存在，但是子进程不属于作业），如果原来的前台进程还存在（这个子进程还没有终止），他将自动变为后台进程组<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-02-操作系统.html#会话)会话<br>&emsp;&emsp;<br>&emsp;&emsp;会话（Session）是一个或多个进程组的集合。一个会话可以有一个控制终端。在xshell或者WinSCP中打开一个窗口就是新建一个会话。<hr><hr>进程::39、进程终止的几种方式<br>&emsp;&emsp;<br>&emsp;&emsp;todo<hr>1、main函数的自然返回，`return` 2、调用`exit`函数，属于c的函数库 3、调用`_exit`函数，属于系统调用 4、调用`abort`函数，异常程序终止，同时发送SIGABRT信号给调用进程。 5、接受能导致进程终止的信号：ctrl+c (^C)、SIGINT(SIGINT中断进程)<br>&emsp;&emsp;<br>&emsp;&emsp;exit和_exit的区别<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205212344845.png)<hr><hr>进程::3、一个进程可以创建多少线程，和什么有关？<hr>这个要分不同系统去看：<br>&emsp;&emsp;<br>&emsp;&emsp;- 如果是32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 300 个左右的线程。<br>&emsp;&emsp;- 如果是64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制。<br>&emsp;&emsp;<br>&emsp;&emsp;顺便多说一句，过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响，无用线程要及时销毁。<br>&emsp;&emsp;<br>&emsp;&emsp;todo 线程应该还占用 tcb空间吧<hr><hr>进程::5、进程线程模型你知道多少？<br>&emsp;&emsp;<br>&emsp;&emsp;todo拆开来<hr>对于进程和线程的理解和把握可以说基本奠定了对系统的认知和把控能力。其核心意义绝不仅仅是“线程是调度的基本单位，进程是资源分配的基本单位”这么简单。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-01-操作系统.html#多线程)多线程<br>&emsp;&emsp;<br>&emsp;&emsp;我们这里讨论的是用户态的多线程模型，同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被所有的线程共享，比如有全局变量int i = 10，这一进程中所有并发运行的线程都可以读取和修改这个i的值，而多个线程被CPU调度的顺序又是不可控的，所以对临界资源的访问尤其需要注意安全。<br>&emsp;&emsp;<br>&emsp;&emsp;我们必须知道，做一次简单的i = i + 1在计算机中并不是原子操作，涉及内存取数，计算和写入内存几个环节，而线程的切换有可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。<br>&emsp;&emsp;<br>&emsp;&emsp;但是，虽然线程在安全性方面会引入许多新挑战，但是线程带来的好处也是有目共睹的。首先，原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（最好这些任务是不相关的）。<br>&emsp;&emsp;<br>&emsp;&emsp;比如 QQ 可以一个线程处理聊天一个线程处理上传文件，两个线程互不干涉，在用户看来是同步在执行两个任务，试想如果线性完成这个任务的话，在数据传输完成之前用户聊天被一直阻塞会是多么尴尬的情况。<br>&emsp;&emsp;<br>&emsp;&emsp;对于线程，我认为弄清以下两点非常重要：<br>&emsp;&emsp;<br>&emsp;&emsp;- 线程之间有无先后访问顺序（线程依赖关系）<br>&emsp;&emsp;- 多个线程共享访问同一变量（同步互斥问题）<br>&emsp;&emsp;<br>&emsp;&emsp;另外，我们通常只会去说同一进程的多个线程共享进程的资源，但是每个线程特有的部分却很少提及，除了标识线程的tid，每个线程还有自己独立的栈空间，线程彼此之间是无法访问其他线程栈上内容的。<br>&emsp;&emsp;<br>&emsp;&emsp;而作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和PC即可，相比进程切换开销要小很多。<br>&emsp;&emsp;<br>&emsp;&emsp;线程相关接口不少，主要需要了解各个参数意义和返回值意义。<br>&emsp;&emsp;<br>&emsp;&emsp;1. 线程创建和结束<br>&emsp;&emsp;<br>&emsp;&emsp;   - 背景知识：<br>&emsp;&emsp;<br>&emsp;&emsp;     在一个文件内的多个函数通常都是按照main函数中出现的顺序来执行，但是在分时系统下，我们可以让每个函数都作为一个逻辑流并发执行，最简单的方式就是采用多线程策略。在main函数中调用多线程接口创建线程，每个线程对应特定的函数（操作），这样就可以不按照main函数中各个函数出现的顺序来执行，避免了忙等的情况。线程基本操作的接口如下。<br>&emsp;&emsp;<br>&emsp;&emsp;   - 相关接口：<br>&emsp;&emsp;<br>&emsp;&emsp;     - 创建线程：int pthread_create(pthread_t *tidp,const pthread_attr_t *attr, void *(*start_rtn)(void*),void *arg);<br>&emsp;&emsp;<br>&emsp;&emsp;       创建一个新线程，pthread和start_routine不可或缺，分别用于标识线程和执行体入口，其他可以填NULL。<br>&emsp;&emsp;<br>&emsp;&emsp;       - pthread：用来返回线程的tid，*pthread值即为tid，类型pthread_t == unsigned long int。<br>&emsp;&emsp;       - attr：指向线程属性结构体的指针，用于改变所创线程的属性，填NULL使用默认值。<br>&emsp;&emsp;       - start_routine：线程执行函数的首地址，传入函数指针。<br>&emsp;&emsp;       - arg：通过地址传递来传递函数参数，这里是无符号类型指针，可以传任意类型变量的地址，在被传入函数中先强制类型转换成所需类型即可。<br>&emsp;&emsp;<br>&emsp;&emsp;     - 获得线程ID：pthread_t pthread_self();<br>&emsp;&emsp;<br>&emsp;&emsp;       调用时，会打印线程ID。<br>&emsp;&emsp;<br>&emsp;&emsp;     - 等待线程结束：int pthread_join(pthread_t tid, void** retval);<br>&emsp;&emsp;<br>&emsp;&emsp;       主线程调用，等待子线程退出并回收其资源，类似于进程中wait/waitpid回收僵尸进程，调用pthread_join的线程会被阻塞。<br>&emsp;&emsp;<br>&emsp;&emsp;       - tid：创建线程时通过指针得到tid值。<br>&emsp;&emsp;       - retval：指向返回值的指针。<br>&emsp;&emsp;<br>&emsp;&emsp;     - 结束线程：pthread_exit(void *retval);<br>&emsp;&emsp;<br>&emsp;&emsp;       子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过pthread_join获得。<br>&emsp;&emsp;<br>&emsp;&emsp;       - retval：同上。<br>&emsp;&emsp;<br>&emsp;&emsp;     - 分离线程：int pthread_detach(pthread_t tid);<br>&emsp;&emsp;<br>&emsp;&emsp;       主线程、子线程均可调用。主线程中pthread_detach(tid)，子线程中pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源。<br>&emsp;&emsp;<br>&emsp;&emsp;       - tid：同上。<br>&emsp;&emsp;<br>&emsp;&emsp;2. 线程属性值修改<br>&emsp;&emsp;<br>&emsp;&emsp;   - 背景知识：<br>&emsp;&emsp;<br>&emsp;&emsp;     线程属性对象类型为pthread_attr_t，结构体定义如下：<br>&emsp;&emsp;<br>&emsp;&emsp;     ```c<br>&emsp;&emsp;     typedef struct{<br>&emsp;&emsp;         int etachstate;    // 线程分离的状态<br>&emsp;&emsp;         int schedpolicy;    // 线程调度策略<br>&emsp;&emsp;         struct sched_param schedparam;    // 线程的调度参数<br>&emsp;&emsp;         int inheritsched;    // 线程的继承性<br>&emsp;&emsp;         int scope;    // 线程的作用域<br>&emsp;&emsp;         // 以下为线程栈的设置<br>&emsp;&emsp;         size_t guardsize;    // 线程栈末尾警戒缓冲大小<br>&emsp;&emsp;         int stackaddr_set;    // 线程的栈设置<br>&emsp;&emsp;         void *    stackaddr;    // 线程栈的位置<br>&emsp;&emsp;         size_t stacksize;    // 线程栈大小<br>&emsp;&emsp;     }pthread_arrt_t;<br>&emsp;&emsp;     ```<br>&emsp;&emsp;<br>&emsp;&emsp;- 相关接口：<br>&emsp;&emsp;<br>&emsp;&emsp;  对上述结构体中各参数大多有：pthread_attr_get()和pthread_attr_set()系统调用函数来设置和获取。这里不一一罗列。<br>&emsp;&emsp;<br>&emsp;&emsp;### 多进程<br>&emsp;&emsp;<br>&emsp;&emsp;每一个进程是资源分配的基本单位。<br>&emsp;&emsp;<br>&emsp;&emsp;进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。<br>&emsp;&emsp;<br>&emsp;&emsp;实际上在父进程创建子进程之后，父、子进程除了pid外，几乎所有的部分几乎一样。<br>&emsp;&emsp;<br>&emsp;&emsp;父、子进程共享全部数据，但并不是说他们就是对同一块数据进行操作，子进程在读写数据时会通过写时复制机制将公共的数据重新拷贝一份，之后在拷贝出的数据上进行操作。<br>&emsp;&emsp;<br>&emsp;&emsp;如果子进程想要运行自己的代码段，还可以通过调用execv()函数重新加载新的代码段，之后就和父进程独立开了。<br>&emsp;&emsp;<br>&emsp;&emsp;我们在shell中执行程序就是通过shell进程先fork()一个子进程再通过execv()重新加载新的代码段的过程。<br>&emsp;&emsp;<br>&emsp;&emsp;1. 进程创建与结束<br>&emsp;&emsp;<br>&emsp;&emsp;   - 背景知识：<br>&emsp;&emsp;<br>&emsp;&emsp;     进程有两种创建方式，一种是操作系统创建的一种是父进程创建的。从计算机启动到终端执行程序的过程为：0号进程 -> 1号内核进程 -> 1号用户进程(init进程) -> getty进程 -> shell进程 -> 命令行执行进程。所以我们在命令行中通过 ./program执行可执行文件时，所有创建的进程都是shell进程的子进程，这也就是为什么shell一关闭，在shell中执行的进程都自动被关闭的原因。从shell进程到创建其他子进程需要通过以下接口。<br>&emsp;&emsp;<br>&emsp;&emsp;   - 相关接口：<br>&emsp;&emsp;<br>&emsp;&emsp;     - 创建进程：pid_t fork(void);<br>&emsp;&emsp;<br>&emsp;&emsp;       返回值：出错返回-1；父进程中返回pid > 0；子进程中pid == 0<br>&emsp;&emsp;<br>&emsp;&emsp;     - 结束进程：void exit(int status);<br>&emsp;&emsp;<br>&emsp;&emsp;       - status是退出状态，保存在全局变量中S?，通常0表示正常退出。<br>&emsp;&emsp;<br>&emsp;&emsp;     - 获得PID：pid_t getpid(void);<br>&emsp;&emsp;<br>&emsp;&emsp;       返回调用者pid。<br>&emsp;&emsp;<br>&emsp;&emsp;     - 获得父进程PID：pid_t getppid(void);<br>&emsp;&emsp;<br>&emsp;&emsp;       返回父进程pid。<br>&emsp;&emsp;<br>&emsp;&emsp;   - 其他补充：<br>&emsp;&emsp;<br>&emsp;&emsp;     - 正常退出方式：exit()、_exit()、return（在main中）。<br>&emsp;&emsp;<br>&emsp;&emsp;       exit()和_exit()区别：exit()是对__exit()的封装，都会终止进程并做相关收尾工作，最主要的区别是_exit()函数关闭全部描述符和清理函数后不会刷新流，但是exit()会在调用_exit()函数前刷新数据流。<br>&emsp;&emsp;<br>&emsp;&emsp;       return和exit()区别：exit()是函数，但有参数，执行完之后控制权交给系统。return若是在调用函数中，执行完之后控制权交给调用进程，若是在main函数中，控制权交给系统。<br>&emsp;&emsp;<br>&emsp;&emsp;     - 异常退出方式：abort()、终止信号。<br>&emsp;&emsp;<br>&emsp;&emsp;2. Linux进程控制<br>&emsp;&emsp;<br>&emsp;&emsp;- 进程地址空间（地址空间）<br>&emsp;&emsp;<br>&emsp;&emsp;  虚拟存储器为每个进程提供了独占系统地址空间的假象。<br>&emsp;&emsp;<br>&emsp;&emsp;  尽管每个进程地址空间内容不尽相同，但是他们的都有相似的结构。X86 Linux进程的地址空间底部是保留给用户程序的，包括文本、数据、堆、栈等，其中文本区和数据区是通过存储器映射方式将磁盘中可执行文件的相应段映射至虚拟存储器地址空间中。<br>&emsp;&emsp;<br>&emsp;&emsp;  有一些"敏感"的地址需要注意下，对于32位进程来说，代码段从0x08048000开始。从0xC0000000开始到0xFFFFFFFF是内核地址空间，通常情况下代码运行在用户态（使用0x00000000 ~ 0xC00000000的用户地址空间），当发生系统调用、进程切换等操作时CPU控制寄存器设置模式位，进入内和模式，在该状态（超级用户模式）下进程可以访问全部存储器位置和执行全部指令。<br>&emsp;&emsp;<br>&emsp;&emsp;  也就说32位进程的地址空间都是4G，但用户态下只能访问低3G的地址空间，若要访问3G ~ 4G的地址空间则只有进入内核态才行。<br>&emsp;&emsp;<br>&emsp;&emsp;- 进程控制块（处理机）<br>&emsp;&emsp;<br>&emsp;&emsp;  进程的调度实际就是内核选择相应的进程控制块，被选择的进程控制块中包含了一个进程基本的信息。<br>&emsp;&emsp;<br>&emsp;&emsp;- 上下文切换<br>&emsp;&emsp;<br>&emsp;&emsp;  内核管理所有进程控制块，而进程控制块记录了进程全部状态信息。每一次进程调度就是一次上下文切换，所谓的上下文本质上就是当前运行状态，主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文件表）等。<br>&emsp;&emsp;<br>&emsp;&emsp;  进程执行时刻，内核可以决定抢占当前进程并开始新的进程，这个过程由内核调度器完成，当调度器选择了某个进程时称为该进程被调度，该过程通过上下文切换来改变当前状态。<br>&emsp;&emsp;<br>&emsp;&emsp;  一次完整的上下文切换通常是进程原先运行于用户态，之后因系统调用或时间片到切换到内核态执行内核指令，完成上下文切换后回到用户态，此时已经切换到进程B。<hr><hr>进程::64、多进程和多线程的区别是什么？换句话说，什么时候该用多线程，什么时候该用多进程？<hr>- <font color=#FEAE00>频繁修改：需要频繁创建和销毁的优先使用</font><font color=#FEAE00>多线程</font><br>&emsp;&emsp;- <font color=#FEAE00>计算量：需要大量计算的优先使用</font><font color=#FEAE00>多线程</font> 因为需要消耗大量CPU资源且切换频繁，所以多线程好一点<br>&emsp;&emsp;- 相关性：<font color=#FEAE00>任务间相关性比较强的用</font><font color=#FEAE00>多线程</font><font color=#FEAE00>，相关性比较弱的用多进程。</font>因为线程之间的数据共享和同步比较简单。<br>&emsp;&emsp;- 多分布：可能要扩展到多机分布的用多进程，多核分布的用多线程。<br>&emsp;&emsp;<br>&emsp;&emsp;但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。<hr><hr>进程::创建线程的函数?	<hr>pthread_create <br>&emsp;&emsp;和 thread 类<hr><hr>进程::多线程同步?  和动态线程池是什么?<br>&emsp;&emsp;静态和动态线程池的性能差异是多少?<hr><hr>进程::小顶堆管理定时器<hr><hr>进程::每个线程占多大的内存<hr><hr>进程::线程如何销毁<hr><hr>通信 ::各种信号都是什么, 如何处理 todo<hr><hr>通信::18、进程通信方法（Linux和windows下），线程通信方法（Linux和windows下）<hr>进程通信方法<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220001927.png)<br>&emsp;&emsp;<br>&emsp;&emsp;| 名称及方式                                                   |<br>&emsp;&emsp;| ------------------------------------------------------------ |<br>&emsp;&emsp;| 管道(pipe)：允许一个进程和另一个与它有共同祖先的进程之间进行通信 |<br>&emsp;&emsp;| 命名管道(FIFO)：类似于管道，但是它可以用于任何两个进程之间的通信，命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建 |<br>&emsp;&emsp;| 消息队列(MQ)：消息队列是消息的连接表，包括POSIX消息对和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能成该无格式字节流以及缓冲区大小受限等缺点； |<br>&emsp;&emsp;| 信号量(semaphore)：信号量主要作为进程间以及同进程不同线程之间的同步手段； |<br>&emsp;&emsp;| 共享内存(shared memory)：它使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。这是针对其他通信机制运行效率较低而设计的。它往往与其他通信机制，如信号量结合使用，以达到进程间的同步及互斥 |<br>&emsp;&emsp;| 信号(signal)：信号是比较复杂的通信方式，用于通知接收进程有某种事情发生，除了用于进程间通信外，进程还可以发送信号给进程本身 |<br>&emsp;&emsp;| 内存映射(mapped memory)：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它 |<br>&emsp;&emsp;| Socket：它是更为通用的进程间通信机制，可用于不同机器之间的进程间通信 |<br>&emsp;&emsp;<br>&emsp;&emsp;线程通信方法<br>&emsp;&emsp;<br>&emsp;&emsp;![img](https://axiu-image-bed.oss-cn-shanghai.aliyuncs.com/img/202205220001656.png)<br>&emsp;&emsp;<br>&emsp;&emsp;| 名称及含义                                                   |<br>&emsp;&emsp;| ------------------------------------------------------------ |<br>&emsp;&emsp;| Linux：                                                  |<br>&emsp;&emsp;| 信号：类似进程间的信号处理                                   |<br>&emsp;&emsp;| 锁机制：互斥锁、读写锁和自旋锁                               |<br>&emsp;&emsp;| 条件变量：使用通知的方式解锁，与互斥锁配合使用               |<br>&emsp;&emsp;| 信号量：包括无名线程信号量和命名线程信号量                   |<br>&emsp;&emsp;| Windows：                                                |<br>&emsp;&emsp;| 全局变量：需要有多个线程来访问一个全局变量时，通常我们会在这个全局变量前加上volatile声明，以防编译器对此变量进行优化 |<br>&emsp;&emsp;| Message消息机制：常用的Message通信的接口主要有两个：PostMessage和PostThreadMessage，PostMessage为线程向主窗口发送消息。而PostThreadMessage是任意两个线程之间的通信接口。 |<br>&emsp;&emsp;| CEvent对象：CEvent为MFC中的一个对象，可以通过对CEvent的触发状态进行改变，从而实现线程间的通信和同步，这个主要是实现线程直接同步的一种方法。 |<hr><hr>通信::19、进程间通信有哪几种方式？把你知道的都说出来<hr>Linux几乎支持全部UNIX进程间通信方法，包括管道（有名管道和无名管道）、消息队列、共享内存、信号量和套接字。其中前四个属于同一台机器下进程间的通信，套接字则是用于网络通信。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-01-操作系统.html#管道)管道<br>&emsp;&emsp;<br>&emsp;&emsp;- 无名管道<br>&emsp;&emsp;  - 无名管道特点：<br>&emsp;&emsp;    - 无名管道是一种特殊的文件，这种文件只存在于内存中。<br>&emsp;&emsp;    - 无名管道只能用于父子进程或兄弟进程之间，必须用于具有亲缘关系的进程间的通信。<br>&emsp;&emsp;    - 无名管道只能由一端向另一端发送数据，是半双工方式，如果双方需要同时收发数据需要两个管道。<br>&emsp;&emsp;  - 相关接口：<br>&emsp;&emsp;    - int pipe(int fd[2]);<br>&emsp;&emsp;      - fd[2]：管道两端用fd[0]和fd[1]来描述，读的一端用fd[0]表示，写的一端用fd[1]表示。通信双方的进程中写数据的一方需要把fd[0]先close掉，读的一方需要先把fd[1]给close掉。<br>&emsp;&emsp;- 有名管道：<br>&emsp;&emsp;  - 有名管道特点：<br>&emsp;&emsp;    - 有名管道是FIFO文件，存在于文件系统中，可以通过文件路径名来指出。<br>&emsp;&emsp;    - 有名管道可以在不具有亲缘关系的进程间进行通信。<br>&emsp;&emsp;  - 相关接口：<br>&emsp;&emsp;    - int mkfifo(const char *pathname, mode_t mode);<br>&emsp;&emsp;      - pathname：即将创建的FIFO文件路径，如果文件存在需要先删除。<br>&emsp;&emsp;      - mode：和open()中的参数相同。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-01-操作系统.html#消息队列)消息队列<br>&emsp;&emsp;<br>&emsp;&emsp;相比于 FIFO，消息队列具有以下优点：<br>&emsp;&emsp;<br>&emsp;&emsp;- 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；<br>&emsp;&emsp;- 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；<br>&emsp;&emsp;- 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-01-操作系统.html#共享内存)共享内存<br>&emsp;&emsp;<br>&emsp;&emsp;进程可以将同一段共享内存连接到它们自己的地址空间，所有进程都可以访问共享内存中的地址，如果某个进程向共享内存内写入数据，所做的改动将立即影响到可以访问该共享内存的其他所有进程。<br>&emsp;&emsp;<br>&emsp;&emsp;- 相关接口<br>&emsp;&emsp;<br>&emsp;&emsp;  - 创建共享内存：int shmget(key_t key, int size, int flag);<br>&emsp;&emsp;<br>&emsp;&emsp;    成功时返回一个和key相关的共享内存标识符，失败范湖范围-1。<br>&emsp;&emsp;<br>&emsp;&emsp;    - key：为共享内存段命名，多个共享同一片内存的进程使用同一个key。<br>&emsp;&emsp;    - size：共享内存容量。<br>&emsp;&emsp;    - flag：权限标志位，和open的mode参数一样。<br>&emsp;&emsp;<br>&emsp;&emsp;  - 连接到共享内存地址空间：void *shmat(int shmid, void *addr, int flag);<br>&emsp;&emsp;<br>&emsp;&emsp;    返回值即共享内存实际地址。<br>&emsp;&emsp;<br>&emsp;&emsp;    - shmid：shmget()返回的标识。<br>&emsp;&emsp;    - addr：决定以什么方式连接地址。<br>&emsp;&emsp;    - flag：访问模式。<br>&emsp;&emsp;<br>&emsp;&emsp;  - 从共享内存分离：int shmdt(const void *shmaddr);<br>&emsp;&emsp;<br>&emsp;&emsp;    调用成功返回0，失败返回-1。<br>&emsp;&emsp;<br>&emsp;&emsp;    - shmaddr：是shmat()返回的地址指针。<br>&emsp;&emsp;<br>&emsp;&emsp;- 其他补充<br>&emsp;&emsp;<br>&emsp;&emsp;  共享内存的方式像极了多线程中线程对全局变量的访问，大家都对等地有权去修改这块内存的值，这就导致在多进程并发下，最终结果是不可预期的。所以对这块临界区的访问需要通过信号量来进行进程同步。<br>&emsp;&emsp;<br>&emsp;&emsp;  但共享内存的优势也很明显，首先可以通过共享内存进行通信的进程不需要像无名管道一样需要通信的进程间有亲缘关系。其次内存共享的速度也比较快，不存在读取文件、消息传递等过程，只需要到相应映射到的内存地址直接读写数据即可。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-01-操作系统.html#信号量)信号量<br>&emsp;&emsp;<br>&emsp;&emsp;在提到共享内存方式时也提到，进程共享内存和多线程共享全局变量非常相似。所以在使用内存共享的方式是也需要通过信号量来完成进程间同步。多线程同步的信号量是POSIX信号量，而在进程里使用SYSTEM V信号量。<br>&emsp;&emsp;<br>&emsp;&emsp;- 相关接口<br>&emsp;&emsp;<br>&emsp;&emsp;  - 创建信号量：int semget(key_t key, int nsems, int semflag);<br>&emsp;&emsp;<br>&emsp;&emsp;    创建成功返回信号量标识符，失败返回-1。<br>&emsp;&emsp;<br>&emsp;&emsp;    - key：进程pid。<br>&emsp;&emsp;    - nsems：创建信号量的个数。<br>&emsp;&emsp;    - semflag：指定信号量读写权限。<br>&emsp;&emsp;<br>&emsp;&emsp;  - 改变信号量值：int semop(int semid, struct sembuf *sops, unsigned nsops);<br>&emsp;&emsp;<br>&emsp;&emsp;    我们所需要做的主要工作就是串讲sembuf变量并设置其值，然后调用semop，把设置好的sembuf变量传递进去。<br>&emsp;&emsp;<br>&emsp;&emsp;    struct sembuf结构体定义如下：<br>&emsp;&emsp;<br>&emsp;&emsp;    ```text<br>&emsp;&emsp;    struct sembuf{<br>&emsp;&emsp;        short sem_num;<br>&emsp;&emsp;        short sem_op;<br>&emsp;&emsp;        short sem_flg;<br>&emsp;&emsp;    };<br>&emsp;&emsp;     <br>&emsp;&emsp;            @阿秀: 代码已成功复制到剪贴板<br>&emsp;&emsp;        <br>&emsp;&emsp;    ```<br>&emsp;&emsp;<br>&emsp;&emsp;    1<br>&emsp;&emsp;    2<br>&emsp;&emsp;    3<br>&emsp;&emsp;    4<br>&emsp;&emsp;    5<br>&emsp;&emsp;<br>&emsp;&emsp;    成功返回信号量标识符，失败返回-1。<br>&emsp;&emsp;<br>&emsp;&emsp;    - semid：信号量集标识符，由semget()函数返回。<br>&emsp;&emsp;    - sops：指向struct sembuf结构的指针，先设置好sembuf值再通过指针传递。<br>&emsp;&emsp;    - nsops：进行操作信号量的个数，即sops结构变量的个数，需大于或等于1。最常见设置此值等于1，只完成对一个信号量的操作。<br>&emsp;&emsp;<br>&emsp;&emsp;  - 直接控制信号量信息：int semctl(int semid, int semnum, int cmd, union semun arg);<br>&emsp;&emsp;<br>&emsp;&emsp;    - semid：信号量集标识符。<br>&emsp;&emsp;    - semnum：信号量集数组上的下标，表示某一个信号量。<br>&emsp;&emsp;    - arg：union semun类型。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-01-操作系统.html#辅助命令)辅助命令<br>&emsp;&emsp;<br>&emsp;&emsp;ipcs命令用于报告共享内存、信号量和消息队列信息。<br>&emsp;&emsp;<br>&emsp;&emsp;- ipcs -a：列出共享内存、信号量和消息队列信息。<br>&emsp;&emsp;- ipcs -l：列出系统限额。<br>&emsp;&emsp;- ipcs -u：列出当前使用情况。<br>&emsp;&emsp;<br>&emsp;&emsp;### [#](https://interviewguide.cn/notes/03-hunting_job/02-interview/02-01-操作系统.html#套接字)套接字<br>&emsp;&emsp;<br>&emsp;&emsp;与其它通信机制不同的是，它可用于不同机器间的进程通信。<hr><hr>通信::7、Linux下进程间通信方式？<br>&emsp;&emsp;<br>&emsp;&emsp;todo 太长<hr>- 管道：<br>&emsp;&emsp;  - 无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。<br>&emsp;&emsp;  - 有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。<br>&emsp;&emsp;- 共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。<br>&emsp;&emsp;- 消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。<br>&emsp;&emsp;- 套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。<br>&emsp;&emsp;- 信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。<br>&emsp;&emsp;- 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。<hr><hr>通用<font color=#FEAE00>块层</font><hr>对于<font color=#FEAE00>块设备</font>，为了减少不同块设备的差异带来的影响，Linux 通过一个统一的<font color=#FEAE00>通用块层</font>，来管理不同的块设备。<br>&emsp;&emsp;通用块层是处于文件系统和磁盘驱动中间的一个块设备抽象层，它主要有两个功能：<br>&emsp;&emsp;	•	第一个功能，<font color=#FEAE00>向上为文件系统和应用程序</font>，提供访问<font color=#FEAE00>块设备的标准接口</font>，向下把各种不同的磁盘设备抽象为统一的块设备，并在内核层面，提供一个框架来管理这些设备的驱动程序；<br>&emsp;&emsp;	•	第二功能，<font color=#FEAE00>通用层还会给文件系统和应用程序发来的</font><font color=#FEAE00> I/O </font><font color=#FEAE00>请求排队</font>，接着会对队列重新排序、请求合并等方式，也就是 I/O 调度，主要目的是为了提高磁盘读写的效率。<br>&emsp;&emsp;Linux 内存支持 5 种 I/O 调度算法，分别是：<br>&emsp;&emsp;	<font color=#FEAE00>•	</font><font color=#FEAE00>没有调度算法</font><font color=#FEAE00><br>&emsp;&emsp;	•	</font><font color=#FEAE00>先入先出调度算法</font><font color=#FEAE00><br>&emsp;&emsp;	•	</font><font color=#FEAE00>完全公平调度算法</font><font color=#FEAE00><br>&emsp;&emsp;	•	</font><font color=#FEAE00>优先级调度</font><font color=#FEAE00><br>&emsp;&emsp;	•	</font><font color=#FEAE00>最终期限调度算法</font><br>&emsp;&emsp;第一种，没有调度算法，是的，你没听错，它不对文件系统和应用程序的 I/O 做任何处理，这种算法常用在<font color=#FEAE00>虚拟机</font><font color=#FEAE00> I/O</font> 中，此时磁盘 I/O 调度算法交由物理机系统负责。<br>&emsp;&emsp;第二种，先入先出调度算法，这是最简单的 I/O 调度算法，先进入 I/O 调度队列的 I/O 请求先发生。<br>&emsp;&emsp;第三种，完全公平调度算法，大部分系统都把这个算法作为默认的 I/O 调度器，它为每个进程维护了一个 I/O 调度队列，并按照时间片来均匀分布每个进程的 I/O 请求。<br>&emsp;&emsp;第四种，优先级调度算法，顾名思义，优先级高的 I/O 请求先发生， 它适用于运行大量进程的系统，像是桌面环境、多媒体应用等。<br>&emsp;&emsp;第五种，最终期限调度算法，分别为读、写请求创建了不同的 I/O 队列，这样可以提高机械磁盘的吞吐量，并确保达到最终期限的请求被优先处理，适用于在 I/O 压力比较大的场景，比如数据库等。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>键盘敲入字母时，期间发生了什么？<hr>看完前面的内容，相信你对输入输出设备的管理有了一定的认识，那接下来就从操作系统的角度回答开头的问题「键盘敲入字母时，操作系统期间发生了什么？」<br>&emsp;&emsp;我们先来看看 <font color=#FEAE00>CPU </font><font color=#FEAE00>的硬件架构图</font>：<br>&emsp;&emsp;￼<br>&emsp;&emsp;CPU 里面的内存接口，直接和系统总线通信，然后系统总线再接入一个 I/O 桥接器，这个 I/O 桥接器，另一边接入了内存总线，使得 CPU 和内存通信。再另一边，又接入了一个 I/O 总线，用来连接 I/O 设备，比如键盘、显示器等。<br>&emsp;&emsp;那当用户输入了键盘字符，<font color=#00A2FF>键盘控制器</font>就会产生扫描码数据，并将其缓冲在键盘控制器的寄存器中，紧接着键盘控制器通过总线给 CPU 发送<font color=#00A2FF>中断请求</font>。<br>&emsp;&emsp;CPU 收到中断请求后，操作系统会<font color=#00A2FF>保存被中断进程的</font><font color=#00A2FF> CPU </font><font color=#00A2FF>上下文</font>，然后调用键盘的<font color=#00A2FF>中断处理程序</font><font color=#00A2FF>。</font><br>&emsp;&emsp;键盘的中断处理程序是在<font color=#00A2FF>键盘驱动程序</font>初始化时注册的，那键盘<font color=#00A2FF>中断处理函数</font>的功能就是<font color=#FEAE00>从键盘控制器的寄存器的缓冲区读取扫描码</font>，再根据扫描码<font color=#FEAE00>找到用户在键盘输入的字符</font>，如果输入的字符是显示字符，那就会把扫描码翻译成对应显示字符的 ASCII 码，比如用户在键盘输入的是字母 A，是显示字符，于是就会把扫描码翻译成 A 字符的 ASCII 码。<br>&emsp;&emsp;得到了显示字符的 ASCII 码后，就会把 ASCII 码放到「读缓冲区队列」，接下来就是要把显示字符显示屏幕了，显示设备的驱动程序会定时从「读缓冲区队列」读取数据放到「写缓冲区队列」，最后把「写缓冲区队列」的数据一个一个写入到显示设备的控制器的寄存器中的数据缓冲区，最后将这些数据显示在屏幕里。<br>&emsp;&emsp;显示出结果后，<font color=#00A2FF>恢复被中断进程的上下文</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>零拷贝::<font color=#FEAE00>PageCache </font>有什么作用？<br>&emsp;&emsp;大文件用pagecache有什么问题<hr>缓存   预读<br>&emsp;&emsp;大文件问题：占用了太多 没有局部性<br>&emsp;&emsp;---<br>&emsp;&emsp;回顾前面说道文件传输过程，其中第一步都是先需要先把<font color=#FEAE00>磁盘文件数据拷贝「内核缓冲区」</font>里，这个「内核缓冲区」实际上是<font color=#FEAE00>磁盘高速缓存（</font><font color=#FEAE00>PageCache</font><font color=#FEAE00>）</font>。<br>&emsp;&emsp;由于零拷贝使用了 PageCache 技术，可以使得零拷贝进一步提升了性能，我们接下来看看 PageCache 是如何做到这一点的。<br>&emsp;&emsp;读写磁盘相比读写内存的速度慢太多了，所以我们应该想办法把「读写磁盘」替换成「读写内存」。于是，我们会通过 DMA 把磁盘里的数据搬运到内存里，这样就可以用读内存替换读磁盘。<br>&emsp;&emsp;但是，内存空间远比磁盘要小，内存注定只能拷贝磁盘里的一小部分数据。<br>&emsp;&emsp;那问题来了，<font color=#00AB8E>选择哪些磁盘数据拷贝到内存呢</font>？<br>&emsp;&emsp;我们都知道程序运行的时候，具有「<font color=#FEAE00>局部性</font>」，所以通常，刚被访问的数据在短时间内再次被访问的概率很高，于是我们可以用 <font color=#FEAE00>PageCache </font><font color=#FEAE00>来缓存最近被访问的数据</font>，当空间不足时淘汰最久未被访问的缓存。<br>&emsp;&emsp;所以，读磁盘数据的时候，优先在 PageCache 找，如果数据存在则可以直接返回；如果没有，则从磁盘中读取，然后缓存 PageCache 中。<br>&emsp;&emsp;还有一点，读取磁盘数据的时候，需要找到数据所在的位置，但是对于机械磁盘来说，就是通过磁头旋转到数据所在的扇区，再开始「顺序」读取数据，但是旋转磁头这个物理动作是非常耗时的，为了降低它的影响，<font color=#FEAE00>PageCache </font><font color=#FEAE00>使用了「预读功能」</font><font color=#FEAE00>。</font><br>&emsp;&emsp;比如，假设 read 方法每次只会读 <font color=#4D647F>32 KB</font> 的字节，虽然 read 刚开始只会读 0 ～ 32 KB 的字节，但内核会把其后面的 32～64 KB 也读取到 PageCache，这样后面读取 32～64 KB 的成本就很低，<font color=#FEAE00>如果在</font><font color=#FEAE00> 32</font><font color=#FEAE00>～</font><font color=#FEAE00>64 KB </font><font color=#FEAE00>淘汰出</font><font color=#FEAE00> PageCache </font><font color=#FEAE00>前，进程读取到它了，收益就非常大。</font><br>&emsp;&emsp;所以，<font color=#FEAE00>PageCache</font> 的优点主要是两个：<br>&emsp;&emsp;	•	<font color=#FEAE00>缓存最近被访问的数据；</font><br>&emsp;&emsp;	•	<font color=#FEAE00>预读功能；</font><br>&emsp;&emsp;这两个做法，将大大提高读写磁盘的性能。<br>&emsp;&emsp;<font color=#1DB100>但是，在传输大文件（</font><font color=#1DB100>GB </font><font color=#1DB100>级别的文件）的时候，</font><font color=#1DB100>PageCache </font><font color=#1DB100>会不起作用，那就白白浪费</font><font color=#1DB100> DMA </font><font color=#1DB100>多做的一次数据拷贝，造成性能的降低，即使使用了</font><font color=#1DB100> PageCache </font><font color=#1DB100>的零拷贝也会损失性能</font><br>&emsp;&emsp;这是因为如果你有很多 GB 级别文件需要传输，每当用户访问这些<font color=#FEAE00>大文件的时候</font>，内核就会把它们载入 PageCache 中，于是 PageCache 空间很快被这些大文件占满。<br>&emsp;&emsp;另外，由于文件太大，可能某些部分的文件数据被再次访问的概率比较低，这样就会带来 2 个问题：<br>&emsp;&emsp;	•	<font color=#FEAE00>PageCache </font><font color=#FEAE00>由于长时间被大文件占据</font>，<font color=#1DB100>其他「热点」的小文件</font>可能就无法充分使用到 PageCache，于是这样磁盘读写的性能就会下降了；<br>&emsp;&emsp;	•	PageCache 中的大文件数据，由于没有享受到缓存带来的好处，但却耗费 <font color=#FEAE00>DMA </font><font color=#FEAE00>多拷贝到</font><font color=#FEAE00> PageCache </font><font color=#FEAE00>一次</font>；<br>&emsp;&emsp;所以，<font color=#FEAE00>针对大文件的传输，不应该使用</font><font color=#FEAE00> PageCache</font><font color=#FEAE00>，也就是说不应该使用零拷贝技术</font>，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，这样在高并发的环境下，会带来严重的性能问题。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>零拷贝::为什么要有 <font color=#FEAE00>DMA </font><font color=#FEAE00>技术</font>?<hr>在没有 DMA 技术前，I/O 的过程是这样的：<br>&emsp;&emsp;	•	CPU 发出对应的指令<font color=#FEAE00>给磁盘控制器，然后返回</font>；<br>&emsp;&emsp;	•	磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个<font color=#FEAE00>中断</font>；<br>&emsp;&emsp;	•	CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据<font color=#FEAE00>一次一个字节地读进自己的寄存器</font>，<font color=#FEAE00>然后再把寄存器里的数据写入到内存</font>，而在数据传输的期间 CPU 是无法执行其他任务的。<br>&emsp;&emsp;为了方便你理解，我画了一副图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;可以看到，整个数据的传输过程，都要需要<font color=#FEAE00> CPU </font><font color=#FEAE00>亲自参与搬运数据的过程</font>，而且这个过程，CPU 是不能做其他事情的。<br>&emsp;&emsp;简单的搬运几个字符数据那没问题，但是如果我们用千兆网卡或者硬盘传输大量数据的时候，都用 CPU 来搬运的话，肯定忙不过来。<br>&emsp;&emsp;计算机科学家们发现了事情的严重性后，于是就发明了 DMA 技术，也就是<font color=#1DB100>直接内存访问（</font><font color=#1DB100>Direct Memory Access</font><font color=#1DB100>）</font> 技术。<br>&emsp;&emsp;什么是 DMA 技术？简单理解就是，<font color=#FEAE00>在进行</font><font color=#FEAE00> I/O </font><font color=#FEAE00>设备和内存的数据传输的时候，数据搬运的工作全部交给</font><font color=#FEAE00> DMA </font><font color=#FEAE00>控制器，而</font><font color=#FEAE00> CPU </font><font color=#FEAE00>不再参与任何与数据搬运相关的事情，这样</font><font color=#FEAE00> CPU </font><font color=#FEAE00>就可以去处理别的事务</font><font color=#FEAE00>。</font><br>&emsp;&emsp;那使用 DMA 控制器进行数据传输的过程究竟是什么样的呢？下面我们来具体看看。<br>&emsp;&emsp;￼<br>&emsp;&emsp;具体过程：<br>&emsp;&emsp;	•	用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，<font color=#FEAE00>进程进入阻塞状态</font>；<br>&emsp;&emsp;	•	操作系统收到请求后，<font color=#FEAE00>进一步将</font><font color=#FEAE00> I/O </font><font color=#FEAE00>请求发送</font><font color=#FEAE00> DMA</font><font color=#FEAE00>，然后让</font><font color=#FEAE00> CPU </font><font color=#FEAE00>执行其他任务；</font><br>&emsp;&emsp;	•	DMA 进一步将 I/O 请求发送给磁盘；<br>&emsp;&emsp;	•	磁盘收到 DMA 的 I/O 请求，<font color=#FEAE00>把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向</font><font color=#FEAE00> DMA </font><font color=#FEAE00>发起中断信号，告知自己缓冲区已满</font>；<br>&emsp;&emsp;<font color=#374EF4>	•	</font><font color=#FEAE00>DMA </font><font color=#FEAE00>收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用</font><font color=#FEAE00> CPU</font><font color=#FEAE00>，</font><font color=#FEAE00>CPU </font><font color=#FEAE00>可以执行其他任务</font>；<br>&emsp;&emsp;	•	当 <font color=#FEAE00>DMA </font><font color=#FEAE00>读取了足够多的数据，就会发送中断信号给</font><font color=#FEAE00> CPU</font>；<br>&emsp;&emsp;	•	CPU 收到 DMA 的信号，知道数据已经准备好，于是<font color=#FEAE00>将数据从内核拷贝到用户空间，系统调用返回；</font><br>&emsp;&emsp;可以看到， 整个数据传输的过程，CPU 不再参与数据搬运的工作，而是全程由 DMA 完成，但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。<br>&emsp;&emsp;早期 DMA 只存在在主板上，如今由于 I/O 设备越来越多，数据传输的需求也不尽相同，所以<font color=#FEAE00>每个</font><font color=#FEAE00> I/O </font><font color=#FEAE00>设备里面都有自己的</font><font color=#FEAE00> DMA </font><font color=#FEAE00>控制器</font>。<hr><hr>零拷贝::传统的<font color=#FEAE00>文件传输</font>有多糟糕？ 网卡发送文件?<hr>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将<font color=#FEAE00>磁盘上的文件读取出来，然后通过网络协议发送给客户</font>端。<br>&emsp;&emsp;传统 I/O 的工作方式是，数据读取和写入是<font color=#FEAE00>从用户空间到内核空间来回复制</font>，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。<br>&emsp;&emsp;代码通常如下，一般会需要两个系统调用：<br>&emsp;&emsp;<font color=#AA5925>read</font>(file, tmp_buf, len);<br>&emsp;&emsp;<font color=#AA5925>write</font>(socket, tmp_buf, len);<br>&emsp;&emsp;代码很简单，虽然就两行代码，但是这里面发生了不少的事情。<br>&emsp;&emsp;￼<br>&emsp;&emsp;首先，期间共<font color=#FEAE00>发生了</font><font color=#FEAE00> 4 </font><font color=#FEAE00>次用户态与内核态的上下文切换</font>，因为发生了两次系统调用，<font color=#FEAE00>一次是</font><font color=#FEAE00> read() </font><font color=#FEAE00>，一次是</font><font color=#FEAE00> write()</font>，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。<br>&emsp;&emsp;上下文切换到成本并不小，<font color=#FEAE00>一次切换需要耗时几十纳秒到几微秒</font>，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。<br>&emsp;&emsp;其次，还<font color=#FEAE00>发生了</font><font color=#FEAE00> 4 </font><font color=#FEAE00>次数据拷贝</font>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>第一次拷贝</font>，把<font color=#FEAE00>磁盘上的数据拷贝到操作系统内核的缓冲区</font>里，这个拷贝的过程是通过 DMA 搬运的。<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>第二次拷贝</font>，把<font color=#FEAE00>内核缓冲区的数据拷贝到用户的缓冲区</font>里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是<font color=#FEAE00>由</font><font color=#FEAE00> CPU </font><font color=#FEAE00>完成</font>的。<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>第三次拷贝</font>，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。<br>&emsp;&emsp;<font color=#7414AF>	•	</font><font color=#7414AF>第四次拷贝</font>，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。<br>&emsp;&emsp;我们回过头看这个文件传输的过程，<font color=#FEAE00>我们只是搬运一份数据，结果却搬运了</font><font color=#FEAE00> 4 </font><font color=#FEAE00>次</font>，过多的数据拷贝无疑会消耗 CPU 资源，大大降低了系统性能。<br>&emsp;&emsp;这种简单又传统的文件传输方式，<font color=#FEAE00>存在冗余的上文切换和数据拷贝</font>，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。<br>&emsp;&emsp;所以，<font color=#1DB100>要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数</font><font color=#1DB100>。</font><hr><hr>零拷贝::<font color=#FEAE00>大文件传输</font>用什么方式实现？<hr>那针对大文件的传输，我们应该使用什么方式呢？<br>&emsp;&emsp;我们先来看看最初的例子，当调用 read 方法读取文件时，<font color=#FEAE00>进程实际上会阻塞在</font><font color=#FEAE00> read </font><font color=#FEAE00>方法调用，因为要等待磁盘数据的返回</font>，如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;具体过程：<br>&emsp;&emsp;	•	当调用 read 方法时，会阻塞着，此时内核会向磁盘发起 I/O 请求，磁盘收到请求后，便会寻址，当磁盘数据准备好后，就会向内核发起 I/O 中断，告知内核磁盘数据已经准备好；<br>&emsp;&emsp;	•	内核收到 I/O 中断后，就将数据从磁盘控制器缓冲区拷贝到 PageCache 里；<br>&emsp;&emsp;	•	最后，内核再把 PageCache 中的数据拷贝到用户缓冲区，于是 read 调用就正常返回了。<br>&emsp;&emsp;对于<font color=#FEAE00>阻塞的问题，可以用异步</font><font color=#FEAE00> I/O </font><font color=#FEAE00>来解决</font>，它工作方式如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;它把读操作分为两部分：<br>&emsp;&emsp;	•	<font color=#FEAE00>前半部分</font>，内核向磁盘发起读请求，但是可以<font color=#FEAE00>不等待数据就位就可以返回</font>，于是进程此时可以处理其他任务；<br>&emsp;&emsp;	•	后半部分，当内核将磁盘中的数据拷贝到进程缓冲区后，<font color=#FEAE00>进程将接收到内核的</font><font color=#FEAE00>通知</font><font color=#FEAE00>，</font>再去处理数据；<br>&emsp;&emsp;而且，我们可以发现，<font color=#FEAE00>异步</font><font color=#FEAE00> I/O </font><font color=#FEAE00>并没有涉及到</font><font color=#FEAE00> PageCache</font>，所以使用异步 I/O 就意味着要绕开 PageCache。<br>&emsp;&emsp;<font color=#FEAE00>绕开</font><font color=#FEAE00> PageCache </font><font color=#FEAE00>的</font><font color=#FEAE00> I/O </font><font color=#FEAE00>叫直接</font><font color=#FEAE00> I/O</font>，使用 PageCache 的<font color=#FEAE00> I/O </font><font color=#FEAE00>则叫缓存</font><font color=#FEAE00> I/O</font><font color=#FEAE00>。</font>通常，对于磁盘，异步 I/O 只支持直接 I/O。<br>&emsp;&emsp;前面也提到，大文件的传输不应该使用 PageCache，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache。<br>&emsp;&emsp;于是，<font color=#1DB100>在高并发的场景下，针对大文件的传输的方式，应该使用「异步</font><font color=#1DB100> I/O + </font><font color=#1DB100>直接</font><font color=#1DB100> I/O</font><font color=#1DB100>」来替代零拷贝技术</font><font color=#1DB100>。</font><br>&emsp;&emsp;<font color=#FEAE00>直接</font><font color=#FEAE00> I/O </font><font color=#FEAE00>应用场景</font>常见的两种：<br>&emsp;&emsp;	•	<font color=#FEAE00>应用程序已经实现了磁盘数据的缓存</font>，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗。在 <font color=#FEAE00>MySQL </font><font color=#FEAE00>数据库</font>中，可以通过参数设置开启直接 I/O，默认是不开启；<br>&emsp;&emsp;	•	<font color=#FEAE00>传输大文件的时候</font>，由于<font color=#FEAE00>大文件难以命中</font><font color=#FEAE00> PageCache</font> 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用直接 I/O。<br>&emsp;&emsp;另外，由于直接 I/O 绕过了 PageCache，就无法享受内核的这两点的优化：<br>&emsp;&emsp;	•	内核的 I/O 调度算法会缓存尽可能多的 I/O 请求在 PageCache 中，最后「<font color=#FEAE00>合并</font>」成一个<font color=#FEAE00>更大的</font><font color=#FEAE00> I/O </font><font color=#FEAE00>请求再发给磁盘</font>，这样做是为了减少磁盘的寻址操作；<br>&emsp;&emsp;	•	内核也会「<font color=#FEAE00>预读</font>」后续的 I/O 请求放在 PageCache 中，一样是为了减少对磁盘的操作；<br>&emsp;&emsp;于是，传输大文件的时候，使用「异步 I/O + 直接 I/O」了，就可以无阻塞地读取文件了。<br>&emsp;&emsp;所以，传输文件的时候，我们要根据文件的大小来使用不同的方式：<br>&emsp;&emsp;	•	传输<font color=#FEAE00>大文件的时候，使用「异步</font><font color=#FEAE00> I/O + </font><font color=#FEAE00>直接</font><font color=#FEAE00> I/O</font><font color=#FEAE00>」</font>；<br>&emsp;&emsp;	•	传输小文件的时候，则使用「零拷贝技术」；<br>&emsp;&emsp;在 nginx 中，我们可以用如下配置，来根据文件的大小来使用不同的方式：<br>&emsp;&emsp;location /video/ { <br>&emsp;&emsp;    sendfile on; <br>&emsp;&emsp;   <font color=#FEAE00> aio on; </font><br>&emsp;&emsp;    directio 1024m; <br>&emsp;&emsp;}<br>&emsp;&emsp;当文件大小<font color=#FEAE00>大于</font><font color=#FEAE00> directio </font><font color=#FEAE00>值后</font>，使用「异步 I/O + 直接 I/O」，否则使用「零拷贝技术」。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>零拷贝::如何优化文件传输的性能？<hr><font color=#00AB8E>先来看看，如何减少「用户态与内核态的上下文切换」的次数呢？</font><br>&emsp;&emsp;读取磁盘数据的时候，之所以要发生上下文切换，这是因为用户空间没有权限操作磁盘或网卡，内核的权限最高，这些操作设备的过程都需要交由操作系统内核来完成，所以一般要通过内核去完成某些任务的时候，就需要使用操作系统提供的系统调用函数。<br>&emsp;&emsp;而一次系统调用必然会发生 2 次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。<br>&emsp;&emsp;所以，<font color=#FEAE00>要想减少上下文切换到次数，就要减少系统调用的次数</font>。<br>&emsp;&emsp;再来看看，<font color=#00AB8E>如何减少「数据拷贝」的次数</font>？<br>&emsp;&emsp;<br>&emsp;&emsp;在前面我们知道了，传统的文件传输方式会历经 4 次数据拷贝，而且这里面，「<font color=#FEAE00>从内核的读缓冲区拷贝到用户的缓冲区里，再从用户的缓冲区里拷贝到</font><font color=#FEAE00> socket </font><font color=#FEAE00>的缓冲区里」，这个过程是没有必要</font>的。<br>&emsp;&emsp;因为文件传输的应用场景中，在用户空间我们并不会对数据「再加工」，所以数据实际上可以不用搬运到用户空间，因此<font color=#FEAE00>用户的缓冲区是没有必要存在的</font>。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>零拷贝::如何实现<font color=#FEAE00>零拷贝？</font><font color=#FEAE00><br>&emsp;&emsp;</font><font color=#FEAE00>实现零拷贝</font><font color=#FEAE00> </font><font color=#FEAE00>两种调用方式？</font><hr>零拷贝技术实现的方式通常有 2 种：<br>&emsp;&emsp;	•	<font color=#00AB8E>mmap + write</font><br>&emsp;&emsp;	•	<font color=#00AB8E>sendfile</font><br>&emsp;&emsp;下面就谈一谈，它们是如何减少「上下文切换」和「数据拷贝」的次数。<br>&emsp;&emsp;# mmap + write<br>&emsp;&emsp;在前面我们知道，<font color=#4D647F>read()</font> 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 <font color=#4D647F>mmap()</font> 替换 <font color=#4D647F>read()</font> 系统调用函数。<br>&emsp;&emsp;buf <font color=#519696>=</font> <font color=#AA5925>mmap</font>(file, len);<br>&emsp;&emsp;<font color=#AA5925>write</font>(sockfd, buf, len);<br>&emsp;&emsp;<font color=#4D647F>mmap()</font> 系统调用函数会直接把内核缓冲区里的数据<font color=#FEAE00>「</font><font color=#FEAE00>映射</font><font color=#FEAE00>」</font>到用户空间，这样，<font color=#FEAE00>操作系统内核与用户空间就不需要再进行任何的数据拷贝</font>操作。<br>&emsp;&emsp;￼<br>&emsp;&emsp;具体过程如下：<br>&emsp;&emsp;	•	应用进程<font color=#FEAE00>调用了</font><font color=#FEAE00> mmap() </font><font color=#FEAE00>后</font>，DMA 会把磁盘的<font color=#FEAE00>数据拷贝到内核的缓冲区里</font>。接着，应用进程跟操作系统内核「<font color=#FEAE00>共享</font>」这个缓冲区；<br>&emsp;&emsp;	•	应用进程再调用 <font color=#FEAE00>write()</font>，操作系统直接将内核缓冲区的<font color=#FEAE00>数据拷贝到</font><font color=#FEAE00> socket </font><font color=#FEAE00>缓冲区中，这一切都发生在内核态</font>，由 CPU 来搬运数据；<br>&emsp;&emsp;	•	最后，把内核的 socket 缓冲区里的数据，拷贝到<font color=#FEAE00>网卡的缓冲区</font>里，这个过程是由 DMA 搬运的。<br>&emsp;&emsp;我们可以得知，通过使用 <font color=#4D647F>mmap()</font> 来代替 <font color=#4D647F>read()</font>， 可以减少一次数据拷贝的过程。<br>&emsp;&emsp;但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><font color=#00AB8E>sendfile</font><br>&emsp;&emsp;在 Linux 内核版本 2.1 中，提供了一个<font color=#1DB100>专门发送文件的系统调用函数</font><font color=#1DB100> sendfile()</font>，函数形式如下：<br>&emsp;&emsp;<font color=#A27929>#</font><font color=#5E3563>include</font><font color=#A27929> </font><font color=#4C7F58><sys/socket.h></font><br>&emsp;&emsp;<font color=#A27929>ssize_t</font> <font color=#AA5925>sendfile</font>(<font color=#5E3563>int</font> out_fd, <font color=#5E3563>int</font> in_fd, <font color=#A27929>off_t</font> <font color=#519696>*</font>offset, <font color=#A27929>size_t</font> count);<br>&emsp;&emsp;它的前两个参数分别是<font color=#FEAE00>目的端和源端的文件描述符</font>，后面两个参数是源端的偏移量和复制数据的长度，<font color=#FEAE00>返回值是实际复制数据的长度</font>。<br>&emsp;&emsp;首先，它可以替代前面的 <font color=#4D647F>read()</font> 和 <font color=#4D647F>write()</font> 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。<br>&emsp;&emsp;其次，该系统调用，<font color=#FEAE00>可以直接把内核缓冲区里的数据拷贝到</font><font color=#FEAE00> socket </font><font color=#FEAE00>缓冲区里</font>，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;但是这还不是真正的零拷贝技术，如果网卡支持<font color=#FEAE00> SG-DMA</font>（<font color=#7414AF>The Scatter-Gather Direct Memory Access</font>）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。<br>&emsp;&emsp;你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：<br>&emsp;&emsp;$ <font color=#AA5925>ethtool</font> -k eth0 <font color=#519696>|</font> <font color=#AA5925>grep</font> scatter-gather<br>&emsp;&emsp;scatter-gather: on<br>&emsp;&emsp;于是，从 Linux 内核 <font color=#4D647F>2.4</font> 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， <font color=#4D647F>sendfile()</font> 系统调用的过程发生了点变化，具体过程如下：<br>&emsp;&emsp;	•	第一步，通过 <font color=#FEAE00>DMA </font><font color=#FEAE00>将磁盘上的数据拷贝到内核缓冲区</font>里；<br>&emsp;&emsp;	•	第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；<br>&emsp;&emsp;所以，<font color=#FEAE00>这个过程之中，只进行了</font><font color=#FEAE00> 2 </font><font color=#FEAE00>次数据拷贝</font>，如下图：<br>&emsp;&emsp;￼<br>&emsp;&emsp;这就是所谓的<font color=#FEAE00>零拷贝（</font><font color=#FEAE00>Zero-copy</font><font color=#FEAE00>）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过</font><font color=#FEAE00> CPU </font><font color=#FEAE00>来搬运数据，所有的数据都是通过</font><font color=#FEAE00> DMA </font><font color=#FEAE00>来进行传输的。</font>。<br>&emsp;&emsp;零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，<font color=#FEAE00>只需要</font><font color=#FEAE00> 2 </font><font color=#FEAE00>次上下文切换和数据拷贝次数，就可以完成文件的传输，而且</font><font color=#FEAE00> 2 </font><font color=#FEAE00>次的数据拷贝过程，都不需要通过</font><font color=#FEAE00> CPU</font><font color=#FEAE00>，</font><font color=#FEAE00>2 </font><font color=#FEAE00>次都是由</font><font color=#FEAE00> DMA </font><font color=#FEAE00>来搬运。</font><br>&emsp;&emsp;所以，总体来看，<font color=#FEAE00>零拷贝技术可以把文件传输的性能提高至少一倍以上</font><font color=#FEAE00>。</font><br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font>使用零拷贝技术的项目<br>&emsp;&emsp;事实上，Kafka 这个开源项目，就利用了「零拷贝」技术，从而大幅提升了 I/O 的吞吐率，这也是 Kafka 在处理海量数据为什么这么快的原因之一。<br>&emsp;&emsp;如果你追溯 <font color=#FEAE00>Kafka</font> 文件传输的代码，你会发现，最终它调用了 Java NIO 库里的 <font color=#4D647F>transferTo</font> 方法：<br>&emsp;&emsp;@Overridepublic <br>&emsp;&emsp;<font color=#5E3563>long</font> <font color=#AA5925>transferFrom</font>(<font color=#A27929>FileChannel</font> fileChannel, <font color=#5E3563>long</font> position, <font color=#5E3563>long</font> count) <font color=#5E3563>throws</font> <font color=#A27929>IOException</font> { <br>&emsp;&emsp;    <font color=#5E3563>return</font> fileChannel.<font color=#AA5925>transferTo</font>(position, count, socketChannel);<br>&emsp;&emsp;}<br>&emsp;&emsp;如果 Linux 系统支持 <font color=#4D647F>sendfile()</font> 系统调用，那么 <font color=#4D647F>transferTo()</font> 实际上最后就会使用到 <font color=#4D647F>sendfile()</font> 系统调用函数。<br>&emsp;&emsp;曾经有大佬专门写过程序测试过，在同样的硬件条件下，传统文件传输和零拷拷贝文件传输的性能差异，你可以看到下面这张测试数据图，<font color=#FEAE00>使用了零拷贝能够缩短</font><font color=#FEAE00> 65% </font><font color=#FEAE00>的时间，大幅度提升了机器传输数据的吞吐量</font>。<br>&emsp;&emsp;￼<br>&emsp;&emsp;另外，Nginx 也支持零拷贝技术，一般默认是开启零拷贝技术，这样有利于提高文件传输的效率，是否开启零拷贝技术的配置如下：<br>&emsp;&emsp;http {<br>&emsp;&emsp;...<br>&emsp;&emsp;    sendfile on<br>&emsp;&emsp;...<br>&emsp;&emsp;}<br>&emsp;&emsp;sendfile 配置的具体意思:<br>&emsp;&emsp;	•	设置为 on 表示，使用零拷贝技术来传输文件：sendfile ，这样只需要 2 次上下文切换，和 2 次数据拷贝。<br>&emsp;&emsp;	•	设置为 off 表示，使用传统的文件传输技术：read + write，这时就需要 4 次上下文切换，和 4 次数据拷贝。<br>&emsp;&emsp;当然，要使用 sendfile，Linux 内核版本必须要 2.1 以上的版本。<br>&emsp;&emsp;<br>&emsp;&emsp;<font color=#5478F6>#</font><font color=#5478F6><br>&emsp;&emsp;</font><hr><hr>